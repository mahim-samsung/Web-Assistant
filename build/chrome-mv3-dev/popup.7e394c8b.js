(function(define){var __define; typeof define === "function" && (__define=define,define=null);
// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"cQRzy":[function(require,module,exports) {
var global = arguments[3];
var W = Object.create;
var k = Object.defineProperty;
var V = Object.getOwnPropertyDescriptor;
var G = Object.getOwnPropertyNames;
var X = Object.getPrototypeOf, J = Object.prototype.hasOwnProperty;
var q = (e, t, o, r)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let s of G(t))!J.call(e, s) && s !== o && k(e, s, {
        get: ()=>t[s],
        enumerable: !(r = V(t, s)) || r.enumerable
    });
    return e;
};
var z = (e, t, o)=>(o = e != null ? W(X(e)) : {}, q(t || !e || !e.__esModule ? k(o, "default", {
        value: e,
        enumerable: !0
    }) : o, e));
var _ = typeof globalThis.process < "u" ? globalThis.process.argv : [];
var D = ()=>typeof globalThis.process < "u" ? globalThis.process.env : {};
var K = new Set(_), T = (e)=>K.has(e), ue = _.filter((e)=>e.startsWith("--") && e.includes("=")).map((e)=>e.split("=")).reduce((e, [t, o])=>(e[t] = o, e), {});
var de = T("--dry-run"), A = ()=>T("--verbose") || D().VERBOSE === "true", fe = A();
var E = (e = "", ...t)=>console.log(e.padEnd(9), "|", ...t);
var w = (...e)=>console.error("\uD83D\uDD34 ERROR".padEnd(9), "|", ...e), L = (...e)=>E("\uD83D\uDD35 INFO", ...e), x = (...e)=>E("\uD83D\uDFE0 WARN", ...e), Q = 0, p = (...e)=>A() && E(`\u{1F7E1} ${Q++}`, ...e);
var c = {
    "isContentScript": false,
    "isBackground": false,
    "isReact": false,
    "runtimes": [
        "page-runtime"
    ],
    "host": "localhost",
    "port": 60492,
    "entryFilePath": "/Users/mahbubislammahim/Desktop/Development/Webpilot/.plasmo/static/popup.ts",
    "bundleId": "8e90d8397e394c8b",
    "envHash": "e792fbbdaa78ee84",
    "verbose": "false",
    "secure": false,
    "serverPort": 60491
};
module.bundle.HMR_BUNDLE_ID = c.bundleId;
globalThis.process = {
    argv: [],
    env: {
        VERBOSE: c.verbose
    }
};
var Y = module.bundle.Module;
function Z(e) {
    Y.call(this, e), this.hot = {
        data: module.bundle.hotData[e],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(t) {
            this._acceptCallbacks.push(t || function() {});
        },
        dispose: function(t) {
            this._disposeCallbacks.push(t);
        }
    }, module.bundle.hotData[e] = void 0;
}
module.bundle.Module = Z;
module.bundle.hotData = {};
var d = globalThis.browser || globalThis.chrome || null;
async function m(e = !1) {
    e ? (p("Triggering full reload"), d.runtime.sendMessage({
        __plasmo_full_reload__: !0
    })) : globalThis.location?.reload?.();
}
function h() {
    return !c.host || c.host === "0.0.0.0" ? location.protocol.indexOf("http") === 0 ? location.hostname : "localhost" : c.host;
}
function f() {
    return c.port || location.port;
}
var S = "__plasmo_runtime_page_";
var i = {
    checkedAssets: {},
    assetsToDispose: [],
    assetsToAccept: []
}, C = ()=>{
    i.checkedAssets = {}, i.assetsToDispose = [], i.assetsToAccept = [];
};
function u(e, t) {
    let { modules: o  } = e;
    if (!o) return [];
    let r = [], s, n, a;
    for(s in o)for(n in o[s][1])a = o[s][1][n], (a === t || Array.isArray(a) && a[a.length - 1] === t) && r.push([
        e,
        s
    ]);
    return e.parent && (r = r.concat(u(e.parent, t))), r;
}
function R(e, t, o) {
    if (B(e, t, o)) return !0;
    let r = u(module.bundle.root, t), s = !1;
    for(; r.length > 0;){
        let [n, a] = r.shift();
        if (B(n, a, null)) s = !0;
        else {
            let y = u(module.bundle.root, a);
            if (y.length === 0) {
                s = !1;
                break;
            }
            r.push(...y);
        }
    }
    return s;
}
function B(e, t, o) {
    let { modules: r  } = e;
    if (!r) return !1;
    if (o && !o[e.HMR_BUNDLE_ID]) return e.parent ? R(e.parent, t, o) : !0;
    if (i.checkedAssets[t]) return !0;
    i.checkedAssets[t] = !0;
    let s = e.cache[t];
    return i.assetsToDispose.push([
        e,
        t
    ]), !s || s.hot && s.hot._acceptCallbacks.length ? (i.assetsToAccept.push([
        e,
        t
    ]), !0) : !1;
}
function M(e, t) {
    let { modules: o  } = e;
    return o ? !!o[t] : !1;
}
function ee(e) {
    if (e.type === "js" && typeof document < "u") return new Promise((t, o)=>{
        let r = document.createElement("script");
        r.src = `${e.url}?t=${Date.now()}`, e.outputFormat === "esmodule" && (r.type = "module"), r.addEventListener("load", ()=>t(r)), r.addEventListener("error", ()=>o(new Error(`Failed to download asset: ${e.id}`))), document.head?.appendChild(r);
    });
}
var P = !1;
try {
    (0, eval)('throw new Error("test"); //# sourceURL=test.js');
} catch (e) {
    P = e.stack.includes("test.js");
}
async function O(e) {
    global.parcelHotUpdate = Object.create(null), e.forEach((o)=>{
        o.url = d.runtime.getURL("/__plasmo_hmr_proxy__?url=" + encodeURIComponent(`${o.url}?t=${Date.now()}`));
    });
    let t = await Promise.all(P ? [] : e.map(ee));
    try {
        e.forEach(function(o) {
            $(module.bundle.root, o);
        });
    } finally{
        delete global.parcelHotUpdate, t && t.forEach((o)=>{
            o && document.head?.removeChild(o);
        });
    }
}
function te(e) {
    let t = e.cloneNode();
    t.onload = function() {
        e.parentNode !== null && e.parentNode.removeChild(e);
    }, t.setAttribute("href", e.getAttribute("href").split("?")[0] + "?" + Date.now()), e.parentNode.insertBefore(t, e.nextSibling);
}
var b = null;
function oe() {
    b || (b = setTimeout(function() {
        let e = document.querySelectorAll('link[rel="stylesheet"]');
        for(var t = 0; t < e.length; t++){
            let o = e[t].getAttribute("href"), r = h(), s = r === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + f()).test(o) : o.indexOf(r + ":" + f());
            /^https?:\/\//i.test(o) && o.indexOf(location.origin) !== 0 && !s || te(e[t]);
        }
        b = null;
    }, 47));
}
function $(e, t) {
    let { modules: o  } = e;
    if (o) {
        if (t.type === "css") oe();
        else if (t.type === "js") {
            let r = t.depsByBundle[e.HMR_BUNDLE_ID];
            if (r) {
                if (o[t.id]) {
                    let n = o[t.id][1];
                    for(let a in n)if (!r[a] || r[a] !== n[a]) {
                        let l = n[a];
                        u(module.bundle.root, l).length === 1 && v(module.bundle.root, l);
                    }
                }
                P && (0, eval)(t.output);
                let s = global.parcelHotUpdate[t.id];
                o[t.id] = [
                    s,
                    r
                ];
            } else e.parent && $(e.parent, t);
        }
    }
}
function v(e, t) {
    let o = e.modules;
    if (o) {
        if (o[t]) {
            let r = o[t][1], s = [];
            for(let n in r)u(module.bundle.root, r[n]).length === 1 && s.push(r[n]);
            delete o[t], delete e.cache[t], s.forEach((n)=>{
                v(module.bundle.root, n);
            });
        } else e.parent && v(e.parent, t);
    }
}
function H(e, t) {
    let o = e.cache[t];
    e.hotData[t] = {}, o && o.hot && (o.hot.data = e.hotData[t]), o && o.hot && o.hot._disposeCallbacks.length && o.hot._disposeCallbacks.forEach(function(r) {
        r(e.hotData[t]);
    }), delete e.cache[t];
}
function j(e, t) {
    e(t);
    let o = e.cache[t];
    if (o && o.hot && o.hot._acceptCallbacks.length) {
        let r = u(module.bundle.root, t);
        o.hot._acceptCallbacks.forEach(function(s) {
            let n = s(()=>r);
            n && n.length && (n.forEach(([a, l])=>{
                H(a, l);
            }), i.assetsToAccept.push.apply(i.assetsToAccept, n));
        });
    }
}
function re(e = f()) {
    let t = h();
    return `${c.secure || location.protocol === "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(t) ? "wss" : "ws"}://${t}:${e}/`;
}
function se(e) {
    typeof e.message == "string" && w("[plasmo/parcel-runtime]: " + e.message);
}
function I(e) {
    if (typeof globalThis.WebSocket > "u") return;
    let t = new WebSocket(re());
    return t.addEventListener("message", async function(o) {
        let r = JSON.parse(o.data);
        if (r.type === "update" && await e(r.assets), r.type === "error") for (let s of r.diagnostics.ansi){
            let n = s.codeframe || s.stack;
            x("[plasmo/parcel-runtime]: " + s.message + `
` + n + `

` + s.hints.join(`
`));
        }
    }), t.addEventListener("error", se), t.addEventListener("open", ()=>{
        L(`[plasmo/parcel-runtime]: Connected to HMR server for ${c.entryFilePath}`);
    }), t.addEventListener("close", ()=>{
        x(`[plasmo/parcel-runtime]: Connection to the HMR server is closed for ${c.entryFilePath}`);
    }), t;
}
var N = z(require("68aae0a3ed7a818f"));
async function U() {
    N.default.injectIntoGlobalHook(window), window.$RefreshReg$ = function() {}, window.$RefreshSig$ = function() {
        return function(e) {
            return e;
        };
    };
}
var ne = `${S}${module.id}__`, g, F = module.bundle.parent;
if (!F || !F.isParcelRequire) {
    try {
        g = d?.runtime.connect({
            name: ne
        }), g.onDisconnect.addListener(()=>{
            m();
        }), c.isReact || g.onMessage.addListener(()=>{
            m();
        });
    } catch (e) {
        p(e);
    }
    I(async (e)=>{
        if (p("Page runtime - On HMR Update"), c.isReact) {
            C();
            let t = e.filter((r)=>r.envHash === c.envHash);
            if (t.some((r)=>r.type === "css" || r.type === "js" && R(module.bundle.root, r.id, r.depsByBundle))) try {
                await O(t);
                let r = {};
                for (let [n, a] of i.assetsToDispose)r[a] || (H(n, a), r[a] = !0);
                let s = {};
                for(let n = 0; n < i.assetsToAccept.length; n++){
                    let [a, l] = i.assetsToAccept[n];
                    s[l] || (j(a, l), s[l] = !0);
                }
            } catch (r) {
                c.verbose === "true" && (console.trace(r), alert(JSON.stringify(r))), await m(!0);
            }
        } else {
            let t = e.filter((o)=>o.envHash === c.envHash).some((o)=>M(module.bundle, o.id));
            p("Page runtime -", {
                sourceChanged: t
            }), t && g.postMessage({
                __plasmo_page_changed__: !0
            });
        }
    });
}
c.isReact && (p("Injecting react refresh"), U());

},{"68aae0a3ed7a818f":"iZhE1"}],"iZhE1":[function(require,module,exports) {
var oe = Object.create;
var H = Object.defineProperty;
var ae = Object.getOwnPropertyDescriptor;
var ue = Object.getOwnPropertyNames;
var se = Object.getPrototypeOf, le = Object.prototype.hasOwnProperty;
var z = (o, f)=>()=>(f || o((f = {
            exports: {}
        }).exports, f), f.exports), ce = (o, f)=>{
    for(var s in f)H(o, s, {
        get: f[s],
        enumerable: !0
    });
}, D = (o, f, s, y)=>{
    if (f && typeof f == "object" || typeof f == "function") for (let m of ue(f))!le.call(o, m) && m !== s && H(o, m, {
        get: ()=>f[m],
        enumerable: !(y = ae(f, m)) || y.enumerable
    });
    return o;
}, S = (o, f, s)=>(D(o, f, "default"), s && D(s, f, "default")), G = (o, f, s)=>(s = o != null ? oe(se(o)) : {}, D(f || !o || !o.__esModule ? H(s, "default", {
        value: o,
        enumerable: !0
    }) : s, o)), de = (o)=>D(H({}, "__esModule", {
        value: !0
    }), o);
var N = z((h)=>{
    "use strict";
    (function() {
        "use strict";
        var o = Symbol.for("react.forward_ref"), f = Symbol.for("react.memo"), s = typeof WeakMap == "function" ? WeakMap : Map, y = new Map, m = new s, b = new s, j = new s, E = [], C = new Map, O = new Map, p = new Set, _ = new Set, F = typeof WeakMap == "function" ? new WeakMap : null, T = !1;
        function B(e) {
            if (e.fullKey !== null) return e.fullKey;
            var r = e.ownKey, n;
            try {
                n = e.getCustomHooks();
            } catch (i) {
                return e.forceReset = !0, e.fullKey = r, r;
            }
            for(var t = 0; t < n.length; t++){
                var l = n[t];
                if (typeof l != "function") return e.forceReset = !0, e.fullKey = r, r;
                var d = b.get(l);
                if (d !== void 0) {
                    var a = B(d);
                    d.forceReset && (e.forceReset = !0), r += `
---
` + a;
                }
            }
            return e.fullKey = r, r;
        }
        function q(e, r) {
            var n = b.get(e), t = b.get(r);
            return n === void 0 && t === void 0 ? !0 : !(n === void 0 || t === void 0 || B(n) !== B(t) || t.forceReset);
        }
        function $(e) {
            return e.prototype && e.prototype.isReactComponent;
        }
        function k(e, r) {
            return $(e) || $(r) ? !1 : !!q(e, r);
        }
        function Y(e) {
            return j.get(e);
        }
        function Z(e) {
            var r = new Map;
            return e.forEach(function(n, t) {
                r.set(t, n);
            }), r;
        }
        function W(e) {
            var r = new Set;
            return e.forEach(function(n) {
                r.add(n);
            }), r;
        }
        function M(e, r) {
            try {
                return e[r];
            } catch (n) {
                return;
            }
        }
        function J() {
            if (E.length === 0 || T) return null;
            T = !0;
            try {
                var e = new Set, r = new Set, n = E;
                E = [], n.forEach(function(u) {
                    var c = u[0], v = u[1], R = c.current;
                    j.set(R, c), j.set(v, c), c.current = v, k(R, v) ? r.add(c) : e.add(c);
                });
                var t = {
                    updatedFamilies: r,
                    staleFamilies: e
                };
                C.forEach(function(u) {
                    u.setRefreshHandler(Y);
                });
                var l = !1, d = null, a = W(_), i = W(p), g = Z(O);
                if (a.forEach(function(u) {
                    var c = g.get(u);
                    if (c === void 0) throw new Error("Could not find helpers for a root. This is a bug in React Refresh.");
                    if (_.has(u), F !== null && F.has(u)) {
                        var v = F.get(u);
                        try {
                            c.scheduleRoot(u, v);
                        } catch (R) {
                            l || (l = !0, d = R);
                        }
                    }
                }), i.forEach(function(u) {
                    var c = g.get(u);
                    if (c === void 0) throw new Error("Could not find helpers for a root. This is a bug in React Refresh.");
                    p.has(u);
                    try {
                        c.scheduleRefresh(u, t);
                    } catch (v) {
                        l || (l = !0, d = v);
                    }
                }), l) throw d;
                return t;
            } finally{
                T = !1;
            }
        }
        function P(e, r) {
            if (e === null || typeof e != "function" && typeof e != "object" || m.has(e)) return;
            var n = y.get(r);
            if (n === void 0 ? (n = {
                current: e
            }, y.set(r, n)) : E.push([
                n,
                e
            ]), m.set(e, n), typeof e == "object" && e !== null) switch(M(e, "$$typeof")){
                case o:
                    P(e.render, r + "$render");
                    break;
                case f:
                    P(e.type, r + "$type");
                    break;
            }
        }
        function K(e, r) {
            var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, t = arguments.length > 3 ? arguments[3] : void 0;
            if (b.has(e) || b.set(e, {
                forceReset: n,
                ownKey: r,
                fullKey: null,
                getCustomHooks: t || function() {
                    return [];
                }
            }), typeof e == "object" && e !== null) switch(M(e, "$$typeof")){
                case o:
                    K(e.render, r, n, t);
                    break;
                case f:
                    K(e.type, r, n, t);
                    break;
            }
        }
        function x(e) {
            var r = b.get(e);
            r !== void 0 && B(r);
        }
        function Q(e) {
            return y.get(e);
        }
        function X(e) {
            return m.get(e);
        }
        function ee(e) {
            var r = new Set;
            return p.forEach(function(n) {
                var t = O.get(n);
                if (t === void 0) throw new Error("Could not find helpers for a root. This is a bug in React Refresh.");
                var l = t.findHostInstancesForRefresh(n, e);
                l.forEach(function(d) {
                    r.add(d);
                });
            }), r;
        }
        function re(e) {
            var r = e.__REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (r === void 0) {
                var n = 0;
                e.__REACT_DEVTOOLS_GLOBAL_HOOK__ = r = {
                    renderers: new Map,
                    supportsFiber: !0,
                    inject: function(a) {
                        return n++;
                    },
                    onScheduleFiberRoot: function(a, i, g) {},
                    onCommitFiberRoot: function(a, i, g, u) {},
                    onCommitFiberUnmount: function() {}
                };
            }
            if (r.isDisabled) {
                console.warn("Something has shimmed the React DevTools global hook (__REACT_DEVTOOLS_GLOBAL_HOOK__). Fast Refresh is not compatible with this shim and will be disabled.");
                return;
            }
            var t = r.inject;
            r.inject = function(a) {
                var i = t.apply(this, arguments);
                return typeof a.scheduleRefresh == "function" && typeof a.setRefreshHandler == "function" && C.set(i, a), i;
            }, r.renderers.forEach(function(a, i) {
                typeof a.scheduleRefresh == "function" && typeof a.setRefreshHandler == "function" && C.set(i, a);
            });
            var l = r.onCommitFiberRoot, d = r.onScheduleFiberRoot || function() {};
            r.onScheduleFiberRoot = function(a, i, g) {
                return T || (_.delete(i), F !== null && F.set(i, g)), d.apply(this, arguments);
            }, r.onCommitFiberRoot = function(a, i, g, u) {
                var c = C.get(a);
                if (c !== void 0) {
                    O.set(i, c);
                    var v = i.current, R = v.alternate;
                    if (R !== null) {
                        var L = R.memoizedState != null && R.memoizedState.element != null && p.has(i), A = v.memoizedState != null && v.memoizedState.element != null;
                        !L && A ? (p.add(i), _.delete(i)) : L && A || (L && !A ? (p.delete(i), u ? _.add(i) : O.delete(i)) : !L && !A && u && _.add(i));
                    } else p.add(i);
                }
                return l.apply(this, arguments);
            };
        }
        function ne() {
            return !1;
        }
        function te() {
            return p.size;
        }
        function fe() {
            var e, r, n = !1;
            return function(t, l, d, a) {
                if (typeof l == "string") return e || (e = t, r = typeof a == "function"), t != null && (typeof t == "function" || typeof t == "object") && K(t, l, d, a), t;
                !n && r && (n = !0, x(e));
            };
        }
        function ie(e) {
            switch(typeof e){
                case "function":
                    if (e.prototype != null) {
                        if (e.prototype.isReactComponent) return !0;
                        var r = Object.getOwnPropertyNames(e.prototype);
                        if (r.length > 1 || r[0] !== "constructor" || e.prototype.__proto__ !== Object.prototype) return !1;
                    }
                    var n = e.name || e.displayName;
                    return typeof n == "string" && /^[A-Z]/.test(n);
                case "object":
                    if (e != null) switch(M(e, "$$typeof")){
                        case o:
                        case f:
                            return !0;
                        default:
                            return !1;
                    }
                    return !1;
                default:
                    return !1;
            }
        }
        h._getMountedRootCount = te, h.collectCustomHooksForSignature = x, h.createSignatureFunctionForTransform = fe, h.findAffectedHostInstances = ee, h.getFamilyByID = Q, h.getFamilyByType = X, h.hasUnrecoverableErrors = ne, h.injectIntoGlobalHook = re, h.isLikelyComponentType = ie, h.performReactRefresh = J, h.register = P, h.setSignature = K;
    })();
});
var I = z((pe, V)=>{
    "use strict";
    V.exports = N();
});
var w = {};
ce(w, {
    default: ()=>he
});
module.exports = de(w);
var U = G(I());
S(w, G(I()), module.exports);
var he = U.default; /*! Bundled license information:

react-refresh/cjs/react-refresh-runtime.development.js:
  (**
   * @license React
   * react-refresh-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/ 

},{}],"4z694":[function(require,module,exports) {
// @ts-nocheck
var _indexVue = require("../../src/popup/index.vue");
var _vue = require("vue");
document.addEventListener("DOMContentLoaded", ()=>{
    const app = (0, _vue.createApp)(_indexVue.default);
    _indexVue.default.prepare?.(app);
    app.mount("#__plasmo");
});

},{"../../src/popup/index.vue":"jY233","vue":"dmrjI"}],"jY233":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require("ae9ad3f225a03b1a");
    if (script.__esModule) script = script.default;
    script.render = require("1b0cf815a8ca2a28").render;
    require("a6ace6381171abbb").default(script);
    script.__scopeId = "data-v-fa6ae5";
    script.__file = "/Users/mahbubislammahim/Desktop/Development/Webpilot/src/popup/index.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "fa6ae5-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("fa6ae5-hmr", script)) __VUE_HMR_RUNTIME__.reload("fa6ae5-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"ae9ad3f225a03b1a":"Lvm87","1b0cf815a8ca2a28":"3xB5O","a6ace6381171abbb":"jRlsO","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"Lvm87":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _featureFlagsConfig = require("@/featureFlagsConfig");
var _vue = require("vue");
var _pinia = require("pinia");
var _i18N = require("@/utils/i18n");
var _store = require("@/stores/store");
var _storeDefault = parcelHelpers.interopDefault(_store);
var _webpilotPopupVue = require("./componetns/WebpilotPopup.vue");
var _webpilotPopupVueDefault = parcelHelpers.interopDefault(_webpilotPopupVue);
var _themeBootstrapCss = require("vue-toast-notification/dist/theme-bootstrap.css");
exports.default = {
    __name: "index",
    setup (__props, { expose: __expose  }) {
        __expose();
        const app = (0, _vue.createApp)((0, _webpilotPopupVueDefault.default));
        const pinia = (0, _pinia.createPinia)();
        app.use(pinia);
        app.use((0, _i18N.i18nPlugin));
        const soterConfig = (0, _storeDefault.default)();
        soterConfig.initConfig().then(()=>{
            app.mount("#webpilot-popup-page");
        });
        const __returned__ = {
            app,
            pinia,
            soterConfig,
            createApp: (0, _vue.createApp),
            get createPinia () {
                return 0, _pinia.createPinia;
            },
            get i18nPlugin () {
                return 0, _i18N.i18nPlugin;
            },
            get useStore () {
                return 0, _storeDefault.default;
            },
            WebpilotPopup: (0, _webpilotPopupVueDefault.default)
        };
        Object.defineProperty(__returned__, "__isScriptSetup", {
            enumerable: false,
            value: true
        });
        return __returned__;
    }
};

},{"@/featureFlagsConfig":"aoOIz","vue":"dmrjI","pinia":"afUQj","@/utils/i18n":"6q3A1","@/stores/store":"6gHZ2","./componetns/WebpilotPopup.vue":"3fjDl","vue-toast-notification/dist/theme-bootstrap.css":"hJnhS","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"aoOIz":[function(require,module,exports) {
// Hardcode to disable the extisions warning
globalThis.__VUE_OPTIONS_API__ = false;
globalThis.__VUE_PROD_DEVTOOLS__ = false;

},{}],"dmrjI":[function(require,module,exports) {
/**
* vue v3.5.16
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "compile", ()=>compile);
var _runtimeDom = require("@vue/runtime-dom");
parcelHelpers.exportAll(_runtimeDom, exports);
function initDev() {
    (0, _runtimeDom.initCustomFormatter)();
}
initDev();
const compile = ()=>{
    (0, _runtimeDom.warn)(`Runtime compilation is not supported in this build of Vue.` + ` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`);
};

},{"@vue/runtime-dom":"illZR","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"illZR":[function(require,module,exports) {
/**
* @vue/runtime-dom v3.5.16
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Transition", ()=>Transition);
parcelHelpers.export(exports, "TransitionGroup", ()=>TransitionGroup);
parcelHelpers.export(exports, "VueElement", ()=>VueElement);
parcelHelpers.export(exports, "createApp", ()=>createApp);
parcelHelpers.export(exports, "createSSRApp", ()=>createSSRApp);
parcelHelpers.export(exports, "defineCustomElement", ()=>defineCustomElement);
parcelHelpers.export(exports, "defineSSRCustomElement", ()=>defineSSRCustomElement);
parcelHelpers.export(exports, "hydrate", ()=>hydrate);
parcelHelpers.export(exports, "initDirectivesForSSR", ()=>initDirectivesForSSR);
parcelHelpers.export(exports, "render", ()=>render);
parcelHelpers.export(exports, "useCssModule", ()=>useCssModule);
parcelHelpers.export(exports, "useCssVars", ()=>useCssVars);
parcelHelpers.export(exports, "useHost", ()=>useHost);
parcelHelpers.export(exports, "useShadowRoot", ()=>useShadowRoot);
parcelHelpers.export(exports, "vModelCheckbox", ()=>vModelCheckbox);
parcelHelpers.export(exports, "vModelDynamic", ()=>vModelDynamic);
parcelHelpers.export(exports, "vModelRadio", ()=>vModelRadio);
parcelHelpers.export(exports, "vModelSelect", ()=>vModelSelect);
parcelHelpers.export(exports, "vModelText", ()=>vModelText);
parcelHelpers.export(exports, "vShow", ()=>vShow);
parcelHelpers.export(exports, "withKeys", ()=>withKeys);
parcelHelpers.export(exports, "withModifiers", ()=>withModifiers);
var _runtimeCore = require("@vue/runtime-core");
parcelHelpers.exportAll(_runtimeCore, exports);
var _shared = require("@vue/shared");
let policy = void 0;
const tt = typeof window !== "undefined" && window.trustedTypes;
if (tt) try {
    policy = /* @__PURE__ */ tt.createPolicy("vue", {
        createHTML: (val)=>val
    });
} catch (e) {
    (0, _runtimeCore.warn)(`Error creating trusted types policy: ${e}`);
}
const unsafeToTrustedHTML = policy ? (val)=>policy.createHTML(val) : (val)=>val;
const svgNS = "http://www.w3.org/2000/svg";
const mathmlNS = "http://www.w3.org/1998/Math/MathML";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
    insert: (child, parent, anchor)=>{
        parent.insertBefore(child, anchor || null);
    },
    remove: (child)=>{
        const parent = child.parentNode;
        if (parent) parent.removeChild(child);
    },
    createElement: (tag, namespace, is, props)=>{
        const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, {
            is
        }) : doc.createElement(tag);
        if (tag === "select" && props && props.multiple != null) el.setAttribute("multiple", props.multiple);
        return el;
    },
    createText: (text)=>doc.createTextNode(text),
    createComment: (text)=>doc.createComment(text),
    setText: (node, text)=>{
        node.nodeValue = text;
    },
    setElementText: (el, text)=>{
        el.textContent = text;
    },
    parentNode: (node)=>node.parentNode,
    nextSibling: (node)=>node.nextSibling,
    querySelector: (selector)=>doc.querySelector(selector),
    setScopeId (el, id) {
        el.setAttribute(id, "");
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent (content, parent, anchor, namespace, start, end) {
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        if (start && (start === end || start.nextSibling)) while(true){
            parent.insertBefore(start.cloneNode(true), anchor);
            if (start === end || !(start = start.nextSibling)) break;
        }
        else {
            templateContainer.innerHTML = unsafeToTrustedHTML(namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content);
            const template = templateContainer.content;
            if (namespace === "svg" || namespace === "mathml") {
                const wrapper = template.firstChild;
                while(wrapper.firstChild)template.appendChild(wrapper.firstChild);
                template.removeChild(wrapper);
            }
            parent.insertBefore(template, anchor);
        }
        return [
            // first
            before ? before.nextSibling : parent.firstChild,
            // last
            anchor ? anchor.previousSibling : parent.lastChild
        ];
    }
};
const TRANSITION = "transition";
const ANIMATION = "animation";
const vtcKey = Symbol("_vtc");
const DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: true
    },
    duration: [
        String,
        Number,
        Object
    ],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
};
const TransitionPropsValidators = /* @__PURE__ */ (0, _shared.extend)({}, (0, _runtimeCore.BaseTransitionPropsValidators), DOMTransitionPropsValidators);
const decorate$1 = (t)=>{
    t.displayName = "Transition";
    t.props = TransitionPropsValidators;
    return t;
};
const Transition = /* @__PURE__ */ decorate$1((props, { slots  })=>(0, _runtimeCore.h)((0, _runtimeCore.BaseTransition), resolveTransitionProps(props), slots));
const callHook = (hook, args = [])=>{
    if ((0, _shared.isArray)(hook)) hook.forEach((h2)=>h2(...args));
    else if (hook) hook(...args);
};
const hasExplicitCallback = (hook)=>{
    return hook ? (0, _shared.isArray)(hook) ? hook.some((h2)=>h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
    const baseProps = {};
    for(const key in rawProps)if (!(key in DOMTransitionPropsValidators)) baseProps[key] = rawProps[key];
    if (rawProps.css === false) return baseProps;
    const { name ="v" , type , duration , enterFromClass =`${name}-enter-from` , enterActiveClass =`${name}-enter-active` , enterToClass =`${name}-enter-to` , appearFromClass =enterFromClass , appearActiveClass =enterActiveClass , appearToClass =enterToClass , leaveFromClass =`${name}-leave-from` , leaveActiveClass =`${name}-leave-active` , leaveToClass =`${name}-leave-to`  } = rawProps;
    const durations = normalizeDuration(duration);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const { onBeforeEnter , onEnter , onEnterCancelled , onLeave , onLeaveCancelled , onBeforeAppear =onBeforeEnter , onAppear =onEnter , onAppearCancelled =onEnterCancelled  } = baseProps;
    const finishEnter = (el, isAppear, done, isCancelled)=>{
        el._enterCancelled = isCancelled;
        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
    };
    const finishLeave = (el, done)=>{
        el._isLeaving = false;
        removeTransitionClass(el, leaveFromClass);
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
        done && done();
    };
    const makeEnterHook = (isAppear)=>{
        return (el, done)=>{
            const hook = isAppear ? onAppear : onEnter;
            const resolve = ()=>finishEnter(el, isAppear, done);
            callHook(hook, [
                el,
                resolve
            ]);
            nextFrame(()=>{
                removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
                addTransitionClass(el, isAppear ? appearToClass : enterToClass);
                if (!hasExplicitCallback(hook)) whenTransitionEnds(el, type, enterDuration, resolve);
            });
        };
    };
    return (0, _shared.extend)(baseProps, {
        onBeforeEnter (el) {
            callHook(onBeforeEnter, [
                el
            ]);
            addTransitionClass(el, enterFromClass);
            addTransitionClass(el, enterActiveClass);
        },
        onBeforeAppear (el) {
            callHook(onBeforeAppear, [
                el
            ]);
            addTransitionClass(el, appearFromClass);
            addTransitionClass(el, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave (el, done) {
            el._isLeaving = true;
            const resolve = ()=>finishLeave(el, done);
            addTransitionClass(el, leaveFromClass);
            if (!el._enterCancelled) {
                forceReflow();
                addTransitionClass(el, leaveActiveClass);
            } else {
                addTransitionClass(el, leaveActiveClass);
                forceReflow();
            }
            nextFrame(()=>{
                if (!el._isLeaving) return;
                removeTransitionClass(el, leaveFromClass);
                addTransitionClass(el, leaveToClass);
                if (!hasExplicitCallback(onLeave)) whenTransitionEnds(el, type, leaveDuration, resolve);
            });
            callHook(onLeave, [
                el,
                resolve
            ]);
        },
        onEnterCancelled (el) {
            finishEnter(el, false, void 0, true);
            callHook(onEnterCancelled, [
                el
            ]);
        },
        onAppearCancelled (el) {
            finishEnter(el, true, void 0, true);
            callHook(onAppearCancelled, [
                el
            ]);
        },
        onLeaveCancelled (el) {
            finishLeave(el);
            callHook(onLeaveCancelled, [
                el
            ]);
        }
    });
}
function normalizeDuration(duration) {
    if (duration == null) return null;
    else if ((0, _shared.isObject)(duration)) return [
        NumberOf(duration.enter),
        NumberOf(duration.leave)
    ];
    else {
        const n = NumberOf(duration);
        return [
            n,
            n
        ];
    }
}
function NumberOf(val) {
    const res = (0, _shared.toNumber)(val);
    (0, _runtimeCore.assertNumber)(res, "<transition> explicit duration");
    return res;
}
function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c)=>c && el.classList.add(c));
    (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c)=>c && el.classList.remove(c));
    const _vtc = el[vtcKey];
    if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) el[vtcKey] = void 0;
    }
}
function nextFrame(cb) {
    requestAnimationFrame(()=>{
        requestAnimationFrame(cb);
    });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
    const id = el._endId = ++endId;
    const resolveIfNotStale = ()=>{
        if (id === el._endId) resolve();
    };
    if (explicitTimeout != null) return setTimeout(resolveIfNotStale, explicitTimeout);
    const { type , timeout , propCount  } = getTransitionInfo(el, expectedType);
    if (!type) return resolve();
    const endEvent = type + "end";
    let ended = 0;
    const end = ()=>{
        el.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
    };
    const onEnd = (e)=>{
        if (e.target === el && ++ended >= propCount) end();
    };
    setTimeout(()=>{
        if (ended < propCount) end();
    }, timeout + 1);
    el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    const getStyleProperties = (key)=>(styles[key] || "").split(", ");
    const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
    const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
    const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type = null;
    let timeout = 0;
    let propCount = 0;
    if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
            type = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
        }
    } else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
            type = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
        }
    } else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
        propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }
    const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(getStyleProperties(`${TRANSITION}Property`).toString());
    return {
        type,
        timeout,
        propCount,
        hasTransform
    };
}
function getTimeout(delays, durations) {
    while(delays.length < durations.length)delays = delays.concat(delays);
    return Math.max(...durations.map((d, i)=>toMs(d) + toMs(delays[i])));
}
function toMs(s) {
    if (s === "auto") return 0;
    return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
    return document.body.offsetHeight;
}
function patchClass(el, value, isSVG) {
    const transitionClasses = el[vtcKey];
    if (transitionClasses) value = (value ? [
        value,
        ...transitionClasses
    ] : [
        ...transitionClasses
    ]).join(" ");
    if (value == null) el.removeAttribute("class");
    else if (isSVG) el.setAttribute("class", value);
    else el.className = value;
}
const vShowOriginalDisplay = Symbol("_vod");
const vShowHidden = Symbol("_vsh");
const vShow = {
    beforeMount (el, { value  }, { transition  }) {
        el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
        if (transition && value) transition.beforeEnter(el);
        else setDisplay(el, value);
    },
    mounted (el, { value  }, { transition  }) {
        if (transition && value) transition.enter(el);
    },
    updated (el, { value , oldValue  }, { transition  }) {
        if (!value === !oldValue) return;
        if (transition) {
            if (value) {
                transition.beforeEnter(el);
                setDisplay(el, true);
                transition.enter(el);
            } else transition.leave(el, ()=>{
                setDisplay(el, false);
            });
        } else setDisplay(el, value);
    },
    beforeUnmount (el, { value  }) {
        setDisplay(el, value);
    }
};
vShow.name = "show";
function setDisplay(el, value) {
    el.style.display = value ? el[vShowOriginalDisplay] : "none";
    el[vShowHidden] = !value;
}
function initVShowForSSR() {
    vShow.getSSRProps = ({ value  })=>{
        if (!value) return {
            style: {
                display: "none"
            }
        };
    };
}
const CSS_VAR_TEXT = Symbol("CSS_VAR_TEXT");
function useCssVars(getter) {
    const instance = (0, _runtimeCore.getCurrentInstance)();
    if (!instance) {
        (0, _runtimeCore.warn)(`useCssVars is called without current active component instance.`);
        return;
    }
    const updateTeleports = instance.ut = (vars = getter(instance.proxy))=>{
        Array.from(document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)).forEach((node)=>setVarsOnNode(node, vars));
    };
    instance.getCssVars = ()=>getter(instance.proxy);
    const setVars = ()=>{
        const vars = getter(instance.proxy);
        if (instance.ce) setVarsOnNode(instance.ce, vars);
        else setVarsOnVNode(instance.subTree, vars);
        updateTeleports(vars);
    };
    (0, _runtimeCore.onBeforeUpdate)(()=>{
        (0, _runtimeCore.queuePostFlushCb)(setVars);
    });
    (0, _runtimeCore.onMounted)(()=>{
        (0, _runtimeCore.watch)(setVars, (0, _shared.NOOP), {
            flush: "post"
        });
        const ob = new MutationObserver(setVars);
        ob.observe(instance.subTree.el.parentNode, {
            childList: true
        });
        (0, _runtimeCore.onUnmounted)(()=>ob.disconnect());
    });
}
function setVarsOnVNode(vnode, vars) {
    if (vnode.shapeFlag & 128) {
        const suspense = vnode.suspense;
        vnode = suspense.activeBranch;
        if (suspense.pendingBranch && !suspense.isHydrating) suspense.effects.push(()=>{
            setVarsOnVNode(suspense.activeBranch, vars);
        });
    }
    while(vnode.component)vnode = vnode.component.subTree;
    if (vnode.shapeFlag & 1 && vnode.el) setVarsOnNode(vnode.el, vars);
    else if (vnode.type === (0, _runtimeCore.Fragment)) vnode.children.forEach((c)=>setVarsOnVNode(c, vars));
    else if (vnode.type === (0, _runtimeCore.Static)) {
        let { el , anchor  } = vnode;
        while(el){
            setVarsOnNode(el, vars);
            if (el === anchor) break;
            el = el.nextSibling;
        }
    }
}
function setVarsOnNode(el, vars) {
    if (el.nodeType === 1) {
        const style = el.style;
        let cssText = "";
        for(const key in vars){
            style.setProperty(`--${key}`, vars[key]);
            cssText += `--${key}: ${vars[key]};`;
        }
        style[CSS_VAR_TEXT] = cssText;
    }
}
const displayRE = /(^|;)\s*display\s*:/;
function patchStyle(el, prev, next) {
    const style = el.style;
    const isCssString = (0, _shared.isString)(next);
    let hasControlledDisplay = false;
    if (next && !isCssString) {
        if (prev) {
            if (!(0, _shared.isString)(prev)) {
                for(const key in prev)if (next[key] == null) setStyle(style, key, "");
            } else for (const prevStyle of prev.split(";")){
                const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
                if (next[key] == null) setStyle(style, key, "");
            }
        }
        for(const key in next){
            if (key === "display") hasControlledDisplay = true;
            setStyle(style, key, next[key]);
        }
    } else {
        if (isCssString) {
            if (prev !== next) {
                const cssVarText = style[CSS_VAR_TEXT];
                if (cssVarText) next += ";" + cssVarText;
                style.cssText = next;
                hasControlledDisplay = displayRE.test(next);
            }
        } else if (prev) el.removeAttribute("style");
    }
    if (vShowOriginalDisplay in el) {
        el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
        if (el[vShowHidden]) style.display = "none";
    }
}
const semicolonRE = /[^\\];\s*$/;
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
    if ((0, _shared.isArray)(val)) val.forEach((v)=>setStyle(style, name, v));
    else {
        if (val == null) val = "";
        if (semicolonRE.test(val)) (0, _runtimeCore.warn)(`Unexpected semicolon at the end of '${name}' style value: '${val}'`);
        if (name.startsWith("--")) style.setProperty(name, val);
        else {
            const prefixed = autoPrefix(style, name);
            if (importantRE.test(val)) style.setProperty((0, _shared.hyphenate)(prefixed), val.replace(importantRE, ""), "important");
            else style[prefixed] = val;
        }
    }
}
const prefixes = [
    "Webkit",
    "Moz",
    "ms"
];
const prefixCache = {};
function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) return cached;
    let name = (0, _runtimeCore.camelize)(rawName);
    if (name !== "filter" && name in style) return prefixCache[rawName] = name;
    name = (0, _shared.capitalize)(name);
    for(let i = 0; i < prefixes.length; i++){
        const prefixed = prefixes[i] + name;
        if (prefixed in style) return prefixCache[rawName] = prefixed;
    }
    return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance, isBoolean = (0, _shared.isSpecialBooleanAttr)(key)) {
    if (isSVG && key.startsWith("xlink:")) {
        if (value == null) el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        else el.setAttributeNS(xlinkNS, key, value);
    } else if (value == null || isBoolean && !(0, _shared.includeBooleanAttr)(value)) el.removeAttribute(key);
    else el.setAttribute(key, isBoolean ? "" : (0, _shared.isSymbol)(value) ? String(value) : value);
}
function patchDOMProp(el, key, value, parentComponent, attrName) {
    if (key === "innerHTML" || key === "textContent") {
        if (value != null) el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
        return;
    }
    const tag = el.tagName;
    if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
    !tag.includes("-")) {
        const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
        const newValue = value == null ? // #11647: value should be set as empty string for null and undefined,
        // but <input type="checkbox"> should be set as 'on'.
        el.type === "checkbox" ? "on" : "" : String(value);
        if (oldValue !== newValue || !("_value" in el)) el.value = newValue;
        if (value == null) el.removeAttribute(key);
        el._value = value;
        return;
    }
    let needRemove = false;
    if (value === "" || value == null) {
        const type = typeof el[key];
        if (type === "boolean") value = (0, _shared.includeBooleanAttr)(value);
        else if (value == null && type === "string") {
            value = "";
            needRemove = true;
        } else if (type === "number") {
            value = 0;
            needRemove = true;
        }
    }
    try {
        el[key] = value;
    } catch (e) {
        if (!needRemove) (0, _runtimeCore.warn)(`Failed setting prop "${key}" on <${tag.toLowerCase()}>: value ${value} is invalid.`, e);
    }
    needRemove && el.removeAttribute(attrName || key);
}
function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
}
const veiKey = Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    const invokers = el[veiKey] || (el[veiKey] = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) existingInvoker.value = sanitizeEventValue(nextValue, rawName);
    else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
            const invoker = invokers[rawName] = createInvoker(sanitizeEventValue(nextValue, rawName), instance);
            addEventListener(el, name, invoker, options);
        } else if (existingInvoker) {
            removeEventListener(el, name, existingInvoker, options);
            invokers[rawName] = void 0;
        }
    }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
        options = {};
        let m;
        while(m = name.match(optionsModifierRE)){
            name = name.slice(0, name.length - m[0].length);
            options[m[0].toLowerCase()] = true;
        }
    }
    const event = name[2] === ":" ? name.slice(3) : (0, _shared.hyphenate)(name.slice(2));
    return [
        event,
        options
    ];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = ()=>cachedNow || (p.then(()=>cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
    const invoker = (e)=>{
        if (!e._vts) e._vts = Date.now();
        else if (e._vts <= invoker.attached) return;
        (0, _runtimeCore.callWithAsyncErrorHandling)(patchStopImmediatePropagation(e, invoker.value), instance, 5, [
            e
        ]);
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
}
function sanitizeEventValue(value, propName) {
    if ((0, _shared.isFunction)(value) || (0, _shared.isArray)(value)) return value;
    (0, _runtimeCore.warn)(`Wrong type passed as event handler to ${propName} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof value}.`);
    return 0, _shared.NOOP;
}
function patchStopImmediatePropagation(e, value) {
    if ((0, _shared.isArray)(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = ()=>{
            originalStop.call(e);
            e._stopped = true;
        };
        return value.map((fn)=>(e2)=>!e2._stopped && fn && fn(e2));
    } else return value;
}
const isNativeOn = (key)=>key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
    key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent)=>{
    const isSVG = namespace === "svg";
    if (key === "class") patchClass(el, nextValue, isSVG);
    else if (key === "style") patchStyle(el, prevValue, nextValue);
    else if ((0, _shared.isOn)(key)) {
        if (!(0, _shared.isModelListener)(key)) patchEvent(el, key, prevValue, nextValue, parentComponent);
    } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
        patchDOMProp(el, key, nextValue);
        if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
    } else if (// #11081 force set props for possible async custom element
    el._isVueCE && (/[A-Z]/.test(key) || !(0, _shared.isString)(nextValue))) patchDOMProp(el, (0, _shared.camelize)(key), nextValue, parentComponent, key);
    else {
        if (key === "true-value") el._trueValue = nextValue;
        else if (key === "false-value") el._falseValue = nextValue;
        patchAttr(el, key, nextValue, isSVG);
    }
};
function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
        if (key === "innerHTML" || key === "textContent") return true;
        if (key in el && isNativeOn(key) && (0, _shared.isFunction)(value)) return true;
        return false;
    }
    if (key === "spellcheck" || key === "draggable" || key === "translate" || key === "autocorrect") return false;
    if (key === "form") return false;
    if (key === "list" && el.tagName === "INPUT") return false;
    if (key === "type" && el.tagName === "TEXTAREA") return false;
    if (key === "width" || key === "height") {
        const tag = el.tagName;
        if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") return false;
    }
    if (isNativeOn(key) && (0, _shared.isString)(value)) return false;
    return key in el;
}
const REMOVAL = {};
/*! #__NO_SIDE_EFFECTS__ */ // @__NO_SIDE_EFFECTS__
function defineCustomElement(options, extraOptions, _createApp) {
    const Comp = (0, _runtimeCore.defineComponent)(options, extraOptions);
    if ((0, _shared.isPlainObject)(Comp)) (0, _shared.extend)(Comp, extraOptions);
    class VueCustomElement extends VueElement {
        constructor(initialProps){
            super(Comp, initialProps, _createApp);
        }
    }
    VueCustomElement.def = Comp;
    return VueCustomElement;
}
/*! #__NO_SIDE_EFFECTS__ */ const defineSSRCustomElement = /* @__NO_SIDE_EFFECTS__ */ (options, extraOptions)=>{
    return /* @__PURE__ */ defineCustomElement(options, extraOptions, createSSRApp);
};
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
    constructor(_def, _props = {}, _createApp = createApp){
        super();
        this._def = _def;
        this._props = _props;
        this._createApp = _createApp;
        this._isVueCE = true;
        /**
     * @internal
     */ this._instance = null;
        /**
     * @internal
     */ this._app = null;
        /**
     * @internal
     */ this._nonce = this._def.nonce;
        this._connected = false;
        this._resolved = false;
        this._numberProps = null;
        this._styleChildren = /* @__PURE__ */ new WeakSet();
        this._ob = null;
        if (this.shadowRoot && _createApp !== createApp) this._root = this.shadowRoot;
        else {
            if (0, this.shadowRoot) (0, _runtimeCore.warn)(`Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use \`defineSSRCustomElement\`.`);
            if (_def.shadowRoot !== false) {
                this.attachShadow({
                    mode: "open"
                });
                this._root = this.shadowRoot;
            } else this._root = this;
        }
    }
    connectedCallback() {
        if (!this.isConnected) return;
        if (!this.shadowRoot && !this._resolved) this._parseSlots();
        this._connected = true;
        let parent = this;
        while(parent = parent && (parent.parentNode || parent.host))if (parent instanceof VueElement) {
            this._parent = parent;
            break;
        }
        if (!this._instance) {
            if (this._resolved) this._mount(this._def);
            else if (parent && parent._pendingResolve) this._pendingResolve = parent._pendingResolve.then(()=>{
                this._pendingResolve = void 0;
                this._resolveDef();
            });
            else this._resolveDef();
        }
    }
    _setParent(parent = this._parent) {
        if (parent) {
            this._instance.parent = parent._instance;
            this._inheritParentContext(parent);
        }
    }
    _inheritParentContext(parent = this._parent) {
        if (parent && this._app) Object.setPrototypeOf(this._app._context.provides, parent._instance.provides);
    }
    disconnectedCallback() {
        this._connected = false;
        (0, _runtimeCore.nextTick)(()=>{
            if (!this._connected) {
                if (this._ob) {
                    this._ob.disconnect();
                    this._ob = null;
                }
                this._app && this._app.unmount();
                if (this._instance) this._instance.ce = void 0;
                this._app = this._instance = null;
            }
        });
    }
    /**
   * resolve inner component definition (handle possible async component)
   */ _resolveDef() {
        if (this._pendingResolve) return;
        for(let i = 0; i < this.attributes.length; i++)this._setAttr(this.attributes[i].name);
        this._ob = new MutationObserver((mutations)=>{
            for (const m of mutations)this._setAttr(m.attributeName);
        });
        this._ob.observe(this, {
            attributes: true
        });
        const resolve = (def, isAsync = false)=>{
            this._resolved = true;
            this._pendingResolve = void 0;
            const { props , styles  } = def;
            let numberProps;
            if (props && !(0, _shared.isArray)(props)) for(const key in props){
                const opt = props[key];
                if (opt === Number || opt && opt.type === Number) {
                    if (key in this._props) this._props[key] = (0, _shared.toNumber)(this._props[key]);
                    (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[(0, _shared.camelize)(key)] = true;
                }
            }
            this._numberProps = numberProps;
            this._resolveProps(def);
            if (this.shadowRoot) this._applyStyles(styles);
            else if (styles) (0, _runtimeCore.warn)("Custom element style injection is not supported when using shadowRoot: false");
            this._mount(def);
        };
        const asyncDef = this._def.__asyncLoader;
        if (asyncDef) this._pendingResolve = asyncDef().then((def)=>resolve(this._def = def, true));
        else resolve(this._def);
    }
    _mount(def) {
        if (!def.name) def.name = "VueElement";
        this._app = this._createApp(def);
        this._inheritParentContext();
        if (def.configureApp) def.configureApp(this._app);
        this._app._ceVNode = this._createVNode();
        this._app.mount(this._root);
        const exposed = this._instance && this._instance.exposed;
        if (!exposed) return;
        for(const key in exposed)if (!(0, _shared.hasOwn)(this, key)) Object.defineProperty(this, key, {
            // unwrap ref to be consistent with public instance behavior
            get: ()=>(0, _runtimeCore.unref)(exposed[key])
        });
        else (0, _runtimeCore.warn)(`Exposed property "${key}" already exists on custom element.`);
    }
    _resolveProps(def) {
        const { props  } = def;
        const declaredPropKeys = (0, _shared.isArray)(props) ? props : Object.keys(props || {});
        for (const key of Object.keys(this))if (key[0] !== "_" && declaredPropKeys.includes(key)) this._setProp(key, this[key]);
        for (const key of declaredPropKeys.map((0, _shared.camelize)))Object.defineProperty(this, key, {
            get () {
                return this._getProp(key);
            },
            set (val) {
                this._setProp(key, val, true, true);
            }
        });
    }
    _setAttr(key) {
        if (key.startsWith("data-v-")) return;
        const has = this.hasAttribute(key);
        let value = has ? this.getAttribute(key) : REMOVAL;
        const camelKey = (0, _shared.camelize)(key);
        if (has && this._numberProps && this._numberProps[camelKey]) value = (0, _shared.toNumber)(value);
        this._setProp(camelKey, value, false, true);
    }
    /**
   * @internal
   */ _getProp(key) {
        return this._props[key];
    }
    /**
   * @internal
   */ _setProp(key, val, shouldReflect = true, shouldUpdate = false) {
        if (val !== this._props[key]) {
            if (val === REMOVAL) delete this._props[key];
            else {
                this._props[key] = val;
                if (key === "key" && this._app) this._app._ceVNode.key = val;
            }
            if (shouldUpdate && this._instance) this._update();
            if (shouldReflect) {
                const ob = this._ob;
                ob && ob.disconnect();
                if (val === true) this.setAttribute((0, _shared.hyphenate)(key), "");
                else if (typeof val === "string" || typeof val === "number") this.setAttribute((0, _shared.hyphenate)(key), val + "");
                else if (!val) this.removeAttribute((0, _shared.hyphenate)(key));
                ob && ob.observe(this, {
                    attributes: true
                });
            }
        }
    }
    _update() {
        const vnode = this._createVNode();
        if (this._app) vnode.appContext = this._app._context;
        render(vnode, this._root);
    }
    _createVNode() {
        const baseProps = {};
        if (!this.shadowRoot) baseProps.onVnodeMounted = baseProps.onVnodeUpdated = this._renderSlots.bind(this);
        const vnode = (0, _runtimeCore.createVNode)(this._def, (0, _shared.extend)(baseProps, this._props));
        if (!this._instance) vnode.ce = (instance)=>{
            this._instance = instance;
            instance.ce = this;
            instance.isCE = true;
            instance.ceReload = (newStyles)=>{
                if (this._styles) {
                    this._styles.forEach((s)=>this._root.removeChild(s));
                    this._styles.length = 0;
                }
                this._applyStyles(newStyles);
                this._instance = null;
                this._update();
            };
            const dispatch = (event, args)=>{
                this.dispatchEvent(new CustomEvent(event, (0, _shared.isPlainObject)(args[0]) ? (0, _shared.extend)({
                    detail: args
                }, args[0]) : {
                    detail: args
                }));
            };
            instance.emit = (event, ...args)=>{
                dispatch(event, args);
                if ((0, _shared.hyphenate)(event) !== event) dispatch((0, _shared.hyphenate)(event), args);
            };
            this._setParent();
        };
        return vnode;
    }
    _applyStyles(styles, owner) {
        if (!styles) return;
        if (owner) {
            if (owner === this._def || this._styleChildren.has(owner)) return;
            this._styleChildren.add(owner);
        }
        const nonce = this._nonce;
        for(let i = styles.length - 1; i >= 0; i--){
            const s = document.createElement("style");
            if (nonce) s.setAttribute("nonce", nonce);
            s.textContent = styles[i];
            this.shadowRoot.prepend(s);
            if (owner) {
                if (owner.__hmrId) {
                    if (!this._childStyles) this._childStyles = /* @__PURE__ */ new Map();
                    let entry = this._childStyles.get(owner.__hmrId);
                    if (!entry) this._childStyles.set(owner.__hmrId, entry = []);
                    entry.push(s);
                }
            } else (this._styles || (this._styles = [])).push(s);
        }
    }
    /**
   * Only called when shadowRoot is false
   */ _parseSlots() {
        const slots = this._slots = {};
        let n;
        while(n = this.firstChild){
            const slotName = n.nodeType === 1 && n.getAttribute("slot") || "default";
            (slots[slotName] || (slots[slotName] = [])).push(n);
            this.removeChild(n);
        }
    }
    /**
   * Only called when shadowRoot is false
   */ _renderSlots() {
        const outlets = (this._teleportTarget || this).querySelectorAll("slot");
        const scopeId = this._instance.type.__scopeId;
        for(let i = 0; i < outlets.length; i++){
            const o = outlets[i];
            const slotName = o.getAttribute("name") || "default";
            const content = this._slots[slotName];
            const parent = o.parentNode;
            if (content) for (const n of content){
                if (scopeId && n.nodeType === 1) {
                    const id = scopeId + "-s";
                    const walker = document.createTreeWalker(n, 1);
                    n.setAttribute(id, "");
                    let child;
                    while(child = walker.nextNode())child.setAttribute(id, "");
                }
                parent.insertBefore(n, o);
            }
            else while(o.firstChild)parent.insertBefore(o.firstChild, o);
            parent.removeChild(o);
        }
    }
    /**
   * @internal
   */ _injectChildStyle(comp) {
        this._applyStyles(comp.styles, comp);
    }
    /**
   * @internal
   */ _removeChildStyle(comp) {
        this._styleChildren.delete(comp);
        if (this._childStyles && comp.__hmrId) {
            const oldStyles = this._childStyles.get(comp.__hmrId);
            if (oldStyles) {
                oldStyles.forEach((s)=>this._root.removeChild(s));
                oldStyles.length = 0;
            }
        }
    }
}
function useHost(caller) {
    const instance = (0, _runtimeCore.getCurrentInstance)();
    const el = instance && instance.ce;
    if (el) return el;
    else if (true) {
        if (!instance) (0, _runtimeCore.warn)(`${caller || "useHost"} called without an active component instance.`);
        else (0, _runtimeCore.warn)(`${caller || "useHost"} can only be used in components defined via defineCustomElement.`);
    }
    return null;
}
function useShadowRoot() {
    const el = useHost("useShadowRoot");
    return el && el.shadowRoot;
}
function useCssModule(name = "$style") {
    {
        const instance = (0, _runtimeCore.getCurrentInstance)();
        if (!instance) {
            (0, _runtimeCore.warn)(`useCssModule must be called inside setup()`);
            return 0, _shared.EMPTY_OBJ;
        }
        const modules = instance.type.__cssModules;
        if (!modules) {
            (0, _runtimeCore.warn)(`Current instance does not have CSS modules injected.`);
            return 0, _shared.EMPTY_OBJ;
        }
        const mod = modules[name];
        if (!mod) {
            (0, _runtimeCore.warn)(`Current instance does not have CSS module named "${name}".`);
            return 0, _shared.EMPTY_OBJ;
        }
        return mod;
    }
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const moveCbKey = Symbol("_moveCb");
const enterCbKey = Symbol("_enterCb");
const decorate = (t)=>{
    delete t.props.mode;
    return t;
};
const TransitionGroupImpl = /* @__PURE__ */ decorate({
    name: "TransitionGroup",
    props: /* @__PURE__ */ (0, _shared.extend)({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
    }),
    setup (props, { slots  }) {
        const instance = (0, _runtimeCore.getCurrentInstance)();
        const state = (0, _runtimeCore.useTransitionState)();
        let prevChildren;
        let children;
        (0, _runtimeCore.onUpdated)(()=>{
            if (!prevChildren.length) return;
            const moveClass = props.moveClass || `${props.name || "v"}-move`;
            if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
                prevChildren = [];
                return;
            }
            prevChildren.forEach(callPendingCbs);
            prevChildren.forEach(recordPosition);
            const movedChildren = prevChildren.filter(applyTranslation);
            forceReflow();
            movedChildren.forEach((c)=>{
                const el = c.el;
                const style = el.style;
                addTransitionClass(el, moveClass);
                style.transform = style.webkitTransform = style.transitionDuration = "";
                const cb = el[moveCbKey] = (e)=>{
                    if (e && e.target !== el) return;
                    if (!e || /transform$/.test(e.propertyName)) {
                        el.removeEventListener("transitionend", cb);
                        el[moveCbKey] = null;
                        removeTransitionClass(el, moveClass);
                    }
                };
                el.addEventListener("transitionend", cb);
            });
            prevChildren = [];
        });
        return ()=>{
            const rawProps = (0, _runtimeCore.toRaw)(props);
            const cssTransitionProps = resolveTransitionProps(rawProps);
            let tag = rawProps.tag || (0, _runtimeCore.Fragment);
            prevChildren = [];
            if (children) for(let i = 0; i < children.length; i++){
                const child = children[i];
                if (child.el && child.el instanceof Element) {
                    prevChildren.push(child);
                    (0, _runtimeCore.setTransitionHooks)(child, (0, _runtimeCore.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
                    positionMap.set(child, child.el.getBoundingClientRect());
                }
            }
            children = slots.default ? (0, _runtimeCore.getTransitionRawChildren)(slots.default()) : [];
            for(let i = 0; i < children.length; i++){
                const child = children[i];
                if (child.key != null) (0, _runtimeCore.setTransitionHooks)(child, (0, _runtimeCore.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
                else if (child.type !== (0, _runtimeCore.Text)) (0, _runtimeCore.warn)(`<TransitionGroup> children must be keyed.`);
            }
            return (0, _runtimeCore.createVNode)(tag, null, children);
        };
    }
});
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
    const el = c.el;
    if (el[moveCbKey]) el[moveCbKey]();
    if (el[enterCbKey]) el[enterCbKey]();
}
function recordPosition(c) {
    newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
    const oldPos = positionMap.get(c);
    const newPos = newPositionMap.get(c);
    const dx = oldPos.left - newPos.left;
    const dy = oldPos.top - newPos.top;
    if (dx || dy) {
        const s = c.el.style;
        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = "0s";
        return c;
    }
}
function hasCSSTransform(el, root, moveClass) {
    const clone = el.cloneNode();
    const _vtc = el[vtcKey];
    if (_vtc) _vtc.forEach((cls)=>{
        cls.split(/\s+/).forEach((c)=>c && clone.classList.remove(c));
    });
    moveClass.split(/\s+/).forEach((c)=>c && clone.classList.add(c));
    clone.style.display = "none";
    const container = root.nodeType === 1 ? root : root.parentNode;
    container.appendChild(clone);
    const { hasTransform  } = getTransitionInfo(clone);
    container.removeChild(clone);
    return hasTransform;
}
const getModelAssigner = (vnode)=>{
    const fn = vnode.props["onUpdate:modelValue"] || false;
    return (0, _shared.isArray)(fn) ? (value)=>(0, _shared.invokeArrayFns)(fn, value) : fn;
};
function onCompositionStart(e) {
    e.target.composing = true;
}
function onCompositionEnd(e) {
    const target = e.target;
    if (target.composing) {
        target.composing = false;
        target.dispatchEvent(new Event("input"));
    }
}
const assignKey = Symbol("_assign");
const vModelText = {
    created (el, { modifiers: { lazy , trim , number  }  }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        const castToNumber = number || vnode.props && vnode.props.type === "number";
        addEventListener(el, lazy ? "change" : "input", (e)=>{
            if (e.target.composing) return;
            let domValue = el.value;
            if (trim) domValue = domValue.trim();
            if (castToNumber) domValue = (0, _shared.looseToNumber)(domValue);
            el[assignKey](domValue);
        });
        if (trim) addEventListener(el, "change", ()=>{
            el.value = el.value.trim();
        });
        if (!lazy) {
            addEventListener(el, "compositionstart", onCompositionStart);
            addEventListener(el, "compositionend", onCompositionEnd);
            addEventListener(el, "change", onCompositionEnd);
        }
    },
    // set value on mounted so it's after min/max for type="range"
    mounted (el, { value  }) {
        el.value = value == null ? "" : value;
    },
    beforeUpdate (el, { value , oldValue , modifiers: { lazy , trim , number  }  }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        if (el.composing) return;
        const elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? (0, _shared.looseToNumber)(el.value) : el.value;
        const newValue = value == null ? "" : value;
        if (elValue === newValue) return;
        if (document.activeElement === el && el.type !== "range") {
            if (lazy && value === oldValue) return;
            if (trim && el.value.trim() === newValue) return;
        }
        el.value = newValue;
    }
};
const vModelCheckbox = {
    // #4096 array checkboxes need to be deep traversed
    deep: true,
    created (el, _, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        addEventListener(el, "change", ()=>{
            const modelValue = el._modelValue;
            const elementValue = getValue(el);
            const checked = el.checked;
            const assign = el[assignKey];
            if ((0, _shared.isArray)(modelValue)) {
                const index = (0, _shared.looseIndexOf)(modelValue, elementValue);
                const found = index !== -1;
                if (checked && !found) assign(modelValue.concat(elementValue));
                else if (!checked && found) {
                    const filtered = [
                        ...modelValue
                    ];
                    filtered.splice(index, 1);
                    assign(filtered);
                }
            } else if ((0, _shared.isSet)(modelValue)) {
                const cloned = new Set(modelValue);
                if (checked) cloned.add(elementValue);
                else cloned.delete(elementValue);
                assign(cloned);
            } else assign(getCheckboxValue(el, checked));
        });
    },
    // set initial checked on mount to wait for true-value/false-value
    mounted: setChecked,
    beforeUpdate (el, binding, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        setChecked(el, binding, vnode);
    }
};
function setChecked(el, { value , oldValue  }, vnode) {
    el._modelValue = value;
    let checked;
    if ((0, _shared.isArray)(value)) checked = (0, _shared.looseIndexOf)(value, vnode.props.value) > -1;
    else if ((0, _shared.isSet)(value)) checked = value.has(vnode.props.value);
    else {
        if (value === oldValue) return;
        checked = (0, _shared.looseEqual)(value, getCheckboxValue(el, true));
    }
    if (el.checked !== checked) el.checked = checked;
}
const vModelRadio = {
    created (el, { value  }, vnode) {
        el.checked = (0, _shared.looseEqual)(value, vnode.props.value);
        el[assignKey] = getModelAssigner(vnode);
        addEventListener(el, "change", ()=>{
            el[assignKey](getValue(el));
        });
    },
    beforeUpdate (el, { value , oldValue  }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        if (value !== oldValue) el.checked = (0, _shared.looseEqual)(value, vnode.props.value);
    }
};
const vModelSelect = {
    // <select multiple> value need to be deep traversed
    deep: true,
    created (el, { value , modifiers: { number  }  }, vnode) {
        const isSetModel = (0, _shared.isSet)(value);
        addEventListener(el, "change", ()=>{
            const selectedVal = Array.prototype.filter.call(el.options, (o)=>o.selected).map((o)=>number ? (0, _shared.looseToNumber)(getValue(o)) : getValue(o));
            el[assignKey](el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
            el._assigning = true;
            (0, _runtimeCore.nextTick)(()=>{
                el._assigning = false;
            });
        });
        el[assignKey] = getModelAssigner(vnode);
    },
    // set value in mounted & updated because <select> relies on its children
    // <option>s.
    mounted (el, { value  }) {
        setSelected(el, value);
    },
    beforeUpdate (el, _binding, vnode) {
        el[assignKey] = getModelAssigner(vnode);
    },
    updated (el, { value  }) {
        if (!el._assigning) setSelected(el, value);
    }
};
function setSelected(el, value) {
    const isMultiple = el.multiple;
    const isArrayValue = (0, _shared.isArray)(value);
    if (isMultiple && !isArrayValue && !(0, _shared.isSet)(value)) {
        (0, _runtimeCore.warn)(`<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);
        return;
    }
    for(let i = 0, l = el.options.length; i < l; i++){
        const option = el.options[i];
        const optionValue = getValue(option);
        if (isMultiple) {
            if (isArrayValue) {
                const optionType = typeof optionValue;
                if (optionType === "string" || optionType === "number") option.selected = value.some((v)=>String(v) === String(optionValue));
                else option.selected = (0, _shared.looseIndexOf)(value, optionValue) > -1;
            } else option.selected = value.has(optionValue);
        } else if ((0, _shared.looseEqual)(getValue(option), value)) {
            if (el.selectedIndex !== i) el.selectedIndex = i;
            return;
        }
    }
    if (!isMultiple && el.selectedIndex !== -1) el.selectedIndex = -1;
}
function getValue(el) {
    return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
    const key = checked ? "_trueValue" : "_falseValue";
    return key in el ? el[key] : checked;
}
const vModelDynamic = {
    created (el, binding, vnode) {
        callModelHook(el, binding, vnode, null, "created");
    },
    mounted (el, binding, vnode) {
        callModelHook(el, binding, vnode, null, "mounted");
    },
    beforeUpdate (el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
    },
    updated (el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, "updated");
    }
};
function resolveDynamicModel(tagName, type) {
    switch(tagName){
        case "SELECT":
            return vModelSelect;
        case "TEXTAREA":
            return vModelText;
        default:
            switch(type){
                case "checkbox":
                    return vModelCheckbox;
                case "radio":
                    return vModelRadio;
                default:
                    return vModelText;
            }
    }
}
function callModelHook(el, binding, vnode, prevVNode, hook) {
    const modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);
    const fn = modelToUse[hook];
    fn && fn(el, binding, vnode, prevVNode);
}
function initVModelForSSR() {
    vModelText.getSSRProps = ({ value  })=>({
            value
        });
    vModelRadio.getSSRProps = ({ value  }, vnode)=>{
        if (vnode.props && (0, _shared.looseEqual)(vnode.props.value, value)) return {
            checked: true
        };
    };
    vModelCheckbox.getSSRProps = ({ value  }, vnode)=>{
        if ((0, _shared.isArray)(value)) {
            if (vnode.props && (0, _shared.looseIndexOf)(value, vnode.props.value) > -1) return {
                checked: true
            };
        } else if ((0, _shared.isSet)(value)) {
            if (vnode.props && value.has(vnode.props.value)) return {
                checked: true
            };
        } else if (value) return {
            checked: true
        };
    };
    vModelDynamic.getSSRProps = (binding, vnode)=>{
        if (typeof vnode.type !== "string") return;
        const modelToUse = resolveDynamicModel(// resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
        vnode.type.toUpperCase(), vnode.props && vnode.props.type);
        if (modelToUse.getSSRProps) return modelToUse.getSSRProps(binding, vnode);
    };
}
const systemModifiers = [
    "ctrl",
    "shift",
    "alt",
    "meta"
];
const modifierGuards = {
    stop: (e)=>e.stopPropagation(),
    prevent: (e)=>e.preventDefault(),
    self: (e)=>e.target !== e.currentTarget,
    ctrl: (e)=>!e.ctrlKey,
    shift: (e)=>!e.shiftKey,
    alt: (e)=>!e.altKey,
    meta: (e)=>!e.metaKey,
    left: (e)=>"button" in e && e.button !== 0,
    middle: (e)=>"button" in e && e.button !== 1,
    right: (e)=>"button" in e && e.button !== 2,
    exact: (e, modifiers)=>systemModifiers.some((m)=>e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers)=>{
    const cache = fn._withMods || (fn._withMods = {});
    const cacheKey = modifiers.join(".");
    return cache[cacheKey] || (cache[cacheKey] = (event, ...args)=>{
        for(let i = 0; i < modifiers.length; i++){
            const guard = modifierGuards[modifiers[i]];
            if (guard && guard(event, modifiers)) return;
        }
        return fn(event, ...args);
    });
};
const keyNames = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
};
const withKeys = (fn, modifiers)=>{
    const cache = fn._withKeys || (fn._withKeys = {});
    const cacheKey = modifiers.join(".");
    return cache[cacheKey] || (cache[cacheKey] = (event)=>{
        if (!("key" in event)) return;
        const eventKey = (0, _shared.hyphenate)(event.key);
        if (modifiers.some((k)=>k === eventKey || keyNames[k] === eventKey)) return fn(event);
    });
};
const rendererOptions = /* @__PURE__ */ (0, _shared.extend)({
    patchProp
}, nodeOps);
let renderer;
let enabledHydration = false;
function ensureRenderer() {
    return renderer || (renderer = (0, _runtimeCore.createRenderer)(rendererOptions));
}
function ensureHydrationRenderer() {
    renderer = enabledHydration ? renderer : (0, _runtimeCore.createHydrationRenderer)(rendererOptions);
    enabledHydration = true;
    return renderer;
}
const render = (...args)=>{
    ensureRenderer().render(...args);
};
const hydrate = (...args)=>{
    ensureHydrationRenderer().hydrate(...args);
};
const createApp = (...args)=>{
    const app = ensureRenderer().createApp(...args);
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
    const { mount  } = app;
    app.mount = (containerOrSelector)=>{
        const container = normalizeContainer(containerOrSelector);
        if (!container) return;
        const component = app._component;
        if (!(0, _shared.isFunction)(component) && !component.render && !component.template) component.template = container.innerHTML;
        if (container.nodeType === 1) container.textContent = "";
        const proxy = mount(container, false, resolveRootNamespace(container));
        if (container instanceof Element) {
            container.removeAttribute("v-cloak");
            container.setAttribute("data-v-app", "");
        }
        return proxy;
    };
    return app;
};
const createSSRApp = (...args)=>{
    const app = ensureHydrationRenderer().createApp(...args);
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
    const { mount  } = app;
    app.mount = (containerOrSelector)=>{
        const container = normalizeContainer(containerOrSelector);
        if (container) return mount(container, true, resolveRootNamespace(container));
    };
    return app;
};
function resolveRootNamespace(container) {
    if (container instanceof SVGElement) return "svg";
    if (typeof MathMLElement === "function" && container instanceof MathMLElement) return "mathml";
}
function injectNativeTagCheck(app) {
    Object.defineProperty(app.config, "isNativeTag", {
        value: (tag)=>(0, _shared.isHTMLTag)(tag) || (0, _shared.isSVGTag)(tag) || (0, _shared.isMathMLTag)(tag),
        writable: false
    });
}
function injectCompilerOptionsCheck(app) {
    if ((0, _runtimeCore.isRuntimeOnly)()) {
        const isCustomElement = app.config.isCustomElement;
        Object.defineProperty(app.config, "isCustomElement", {
            get () {
                return isCustomElement;
            },
            set () {
                (0, _runtimeCore.warn)(`The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`);
            }
        });
        const compilerOptions = app.config.compilerOptions;
        const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;
        Object.defineProperty(app.config, "compilerOptions", {
            get () {
                (0, _runtimeCore.warn)(msg);
                return compilerOptions;
            },
            set () {
                (0, _runtimeCore.warn)(msg);
            }
        });
    }
}
function normalizeContainer(container) {
    if ((0, _shared.isString)(container)) {
        const res = document.querySelector(container);
        if (!res) (0, _runtimeCore.warn)(`Failed to mount app: mount target selector "${container}" returned null.`);
        return res;
    }
    if ((0, window.ShadowRoot) && container instanceof window.ShadowRoot && container.mode === "closed") (0, _runtimeCore.warn)(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
    return container;
}
let ssrDirectiveInitialized = false;
const initDirectivesForSSR = ()=>{
    if (!ssrDirectiveInitialized) {
        ssrDirectiveInitialized = true;
        initVModelForSSR();
        initVShowForSSR();
    }
};

},{"@vue/runtime-core":"6EA3u","@vue/shared":"din1v","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"6EA3u":[function(require,module,exports) {
/**
* @vue/runtime-core v3.5.16
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EffectScope", ()=>(0, _reactivity.EffectScope));
parcelHelpers.export(exports, "ReactiveEffect", ()=>(0, _reactivity.ReactiveEffect));
parcelHelpers.export(exports, "TrackOpTypes", ()=>(0, _reactivity.TrackOpTypes));
parcelHelpers.export(exports, "TriggerOpTypes", ()=>(0, _reactivity.TriggerOpTypes));
parcelHelpers.export(exports, "customRef", ()=>(0, _reactivity.customRef));
parcelHelpers.export(exports, "effect", ()=>(0, _reactivity.effect));
parcelHelpers.export(exports, "effectScope", ()=>(0, _reactivity.effectScope));
parcelHelpers.export(exports, "getCurrentScope", ()=>(0, _reactivity.getCurrentScope));
parcelHelpers.export(exports, "getCurrentWatcher", ()=>(0, _reactivity.getCurrentWatcher));
parcelHelpers.export(exports, "isProxy", ()=>(0, _reactivity.isProxy));
parcelHelpers.export(exports, "isReactive", ()=>(0, _reactivity.isReactive));
parcelHelpers.export(exports, "isReadonly", ()=>(0, _reactivity.isReadonly));
parcelHelpers.export(exports, "isRef", ()=>(0, _reactivity.isRef));
parcelHelpers.export(exports, "isShallow", ()=>(0, _reactivity.isShallow));
parcelHelpers.export(exports, "markRaw", ()=>(0, _reactivity.markRaw));
parcelHelpers.export(exports, "onScopeDispose", ()=>(0, _reactivity.onScopeDispose));
parcelHelpers.export(exports, "onWatcherCleanup", ()=>(0, _reactivity.onWatcherCleanup));
parcelHelpers.export(exports, "proxyRefs", ()=>(0, _reactivity.proxyRefs));
parcelHelpers.export(exports, "reactive", ()=>(0, _reactivity.reactive));
parcelHelpers.export(exports, "readonly", ()=>(0, _reactivity.readonly));
parcelHelpers.export(exports, "ref", ()=>(0, _reactivity.ref));
parcelHelpers.export(exports, "shallowReactive", ()=>(0, _reactivity.shallowReactive));
parcelHelpers.export(exports, "shallowReadonly", ()=>(0, _reactivity.shallowReadonly));
parcelHelpers.export(exports, "shallowRef", ()=>(0, _reactivity.shallowRef));
parcelHelpers.export(exports, "stop", ()=>(0, _reactivity.stop));
parcelHelpers.export(exports, "toRaw", ()=>(0, _reactivity.toRaw));
parcelHelpers.export(exports, "toRef", ()=>(0, _reactivity.toRef));
parcelHelpers.export(exports, "toRefs", ()=>(0, _reactivity.toRefs));
parcelHelpers.export(exports, "toValue", ()=>(0, _reactivity.toValue));
parcelHelpers.export(exports, "triggerRef", ()=>(0, _reactivity.triggerRef));
parcelHelpers.export(exports, "unref", ()=>(0, _reactivity.unref));
parcelHelpers.export(exports, "camelize", ()=>(0, _shared.camelize));
parcelHelpers.export(exports, "capitalize", ()=>(0, _shared.capitalize));
parcelHelpers.export(exports, "normalizeClass", ()=>(0, _shared.normalizeClass));
parcelHelpers.export(exports, "normalizeProps", ()=>(0, _shared.normalizeProps));
parcelHelpers.export(exports, "normalizeStyle", ()=>(0, _shared.normalizeStyle));
parcelHelpers.export(exports, "toDisplayString", ()=>(0, _shared.toDisplayString));
parcelHelpers.export(exports, "toHandlerKey", ()=>(0, _shared.toHandlerKey));
parcelHelpers.export(exports, "BaseTransition", ()=>BaseTransition);
parcelHelpers.export(exports, "BaseTransitionPropsValidators", ()=>BaseTransitionPropsValidators);
parcelHelpers.export(exports, "Comment", ()=>Comment);
parcelHelpers.export(exports, "DeprecationTypes", ()=>DeprecationTypes);
parcelHelpers.export(exports, "ErrorCodes", ()=>ErrorCodes);
parcelHelpers.export(exports, "ErrorTypeStrings", ()=>ErrorTypeStrings);
parcelHelpers.export(exports, "Fragment", ()=>Fragment);
parcelHelpers.export(exports, "KeepAlive", ()=>KeepAlive);
parcelHelpers.export(exports, "Static", ()=>Static);
parcelHelpers.export(exports, "Suspense", ()=>Suspense);
parcelHelpers.export(exports, "Teleport", ()=>Teleport);
parcelHelpers.export(exports, "Text", ()=>Text);
parcelHelpers.export(exports, "assertNumber", ()=>assertNumber);
parcelHelpers.export(exports, "callWithAsyncErrorHandling", ()=>callWithAsyncErrorHandling);
parcelHelpers.export(exports, "callWithErrorHandling", ()=>callWithErrorHandling);
parcelHelpers.export(exports, "cloneVNode", ()=>cloneVNode);
parcelHelpers.export(exports, "compatUtils", ()=>compatUtils);
parcelHelpers.export(exports, "computed", ()=>computed);
parcelHelpers.export(exports, "createBlock", ()=>createBlock);
parcelHelpers.export(exports, "createCommentVNode", ()=>createCommentVNode);
parcelHelpers.export(exports, "createElementBlock", ()=>createElementBlock);
parcelHelpers.export(exports, "createElementVNode", ()=>createBaseVNode);
parcelHelpers.export(exports, "createHydrationRenderer", ()=>createHydrationRenderer);
parcelHelpers.export(exports, "createPropsRestProxy", ()=>createPropsRestProxy);
parcelHelpers.export(exports, "createRenderer", ()=>createRenderer);
parcelHelpers.export(exports, "createSlots", ()=>createSlots);
parcelHelpers.export(exports, "createStaticVNode", ()=>createStaticVNode);
parcelHelpers.export(exports, "createTextVNode", ()=>createTextVNode);
parcelHelpers.export(exports, "createVNode", ()=>createVNode);
parcelHelpers.export(exports, "defineAsyncComponent", ()=>defineAsyncComponent);
parcelHelpers.export(exports, "defineComponent", ()=>defineComponent);
parcelHelpers.export(exports, "defineEmits", ()=>defineEmits);
parcelHelpers.export(exports, "defineExpose", ()=>defineExpose);
parcelHelpers.export(exports, "defineModel", ()=>defineModel);
parcelHelpers.export(exports, "defineOptions", ()=>defineOptions);
parcelHelpers.export(exports, "defineProps", ()=>defineProps);
parcelHelpers.export(exports, "defineSlots", ()=>defineSlots);
parcelHelpers.export(exports, "devtools", ()=>devtools);
parcelHelpers.export(exports, "getCurrentInstance", ()=>getCurrentInstance);
parcelHelpers.export(exports, "getTransitionRawChildren", ()=>getTransitionRawChildren);
parcelHelpers.export(exports, "guardReactiveProps", ()=>guardReactiveProps);
parcelHelpers.export(exports, "h", ()=>h);
parcelHelpers.export(exports, "handleError", ()=>handleError);
parcelHelpers.export(exports, "hasInjectionContext", ()=>hasInjectionContext);
parcelHelpers.export(exports, "hydrateOnIdle", ()=>hydrateOnIdle);
parcelHelpers.export(exports, "hydrateOnInteraction", ()=>hydrateOnInteraction);
parcelHelpers.export(exports, "hydrateOnMediaQuery", ()=>hydrateOnMediaQuery);
parcelHelpers.export(exports, "hydrateOnVisible", ()=>hydrateOnVisible);
parcelHelpers.export(exports, "initCustomFormatter", ()=>initCustomFormatter);
parcelHelpers.export(exports, "inject", ()=>inject);
parcelHelpers.export(exports, "isMemoSame", ()=>isMemoSame);
parcelHelpers.export(exports, "isRuntimeOnly", ()=>isRuntimeOnly);
parcelHelpers.export(exports, "isVNode", ()=>isVNode);
parcelHelpers.export(exports, "mergeDefaults", ()=>mergeDefaults);
parcelHelpers.export(exports, "mergeModels", ()=>mergeModels);
parcelHelpers.export(exports, "mergeProps", ()=>mergeProps);
parcelHelpers.export(exports, "nextTick", ()=>nextTick);
parcelHelpers.export(exports, "onActivated", ()=>onActivated);
parcelHelpers.export(exports, "onBeforeMount", ()=>onBeforeMount);
parcelHelpers.export(exports, "onBeforeUnmount", ()=>onBeforeUnmount);
parcelHelpers.export(exports, "onBeforeUpdate", ()=>onBeforeUpdate);
parcelHelpers.export(exports, "onDeactivated", ()=>onDeactivated);
parcelHelpers.export(exports, "onErrorCaptured", ()=>onErrorCaptured);
parcelHelpers.export(exports, "onMounted", ()=>onMounted);
parcelHelpers.export(exports, "onRenderTracked", ()=>onRenderTracked);
parcelHelpers.export(exports, "onRenderTriggered", ()=>onRenderTriggered);
parcelHelpers.export(exports, "onServerPrefetch", ()=>onServerPrefetch);
parcelHelpers.export(exports, "onUnmounted", ()=>onUnmounted);
parcelHelpers.export(exports, "onUpdated", ()=>onUpdated);
parcelHelpers.export(exports, "openBlock", ()=>openBlock);
parcelHelpers.export(exports, "popScopeId", ()=>popScopeId);
parcelHelpers.export(exports, "provide", ()=>provide);
parcelHelpers.export(exports, "pushScopeId", ()=>pushScopeId);
parcelHelpers.export(exports, "queuePostFlushCb", ()=>queuePostFlushCb);
parcelHelpers.export(exports, "registerRuntimeCompiler", ()=>registerRuntimeCompiler);
parcelHelpers.export(exports, "renderList", ()=>renderList);
parcelHelpers.export(exports, "renderSlot", ()=>renderSlot);
parcelHelpers.export(exports, "resolveComponent", ()=>resolveComponent);
parcelHelpers.export(exports, "resolveDirective", ()=>resolveDirective);
parcelHelpers.export(exports, "resolveDynamicComponent", ()=>resolveDynamicComponent);
parcelHelpers.export(exports, "resolveFilter", ()=>resolveFilter);
parcelHelpers.export(exports, "resolveTransitionHooks", ()=>resolveTransitionHooks);
parcelHelpers.export(exports, "setBlockTracking", ()=>setBlockTracking);
parcelHelpers.export(exports, "setDevtoolsHook", ()=>setDevtoolsHook);
parcelHelpers.export(exports, "setTransitionHooks", ()=>setTransitionHooks);
parcelHelpers.export(exports, "ssrContextKey", ()=>ssrContextKey);
parcelHelpers.export(exports, "ssrUtils", ()=>ssrUtils);
parcelHelpers.export(exports, "toHandlers", ()=>toHandlers);
parcelHelpers.export(exports, "transformVNodeArgs", ()=>transformVNodeArgs);
parcelHelpers.export(exports, "useAttrs", ()=>useAttrs);
parcelHelpers.export(exports, "useId", ()=>useId);
parcelHelpers.export(exports, "useModel", ()=>useModel);
parcelHelpers.export(exports, "useSSRContext", ()=>useSSRContext);
parcelHelpers.export(exports, "useSlots", ()=>useSlots);
parcelHelpers.export(exports, "useTemplateRef", ()=>useTemplateRef);
parcelHelpers.export(exports, "useTransitionState", ()=>useTransitionState);
parcelHelpers.export(exports, "version", ()=>version);
parcelHelpers.export(exports, "warn", ()=>warn);
parcelHelpers.export(exports, "watch", ()=>watch);
parcelHelpers.export(exports, "watchEffect", ()=>watchEffect);
parcelHelpers.export(exports, "watchPostEffect", ()=>watchPostEffect);
parcelHelpers.export(exports, "watchSyncEffect", ()=>watchSyncEffect);
parcelHelpers.export(exports, "withAsyncContext", ()=>withAsyncContext);
parcelHelpers.export(exports, "withCtx", ()=>withCtx);
parcelHelpers.export(exports, "withDefaults", ()=>withDefaults);
parcelHelpers.export(exports, "withDirectives", ()=>withDirectives);
parcelHelpers.export(exports, "withMemo", ()=>withMemo);
parcelHelpers.export(exports, "withScopeId", ()=>withScopeId);
var _reactivity = require("@vue/reactivity");
var _shared = require("@vue/shared");
const stack = [];
function pushWarningContext(vnode) {
    stack.push(vnode);
}
function popWarningContext() {
    stack.pop();
}
let isWarning = false;
function warn$1(msg, ...args) {
    if (isWarning) return;
    isWarning = true;
    (0, _reactivity.pauseTracking)();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) callWithErrorHandling(appWarnHandler, instance, 11, [
        // eslint-disable-next-line no-restricted-syntax
        msg + args.map((a)=>{
            var _a, _b;
            return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
        }).join(""),
        instance && instance.proxy,
        trace.map(({ vnode  })=>`at <${formatComponentName(instance, vnode.type)}>`).join("\n"),
        trace
    ]);
    else {
        const warnArgs = [
            `[Vue warn]: ${msg}`,
            ...args
        ];
        if (trace.length && // avoid spamming console during tests
        true) warnArgs.push(`
`, ...formatTrace(trace));
        console.warn(...warnArgs);
    }
    (0, _reactivity.resetTracking)();
    isWarning = false;
}
function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) return [];
    const normalizedStack = [];
    while(currentVNode){
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) last.recurseCount++;
        else normalizedStack.push({
            vnode: currentVNode,
            recurseCount: 0
        });
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
}
function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i)=>{
        logs.push(...i === 0 ? [] : [
            `
`
        ], ...formatTraceEntry(entry));
    });
    return logs;
}
function formatTraceEntry({ vnode , recurseCount  }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
    const close = `>` + postfix;
    return vnode.props ? [
        open,
        ...formatProps(vnode.props),
        close
    ] : [
        open + close
    ];
}
function formatProps(props) {
    const res = [];
    const keys = Object.keys(props);
    keys.slice(0, 3).forEach((key)=>{
        res.push(...formatProp(key, props[key]));
    });
    if (keys.length > 3) res.push(` ...`);
    return res;
}
function formatProp(key, value, raw) {
    if ((0, _shared.isString)(value)) {
        value = JSON.stringify(value);
        return raw ? value : [
            `${key}=${value}`
        ];
    } else if (typeof value === "number" || typeof value === "boolean" || value == null) return raw ? value : [
        `${key}=${value}`
    ];
    else if ((0, _reactivity.isRef)(value)) {
        value = formatProp(key, (0, _reactivity.toRaw)(value.value), true);
        return raw ? value : [
            `${key}=Ref<`,
            value,
            `>`
        ];
    } else if ((0, _shared.isFunction)(value)) return [
        `${key}=fn${value.name ? `<${value.name}>` : ``}`
    ];
    else {
        value = (0, _reactivity.toRaw)(value);
        return raw ? value : [
            `${key}=`,
            value
        ];
    }
}
function assertNumber(val, type) {
    if (val === void 0) return;
    else if (typeof val !== "number") warn$1(`${type} is not a valid number - got ${JSON.stringify(val)}.`);
    else if (isNaN(val)) warn$1(`${type} is NaN - the duration expression might be incorrect.`);
}
const ErrorCodes = {
    "SETUP_FUNCTION": 0,
    "0": "SETUP_FUNCTION",
    "RENDER_FUNCTION": 1,
    "1": "RENDER_FUNCTION",
    "NATIVE_EVENT_HANDLER": 5,
    "5": "NATIVE_EVENT_HANDLER",
    "COMPONENT_EVENT_HANDLER": 6,
    "6": "COMPONENT_EVENT_HANDLER",
    "VNODE_HOOK": 7,
    "7": "VNODE_HOOK",
    "DIRECTIVE_HOOK": 8,
    "8": "DIRECTIVE_HOOK",
    "TRANSITION_HOOK": 9,
    "9": "TRANSITION_HOOK",
    "APP_ERROR_HANDLER": 10,
    "10": "APP_ERROR_HANDLER",
    "APP_WARN_HANDLER": 11,
    "11": "APP_WARN_HANDLER",
    "FUNCTION_REF": 12,
    "12": "FUNCTION_REF",
    "ASYNC_COMPONENT_LOADER": 13,
    "13": "ASYNC_COMPONENT_LOADER",
    "SCHEDULER": 14,
    "14": "SCHEDULER",
    "COMPONENT_UPDATE": 15,
    "15": "COMPONENT_UPDATE",
    "APP_UNMOUNT_CLEANUP": 16,
    "16": "APP_UNMOUNT_CLEANUP"
};
const ErrorTypeStrings$1 = {
    ["sp"]: "serverPrefetch hook",
    ["bc"]: "beforeCreate hook",
    ["c"]: "created hook",
    ["bm"]: "beforeMount hook",
    ["m"]: "mounted hook",
    ["bu"]: "beforeUpdate hook",
    ["u"]: "updated",
    ["bum"]: "beforeUnmount hook",
    ["um"]: "unmounted hook",
    ["a"]: "activated hook",
    ["da"]: "deactivated hook",
    ["ec"]: "errorCaptured hook",
    ["rtc"]: "renderTracked hook",
    ["rtg"]: "renderTriggered hook",
    [0]: "setup function",
    [1]: "render function",
    [2]: "watcher getter",
    [3]: "watcher callback",
    [4]: "watcher cleanup function",
    [5]: "native event handler",
    [6]: "component event handler",
    [7]: "vnode hook",
    [8]: "directive hook",
    [9]: "transition hook",
    [10]: "app errorHandler",
    [11]: "app warnHandler",
    [12]: "ref function",
    [13]: "async component loader",
    [14]: "scheduler flush",
    [15]: "component update",
    [16]: "app unmount cleanup function"
};
function callWithErrorHandling(fn, instance, type, args) {
    try {
        return args ? fn(...args) : fn();
    } catch (err) {
        handleError(err, instance, type);
    }
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
    if ((0, _shared.isFunction)(fn)) {
        const res = callWithErrorHandling(fn, instance, type, args);
        if (res && (0, _shared.isPromise)(res)) res.catch((err)=>{
            handleError(err, instance, type);
        });
        return res;
    }
    if ((0, _shared.isArray)(fn)) {
        const values = [];
        for(let i = 0; i < fn.length; i++)values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
        return values;
    } else warn$1(`Invalid value type passed to callWithAsyncErrorHandling(): ${typeof fn}`);
}
function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    const { errorHandler , throwUnhandledErrorInProduction  } = instance && instance.appContext.config || (0, _shared.EMPTY_OBJ);
    if (instance) {
        let cur = instance.parent;
        const exposedInstance = instance.proxy;
        const errorInfo = (0, ErrorTypeStrings$1[type]);
        while(cur){
            const errorCapturedHooks = cur.ec;
            if (errorCapturedHooks) for(let i = 0; i < errorCapturedHooks.length; i++){
                if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) return;
            }
            cur = cur.parent;
        }
        if (errorHandler) {
            (0, _reactivity.pauseTracking)();
            callWithErrorHandling(errorHandler, null, 10, [
                err,
                exposedInstance,
                errorInfo
            ]);
            (0, _reactivity.resetTracking)();
            return;
        }
    }
    logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
}
function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
    {
        const info = ErrorTypeStrings$1[type];
        if (contextVNode) pushWarningContext(contextVNode);
        warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
        if (contextVNode) popWarningContext();
        if (throwInDev) throw err;
        else console.error(err);
    }
}
const queue = [];
let flushIndex = -1;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
    const p = currentFlushPromise || resolvedPromise;
    return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
function findInsertionIndex(id) {
    let start = flushIndex + 1;
    let end = queue.length;
    while(start < end){
        const middle = start + end >>> 1;
        const middleJob = queue[middle];
        const middleJobId = getId(middleJob);
        if (middleJobId < id || middleJobId === id && middleJob.flags & 2) start = middle + 1;
        else end = middle;
    }
    return start;
}
function queueJob(job) {
    if (!(job.flags & 1)) {
        const jobId = getId(job);
        const lastJob = queue[queue.length - 1];
        if (!lastJob || // fast path when the job id is larger than the tail
        !(job.flags & 2) && jobId >= getId(lastJob)) queue.push(job);
        else queue.splice(findInsertionIndex(jobId), 0, job);
        job.flags |= 1;
        queueFlush();
    }
}
function queueFlush() {
    if (!currentFlushPromise) currentFlushPromise = resolvedPromise.then(flushJobs);
}
function queuePostFlushCb(cb) {
    if (!(0, _shared.isArray)(cb)) {
        if (activePostFlushCbs && cb.id === -1) activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
        else if (!(cb.flags & 1)) {
            pendingPostFlushCbs.push(cb);
            cb.flags |= 1;
        }
    } else pendingPostFlushCbs.push(...cb);
    queueFlush();
}
function flushPreFlushCbs(instance, seen, i = flushIndex + 1) {
    seen = seen || /* @__PURE__ */ new Map();
    for(; i < queue.length; i++){
        const cb = queue[i];
        if (cb && cb.flags & 2) {
            if (instance && cb.id !== instance.uid) continue;
            if (checkRecursiveUpdates(seen, cb)) continue;
            queue.splice(i, 1);
            i--;
            if (cb.flags & 4) cb.flags &= -2;
            cb();
            if (!(cb.flags & 4)) cb.flags &= -2;
        }
    }
}
function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
        const deduped = [
            ...new Set(pendingPostFlushCbs)
        ].sort((a, b)=>getId(a) - getId(b));
        pendingPostFlushCbs.length = 0;
        if (activePostFlushCbs) {
            activePostFlushCbs.push(...deduped);
            return;
        }
        activePostFlushCbs = deduped;
        seen = seen || /* @__PURE__ */ new Map();
        for(postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++){
            const cb = activePostFlushCbs[postFlushIndex];
            if (checkRecursiveUpdates(seen, cb)) continue;
            if (cb.flags & 4) cb.flags &= -2;
            if (!(cb.flags & 8)) cb();
            cb.flags &= -2;
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
    }
}
const getId = (job)=>job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
function flushJobs(seen) {
    seen = seen || /* @__PURE__ */ new Map();
    const check = (job)=>checkRecursiveUpdates(seen, job);
    try {
        for(flushIndex = 0; flushIndex < queue.length; flushIndex++){
            const job = queue[flushIndex];
            if (job && !(job.flags & 8)) {
                if (check(job)) continue;
                if (job.flags & 4) job.flags &= -2;
                callWithErrorHandling(job, job.i, job.i ? 15 : 14);
                if (!(job.flags & 4)) job.flags &= -2;
            }
        }
    } finally{
        for(; flushIndex < queue.length; flushIndex++){
            const job = queue[flushIndex];
            if (job) job.flags &= -2;
        }
        flushIndex = -1;
        queue.length = 0;
        flushPostFlushCbs(seen);
        currentFlushPromise = null;
        if (queue.length || pendingPostFlushCbs.length) flushJobs(seen);
    }
}
function checkRecursiveUpdates(seen, fn) {
    const count = seen.get(fn) || 0;
    if (count > RECURSION_LIMIT) {
        const instance = fn.i;
        const componentName = instance && getComponentName(instance.type);
        handleError(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`, null, 10);
        return true;
    }
    seen.set(fn, count + 1);
    return false;
}
let isHmrUpdating = false;
const hmrDirtyComponents = /* @__PURE__ */ new Map();
(0, _shared.getGlobalThis)().__VUE_HMR_RUNTIME__ = {
    createRecord: tryWrap(createRecord),
    rerender: tryWrap(rerender),
    reload: tryWrap(reload)
};
const map = /* @__PURE__ */ new Map();
function registerHMR(instance) {
    const id = instance.type.__hmrId;
    let record = map.get(id);
    if (!record) {
        createRecord(id, instance.type);
        record = map.get(id);
    }
    record.instances.add(instance);
}
function unregisterHMR(instance) {
    map.get(instance.type.__hmrId).instances.delete(instance);
}
function createRecord(id, initialDef) {
    if (map.has(id)) return false;
    map.set(id, {
        initialDef: normalizeClassComponent(initialDef),
        instances: /* @__PURE__ */ new Set()
    });
    return true;
}
function normalizeClassComponent(component) {
    return isClassComponent(component) ? component.__vccOpts : component;
}
function rerender(id, newRender) {
    const record = map.get(id);
    if (!record) return;
    record.initialDef.render = newRender;
    [
        ...record.instances
    ].forEach((instance)=>{
        if (newRender) {
            instance.render = newRender;
            normalizeClassComponent(instance.type).render = newRender;
        }
        instance.renderCache = [];
        isHmrUpdating = true;
        instance.update();
        isHmrUpdating = false;
    });
}
function reload(id, newComp) {
    const record = map.get(id);
    if (!record) return;
    newComp = normalizeClassComponent(newComp);
    updateComponentDef(record.initialDef, newComp);
    const instances = [
        ...record.instances
    ];
    for(let i = 0; i < instances.length; i++){
        const instance = instances[i];
        const oldComp = normalizeClassComponent(instance.type);
        let dirtyInstances = hmrDirtyComponents.get(oldComp);
        if (!dirtyInstances) {
            if (oldComp !== record.initialDef) updateComponentDef(oldComp, newComp);
            hmrDirtyComponents.set(oldComp, dirtyInstances = /* @__PURE__ */ new Set());
        }
        dirtyInstances.add(instance);
        instance.appContext.propsCache.delete(instance.type);
        instance.appContext.emitsCache.delete(instance.type);
        instance.appContext.optionsCache.delete(instance.type);
        if (instance.ceReload) {
            dirtyInstances.add(instance);
            instance.ceReload(newComp.styles);
            dirtyInstances.delete(instance);
        } else if (instance.parent) queueJob(()=>{
            isHmrUpdating = true;
            instance.parent.update();
            isHmrUpdating = false;
            dirtyInstances.delete(instance);
        });
        else if (instance.appContext.reload) instance.appContext.reload();
        else if (typeof window !== "undefined") window.location.reload();
        else console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");
        if (instance.root.ce && instance !== instance.root) instance.root.ce._removeChildStyle(oldComp);
    }
    queuePostFlushCb(()=>{
        hmrDirtyComponents.clear();
    });
}
function updateComponentDef(oldComp, newComp) {
    (0, _shared.extend)(oldComp, newComp);
    for(const key in oldComp)if (key !== "__file" && !(key in newComp)) delete oldComp[key];
}
function tryWrap(fn) {
    return (id, arg)=>{
        try {
            return fn(id, arg);
        } catch (e) {
            console.error(e);
            console.warn(`[HMR] Something went wrong during Vue component hot-reload. Full reload required.`);
        }
    };
}
let devtools$1;
let buffer = [];
let devtoolsNotInstalled = false;
function emit$1(event, ...args) {
    if (devtools$1) devtools$1.emit(event, ...args);
    else if (!devtoolsNotInstalled) buffer.push({
        event,
        args
    });
}
function setDevtoolsHook$1(hook, target) {
    var _a, _b;
    devtools$1 = hook;
    if (devtools$1) {
        devtools$1.enabled = true;
        buffer.forEach(({ event , args  })=>devtools$1.emit(event, ...args));
        buffer = [];
    } else if (// handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== "undefined" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    // eslint-disable-next-line no-restricted-syntax
    !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))) {
        const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
        replay.push((newHook)=>{
            setDevtoolsHook$1(newHook, target);
        });
        setTimeout(()=>{
            if (!devtools$1) {
                target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
                devtoolsNotInstalled = true;
                buffer = [];
            }
        }, 3e3);
    } else {
        devtoolsNotInstalled = true;
        buffer = [];
    }
}
function devtoolsInitApp(app, version) {
    emit$1("app:init" /* APP_INIT */ , app, version, {
        Fragment,
        Text,
        Comment,
        Static
    });
}
function devtoolsUnmountApp(app) {
    emit$1("app:unmount" /* APP_UNMOUNT */ , app);
}
const devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook("component:added" /* COMPONENT_ADDED */ );
const devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook("component:updated" /* COMPONENT_UPDATED */ );
const _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook("component:removed" /* COMPONENT_REMOVED */ );
const devtoolsComponentRemoved = (component)=>{
    if (devtools$1 && typeof devtools$1.cleanupBuffer === "function" && // remove the component if it wasn't buffered
    !devtools$1.cleanupBuffer(component)) _devtoolsComponentRemoved(component);
};
/*! #__NO_SIDE_EFFECTS__ */ // @__NO_SIDE_EFFECTS__
function createDevtoolsComponentHook(hook) {
    return (component)=>{
        emit$1(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : void 0, component);
    };
}
const devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:start" /* PERFORMANCE_START */ );
const devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:end" /* PERFORMANCE_END */ );
function createDevtoolsPerformanceHook(hook) {
    return (component, type, time)=>{
        emit$1(hook, component.appContext.app, component.uid, component, type, time);
    };
}
function devtoolsComponentEmit(component, event, params) {
    emit$1("component:emit" /* COMPONENT_EMIT */ , component.appContext.app, component, event, params);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
}
function pushScopeId(id) {
    currentScopeId = id;
}
function popScopeId() {
    currentScopeId = null;
}
const withScopeId = (_id)=>withCtx;
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
    if (!ctx) return fn;
    if (fn._n) return fn;
    const renderFnWithContext = (...args)=>{
        if (renderFnWithContext._d) setBlockTracking(-1);
        const prevInstance = setCurrentRenderingInstance(ctx);
        let res;
        try {
            res = fn(...args);
        } finally{
            setCurrentRenderingInstance(prevInstance);
            if (renderFnWithContext._d) setBlockTracking(1);
        }
        devtoolsComponentUpdated(ctx);
        return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
}
function validateDirectiveName(name) {
    if ((0, _shared.isBuiltInDirective)(name)) warn$1("Do not use built-in directive ids as custom directive id: " + name);
}
function withDirectives(vnode, directives) {
    if (currentRenderingInstance === null) {
        warn$1(`withDirectives can only be used inside render functions.`);
        return vnode;
    }
    const instance = getComponentPublicInstance(currentRenderingInstance);
    const bindings = vnode.dirs || (vnode.dirs = []);
    for(let i = 0; i < directives.length; i++){
        let [dir, value, arg, modifiers = (0, _shared.EMPTY_OBJ)] = directives[i];
        if (dir) {
            if ((0, _shared.isFunction)(dir)) dir = {
                mounted: dir,
                updated: dir
            };
            if (dir.deep) (0, _reactivity.traverse)(value);
            bindings.push({
                dir,
                instance,
                value,
                oldValue: void 0,
                arg,
                modifiers
            });
        }
    }
    return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for(let i = 0; i < bindings.length; i++){
        const binding = bindings[i];
        if (oldBindings) binding.oldValue = oldBindings[i].value;
        let hook = binding.dir[name];
        if (hook) {
            (0, _reactivity.pauseTracking)();
            callWithAsyncErrorHandling(hook, instance, 8, [
                vnode.el,
                binding,
                vnode,
                prevVNode
            ]);
            (0, _reactivity.resetTracking)();
        }
    }
}
const TeleportEndKey = Symbol("_vte");
const isTeleport = (type)=>type.__isTeleport;
const isTeleportDisabled = (props)=>props && (props.disabled || props.disabled === "");
const isTeleportDeferred = (props)=>props && (props.defer || props.defer === "");
const isTargetSVG = (target)=>typeof SVGElement !== "undefined" && target instanceof SVGElement;
const isTargetMathML = (target)=>typeof MathMLElement === "function" && target instanceof MathMLElement;
const resolveTarget = (props, select)=>{
    const targetSelector = props && props.to;
    if ((0, _shared.isString)(targetSelector)) {
        if (!select) {
            warn$1(`Current renderer does not support string target for Teleports. (missing querySelector renderer option)`);
            return null;
        } else {
            const target = select(targetSelector);
            if (!target && !isTeleportDisabled(props)) warn$1(`Failed to locate Teleport target with selector "${targetSelector}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`);
            return target;
        }
    } else {
        if (!targetSelector && !isTeleportDisabled(props)) warn$1(`Invalid Teleport target: ${targetSelector}`);
        return targetSelector;
    }
};
const TeleportImpl = {
    name: "Teleport",
    __isTeleport: true,
    process (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
        const { mc: mountChildren , pc: patchChildren , pbc: patchBlockChildren , o: { insert , querySelector , createText , createComment  }  } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag , children , dynamicChildren  } = n2;
        if (isHmrUpdating) {
            optimized = false;
            dynamicChildren = null;
        }
        if (n1 == null) {
            const placeholder = n2.el = createComment("teleport start");
            const mainAnchor = n2.anchor = createComment("teleport end");
            insert(placeholder, container, anchor);
            insert(mainAnchor, container, anchor);
            const mount = (container2, anchor2)=>{
                if (shapeFlag & 16) {
                    if (parentComponent && parentComponent.isCE) parentComponent.ce._teleportTarget = container2;
                    mountChildren(children, container2, anchor2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                }
            };
            const mountToTarget = ()=>{
                const target = n2.target = resolveTarget(n2.props, querySelector);
                const targetAnchor = prepareAnchor(target, n2, createText, insert);
                if (target) {
                    if (namespace !== "svg" && isTargetSVG(target)) namespace = "svg";
                    else if (namespace !== "mathml" && isTargetMathML(target)) namespace = "mathml";
                    if (!disabled) {
                        mount(target, targetAnchor);
                        updateCssVars(n2, false);
                    }
                } else if (!disabled) warn$1("Invalid Teleport target on mount:", target, `(${typeof target})`);
            };
            if (disabled) {
                mount(container, mainAnchor);
                updateCssVars(n2, true);
            }
            if (isTeleportDeferred(n2.props)) {
                n2.el.__isMounted = false;
                queuePostRenderEffect(()=>{
                    mountToTarget();
                    delete n2.el.__isMounted;
                }, parentSuspense);
            } else mountToTarget();
        } else {
            if (isTeleportDeferred(n2.props) && n1.el.__isMounted === false) {
                queuePostRenderEffect(()=>{
                    TeleportImpl.process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals);
                }, parentSuspense);
                return;
            }
            n2.el = n1.el;
            n2.targetStart = n1.targetStart;
            const mainAnchor = n2.anchor = n1.anchor;
            const target = n2.target = n1.target;
            const targetAnchor = n2.targetAnchor = n1.targetAnchor;
            const wasDisabled = isTeleportDisabled(n1.props);
            const currentContainer = wasDisabled ? container : target;
            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
            if (namespace === "svg" || isTargetSVG(target)) namespace = "svg";
            else if (namespace === "mathml" || isTargetMathML(target)) namespace = "mathml";
            if (dynamicChildren) {
                patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, namespace, slotScopeIds);
                traverseStaticChildren(n1, n2, false);
            } else if (!optimized) patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, false);
            if (disabled) {
                if (!wasDisabled) moveTeleport(n2, container, mainAnchor, internals, 1);
                else if (n2.props && n1.props && n2.props.to !== n1.props.to) n2.props.to = n1.props.to;
            } else {
                if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                    const nextTarget = n2.target = resolveTarget(n2.props, querySelector);
                    if (nextTarget) moveTeleport(n2, nextTarget, null, internals, 0);
                    else warn$1("Invalid Teleport target on update:", target, `(${typeof target})`);
                } else if (wasDisabled) moveTeleport(n2, target, targetAnchor, internals, 1);
            }
            updateCssVars(n2, disabled);
        }
    },
    remove (vnode, parentComponent, parentSuspense, { um: unmount , o: { remove: hostRemove  }  }, doRemove) {
        const { shapeFlag , children , anchor , targetStart , targetAnchor , target , props  } = vnode;
        if (target) {
            hostRemove(targetStart);
            hostRemove(targetAnchor);
        }
        doRemove && hostRemove(anchor);
        if (shapeFlag & 16) {
            const shouldRemove = doRemove || !isTeleportDisabled(props);
            for(let i = 0; i < children.length; i++){
                const child = children[i];
                unmount(child, parentComponent, parentSuspense, shouldRemove, !!child.dynamicChildren);
            }
        }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert  } , m: move  }, moveType = 2) {
    if (moveType === 0) insert(vnode.targetAnchor, container, parentAnchor);
    const { el , anchor , shapeFlag , children , props  } = vnode;
    const isReorder = moveType === 2;
    if (isReorder) insert(el, container, parentAnchor);
    if (!isReorder || isTeleportDisabled(props)) {
        if (shapeFlag & 16) for(let i = 0; i < children.length; i++)move(children[i], container, parentAnchor, 2);
    }
    if (isReorder) insert(anchor, container, parentAnchor);
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling , parentNode , querySelector , insert , createText  }  }, hydrateChildren) {
    const target = vnode.target = resolveTarget(vnode.props, querySelector);
    if (target) {
        const disabled = isTeleportDisabled(vnode.props);
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16) {
            if (disabled) {
                vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
                vnode.targetStart = targetNode;
                vnode.targetAnchor = targetNode && nextSibling(targetNode);
            } else {
                vnode.anchor = nextSibling(node);
                let targetAnchor = targetNode;
                while(targetAnchor){
                    if (targetAnchor && targetAnchor.nodeType === 8) {
                        if (targetAnchor.data === "teleport start anchor") vnode.targetStart = targetAnchor;
                        else if (targetAnchor.data === "teleport anchor") {
                            vnode.targetAnchor = targetAnchor;
                            target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                            break;
                        }
                    }
                    targetAnchor = nextSibling(targetAnchor);
                }
                if (!vnode.targetAnchor) prepareAnchor(target, vnode, createText, insert);
                hydrateChildren(targetNode && nextSibling(targetNode), vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
            }
        }
        updateCssVars(vnode, disabled);
    }
    return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode, isDisabled) {
    const ctx = vnode.ctx;
    if (ctx && ctx.ut) {
        let node, anchor;
        if (isDisabled) {
            node = vnode.el;
            anchor = vnode.anchor;
        } else {
            node = vnode.targetStart;
            anchor = vnode.targetAnchor;
        }
        while(node && node !== anchor){
            if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
            node = node.nextSibling;
        }
        ctx.ut();
    }
}
function prepareAnchor(target, vnode, createText, insert) {
    const targetStart = vnode.targetStart = createText("");
    const targetAnchor = vnode.targetAnchor = createText("");
    targetStart[TeleportEndKey] = targetAnchor;
    if (target) {
        insert(targetStart, target);
        insert(targetAnchor, target);
    }
    return targetAnchor;
}
const leaveCbKey = Symbol("_leaveCb");
const enterCbKey = Symbol("_enterCb");
function useTransitionState() {
    const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: /* @__PURE__ */ new Map()
    };
    onMounted(()=>{
        state.isMounted = true;
    });
    onBeforeUnmount(()=>{
        state.isUnmounting = true;
    });
    return state;
}
const TransitionHookValidator = [
    Function,
    Array
];
const BaseTransitionPropsValidators = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    // enter
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    // leave
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    // appear
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
};
const recursiveGetSubtree = (instance)=>{
    const subTree = instance.subTree;
    return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
};
const BaseTransitionImpl = {
    name: `BaseTransition`,
    props: BaseTransitionPropsValidators,
    setup (props, { slots  }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        return ()=>{
            const children = slots.default && getTransitionRawChildren(slots.default(), true);
            if (!children || !children.length) return;
            const child = findNonCommentChild(children);
            const rawProps = (0, _reactivity.toRaw)(props);
            const { mode  } = rawProps;
            if (mode && mode !== "in-out" && mode !== "out-in" && mode !== "default") warn$1(`invalid <transition> mode: ${mode}`);
            if (state.isLeaving) return emptyPlaceholder(child);
            const innerChild = getInnerChild$1(child);
            if (!innerChild) return emptyPlaceholder(child);
            let enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance, // #11061, ensure enterHooks is fresh after clone
            (hooks)=>enterHooks = hooks);
            if (innerChild.type !== Comment) setTransitionHooks(innerChild, enterHooks);
            let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
            if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
                let leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
                setTransitionHooks(oldInnerChild, leavingHooks);
                if (mode === "out-in" && innerChild.type !== Comment) {
                    state.isLeaving = true;
                    leavingHooks.afterLeave = ()=>{
                        state.isLeaving = false;
                        if (!(instance.job.flags & 8)) instance.update();
                        delete leavingHooks.afterLeave;
                        oldInnerChild = void 0;
                    };
                    return emptyPlaceholder(child);
                } else if (mode === "in-out" && innerChild.type !== Comment) leavingHooks.delayLeave = (el, earlyRemove, delayedLeave)=>{
                    const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
                    leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                    el[leaveCbKey] = ()=>{
                        earlyRemove();
                        el[leaveCbKey] = void 0;
                        delete enterHooks.delayedLeave;
                        oldInnerChild = void 0;
                    };
                    enterHooks.delayedLeave = ()=>{
                        delayedLeave();
                        delete enterHooks.delayedLeave;
                        oldInnerChild = void 0;
                    };
                };
                else oldInnerChild = void 0;
            } else if (oldInnerChild) oldInnerChild = void 0;
            return child;
        };
    }
};
function findNonCommentChild(children) {
    let child = children[0];
    if (children.length > 1) {
        let hasFound = false;
        for (const c of children)if (c.type !== Comment) {
            if (hasFound) {
                warn$1("<transition> can only be used on a single element or component. Use <transition-group> for lists.");
                break;
            }
            child = c;
            hasFound = true;
        }
    }
    return child;
}
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes  } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
        leavingVNodesCache = /* @__PURE__ */ Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance, postClone) {
    const { appear , mode , persisted =false , onBeforeEnter , onEnter , onAfterEnter , onEnterCancelled , onBeforeLeave , onLeave , onAfterLeave , onLeaveCancelled , onBeforeAppear , onAppear , onAfterAppear , onAppearCancelled  } = props;
    const key = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook = (hook, args)=>{
        hook && callWithAsyncErrorHandling(hook, instance, 9, args);
    };
    const callAsyncHook = (hook, args)=>{
        const done = args[1];
        callHook(hook, args);
        if ((0, _shared.isArray)(hook)) {
            if (hook.every((hook2)=>hook2.length <= 1)) done();
        } else if (hook.length <= 1) done();
    };
    const hooks = {
        mode,
        persisted,
        beforeEnter (el) {
            let hook = onBeforeEnter;
            if (!state.isMounted) {
                if (appear) hook = onBeforeAppear || onBeforeEnter;
                else return;
            }
            if (el[leaveCbKey]) el[leaveCbKey](true);
            const leavingVNode = leavingVNodesCache[key];
            if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) leavingVNode.el[leaveCbKey]();
            callHook(hook, [
                el
            ]);
        },
        enter (el) {
            let hook = onEnter;
            let afterHook = onAfterEnter;
            let cancelHook = onEnterCancelled;
            if (!state.isMounted) {
                if (appear) {
                    hook = onAppear || onEnter;
                    afterHook = onAfterAppear || onAfterEnter;
                    cancelHook = onAppearCancelled || onEnterCancelled;
                } else return;
            }
            let called = false;
            const done = el[enterCbKey] = (cancelled)=>{
                if (called) return;
                called = true;
                if (cancelled) callHook(cancelHook, [
                    el
                ]);
                else callHook(afterHook, [
                    el
                ]);
                if (hooks.delayedLeave) hooks.delayedLeave();
                el[enterCbKey] = void 0;
            };
            if (hook) callAsyncHook(hook, [
                el,
                done
            ]);
            else done();
        },
        leave (el, remove) {
            const key2 = String(vnode.key);
            if (el[enterCbKey]) el[enterCbKey](true);
            if (state.isUnmounting) return remove();
            callHook(onBeforeLeave, [
                el
            ]);
            let called = false;
            const done = el[leaveCbKey] = (cancelled)=>{
                if (called) return;
                called = true;
                remove();
                if (cancelled) callHook(onLeaveCancelled, [
                    el
                ]);
                else callHook(onAfterLeave, [
                    el
                ]);
                el[leaveCbKey] = void 0;
                if (leavingVNodesCache[key2] === vnode) delete leavingVNodesCache[key2];
            };
            leavingVNodesCache[key2] = vnode;
            if (onLeave) callAsyncHook(onLeave, [
                el,
                done
            ]);
            else done();
        },
        clone (vnode2) {
            const hooks2 = resolveTransitionHooks(vnode2, props, state, instance, postClone);
            if (postClone) postClone(hooks2);
            return hooks2;
        }
    };
    return hooks;
}
function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
    }
}
function getInnerChild$1(vnode) {
    if (!isKeepAlive(vnode)) {
        if (isTeleport(vnode.type) && vnode.children) return findNonCommentChild(vnode.children);
        return vnode;
    }
    if (vnode.component) return vnode.component.subTree;
    const { shapeFlag , children  } = vnode;
    if (children) {
        if (shapeFlag & 16) return children[0];
        if (shapeFlag & 32 && (0, _shared.isFunction)(children.default)) return children.default();
    }
}
function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) {
        vnode.transition = hooks;
        setTransitionHooks(vnode.component.subTree, hooks);
    } else if (vnode.shapeFlag & 128) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else vnode.transition = hooks;
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
    let ret = [];
    let keyedFragmentCount = 0;
    for(let i = 0; i < children.length; i++){
        let child = children[i];
        const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
        if (child.type === Fragment) {
            if (child.patchFlag & 128) keyedFragmentCount++;
            ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
        } else if (keepComment || child.type !== Comment) ret.push(key != null ? cloneVNode(child, {
            key
        }) : child);
    }
    if (keyedFragmentCount > 1) for(let i = 0; i < ret.length; i++)ret[i].patchFlag = -2;
    return ret;
}
/*! #__NO_SIDE_EFFECTS__ */ // @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
    return (0, _shared.isFunction)(options) ? // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (()=>(0, _shared.extend)({
            name: options.name
        }, extraOptions, {
            setup: options
        }))() : options;
}
function useId() {
    const i = getCurrentInstance();
    if (i) return (i.appContext.config.idPrefix || "v") + "-" + i.ids[0] + i.ids[1]++;
    else warn$1(`useId() is called when there is no active component instance to be associated with.`);
    return "";
}
function markAsyncBoundary(instance) {
    instance.ids = [
        instance.ids[0] + instance.ids[2]++ + "-",
        0,
        0
    ];
}
const knownTemplateRefs = /* @__PURE__ */ new WeakSet();
function useTemplateRef(key) {
    const i = getCurrentInstance();
    const r = (0, _reactivity.shallowRef)(null);
    if (i) {
        const refs = i.refs === (0, _shared.EMPTY_OBJ) ? i.refs = {} : i.refs;
        let desc;
        if ((desc = Object.getOwnPropertyDescriptor(refs, key)) && !desc.configurable) warn$1(`useTemplateRef('${key}') already exists.`);
        else Object.defineProperty(refs, key, {
            enumerable: true,
            get: ()=>r.value,
            set: (val)=>r.value = val
        });
    } else warn$1(`useTemplateRef() is called when there is no active component instance to be associated with.`);
    const ret = (0, _reactivity.readonly)(r);
    knownTemplateRefs.add(ret);
    return ret;
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if ((0, _shared.isArray)(rawRef)) {
        rawRef.forEach((r, i)=>setRef(r, oldRawRef && ((0, _shared.isArray)(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
        return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
        if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
        return;
    }
    const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner , r: ref  } = rawRef;
    if (!owner) {
        warn$1(`Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`);
        return;
    }
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === (0, _shared.EMPTY_OBJ) ? owner.refs = {} : owner.refs;
    const setupState = owner.setupState;
    const rawSetupState = (0, _reactivity.toRaw)(setupState);
    const canSetSetupRef = setupState === (0, _shared.EMPTY_OBJ) ? ()=>false : (key)=>{
        if ((0, _shared.hasOwn)(rawSetupState, key) && !(0, _reactivity.isRef)(rawSetupState[key])) warn$1(`Template ref "${key}" used on a non-ref value. It will not work in the production build.`);
        if (knownTemplateRefs.has(rawSetupState[key])) return false;
        return (0, _shared.hasOwn)(rawSetupState, key);
    };
    if (oldRef != null && oldRef !== ref) {
        if ((0, _shared.isString)(oldRef)) {
            refs[oldRef] = null;
            if (canSetSetupRef(oldRef)) setupState[oldRef] = null;
        } else if ((0, _reactivity.isRef)(oldRef)) oldRef.value = null;
    }
    if ((0, _shared.isFunction)(ref)) callWithErrorHandling(ref, owner, 12, [
        value,
        refs
    ]);
    else {
        const _isString = (0, _shared.isString)(ref);
        const _isRef = (0, _reactivity.isRef)(ref);
        if (_isString || _isRef) {
            const doSet = ()=>{
                if (rawRef.f) {
                    const existing = _isString ? canSetSetupRef(ref) ? setupState[ref] : refs[ref] : ref.value;
                    if (isUnmount) (0, _shared.isArray)(existing) && (0, _shared.remove)(existing, refValue);
                    else {
                        if (!(0, _shared.isArray)(existing)) {
                            if (_isString) {
                                refs[ref] = [
                                    refValue
                                ];
                                if (canSetSetupRef(ref)) setupState[ref] = refs[ref];
                            } else {
                                ref.value = [
                                    refValue
                                ];
                                if (rawRef.k) refs[rawRef.k] = ref.value;
                            }
                        } else if (!existing.includes(refValue)) existing.push(refValue);
                    }
                } else if (_isString) {
                    refs[ref] = value;
                    if (canSetSetupRef(ref)) setupState[ref] = value;
                } else if (_isRef) {
                    ref.value = value;
                    if (rawRef.k) refs[rawRef.k] = value;
                } else warn$1("Invalid template ref type:", ref, `(${typeof ref})`);
            };
            if (value) {
                doSet.id = -1;
                queuePostRenderEffect(doSet, parentSuspense);
            } else doSet();
        } else warn$1("Invalid template ref type:", ref, `(${typeof ref})`);
    }
}
let hasLoggedMismatchError = false;
const logMismatchError = ()=>{
    if (hasLoggedMismatchError) return;
    console.error("Hydration completed but contains mismatches.");
    hasLoggedMismatchError = true;
};
const isSVGContainer = (container)=>container.namespaceURI.includes("svg") && container.tagName !== "foreignObject";
const isMathMLContainer = (container)=>container.namespaceURI.includes("MathML");
const getContainerType = (container)=>{
    if (container.nodeType !== 1) return void 0;
    if (isSVGContainer(container)) return "svg";
    if (isMathMLContainer(container)) return "mathml";
    return void 0;
};
const isComment = (node)=>node.nodeType === 8;
function createHydrationFunctions(rendererInternals) {
    const { mt: mountComponent , p: patch , o: { patchProp , createText , nextSibling , parentNode , remove , insert , createComment  }  } = rendererInternals;
    const hydrate = (vnode, container)=>{
        if (!container.hasChildNodes()) {
            warn$1(`Attempting to hydrate existing markup but container is empty. Performing full mount instead.`);
            patch(null, vnode, container);
            flushPostFlushCbs();
            container._vnode = vnode;
            return;
        }
        hydrateNode(container.firstChild, vnode, null, null, null);
        flushPostFlushCbs();
        container._vnode = vnode;
    };
    const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false)=>{
        optimized = optimized || !!vnode.dynamicChildren;
        const isFragmentStart = isComment(node) && node.data === "[";
        const onMismatch = ()=>handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
        const { type , ref , shapeFlag , patchFlag  } = vnode;
        let domType = node.nodeType;
        vnode.el = node;
        (0, _shared.def)(node, "__vnode", vnode, true);
        (0, _shared.def)(node, "__vueParentComponent", parentComponent, true);
        if (patchFlag === -2) {
            optimized = false;
            vnode.dynamicChildren = null;
        }
        let nextNode = null;
        switch(type){
            case Text:
                if (domType !== 3) {
                    if (vnode.children === "") {
                        insert(vnode.el = createText(""), parentNode(node), node);
                        nextNode = node;
                    } else nextNode = onMismatch();
                } else {
                    if (node.data !== vnode.children) {
                        warn$1(`Hydration text mismatch in`, node.parentNode, `
  - rendered on server: ${JSON.stringify(node.data)}
  - expected on client: ${JSON.stringify(vnode.children)}`);
                        logMismatchError();
                        node.data = vnode.children;
                    }
                    nextNode = nextSibling(node);
                }
                break;
            case Comment:
                if (isTemplateNode(node)) {
                    nextNode = nextSibling(node);
                    replaceNode(vnode.el = node.content.firstChild, node, parentComponent);
                } else if (domType !== 8 || isFragmentStart) nextNode = onMismatch();
                else nextNode = nextSibling(node);
                break;
            case Static:
                if (isFragmentStart) {
                    node = nextSibling(node);
                    domType = node.nodeType;
                }
                if (domType === 1 || domType === 3) {
                    nextNode = node;
                    const needToAdoptContent = !vnode.children.length;
                    for(let i = 0; i < vnode.staticCount; i++){
                        if (needToAdoptContent) vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
                        if (i === vnode.staticCount - 1) vnode.anchor = nextNode;
                        nextNode = nextSibling(nextNode);
                    }
                    return isFragmentStart ? nextSibling(nextNode) : nextNode;
                } else onMismatch();
                break;
            case Fragment:
                if (!isFragmentStart) nextNode = onMismatch();
                else nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                break;
            default:
                if (shapeFlag & 1) {
                    if ((domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) && !isTemplateNode(node)) nextNode = onMismatch();
                    else nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                } else if (shapeFlag & 6) {
                    vnode.slotScopeIds = slotScopeIds;
                    const container = parentNode(node);
                    if (isFragmentStart) nextNode = locateClosingAnchor(node);
                    else if (isComment(node) && node.data === "teleport start") nextNode = locateClosingAnchor(node, node.data, "teleport end");
                    else nextNode = nextSibling(node);
                    mountComponent(vnode, container, null, parentComponent, parentSuspense, getContainerType(container), optimized);
                    if (isAsyncWrapper(vnode) && !vnode.type.__asyncResolved) {
                        let subTree;
                        if (isFragmentStart) {
                            subTree = createVNode(Fragment);
                            subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
                        } else subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
                        subTree.el = node;
                        vnode.component.subTree = subTree;
                    }
                } else if (shapeFlag & 64) {
                    if (domType !== 8) nextNode = onMismatch();
                    else nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
                } else if (shapeFlag & 128) nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, getContainerType(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
                else warn$1("Invalid HostVNode type:", type, `(${typeof type})`);
        }
        if (ref != null) setRef(ref, null, parentSuspense, vnode);
        return nextNode;
    };
    const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized)=>{
        optimized = optimized || !!vnode.dynamicChildren;
        const { type , props , patchFlag , shapeFlag , dirs , transition  } = vnode;
        const forcePatch = type === "input" || type === "option";
        {
            if (dirs) invokeDirectiveHook(vnode, null, parentComponent, "created");
            let needCallTransitionHooks = false;
            if (isTemplateNode(el)) {
                needCallTransitionHooks = needTransition(null, // no need check parentSuspense in hydration
                transition) && parentComponent && parentComponent.vnode.props && parentComponent.vnode.props.appear;
                const content = el.content.firstChild;
                if (needCallTransitionHooks) {
                    const cls = content.getAttribute("class");
                    if (cls) content.$cls = cls;
                    transition.beforeEnter(content);
                }
                replaceNode(content, el, parentComponent);
                vnode.el = el = content;
            }
            if (shapeFlag & 16 && // skip if element has innerHTML / textContent
            !(props && (props.innerHTML || props.textContent))) {
                let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
                let hasWarned = false;
                while(next){
                    if (!isMismatchAllowed(el, 1 /* CHILDREN */ )) {
                        if (!hasWarned) {
                            warn$1(`Hydration children mismatch on`, el, `
Server rendered element contains more child nodes than client vdom.`);
                            hasWarned = true;
                        }
                        logMismatchError();
                    }
                    const cur = next;
                    next = next.nextSibling;
                    remove(cur);
                }
            } else if (shapeFlag & 8) {
                let clientText = vnode.children;
                if (clientText[0] === "\n" && (el.tagName === "PRE" || el.tagName === "TEXTAREA")) clientText = clientText.slice(1);
                if (el.textContent !== clientText) {
                    if (!isMismatchAllowed(el, 0 /* TEXT */ )) {
                        warn$1(`Hydration text content mismatch on`, el, `
  - rendered on server: ${el.textContent}
  - expected on client: ${vnode.children}`);
                        logMismatchError();
                    }
                    el.textContent = vnode.children;
                }
            }
            if (props) {
                const isCustomElement = el.tagName.includes("-");
                for(const key in props){
                    if (// #11189 skip if this node has directives that have created hooks
                    // as it could have mutated the DOM in any possible way
                    !(dirs && dirs.some((d)=>d.dir.created)) && propHasMismatch(el, key, props[key], vnode, parentComponent)) logMismatchError();
                    if (forcePatch && (key.endsWith("value") || key === "indeterminate") || (0, _shared.isOn)(key) && !(0, _shared.isReservedProp)(key) || // force hydrate v-bind with .prop modifiers
                    key[0] === "." || isCustomElement) patchProp(el, key, null, props[key], void 0, parentComponent);
                }
            }
            let vnodeHooks;
            if (vnodeHooks = props && props.onVnodeBeforeMount) invokeVNodeHook(vnodeHooks, parentComponent, vnode);
            if (dirs) invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
            if ((vnodeHooks = props && props.onVnodeMounted) || dirs || needCallTransitionHooks) queueEffectWithSuspense(()=>{
                vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
                needCallTransitionHooks && transition.enter(el);
                dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
            }, parentSuspense);
        }
        return el.nextSibling;
    };
    const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized)=>{
        optimized = optimized || !!parentVNode.dynamicChildren;
        const children = parentVNode.children;
        const l = children.length;
        let hasWarned = false;
        for(let i = 0; i < l; i++){
            const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);
            const isText = vnode.type === Text;
            if (node) {
                if (isText && !optimized) {
                    if (i + 1 < l && normalizeVNode(children[i + 1]).type === Text) {
                        insert(createText(node.data.slice(vnode.children.length)), container, nextSibling(node));
                        node.data = vnode.children;
                    }
                }
                node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
            } else if (isText && !vnode.children) insert(vnode.el = createText(""), container);
            else {
                if (!isMismatchAllowed(container, 1 /* CHILDREN */ )) {
                    if (!hasWarned) {
                        warn$1(`Hydration children mismatch on`, container, `
Server rendered element contains fewer child nodes than client vdom.`);
                        hasWarned = true;
                    }
                    logMismatchError();
                }
                patch(null, vnode, container, null, parentComponent, parentSuspense, getContainerType(container), slotScopeIds);
            }
        }
        return node;
    };
    const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized)=>{
        const { slotScopeIds: fragmentSlotScopeIds  } = vnode;
        if (fragmentSlotScopeIds) slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        const container = parentNode(node);
        const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);
        if (next && isComment(next) && next.data === "]") return nextSibling(vnode.anchor = next);
        else {
            logMismatchError();
            insert(vnode.anchor = createComment(`]`), container, next);
            return next;
        }
    };
    const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment)=>{
        if (!isMismatchAllowed(node.parentElement, 1 /* CHILDREN */ )) {
            warn$1(`Hydration node mismatch:
- rendered on server:`, node, node.nodeType === 3 ? `(text)` : isComment(node) && node.data === "[" ? `(start of fragment)` : ``, `
- expected on client:`, vnode.type);
            logMismatchError();
        }
        vnode.el = null;
        if (isFragment) {
            const end = locateClosingAnchor(node);
            while(true){
                const next2 = nextSibling(node);
                if (next2 && next2 !== end) remove(next2);
                else break;
            }
        }
        const next = nextSibling(node);
        const container = parentNode(node);
        remove(node);
        patch(null, vnode, container, next, parentComponent, parentSuspense, getContainerType(container), slotScopeIds);
        if (parentComponent) {
            parentComponent.vnode.el = vnode.el;
            updateHOCHostEl(parentComponent, vnode.el);
        }
        return next;
    };
    const locateClosingAnchor = (node, open = "[", close = "]")=>{
        let match = 0;
        while(node){
            node = nextSibling(node);
            if (node && isComment(node)) {
                if (node.data === open) match++;
                if (node.data === close) {
                    if (match === 0) return nextSibling(node);
                    else match--;
                }
            }
        }
        return node;
    };
    const replaceNode = (newNode, oldNode, parentComponent)=>{
        const parentNode2 = oldNode.parentNode;
        if (parentNode2) parentNode2.replaceChild(newNode, oldNode);
        let parent = parentComponent;
        while(parent){
            if (parent.vnode.el === oldNode) parent.vnode.el = parent.subTree.el = newNode;
            parent = parent.parent;
        }
    };
    const isTemplateNode = (node)=>{
        return node.nodeType === 1 && node.tagName === "TEMPLATE";
    };
    return [
        hydrate,
        hydrateNode
    ];
}
function propHasMismatch(el, key, clientValue, vnode, instance) {
    let mismatchType;
    let mismatchKey;
    let actual;
    let expected;
    if (key === "class") {
        if (el.$cls) {
            actual = el.$cls;
            delete el.$cls;
        } else actual = el.getAttribute("class");
        expected = (0, _shared.normalizeClass)(clientValue);
        if (!isSetEqual(toClassSet(actual || ""), toClassSet(expected))) {
            mismatchType = 2 /* CLASS */ ;
            mismatchKey = `class`;
        }
    } else if (key === "style") {
        actual = el.getAttribute("style") || "";
        expected = (0, _shared.isString)(clientValue) ? clientValue : (0, _shared.stringifyStyle)((0, _shared.normalizeStyle)(clientValue));
        const actualMap = toStyleMap(actual);
        const expectedMap = toStyleMap(expected);
        if (vnode.dirs) {
            for (const { dir , value  } of vnode.dirs)if (dir.name === "show" && !value) expectedMap.set("display", "none");
        }
        if (instance) resolveCssVars(instance, vnode, expectedMap);
        if (!isMapEqual(actualMap, expectedMap)) {
            mismatchType = 3 /* STYLE */ ;
            mismatchKey = "style";
        }
    } else if (el instanceof SVGElement && (0, _shared.isKnownSvgAttr)(key) || el instanceof HTMLElement && ((0, _shared.isBooleanAttr)(key) || (0, _shared.isKnownHtmlAttr)(key))) {
        if ((0, _shared.isBooleanAttr)(key)) {
            actual = el.hasAttribute(key);
            expected = (0, _shared.includeBooleanAttr)(clientValue);
        } else if (clientValue == null) {
            actual = el.hasAttribute(key);
            expected = false;
        } else {
            if (el.hasAttribute(key)) actual = el.getAttribute(key);
            else if (key === "value" && el.tagName === "TEXTAREA") actual = el.value;
            else actual = false;
            expected = (0, _shared.isRenderableAttrValue)(clientValue) ? String(clientValue) : false;
        }
        if (actual !== expected) {
            mismatchType = 4 /* ATTRIBUTE */ ;
            mismatchKey = key;
        }
    }
    if (mismatchType != null && !isMismatchAllowed(el, mismatchType)) {
        const format = (v1)=>v1 === false ? `(not rendered)` : `${mismatchKey}="${v1}"`;
        const preSegment = `Hydration ${MismatchTypeString[mismatchType]} mismatch on`;
        const postSegment = `
  - rendered on server: ${format(actual)}
  - expected on client: ${format(expected)}
  Note: this mismatch is check-only. The DOM will not be rectified in production due to performance overhead.
  You should fix the source of the mismatch.`;
        warn$1(preSegment, el, postSegment);
        return true;
    }
    return false;
}
function toClassSet(str) {
    return new Set(str.trim().split(/\s+/));
}
function isSetEqual(a, b) {
    if (a.size !== b.size) return false;
    for (const s of a){
        if (!b.has(s)) return false;
    }
    return true;
}
function toStyleMap(str) {
    const styleMap = /* @__PURE__ */ new Map();
    for (const item of str.split(";")){
        let [key, value] = item.split(":");
        key = key.trim();
        value = value && value.trim();
        if (key && value) styleMap.set(key, value);
    }
    return styleMap;
}
function isMapEqual(a, b) {
    if (a.size !== b.size) return false;
    for (const [key, value] of a){
        if (value !== b.get(key)) return false;
    }
    return true;
}
function resolveCssVars(instance, vnode, expectedMap) {
    const root = instance.subTree;
    if (instance.getCssVars && (vnode === root || root && root.type === Fragment && root.children.includes(vnode))) {
        const cssVars = instance.getCssVars();
        for(const key in cssVars)expectedMap.set(`--${(0, _shared.getEscapedCssVarName)(key, false)}`, String(cssVars[key]));
    }
    if (vnode === root && instance.parent) resolveCssVars(instance.parent, instance.vnode, expectedMap);
}
const allowMismatchAttr = "data-allow-mismatch";
const MismatchTypeString = {
    [0 /* TEXT */ ]: "text",
    [1 /* CHILDREN */ ]: "children",
    [2 /* CLASS */ ]: "class",
    [3 /* STYLE */ ]: "style",
    [4 /* ATTRIBUTE */ ]: "attribute"
};
function isMismatchAllowed(el, allowedType) {
    if (allowedType === 0 /* TEXT */  || allowedType === 1 /* CHILDREN */ ) while(el && !el.hasAttribute(allowMismatchAttr))el = el.parentElement;
    const allowedAttr = el && el.getAttribute(allowMismatchAttr);
    if (allowedAttr == null) return false;
    else if (allowedAttr === "") return true;
    else {
        const list = allowedAttr.split(",");
        if (allowedType === 0 /* TEXT */  && list.includes("children")) return true;
        return allowedAttr.split(",").includes(MismatchTypeString[allowedType]);
    }
}
const requestIdleCallback = (0, _shared.getGlobalThis)().requestIdleCallback || ((cb)=>setTimeout(cb, 1));
const cancelIdleCallback = (0, _shared.getGlobalThis)().cancelIdleCallback || ((id)=>clearTimeout(id));
const hydrateOnIdle = (timeout = 1e4)=>(hydrate)=>{
        const id = requestIdleCallback(hydrate, {
            timeout
        });
        return ()=>cancelIdleCallback(id);
    };
function elementIsVisibleInViewport(el) {
    const { top , left , bottom , right  } = el.getBoundingClientRect();
    const { innerHeight , innerWidth  } = window;
    return (top > 0 && top < innerHeight || bottom > 0 && bottom < innerHeight) && (left > 0 && left < innerWidth || right > 0 && right < innerWidth);
}
const hydrateOnVisible = (opts)=>(hydrate, forEach)=>{
        const ob = new IntersectionObserver((entries)=>{
            for (const e of entries){
                if (!e.isIntersecting) continue;
                ob.disconnect();
                hydrate();
                break;
            }
        }, opts);
        forEach((el)=>{
            if (!(el instanceof Element)) return;
            if (elementIsVisibleInViewport(el)) {
                hydrate();
                ob.disconnect();
                return false;
            }
            ob.observe(el);
        });
        return ()=>ob.disconnect();
    };
const hydrateOnMediaQuery = (query)=>(hydrate)=>{
        if (query) {
            const mql = matchMedia(query);
            if (mql.matches) hydrate();
            else {
                mql.addEventListener("change", hydrate, {
                    once: true
                });
                return ()=>mql.removeEventListener("change", hydrate);
            }
        }
    };
const hydrateOnInteraction = (interactions = [])=>(hydrate, forEach)=>{
        if ((0, _shared.isString)(interactions)) interactions = [
            interactions
        ];
        let hasHydrated = false;
        const doHydrate = (e)=>{
            if (!hasHydrated) {
                hasHydrated = true;
                teardown();
                hydrate();
                e.target.dispatchEvent(new e.constructor(e.type, e));
            }
        };
        const teardown = ()=>{
            forEach((el)=>{
                for (const i of interactions)el.removeEventListener(i, doHydrate);
            });
        };
        forEach((el)=>{
            for (const i of interactions)el.addEventListener(i, doHydrate, {
                once: true
            });
        });
        return teardown;
    };
function forEachElement(node, cb) {
    if (isComment(node) && node.data === "[") {
        let depth = 1;
        let next = node.nextSibling;
        while(next){
            if (next.nodeType === 1) {
                const result = cb(next);
                if (result === false) break;
            } else if (isComment(next)) {
                if (next.data === "]") {
                    if (--depth === 0) break;
                } else if (next.data === "[") depth++;
            }
            next = next.nextSibling;
        }
    } else cb(node);
}
const isAsyncWrapper = (i)=>!!i.type.__asyncLoader;
/*! #__NO_SIDE_EFFECTS__ */ // @__NO_SIDE_EFFECTS__
function defineAsyncComponent(source) {
    if ((0, _shared.isFunction)(source)) source = {
        loader: source
    };
    const { loader , loadingComponent , errorComponent , delay =200 , hydrate: hydrateStrategy , timeout , // undefined = never times out
    suspensible =true , onError: userOnError  } = source;
    let pendingRequest = null;
    let resolvedComp;
    let retries = 0;
    const retry = ()=>{
        retries++;
        pendingRequest = null;
        return load();
    };
    const load = ()=>{
        let thisRequest;
        return pendingRequest || (thisRequest = pendingRequest = loader().catch((err)=>{
            err = err instanceof Error ? err : new Error(String(err));
            if (userOnError) return new Promise((resolve, reject)=>{
                const userRetry = ()=>resolve(retry());
                const userFail = ()=>reject(err);
                userOnError(err, userRetry, userFail, retries + 1);
            });
            else throw err;
        }).then((comp)=>{
            if (thisRequest !== pendingRequest && pendingRequest) return pendingRequest;
            if (!comp) warn$1(`Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.`);
            if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) comp = comp.default;
            if (comp && !(0, _shared.isObject)(comp) && !(0, _shared.isFunction)(comp)) throw new Error(`Invalid async component load result: ${comp}`);
            resolvedComp = comp;
            return comp;
        }));
    };
    return defineComponent({
        name: "AsyncComponentWrapper",
        __asyncLoader: load,
        __asyncHydrate (el, instance, hydrate) {
            let patched = false;
            const doHydrate = hydrateStrategy ? ()=>{
                const performHydrate = ()=>{
                    if (patched) {
                        warn$1(`Skipping lazy hydration for component '${getComponentName(resolvedComp)}': it was updated before lazy hydration performed.`);
                        return;
                    }
                    hydrate();
                };
                const teardown = hydrateStrategy(performHydrate, (cb)=>forEachElement(el, cb));
                if (teardown) (instance.bum || (instance.bum = [])).push(teardown);
                (instance.u || (instance.u = [])).push(()=>patched = true);
            } : hydrate;
            if (resolvedComp) doHydrate();
            else load().then(()=>!instance.isUnmounted && doHydrate());
        },
        get __asyncResolved () {
            return resolvedComp;
        },
        setup () {
            const instance = currentInstance;
            markAsyncBoundary(instance);
            if (resolvedComp) return ()=>createInnerComp(resolvedComp, instance);
            const onError = (err)=>{
                pendingRequest = null;
                handleError(err, instance, 13, !errorComponent);
            };
            if (suspensible && instance.suspense || isInSSRComponentSetup) return load().then((comp)=>{
                return ()=>createInnerComp(comp, instance);
            }).catch((err)=>{
                onError(err);
                return ()=>errorComponent ? createVNode(errorComponent, {
                        error: err
                    }) : null;
            });
            const loaded = (0, _reactivity.ref)(false);
            const error = (0, _reactivity.ref)();
            const delayed = (0, _reactivity.ref)(!!delay);
            if (delay) setTimeout(()=>{
                delayed.value = false;
            }, delay);
            if (timeout != null) setTimeout(()=>{
                if (!loaded.value && !error.value) {
                    const err = new Error(`Async component timed out after ${timeout}ms.`);
                    onError(err);
                    error.value = err;
                }
            }, timeout);
            load().then(()=>{
                loaded.value = true;
                if (instance.parent && isKeepAlive(instance.parent.vnode)) instance.parent.update();
            }).catch((err)=>{
                onError(err);
                error.value = err;
            });
            return ()=>{
                if (loaded.value && resolvedComp) return createInnerComp(resolvedComp, instance);
                else if (error.value && errorComponent) return createVNode(errorComponent, {
                    error: error.value
                });
                else if (loadingComponent && !delayed.value) return createVNode(loadingComponent);
            };
        }
    });
}
function createInnerComp(comp, parent) {
    const { ref: ref2 , props , children , ce  } = parent.vnode;
    const vnode = createVNode(comp, props, children);
    vnode.ref = ref2;
    vnode.ce = ce;
    delete parent.vnode.ce;
    return vnode;
}
const isKeepAlive = (vnode)=>vnode.type.__isKeepAlive;
const KeepAliveImpl = {
    name: `KeepAlive`,
    // Marker for special handling inside the renderer. We are not using a ===
    // check directly on KeepAlive in the renderer, because importing it directly
    // would prevent it from being tree-shaken.
    __isKeepAlive: true,
    props: {
        include: [
            String,
            RegExp,
            Array
        ],
        exclude: [
            String,
            RegExp,
            Array
        ],
        max: [
            String,
            Number
        ]
    },
    setup (props, { slots  }) {
        const instance = getCurrentInstance();
        const sharedContext = instance.ctx;
        if (!sharedContext.renderer) return ()=>{
            const children = slots.default && slots.default();
            return children && children.length === 1 ? children[0] : children;
        };
        const cache = /* @__PURE__ */ new Map();
        const keys = /* @__PURE__ */ new Set();
        let current = null;
        instance.__v_cache = cache;
        const parentSuspense = instance.suspense;
        const { renderer: { p: patch , m: move , um: _unmount , o: { createElement  }  }  } = sharedContext;
        const storageContainer = createElement("div");
        sharedContext.activate = (vnode, container, anchor, namespace, optimized)=>{
            const instance2 = vnode.component;
            move(vnode, container, anchor, 0, parentSuspense);
            patch(instance2.vnode, vnode, container, anchor, instance2, parentSuspense, namespace, vnode.slotScopeIds, optimized);
            queuePostRenderEffect(()=>{
                instance2.isDeactivated = false;
                if (instance2.a) (0, _shared.invokeArrayFns)(instance2.a);
                const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
                if (vnodeHook) invokeVNodeHook(vnodeHook, instance2.parent, vnode);
            }, parentSuspense);
            devtoolsComponentAdded(instance2);
        };
        sharedContext.deactivate = (vnode)=>{
            const instance2 = vnode.component;
            invalidateMount(instance2.m);
            invalidateMount(instance2.a);
            move(vnode, storageContainer, null, 1, parentSuspense);
            queuePostRenderEffect(()=>{
                if (instance2.da) (0, _shared.invokeArrayFns)(instance2.da);
                const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
                if (vnodeHook) invokeVNodeHook(vnodeHook, instance2.parent, vnode);
                instance2.isDeactivated = true;
            }, parentSuspense);
            devtoolsComponentAdded(instance2);
            instance2.__keepAliveStorageContainer = storageContainer;
        };
        function unmount(vnode) {
            resetShapeFlag(vnode);
            _unmount(vnode, instance, parentSuspense, true);
        }
        function pruneCache(filter) {
            cache.forEach((vnode, key)=>{
                const name = getComponentName(vnode.type);
                if (name && !filter(name)) pruneCacheEntry(key);
            });
        }
        function pruneCacheEntry(key) {
            const cached = cache.get(key);
            if (cached && (!current || !isSameVNodeType(cached, current))) unmount(cached);
            else if (current) resetShapeFlag(current);
            cache.delete(key);
            keys.delete(key);
        }
        watch(()=>[
                props.include,
                props.exclude
            ], ([include, exclude])=>{
            include && pruneCache((name)=>matches(include, name));
            exclude && pruneCache((name)=>!matches(exclude, name));
        }, // prune post-render after `current` has been updated
        {
            flush: "post",
            deep: true
        });
        let pendingCacheKey = null;
        const cacheSubtree = ()=>{
            if (pendingCacheKey != null) {
                if (isSuspense(instance.subTree.type)) queuePostRenderEffect(()=>{
                    cache.set(pendingCacheKey, getInnerChild(instance.subTree));
                }, instance.subTree.suspense);
                else cache.set(pendingCacheKey, getInnerChild(instance.subTree));
            }
        };
        onMounted(cacheSubtree);
        onUpdated(cacheSubtree);
        onBeforeUnmount(()=>{
            cache.forEach((cached)=>{
                const { subTree , suspense  } = instance;
                const vnode = getInnerChild(subTree);
                if (cached.type === vnode.type && cached.key === vnode.key) {
                    resetShapeFlag(vnode);
                    const da = vnode.component.da;
                    da && queuePostRenderEffect(da, suspense);
                    return;
                }
                unmount(cached);
            });
        });
        return ()=>{
            pendingCacheKey = null;
            if (!slots.default) return current = null;
            const children = slots.default();
            const rawVNode = children[0];
            if (children.length > 1) {
                warn$1(`KeepAlive should contain exactly one component child.`);
                current = null;
                return children;
            } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
                current = null;
                return rawVNode;
            }
            let vnode = getInnerChild(rawVNode);
            if (vnode.type === Comment) {
                current = null;
                return vnode;
            }
            const comp = vnode.type;
            const name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp);
            const { include , exclude , max  } = props;
            if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
                vnode.shapeFlag &= -257;
                current = vnode;
                return rawVNode;
            }
            const key = vnode.key == null ? comp : vnode.key;
            const cachedVNode = cache.get(key);
            if (vnode.el) {
                vnode = cloneVNode(vnode);
                if (rawVNode.shapeFlag & 128) rawVNode.ssContent = vnode;
            }
            pendingCacheKey = key;
            if (cachedVNode) {
                vnode.el = cachedVNode.el;
                vnode.component = cachedVNode.component;
                if (vnode.transition) setTransitionHooks(vnode, vnode.transition);
                vnode.shapeFlag |= 512;
                keys.delete(key);
                keys.add(key);
            } else {
                keys.add(key);
                if (max && keys.size > parseInt(max, 10)) pruneCacheEntry(keys.values().next().value);
            }
            vnode.shapeFlag |= 256;
            current = vnode;
            return isSuspense(rawVNode.type) ? rawVNode : vnode;
        };
    }
};
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
    if ((0, _shared.isArray)(pattern)) return pattern.some((p)=>matches(p, name));
    else if ((0, _shared.isString)(pattern)) return pattern.split(",").includes(name);
    else if ((0, _shared.isRegExp)(pattern)) {
        pattern.lastIndex = 0;
        return pattern.test(name);
    }
    return false;
}
function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
    const wrappedHook = hook.__wdc || (hook.__wdc = ()=>{
        let current = target;
        while(current){
            if (current.isDeactivated) return;
            current = current.parent;
        }
        return hook();
    });
    injectHook(type, wrappedHook, target);
    if (target) {
        let current = target.parent;
        while(current && current.parent){
            if (isKeepAlive(current.parent.vnode)) injectToKeepAliveRoot(wrappedHook, type, target, current);
            current = current.parent;
        }
    }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    const injected = injectHook(type, hook, keepAliveRoot, true);
    onUnmounted(()=>{
        (0, _shared.remove)(keepAliveRoot[type], injected);
    }, target);
}
function resetShapeFlag(vnode) {
    vnode.shapeFlag &= -257;
    vnode.shapeFlag &= -513;
}
function getInnerChild(vnode) {
    return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
        const hooks = target[type] || (target[type] = []);
        const wrappedHook = hook.__weh || (hook.__weh = (...args)=>{
            (0, _reactivity.pauseTracking)();
            const reset = setCurrentInstance(target);
            const res = callWithAsyncErrorHandling(hook, target, type, args);
            reset();
            (0, _reactivity.resetTracking)();
            return res;
        });
        if (prepend) hooks.unshift(wrappedHook);
        else hooks.push(wrappedHook);
        return wrappedHook;
    } else {
        const apiName = (0, _shared.toHandlerKey)(ErrorTypeStrings$1[type].replace(/ hook$/, ""));
        warn$1(`${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup().` + ` If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`);
    }
}
const createHook = (lifecycle)=>(hook, target = currentInstance)=>{
        if (!isInSSRComponentSetup || lifecycle === "sp") injectHook(lifecycle, (...args)=>hook(...args), target);
    };
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec", hook, target);
}
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
    if ((0, _shared.isString)(component)) return resolveAsset(COMPONENTS, component, false) || component;
    else return component || NULL_DYNAMIC_COMPONENT;
}
function resolveDirective(name) {
    return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
        const Component = instance.type;
        if (type === COMPONENTS) {
            const selfName = getComponentName(Component, false);
            if (selfName && (selfName === name || selfName === (0, _shared.camelize)(name) || selfName === (0, _shared.capitalize)((0, _shared.camelize)(name)))) return Component;
        }
        const res = // local registration
        // check instance[type] first which is resolved for options API
        resolve(instance[type] || Component[type], name) || // global registration
        resolve(instance.appContext[type], name);
        if (!res && maybeSelfReference) return Component;
        if (warnMissing && !res) {
            const extra = type === COMPONENTS ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;
            warn$1(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
        }
        return res;
    } else warn$1(`resolve${(0, _shared.capitalize)(type.slice(0, -1))} can only be used in render() or setup().`);
}
function resolve(registry, name) {
    return registry && (registry[name] || registry[(0, _shared.camelize)(name)] || registry[(0, _shared.capitalize)((0, _shared.camelize)(name))]);
}
function renderList(source, renderItem, cache, index) {
    let ret;
    const cached = cache && cache[index];
    const sourceIsArray = (0, _shared.isArray)(source);
    if (sourceIsArray || (0, _shared.isString)(source)) {
        const sourceIsReactiveArray = sourceIsArray && (0, _reactivity.isReactive)(source);
        let needsWrap = false;
        let isReadonlySource = false;
        if (sourceIsReactiveArray) {
            needsWrap = !(0, _reactivity.isShallow)(source);
            isReadonlySource = (0, _reactivity.isReadonly)(source);
            source = (0, _reactivity.shallowReadArray)(source);
        }
        ret = new Array(source.length);
        for(let i = 0, l = source.length; i < l; i++)ret[i] = renderItem(needsWrap ? isReadonlySource ? (0, _reactivity.toReadonly)((0, _reactivity.toReactive)(source[i])) : (0, _reactivity.toReactive)(source[i]) : source[i], i, void 0, cached && cached[i]);
    } else if (typeof source === "number") {
        if (!Number.isInteger(source)) warn$1(`The v-for range expect an integer value but got ${source}.`);
        ret = new Array(source);
        for(let i = 0; i < source; i++)ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    } else if ((0, _shared.isObject)(source)) {
        if (source[Symbol.iterator]) ret = Array.from(source, (item, i)=>renderItem(item, i, void 0, cached && cached[i]));
        else {
            const keys = Object.keys(source);
            ret = new Array(keys.length);
            for(let i = 0, l = keys.length; i < l; i++){
                const key = keys[i];
                ret[i] = renderItem(source[key], key, i, cached && cached[i]);
            }
        }
    } else ret = [];
    if (cache) cache[index] = ret;
    return ret;
}
function createSlots(slots, dynamicSlots) {
    for(let i = 0; i < dynamicSlots.length; i++){
        const slot = dynamicSlots[i];
        if ((0, _shared.isArray)(slot)) for(let j = 0; j < slot.length; j++)slots[slot[j].name] = slot[j].fn;
        else if (slot) slots[slot.name] = slot.key ? (...args)=>{
            const res = slot.fn(...args);
            if (res) res.key = slot.key;
            return res;
        } : slot.fn;
    }
    return slots;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
    if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
        if (name !== "default") props.name = name;
        return openBlock(), createBlock(Fragment, null, [
            createVNode("slot", props, fallback && fallback())
        ], 64);
    }
    let slot = slots[name];
    if (slot && slot.length > 1) {
        warn$1(`SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`);
        slot = ()=>[];
    }
    if (slot && slot._c) slot._d = false;
    openBlock();
    const validSlotContent = slot && ensureValidVNode(slot(props));
    const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch
    // key attached in the `createSlots` helper, respect that
    validSlotContent && validSlotContent.key;
    const rendered = createBlock(Fragment, {
        key: (slotKey && !(0, _shared.isSymbol)(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content
        (!validSlotContent && fallback ? "_fb" : "")
    }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
    if (!noSlotted && rendered.scopeId) rendered.slotScopeIds = [
        rendered.scopeId + "-s"
    ];
    if (slot && slot._c) slot._d = true;
    return rendered;
}
function ensureValidVNode(vnodes) {
    return vnodes.some((child)=>{
        if (!isVNode(child)) return true;
        if (child.type === Comment) return false;
        if (child.type === Fragment && !ensureValidVNode(child.children)) return false;
        return true;
    }) ? vnodes : null;
}
function toHandlers(obj, preserveCaseIfNecessary) {
    const ret = {};
    if (!(0, _shared.isObject)(obj)) {
        warn$1(`v-on with no argument expects an object value.`);
        return ret;
    }
    for(const key in obj)ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : (0, _shared.toHandlerKey)(key)] = obj[key];
    return ret;
}
const getPublicInstance = (i)=>{
    if (!i) return null;
    if (isStatefulComponent(i)) return getComponentPublicInstance(i);
    return getPublicInstance(i.parent);
};
const publicPropertiesMap = // Move PURE marker to new line to workaround compiler discarding it
// due to type annotation
/* @__PURE__ */ (0, _shared.extend)(/* @__PURE__ */ Object.create(null), {
    $: (i)=>i,
    $el: (i)=>i.vnode.el,
    $data: (i)=>i.data,
    $props: (i)=>(0, _reactivity.shallowReadonly)(i.props),
    $attrs: (i)=>(0, _reactivity.shallowReadonly)(i.attrs),
    $slots: (i)=>(0, _reactivity.shallowReadonly)(i.slots),
    $refs: (i)=>(0, _reactivity.shallowReadonly)(i.refs),
    $parent: (i)=>getPublicInstance(i.parent),
    $root: (i)=>getPublicInstance(i.root),
    $host: (i)=>i.ce,
    $emit: (i)=>i.emit,
    $options: (i)=>__VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type,
    $forceUpdate: (i)=>i.f || (i.f = ()=>{
            queueJob(i.update);
        }),
    $nextTick: (i)=>i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i)=>__VUE_OPTIONS_API__ ? instanceWatch.bind(i) : (0, _shared.NOOP)
});
const isReservedPrefix = (key)=>key === "_" || key === "$";
const hasSetupBinding = (state, key)=>state !== (0, _shared.EMPTY_OBJ) && !state.__isScriptSetup && (0, _shared.hasOwn)(state, key);
const PublicInstanceProxyHandlers = {
    get ({ _: instance  }, key) {
        if (key === "__v_skip") return true;
        const { ctx , setupState , data , props , accessCache , type , appContext  } = instance;
        if (key === "__isVue") return true;
        let normalizedProps;
        if (key[0] !== "$") {
            const n = accessCache[key];
            if (n !== void 0) switch(n){
                case 1 /* SETUP */ :
                    return setupState[key];
                case 2 /* DATA */ :
                    return data[key];
                case 4 /* CONTEXT */ :
                    return ctx[key];
                case 3 /* PROPS */ :
                    return props[key];
            }
            else if (hasSetupBinding(setupState, key)) {
                accessCache[key] = 1 /* SETUP */ ;
                return setupState[key];
            } else if (data !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasOwn)(data, key)) {
                accessCache[key] = 2 /* DATA */ ;
                return data[key];
            } else if (// only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) && (0, _shared.hasOwn)(normalizedProps, key)) {
                accessCache[key] = 3 /* PROPS */ ;
                return props[key];
            } else if (ctx !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasOwn)(ctx, key)) {
                accessCache[key] = 4 /* CONTEXT */ ;
                return ctx[key];
            } else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) accessCache[key] = 0 /* OTHER */ ;
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        if (publicGetter) {
            if (key === "$attrs") {
                (0, _reactivity.track)(instance.attrs, "get", "");
                markAttrsAccessed();
            } else if (key === "$slots") (0, _reactivity.track)(instance, "get", key);
            return publicGetter(instance);
        } else if (// css module (injected by vue-loader)
        (cssModule = type.__cssModules) && (cssModule = cssModule[key])) return cssModule;
        else if (ctx !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasOwn)(ctx, key)) {
            accessCache[key] = 4 /* CONTEXT */ ;
            return ctx[key];
        } else if (// global properties
        globalProperties = appContext.config.globalProperties, (0, _shared.hasOwn)(globalProperties, key)) return globalProperties[key];
        else if (currentRenderingInstance && (!(0, _shared.isString)(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
        // to infinite warning loop
        key.indexOf("__v") !== 0)) {
            if (data !== (0, _shared.EMPTY_OBJ) && isReservedPrefix(key[0]) && (0, _shared.hasOwn)(data, key)) warn$1(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`);
            else if (instance === currentRenderingInstance) warn$1(`Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`);
        }
    },
    set ({ _: instance  }, key, value) {
        const { data , setupState , ctx  } = instance;
        if (hasSetupBinding(setupState, key)) {
            setupState[key] = value;
            return true;
        } else if ((0, setupState.__isScriptSetup) && (0, _shared.hasOwn)(setupState, key)) {
            warn$1(`Cannot mutate <script setup> binding "${key}" from Options API.`);
            return false;
        } else if (data !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasOwn)(data, key)) {
            data[key] = value;
            return true;
        } else if ((0, _shared.hasOwn)(instance.props, key)) {
            warn$1(`Attempting to mutate prop "${key}". Props are readonly.`);
            return false;
        }
        if (key[0] === "$" && key.slice(1) in instance) {
            warn$1(`Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`);
            return false;
        } else if (key in instance.appContext.config.globalProperties) Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            value
        });
        else ctx[key] = value;
        return true;
    },
    has ({ _: { data , setupState , accessCache , ctx , appContext , propsOptions  }  }, key) {
        let normalizedProps;
        return !!accessCache[key] || data !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasOwn)(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && (0, _shared.hasOwn)(normalizedProps, key) || (0, _shared.hasOwn)(ctx, key) || (0, _shared.hasOwn)(publicPropertiesMap, key) || (0, _shared.hasOwn)(appContext.config.globalProperties, key);
    },
    defineProperty (target, key, descriptor) {
        if (descriptor.get != null) target._.accessCache[key] = 0;
        else if ((0, _shared.hasOwn)(descriptor, "value")) this.set(target, key, descriptor.value, null);
        return Reflect.defineProperty(target, key, descriptor);
    }
};
PublicInstanceProxyHandlers.ownKeys = (target)=>{
    warn$1(`Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`);
    return Reflect.ownKeys(target);
};
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ (0, _shared.extend)({}, PublicInstanceProxyHandlers, {
    get (target, key) {
        if (key === Symbol.unscopables) return;
        return PublicInstanceProxyHandlers.get(target, key, target);
    },
    has (_, key) {
        const has = key[0] !== "_" && !(0, _shared.isGloballyAllowed)(key);
        if (!has && PublicInstanceProxyHandlers.has(_, key)) warn$1(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);
        return has;
    }
});
function createDevRenderContext(instance) {
    const target = {};
    Object.defineProperty(target, `_`, {
        configurable: true,
        enumerable: false,
        get: ()=>instance
    });
    Object.keys(publicPropertiesMap).forEach((key)=>{
        Object.defineProperty(target, key, {
            configurable: true,
            enumerable: false,
            get: ()=>publicPropertiesMap[key](instance),
            // intercepted by the proxy so no need for implementation,
            // but needed to prevent set errors
            set: (0, _shared.NOOP)
        });
    });
    return target;
}
function exposePropsOnRenderContext(instance) {
    const { ctx , propsOptions: [propsOptions]  } = instance;
    if (propsOptions) Object.keys(propsOptions).forEach((key)=>{
        Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: ()=>instance.props[key],
            set: (0, _shared.NOOP)
        });
    });
}
function exposeSetupStateOnRenderContext(instance) {
    const { ctx , setupState  } = instance;
    Object.keys((0, _reactivity.toRaw)(setupState)).forEach((key)=>{
        if (!setupState.__isScriptSetup) {
            if (isReservedPrefix(key[0])) {
                warn$1(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);
                return;
            }
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: ()=>setupState[key],
                set: (0, _shared.NOOP)
            });
        }
    });
}
const warnRuntimeUsage = (method)=>warn$1(`${method}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`);
function defineProps() {
    warnRuntimeUsage(`defineProps`);
    return null;
}
function defineEmits() {
    warnRuntimeUsage(`defineEmits`);
    return null;
}
function defineExpose(exposed) {
    warnRuntimeUsage(`defineExpose`);
}
function defineOptions(options) {
    warnRuntimeUsage(`defineOptions`);
}
function defineSlots() {
    warnRuntimeUsage(`defineSlots`);
    return null;
}
function defineModel() {
    warnRuntimeUsage("defineModel");
}
function withDefaults(props, defaults) {
    warnRuntimeUsage(`withDefaults`);
    return null;
}
function useSlots() {
    return getContext().slots;
}
function useAttrs() {
    return getContext().attrs;
}
function getContext() {
    const i = getCurrentInstance();
    if (!i) warn$1(`useContext() called without active instance.`);
    return i.setupContext || (i.setupContext = createSetupContext(i));
}
function normalizePropsOrEmits(props) {
    return (0, _shared.isArray)(props) ? props.reduce((normalized, p)=>(normalized[p] = null, normalized), {}) : props;
}
function mergeDefaults(raw, defaults) {
    const props = normalizePropsOrEmits(raw);
    for(const key in defaults){
        if (key.startsWith("__skip")) continue;
        let opt = props[key];
        if (opt) {
            if ((0, _shared.isArray)(opt) || (0, _shared.isFunction)(opt)) opt = props[key] = {
                type: opt,
                default: defaults[key]
            };
            else opt.default = defaults[key];
        } else if (opt === null) opt = props[key] = {
            default: defaults[key]
        };
        else warn$1(`props default key "${key}" has no corresponding declaration.`);
        if (opt && defaults[`__skip_${key}`]) opt.skipFactory = true;
    }
    return props;
}
function mergeModels(a, b) {
    if (!a || !b) return a || b;
    if ((0, _shared.isArray)(a) && (0, _shared.isArray)(b)) return a.concat(b);
    return (0, _shared.extend)({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));
}
function createPropsRestProxy(props, excludedKeys) {
    const ret = {};
    for(const key in props)if (!excludedKeys.includes(key)) Object.defineProperty(ret, key, {
        enumerable: true,
        get: ()=>props[key]
    });
    return ret;
}
function withAsyncContext(getAwaitable) {
    const ctx = getCurrentInstance();
    if (!ctx) warn$1(`withAsyncContext called without active current instance. This is likely a bug.`);
    let awaitable = getAwaitable();
    unsetCurrentInstance();
    if ((0, _shared.isPromise)(awaitable)) awaitable = awaitable.catch((e)=>{
        setCurrentInstance(ctx);
        throw e;
    });
    return [
        awaitable,
        ()=>setCurrentInstance(ctx)
    ];
}
function createDuplicateChecker() {
    const cache = /* @__PURE__ */ Object.create(null);
    return (type, key)=>{
        if (cache[key]) warn$1(`${type} property "${key}" is already defined in ${cache[key]}.`);
        else cache[key] = type;
    };
}
let shouldCacheAccess = true;
function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    shouldCacheAccess = false;
    if (options.beforeCreate) callHook(options.beforeCreate, instance, "bc");
    const { // state
    data: dataOptions , computed: computedOptions , methods , watch: watchOptions , provide: provideOptions , inject: injectOptions , // lifecycle
    created , beforeMount , mounted , beforeUpdate , updated , activated , deactivated , beforeDestroy , beforeUnmount , destroyed , unmounted , render , renderTracked , renderTriggered , errorCaptured , serverPrefetch , // public API
    expose , inheritAttrs , // assets
    components , directives , filters  } = options;
    const checkDuplicateProperties = createDuplicateChecker();
    {
        const [propsOptions] = instance.propsOptions;
        if (propsOptions) for(const key in propsOptions)checkDuplicateProperties("Props" /* PROPS */ , key);
    }
    if (injectOptions) resolveInjections(injectOptions, ctx, checkDuplicateProperties);
    if (methods) for(const key in methods){
        const methodHandler = methods[key];
        if ((0, _shared.isFunction)(methodHandler)) {
            Object.defineProperty(ctx, key, {
                value: methodHandler.bind(publicThis),
                configurable: true,
                enumerable: true,
                writable: true
            });
            checkDuplicateProperties("Methods" /* METHODS */ , key);
        } else warn$1(`Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`);
    }
    if (dataOptions) {
        if (!(0, _shared.isFunction)(dataOptions)) warn$1(`The data option must be a function. Plain object usage is no longer supported.`);
        const data = dataOptions.call(publicThis, publicThis);
        if ((0, _shared.isPromise)(data)) warn$1(`data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`);
        if (!(0, _shared.isObject)(data)) warn$1(`data() should return an object.`);
        else {
            instance.data = (0, _reactivity.reactive)(data);
            for(const key in data){
                checkDuplicateProperties("Data" /* DATA */ , key);
                if (!isReservedPrefix(key[0])) Object.defineProperty(ctx, key, {
                    configurable: true,
                    enumerable: true,
                    get: ()=>data[key],
                    set: (0, _shared.NOOP)
                });
            }
        }
    }
    shouldCacheAccess = true;
    if (computedOptions) for(const key in computedOptions){
        const opt = computedOptions[key];
        const get = (0, _shared.isFunction)(opt) ? opt.bind(publicThis, publicThis) : (0, _shared.isFunction)(opt.get) ? opt.get.bind(publicThis, publicThis) : (0, _shared.NOOP);
        if (get === (0, _shared.NOOP)) warn$1(`Computed property "${key}" has no getter.`);
        const set = !(0, _shared.isFunction)(opt) && (0, _shared.isFunction)(opt.set) ? opt.set.bind(publicThis) : ()=>{
            warn$1(`Write operation failed: computed property "${key}" is readonly.`);
        };
        const c = computed({
            get,
            set
        });
        Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: ()=>c.value,
            set: (v1)=>c.value = v1
        });
        checkDuplicateProperties("Computed" /* COMPUTED */ , key);
    }
    if (watchOptions) for(const key in watchOptions)createWatcher(watchOptions[key], ctx, publicThis, key);
    if (provideOptions) {
        const provides = (0, _shared.isFunction)(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
        Reflect.ownKeys(provides).forEach((key)=>{
            provide(key, provides[key]);
        });
    }
    if (created) callHook(created, instance, "c");
    function registerLifecycleHook(register, hook) {
        if ((0, _shared.isArray)(hook)) hook.forEach((_hook)=>register(_hook.bind(publicThis)));
        else if (hook) register(hook.bind(publicThis));
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if ((0, _shared.isArray)(expose)) {
        if (expose.length) {
            const exposed = instance.exposed || (instance.exposed = {});
            expose.forEach((key)=>{
                Object.defineProperty(exposed, key, {
                    get: ()=>publicThis[key],
                    set: (val)=>publicThis[key] = val
                });
            });
        } else if (!instance.exposed) instance.exposed = {};
    }
    if (render && instance.render === (0, _shared.NOOP)) instance.render = render;
    if (inheritAttrs != null) instance.inheritAttrs = inheritAttrs;
    if (components) instance.components = components;
    if (directives) instance.directives = directives;
    if (serverPrefetch) markAsyncBoundary(instance);
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = (0, _shared.NOOP)) {
    if ((0, _shared.isArray)(injectOptions)) injectOptions = normalizeInject(injectOptions);
    for(const key in injectOptions){
        const opt = injectOptions[key];
        let injected;
        if ((0, _shared.isObject)(opt)) {
            if ("default" in opt) injected = inject(opt.from || key, opt.default, true);
            else injected = inject(opt.from || key);
        } else injected = inject(opt);
        if ((0, _reactivity.isRef)(injected)) Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: ()=>injected.value,
            set: (v1)=>injected.value = v1
        });
        else ctx[key] = injected;
        checkDuplicateProperties("Inject" /* INJECT */ , key);
    }
}
function callHook(hook, instance, type) {
    callWithAsyncErrorHandling((0, _shared.isArray)(hook) ? hook.map((h)=>h.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
    let getter = key.includes(".") ? createPathGetter(publicThis, key) : ()=>publicThis[key];
    if ((0, _shared.isString)(raw)) {
        const handler = ctx[raw];
        if ((0, _shared.isFunction)(handler)) watch(getter, handler);
        else warn$1(`Invalid watch handler specified by key "${raw}"`, handler);
    } else if ((0, _shared.isFunction)(raw)) watch(getter, raw.bind(publicThis));
    else if ((0, _shared.isObject)(raw)) {
        if ((0, _shared.isArray)(raw)) raw.forEach((r)=>createWatcher(r, ctx, publicThis, key));
        else {
            const handler = (0, _shared.isFunction)(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
            if ((0, _shared.isFunction)(handler)) watch(getter, handler, raw);
            else warn$1(`Invalid watch handler specified by key "${raw.handler}"`, handler);
        }
    } else warn$1(`Invalid watch option: "${key}"`, raw);
}
function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins , extends: extendsOptions  } = base;
    const { mixins: globalMixins , optionsCache: cache , config: { optionMergeStrategies  }  } = instance.appContext;
    const cached = cache.get(base);
    let resolved;
    if (cached) resolved = cached;
    else if (!globalMixins.length && !mixins && !extendsOptions) resolved = base;
    else {
        resolved = {};
        if (globalMixins.length) globalMixins.forEach((m)=>mergeOptions(resolved, m, optionMergeStrategies, true));
        mergeOptions(resolved, base, optionMergeStrategies);
    }
    if ((0, _shared.isObject)(base)) cache.set(base, resolved);
    return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
    const { mixins , extends: extendsOptions  } = from;
    if (extendsOptions) mergeOptions(to, extendsOptions, strats, true);
    if (mixins) mixins.forEach((m)=>mergeOptions(to, m, strats, true));
    for(const key in from)if (asMixin && key === "expose") warn$1(`"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`);
    else {
        const strat = internalOptionMergeStrats[key] || strats && strats[key];
        to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
    return to;
}
const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeEmitsOrPropsOptions,
    emits: mergeEmitsOrPropsOptions,
    // objects
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    // lifecycle
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    // assets
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    // watch
    watch: mergeWatchOptions,
    // provide / inject
    provide: mergeDataFn,
    inject: mergeInject
};
function mergeDataFn(to, from) {
    if (!from) return to;
    if (!to) return from;
    return function mergedDataFn() {
        return (0, _shared.extend)((0, _shared.isFunction)(to) ? to.call(this, this) : to, (0, _shared.isFunction)(from) ? from.call(this, this) : from);
    };
}
function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
    if ((0, _shared.isArray)(raw)) {
        const res = {};
        for(let i = 0; i < raw.length; i++)res[raw[i]] = raw[i];
        return res;
    }
    return raw;
}
function mergeAsArray(to, from) {
    return to ? [
        ...new Set([].concat(to, from))
    ] : from;
}
function mergeObjectOptions(to, from) {
    return to ? (0, _shared.extend)(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
    if (to) {
        if ((0, _shared.isArray)(to) && (0, _shared.isArray)(from)) return [
            .../* @__PURE__ */ new Set([
                ...to,
                ...from
            ])
        ];
        return (0, _shared.extend)(/* @__PURE__ */ Object.create(null), normalizePropsOrEmits(to), normalizePropsOrEmits(from != null ? from : {}));
    } else return from;
}
function mergeWatchOptions(to, from) {
    if (!to) return from;
    if (!from) return to;
    const merged = (0, _shared.extend)(/* @__PURE__ */ Object.create(null), to);
    for(const key in from)merged[key] = mergeAsArray(to[key], from[key]);
    return merged;
}
function createAppContext() {
    return {
        app: null,
        config: {
            isNativeTag: (0, _shared.NO),
            performance: false,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: /* @__PURE__ */ Object.create(null),
        optionsCache: /* @__PURE__ */ new WeakMap(),
        propsCache: /* @__PURE__ */ new WeakMap(),
        emitsCache: /* @__PURE__ */ new WeakMap()
    };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
    return function createApp(rootComponent, rootProps = null) {
        if (!(0, _shared.isFunction)(rootComponent)) rootComponent = (0, _shared.extend)({}, rootComponent);
        if (rootProps != null && !(0, _shared.isObject)(rootProps)) {
            warn$1(`root props passed to app.mount() must be an object.`);
            rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = /* @__PURE__ */ new WeakSet();
        const pluginCleanupFns = [];
        let isMounted = false;
        const app = context.app = {
            _uid: uid$1++,
            _component: rootComponent,
            _props: rootProps,
            _container: null,
            _context: context,
            _instance: null,
            version,
            get config () {
                return context.config;
            },
            set config (v){
                warn$1(`app.config cannot be replaced. Modify individual options instead.`);
            },
            use (plugin, ...options) {
                if (installedPlugins.has(plugin)) warn$1(`Plugin has already been applied to target app.`);
                else if (plugin && (0, _shared.isFunction)(plugin.install)) {
                    installedPlugins.add(plugin);
                    plugin.install(app, ...options);
                } else if ((0, _shared.isFunction)(plugin)) {
                    installedPlugins.add(plugin);
                    plugin(app, ...options);
                } else warn$1(`A plugin must either be a function or an object with an "install" function.`);
                return app;
            },
            mixin (mixin) {
                if (__VUE_OPTIONS_API__) {
                    if (!context.mixins.includes(mixin)) context.mixins.push(mixin);
                    else warn$1("Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : ""));
                } else warn$1("Mixins are only available in builds supporting Options API");
                return app;
            },
            component (name, component) {
                validateComponentName(name, context.config);
                if (!component) return context.components[name];
                if (0, context.components[name]) warn$1(`Component "${name}" has already been registered in target app.`);
                context.components[name] = component;
                return app;
            },
            directive (name, directive) {
                validateDirectiveName(name);
                if (!directive) return context.directives[name];
                if (0, context.directives[name]) warn$1(`Directive "${name}" has already been registered in target app.`);
                context.directives[name] = directive;
                return app;
            },
            mount (rootContainer, isHydrate, namespace) {
                if (!isMounted) {
                    if (0, rootContainer.__vue_app__) warn$1(`There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`);
                    const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
                    vnode.appContext = context;
                    if (namespace === true) namespace = "svg";
                    else if (namespace === false) namespace = void 0;
                    context.reload = ()=>{
                        const cloned = cloneVNode(vnode);
                        cloned.el = null;
                        render(cloned, rootContainer, namespace);
                    };
                    if (isHydrate && hydrate) hydrate(vnode, rootContainer);
                    else render(vnode, rootContainer, namespace);
                    isMounted = true;
                    app._container = rootContainer;
                    rootContainer.__vue_app__ = app;
                    app._instance = vnode.component;
                    devtoolsInitApp(app, version);
                    return getComponentPublicInstance(vnode.component);
                } else warn$1(`App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``);
            },
            onUnmount (cleanupFn) {
                if (typeof cleanupFn !== "function") warn$1(`Expected function as first argument to app.onUnmount(), but got ${typeof cleanupFn}`);
                pluginCleanupFns.push(cleanupFn);
            },
            unmount () {
                if (isMounted) {
                    callWithAsyncErrorHandling(pluginCleanupFns, app._instance, 16);
                    render(null, app._container);
                    app._instance = null;
                    devtoolsUnmountApp(app);
                    delete app._container.__vue_app__;
                } else warn$1(`Cannot unmount an app that is not mounted.`);
            },
            provide (key, value) {
                if (key in context.provides) {
                    if ((0, _shared.hasOwn)(context.provides, key)) warn$1(`App already provides property with key "${String(key)}". It will be overwritten with the new value.`);
                    else warn$1(`App already provides property with key "${String(key)}" inherited from its parent element. It will be overwritten with the new value.`);
                }
                context.provides[key] = value;
                return app;
            },
            runWithContext (fn) {
                const lastApp = currentApp;
                currentApp = app;
                try {
                    return fn();
                } finally{
                    currentApp = lastApp;
                }
            }
        };
        return app;
    };
}
let currentApp = null;
function provide(key, value) {
    if (!currentInstance) warn$1(`provide() can only be used inside setup().`);
    else {
        let provides = currentInstance.provides;
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) provides = currentInstance.provides = Object.create(parentProvides);
        provides[key] = value;
    }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
    const instance = currentInstance || currentRenderingInstance;
    if (instance || currentApp) {
        let provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null || instance.ce ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
        if (provides && key in provides) return provides[key];
        else if (arguments.length > 1) return treatDefaultAsFactory && (0, _shared.isFunction)(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
        else warn$1(`injection "${String(key)}" not found.`);
    } else warn$1(`inject() can only be used inside setup() or functional components.`);
}
function hasInjectionContext() {
    return !!(currentInstance || currentRenderingInstance || currentApp);
}
const internalObjectProto = {};
const createInternalObject = ()=>Object.create(internalObjectProto);
const isInternalObject = (obj)=>Object.getPrototypeOf(obj) === internalObjectProto;
function initProps(instance, rawProps, isStateful, isSSR = false) {
    const props = {};
    const attrs = createInternalObject();
    instance.propsDefaults = /* @__PURE__ */ Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    for(const key in instance.propsOptions[0])if (!(key in props)) props[key] = void 0;
    validateProps(rawProps || {}, props, instance);
    if (isStateful) instance.props = isSSR ? props : (0, _reactivity.shallowReactive)(props);
    else if (!instance.type.props) instance.props = attrs;
    else instance.props = props;
    instance.attrs = attrs;
}
function isInHmrContext(instance) {
    while(instance){
        if (instance.type.__hmrId) return true;
        instance = instance.parent;
    }
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const { props , attrs , vnode: { patchFlag  }  } = instance;
    const rawCurrentProps = (0, _reactivity.toRaw)(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (// always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !isInHmrContext(instance) && (optimized || patchFlag > 0) && !(patchFlag & 16)) {
        if (patchFlag & 8) {
            const propsToUpdate = instance.vnode.dynamicProps;
            for(let i = 0; i < propsToUpdate.length; i++){
                let key = propsToUpdate[i];
                if (isEmitListener(instance.emitsOptions, key)) continue;
                const value = rawProps[key];
                if (options) {
                    if ((0, _shared.hasOwn)(attrs, key)) {
                        if (value !== attrs[key]) {
                            attrs[key] = value;
                            hasAttrsChanged = true;
                        }
                    } else {
                        const camelizedKey = (0, _shared.camelize)(key);
                        props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false);
                    }
                } else if (value !== attrs[key]) {
                    attrs[key] = value;
                    hasAttrsChanged = true;
                }
            }
        }
    } else {
        if (setFullProps(instance, rawProps, props, attrs)) hasAttrsChanged = true;
        let kebabKey;
        for(const key in rawCurrentProps)if (!rawProps || // for camelCase
        !(0, _shared.hasOwn)(rawProps, key) && // it's possible the original props was passed in as kebab-case
        // and converted to camelCase (#955)
        ((kebabKey = (0, _shared.hyphenate)(key)) === key || !(0, _shared.hasOwn)(rawProps, kebabKey))) {
            if (options) {
                if (rawPrevProps && // for camelCase
                (rawPrevProps[key] !== void 0 || // for kebab-case
                rawPrevProps[kebabKey] !== void 0)) props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance, true);
            } else delete props[key];
        }
        if (attrs !== rawCurrentProps) {
            for(const key in attrs)if (!rawProps || !(0, _shared.hasOwn)(rawProps, key) && true) {
                delete attrs[key];
                hasAttrsChanged = true;
            }
        }
    }
    if (hasAttrsChanged) (0, _reactivity.trigger)(instance.attrs, "set", "");
    validateProps(rawProps || {}, props, instance);
}
function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) for(let key in rawProps){
        if ((0, _shared.isReservedProp)(key)) continue;
        const value = rawProps[key];
        let camelKey;
        if (options && (0, _shared.hasOwn)(options, camelKey = (0, _shared.camelize)(key))) {
            if (!needCastKeys || !needCastKeys.includes(camelKey)) props[camelKey] = value;
            else (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        } else if (!isEmitListener(instance.emitsOptions, key)) {
            if (!(key in attrs) || value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
            }
        }
    }
    if (needCastKeys) {
        const rawCurrentProps = (0, _reactivity.toRaw)(props);
        const castValues = rawCastValues || (0, _shared.EMPTY_OBJ);
        for(let i = 0; i < needCastKeys.length; i++){
            const key = needCastKeys[i];
            props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !(0, _shared.hasOwn)(castValues, key));
        }
    }
    return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
        const hasDefault = (0, _shared.hasOwn)(opt, "default");
        if (hasDefault && value === void 0) {
            const defaultValue = opt.default;
            if (opt.type !== Function && !opt.skipFactory && (0, _shared.isFunction)(defaultValue)) {
                const { propsDefaults  } = instance;
                if (key in propsDefaults) value = propsDefaults[key];
                else {
                    const reset = setCurrentInstance(instance);
                    value = propsDefaults[key] = defaultValue.call(null, props);
                    reset();
                }
            } else value = defaultValue;
            if (instance.ce) instance.ce._setProp(key, value);
        }
        if (opt[0 /* shouldCast */ ]) {
            if (isAbsent && !hasDefault) value = false;
            else if (opt[1 /* shouldCastTrue */ ] && (value === "" || value === (0, _shared.hyphenate)(key))) value = true;
        }
    }
    return value;
}
const mixinPropsCache = /* @__PURE__ */ new WeakMap();
function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache = __VUE_OPTIONS_API__ && asMixin ? mixinPropsCache : appContext.propsCache;
    const cached = cache.get(comp);
    if (cached) return cached;
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !(0, _shared.isFunction)(comp)) {
        const extendProps = (raw2)=>{
            hasExtends = true;
            const [props, keys] = normalizePropsOptions(raw2, appContext, true);
            (0, _shared.extend)(normalized, props);
            if (keys) needCastKeys.push(...keys);
        };
        if (!asMixin && appContext.mixins.length) appContext.mixins.forEach(extendProps);
        if (comp.extends) extendProps(comp.extends);
        if (comp.mixins) comp.mixins.forEach(extendProps);
    }
    if (!raw && !hasExtends) {
        if ((0, _shared.isObject)(comp)) cache.set(comp, (0, _shared.EMPTY_ARR));
        return 0, _shared.EMPTY_ARR;
    }
    if ((0, _shared.isArray)(raw)) for(let i = 0; i < raw.length; i++){
        if (!(0, _shared.isString)(raw[i])) warn$1(`props must be strings when using array syntax.`, raw[i]);
        const normalizedKey = (0, _shared.camelize)(raw[i]);
        if (validatePropName(normalizedKey)) normalized[normalizedKey] = (0, _shared.EMPTY_OBJ);
    }
    else if (raw) {
        if (!(0, _shared.isObject)(raw)) warn$1(`invalid props options`, raw);
        for(const key in raw){
            const normalizedKey = (0, _shared.camelize)(key);
            if (validatePropName(normalizedKey)) {
                const opt = raw[key];
                const prop = normalized[normalizedKey] = (0, _shared.isArray)(opt) || (0, _shared.isFunction)(opt) ? {
                    type: opt
                } : (0, _shared.extend)({}, opt);
                const propType = prop.type;
                let shouldCast = false;
                let shouldCastTrue = true;
                if ((0, _shared.isArray)(propType)) for(let index = 0; index < propType.length; ++index){
                    const type = propType[index];
                    const typeName = (0, _shared.isFunction)(type) && type.name;
                    if (typeName === "Boolean") {
                        shouldCast = true;
                        break;
                    } else if (typeName === "String") shouldCastTrue = false;
                }
                else shouldCast = (0, _shared.isFunction)(propType) && propType.name === "Boolean";
                prop[0 /* shouldCast */ ] = shouldCast;
                prop[1 /* shouldCastTrue */ ] = shouldCastTrue;
                if (shouldCast || (0, _shared.hasOwn)(prop, "default")) needCastKeys.push(normalizedKey);
            }
        }
    }
    const res = [
        normalized,
        needCastKeys
    ];
    if ((0, _shared.isObject)(comp)) cache.set(comp, res);
    return res;
}
function validatePropName(key) {
    if (key[0] !== "$" && !(0, _shared.isReservedProp)(key)) return true;
    else warn$1(`Invalid prop name: "${key}" is a reserved property.`);
    return false;
}
function getType(ctor) {
    if (ctor === null) return "null";
    if (typeof ctor === "function") return ctor.name || "";
    else if (typeof ctor === "object") {
        const name = ctor.constructor && ctor.constructor.name;
        return name || "";
    }
    return "";
}
function validateProps(rawProps, props, instance) {
    const resolvedValues = (0, _reactivity.toRaw)(props);
    const options = instance.propsOptions[0];
    const camelizePropsKey = Object.keys(rawProps).map((key)=>(0, _shared.camelize)(key));
    for(const key in options){
        let opt = options[key];
        if (opt == null) continue;
        validateProp(key, resolvedValues[key], opt, (0, _reactivity.shallowReadonly)(resolvedValues), !camelizePropsKey.includes(key));
    }
}
function validateProp(name, value, prop, props, isAbsent) {
    const { type , required , validator , skipCheck  } = prop;
    if (required && isAbsent) {
        warn$1('Missing required prop: "' + name + '"');
        return;
    }
    if (value == null && !required) return;
    if (type != null && type !== true && !skipCheck) {
        let isValid = false;
        const types = (0, _shared.isArray)(type) ? type : [
            type
        ];
        const expectedTypes = [];
        for(let i = 0; i < types.length && !isValid; i++){
            const { valid , expectedType  } = assertType(value, types[i]);
            expectedTypes.push(expectedType || "");
            isValid = valid;
        }
        if (!isValid) {
            warn$1(getInvalidTypeMessage(name, value, expectedTypes));
            return;
        }
    }
    if (validator && !validator(value, props)) warn$1('Invalid prop: custom validator check failed for prop "' + name + '".');
}
const isSimpleType = /* @__PURE__ */ (0, _shared.makeMap)("String,Number,Boolean,Function,Symbol,BigInt");
function assertType(value, type) {
    let valid;
    const expectedType = getType(type);
    if (expectedType === "null") valid = value === null;
    else if (isSimpleType(expectedType)) {
        const t = typeof value;
        valid = t === expectedType.toLowerCase();
        if (!valid && t === "object") valid = value instanceof type;
    } else if (expectedType === "Object") valid = (0, _shared.isObject)(value);
    else if (expectedType === "Array") valid = (0, _shared.isArray)(value);
    else valid = value instanceof type;
    return {
        valid,
        expectedType
    };
}
function getInvalidTypeMessage(name, value, expectedTypes) {
    if (expectedTypes.length === 0) return `Prop type [] for prop "${name}" won't match anything. Did you mean to use type Array instead?`;
    let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map((0, _shared.capitalize)).join(" | ")}`;
    const expectedType = expectedTypes[0];
    const receivedType = (0, _shared.toRawType)(value);
    const expectedValue = styleValue(value, expectedType);
    const receivedValue = styleValue(value, receivedType);
    if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) message += ` with value ${expectedValue}`;
    message += `, got ${receivedType} `;
    if (isExplicable(receivedType)) message += `with value ${receivedValue}.`;
    return message;
}
function styleValue(value, type) {
    if (type === "String") return `"${value}"`;
    else if (type === "Number") return `${Number(value)}`;
    else return `${value}`;
}
function isExplicable(type) {
    const explicitTypes = [
        "string",
        "number",
        "boolean"
    ];
    return explicitTypes.some((elem)=>type.toLowerCase() === elem);
}
function isBoolean(...args) {
    return args.some((elem)=>elem.toLowerCase() === "boolean");
}
const isInternalKey = (key)=>key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value)=>(0, _shared.isArray)(value) ? value.map(normalizeVNode) : [
        normalizeVNode(value)
    ];
const normalizeSlot = (key, rawSlot, ctx)=>{
    if (rawSlot._n) return rawSlot;
    const normalized = withCtx((...args)=>{
        if (currentInstance && !(ctx === null && currentRenderingInstance) && !(ctx && ctx.root !== currentInstance.root)) warn$1(`Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`);
        return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance)=>{
    const ctx = rawSlots._ctx;
    for(const key in rawSlots){
        if (isInternalKey(key)) continue;
        const value = rawSlots[key];
        if ((0, _shared.isFunction)(value)) slots[key] = normalizeSlot(key, value, ctx);
        else if (value != null) {
            warn$1(`Non-function value encountered for slot "${key}". Prefer function slots for better performance.`);
            const normalized = normalizeSlotValue(value);
            slots[key] = ()=>normalized;
        }
    }
};
const normalizeVNodeSlots = (instance, children)=>{
    if (!isKeepAlive(instance.vnode) && true) warn$1(`Non-function value encountered for default slot. Prefer function slots for better performance.`);
    const normalized = normalizeSlotValue(children);
    instance.slots.default = ()=>normalized;
};
const assignSlots = (slots, children, optimized)=>{
    for(const key in children)if (optimized || !isInternalKey(key)) slots[key] = children[key];
};
const initSlots = (instance, children, optimized)=>{
    const slots = instance.slots = createInternalObject();
    if (instance.vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
            assignSlots(slots, children, optimized);
            if (optimized) (0, _shared.def)(slots, "_", type, true);
        } else normalizeObjectSlots(children, slots);
    } else if (children) normalizeVNodeSlots(instance, children);
};
const updateSlots = (instance, children, optimized)=>{
    const { vnode , slots  } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = (0, _shared.EMPTY_OBJ);
    if (vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
            if (isHmrUpdating) {
                assignSlots(slots, children, optimized);
                (0, _reactivity.trigger)(instance, "set", "$slots");
            } else if (optimized && type === 1) needDeletionCheck = false;
            else assignSlots(slots, children, optimized);
        } else {
            needDeletionCheck = !children.$stable;
            normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
    } else if (children) {
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = {
            default: 1
        };
    }
    if (needDeletionCheck) {
        for(const key in slots)if (!isInternalKey(key) && deletionComparisonTarget[key] == null) delete slots[key];
    }
};
let supported;
let perf;
function startMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) perf.mark(`vue-${type}-${instance.uid}`);
    devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());
}
function endMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
        const startTag = `vue-${type}-${instance.uid}`;
        const endTag = startTag + `:end`;
        perf.mark(endTag);
        perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
        perf.clearMarks(startTag);
        perf.clearMarks(endTag);
    }
    devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());
}
function isSupported() {
    if (supported !== void 0) return supported;
    if (typeof window !== "undefined" && window.performance) {
        supported = true;
        perf = window.performance;
    } else supported = false;
    return supported;
}
function initFeatureFlags() {
    const needWarn = [];
    if (typeof __VUE_OPTIONS_API__ !== "boolean") {
        needWarn.push(`__VUE_OPTIONS_API__`);
        (0, _shared.getGlobalThis)().__VUE_OPTIONS_API__ = true;
    }
    if (typeof __VUE_PROD_DEVTOOLS__ !== "boolean") {
        needWarn.push(`__VUE_PROD_DEVTOOLS__`);
        (0, _shared.getGlobalThis)().__VUE_PROD_DEVTOOLS__ = false;
    }
    if (typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ !== "boolean") {
        needWarn.push(`__VUE_PROD_HYDRATION_MISMATCH_DETAILS__`);
        (0, _shared.getGlobalThis)().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = false;
    }
    if (0, needWarn.length) {
        const multi = needWarn.length > 1;
        console.warn(`Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`);
    }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
    return baseCreateRenderer(options);
}
function createHydrationRenderer(options) {
    return baseCreateRenderer(options, createHydrationFunctions);
}
function baseCreateRenderer(options, createHydrationFns) {
    initFeatureFlags();
    const target = (0, _shared.getGlobalThis)();
    target.__VUE__ = true;
    setDevtoolsHook$1(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
    const { insert: hostInsert , remove: hostRemove , patchProp: hostPatchProp , createElement: hostCreateElement , createText: hostCreateText , createComment: hostCreateComment , setText: hostSetText , setElementText: hostSetElementText , parentNode: hostParentNode , nextSibling: hostNextSibling , setScopeId: hostSetScopeId = (0, _shared.NOOP) , insertStaticContent: hostInsertStaticContent  } = options;
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n2.dynamicChildren)=>{
        if (n1 === n2) return;
        if (n1 && !isSameVNodeType(n1, n2)) {
            anchor = getNextHostNode(n1);
            unmount(n1, parentComponent, parentSuspense, true);
            n1 = null;
        }
        if (n2.patchFlag === -2) {
            optimized = false;
            n2.dynamicChildren = null;
        }
        const { type , ref , shapeFlag  } = n2;
        switch(type){
            case Text:
                processText(n1, n2, container, anchor);
                break;
            case Comment:
                processCommentNode(n1, n2, container, anchor);
                break;
            case Static:
                if (n1 == null) mountStaticNode(n2, container, anchor, namespace);
                else patchStaticNode(n1, n2, container, namespace);
                break;
            case Fragment:
                processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                break;
            default:
                if (shapeFlag & 1) processElement(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                else if (shapeFlag & 6) processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                else if (shapeFlag & 64) type.process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals);
                else if (shapeFlag & 128) type.process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals);
                else warn$1("Invalid VNode type:", type, `(${typeof type})`);
        }
        if (ref != null && parentComponent) setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    };
    const processText = (n1, n2, container, anchor)=>{
        if (n1 == null) hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
        else {
            const el = n2.el = n1.el;
            if (n2.children !== n1.children) hostSetText(el, n2.children);
        }
    };
    const processCommentNode = (n1, n2, container, anchor)=>{
        if (n1 == null) hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
        else n2.el = n1.el;
    };
    const mountStaticNode = (n2, container, anchor, namespace)=>{
        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, namespace, n2.el, n2.anchor);
    };
    const patchStaticNode = (n1, n2, container, namespace)=>{
        if (n2.children !== n1.children) {
            const anchor = hostNextSibling(n1.anchor);
            removeStaticNode(n1);
            [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, namespace);
        } else {
            n2.el = n1.el;
            n2.anchor = n1.anchor;
        }
    };
    const moveStaticNode = ({ el , anchor  }, container, nextSibling)=>{
        let next;
        while(el && el !== anchor){
            next = hostNextSibling(el);
            hostInsert(el, container, nextSibling);
            el = next;
        }
        hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el , anchor  })=>{
        let next;
        while(el && el !== anchor){
            next = hostNextSibling(el);
            hostRemove(el);
            el = next;
        }
        hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)=>{
        if (n2.type === "svg") namespace = "svg";
        else if (n2.type === "math") namespace = "mathml";
        if (n1 == null) mountElement(n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
        else patchElement(n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)=>{
        let el;
        let vnodeHook;
        const { props , shapeFlag , transition , dirs  } = vnode;
        el = vnode.el = hostCreateElement(vnode.type, namespace, props && props.is, props);
        if (shapeFlag & 8) hostSetElementText(el, vnode.children);
        else if (shapeFlag & 16) mountChildren(vnode.children, el, null, parentComponent, parentSuspense, resolveChildrenNamespace(vnode, namespace), slotScopeIds, optimized);
        if (dirs) invokeDirectiveHook(vnode, null, parentComponent, "created");
        setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        if (props) {
            for(const key in props)if (key !== "value" && !(0, _shared.isReservedProp)(key)) hostPatchProp(el, key, null, props[key], namespace, parentComponent);
            if ("value" in props) hostPatchProp(el, "value", null, props.value, namespace);
            if (vnodeHook = props.onVnodeBeforeMount) invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        (0, _shared.def)(el, "__vnode", vnode, true);
        (0, _shared.def)(el, "__vueParentComponent", parentComponent, true);
        if (dirs) invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        const needCallTransitionHooks = needTransition(parentSuspense, transition);
        if (needCallTransitionHooks) transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) queuePostRenderEffect(()=>{
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent)=>{
        if (scopeId) hostSetScopeId(el, scopeId);
        if (slotScopeIds) for(let i = 0; i < slotScopeIds.length; i++)hostSetScopeId(el, slotScopeIds[i]);
        if (parentComponent) {
            let subTree = parentComponent.subTree;
            if (subTree.patchFlag > 0 && subTree.patchFlag & 2048) subTree = filterSingleRoot(subTree.children) || subTree;
            if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
                const parentVNode = parentComponent.vnode;
                setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
            }
        }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0)=>{
        for(let i = start; i < children.length; i++){
            const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
            patch(null, child, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
        }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)=>{
        const el = n2.el = n1.el;
        el.__vnode = n2;
        let { patchFlag , dynamicChildren , dirs  } = n2;
        patchFlag |= n1.patchFlag & 16;
        const oldProps = n1.props || (0, _shared.EMPTY_OBJ);
        const newProps = n2.props || (0, _shared.EMPTY_OBJ);
        let vnodeHook;
        parentComponent && toggleRecurse(parentComponent, false);
        if (vnodeHook = newProps.onVnodeBeforeUpdate) invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        if (dirs) invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
        parentComponent && toggleRecurse(parentComponent, true);
        if (isHmrUpdating) {
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
        }
        if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) hostSetElementText(el, "");
        if (dynamicChildren) {
            patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, resolveChildrenNamespace(n2, namespace), slotScopeIds);
            traverseStaticChildren(n1, n2);
        } else if (!optimized) patchChildren(n1, n2, el, null, parentComponent, parentSuspense, resolveChildrenNamespace(n2, namespace), slotScopeIds, false);
        if (patchFlag > 0) {
            if (patchFlag & 16) patchProps(el, oldProps, newProps, parentComponent, namespace);
            else {
                if (patchFlag & 2) {
                    if (oldProps.class !== newProps.class) hostPatchProp(el, "class", null, newProps.class, namespace);
                }
                if (patchFlag & 4) hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
                if (patchFlag & 8) {
                    const propsToUpdate = n2.dynamicProps;
                    for(let i = 0; i < propsToUpdate.length; i++){
                        const key = propsToUpdate[i];
                        const prev = oldProps[key];
                        const next = newProps[key];
                        if (next !== prev || key === "value") hostPatchProp(el, key, prev, next, namespace, parentComponent);
                    }
                }
            }
            if (patchFlag & 1) {
                if (n1.children !== n2.children) hostSetElementText(el, n2.children);
            }
        } else if (!optimized && dynamicChildren == null) patchProps(el, oldProps, newProps, parentComponent, namespace);
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) queuePostRenderEffect(()=>{
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
            dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
        }, parentSuspense);
    };
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds)=>{
        for(let i = 0; i < newChildren.length; i++){
            const oldVNode = oldChildren[i];
            const newVNode = newChildren[i];
            const container = // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
            // of the Fragment itself so it can move its children.
            (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
            // which also requires the correct parent container
            !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
            oldVNode.shapeFlag & 198) ? hostParentNode(oldVNode.el) : // In other cases, the parent container is not actually used so we
            // just pass the block element here to avoid a DOM parentNode call.
            fallbackContainer;
            patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, true);
        }
    };
    const patchProps = (el, oldProps, newProps, parentComponent, namespace)=>{
        if (oldProps !== newProps) {
            if (oldProps !== (0, _shared.EMPTY_OBJ)) {
                for(const key in oldProps)if (!(0, _shared.isReservedProp)(key) && !(key in newProps)) hostPatchProp(el, key, oldProps[key], null, namespace, parentComponent);
            }
            for(const key in newProps){
                if ((0, _shared.isReservedProp)(key)) continue;
                const next = newProps[key];
                const prev = oldProps[key];
                if (next !== prev && key !== "value") hostPatchProp(el, key, prev, next, namespace, parentComponent);
            }
            if ("value" in newProps) hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
        }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)=>{
        const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
        const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
        let { patchFlag , dynamicChildren , slotScopeIds: fragmentSlotScopeIds  } = n2;
        if (// #5523 dev root fragment may inherit directives
        isHmrUpdating || patchFlag & 2048) {
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
        }
        if (fragmentSlotScopeIds) slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        if (n1 == null) {
            hostInsert(fragmentStartAnchor, container, anchor);
            hostInsert(fragmentEndAnchor, container, anchor);
            mountChildren(// #10007
            // such fragment like `<></>` will be compiled into
            // a fragment which doesn't have a children.
            // In this case fallback to an empty array
            n2.children || [], container, fragmentEndAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
        } else if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
        // of renderSlot() with no valid children
        n1.dynamicChildren) {
            patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, namespace, slotScopeIds);
            traverseStaticChildren(n1, n2);
        } else patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)=>{
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
            if (n2.shapeFlag & 512) parentComponent.ctx.activate(n2, container, anchor, namespace, optimized);
            else mountComponent(n2, container, anchor, parentComponent, parentSuspense, namespace, optimized);
        } else updateComponent(n1, n2, optimized);
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized)=>{
        const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
        if (0, instance.type.__hmrId) registerHMR(instance);
        pushWarningContext(initialVNode);
        startMeasure(instance, `mount`);
        if (isKeepAlive(initialVNode)) instance.ctx.renderer = internals;
        startMeasure(instance, `init`);
        setupComponent(instance, false, optimized);
        endMeasure(instance, `init`);
        if (isHmrUpdating) initialVNode.el = null;
        if (instance.asyncDep) {
            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
            if (!initialVNode.el) {
                const placeholder = instance.subTree = createVNode(Comment);
                processCommentNode(null, placeholder, container, anchor);
            }
        } else setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, namespace, optimized);
        popWarningContext();
        endMeasure(instance, `mount`);
    };
    const updateComponent = (n1, n2, optimized)=>{
        const instance = n2.component = n1.component;
        if (shouldUpdateComponent(n1, n2, optimized)) {
            if (instance.asyncDep && !instance.asyncResolved) {
                pushWarningContext(n2);
                updateComponentPreRender(instance, n2, optimized);
                popWarningContext();
                return;
            } else {
                instance.next = n2;
                instance.update();
            }
        } else {
            n2.el = n1.el;
            instance.vnode = n2;
        }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized)=>{
        const componentUpdateFn = ()=>{
            if (!instance.isMounted) {
                let vnodeHook;
                const { el , props  } = initialVNode;
                const { bm , m , parent , root , type  } = instance;
                const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
                toggleRecurse(instance, false);
                if (bm) (0, _shared.invokeArrayFns)(bm);
                if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) invokeVNodeHook(vnodeHook, parent, initialVNode);
                toggleRecurse(instance, true);
                if (el && hydrateNode) {
                    const hydrateSubTree = ()=>{
                        startMeasure(instance, `render`);
                        instance.subTree = renderComponentRoot(instance);
                        endMeasure(instance, `render`);
                        startMeasure(instance, `hydrate`);
                        hydrateNode(el, instance.subTree, instance, parentSuspense, null);
                        endMeasure(instance, `hydrate`);
                    };
                    if (isAsyncWrapperVNode && type.__asyncHydrate) type.__asyncHydrate(el, instance, hydrateSubTree);
                    else hydrateSubTree();
                } else {
                    if (root.ce) root.ce._injectChildStyle(type);
                    startMeasure(instance, `render`);
                    const subTree = instance.subTree = renderComponentRoot(instance);
                    endMeasure(instance, `render`);
                    startMeasure(instance, `patch`);
                    patch(null, subTree, container, anchor, instance, parentSuspense, namespace);
                    endMeasure(instance, `patch`);
                    initialVNode.el = subTree.el;
                }
                if (m) queuePostRenderEffect(m, parentSuspense);
                if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
                    const scopedInitialVNode = initialVNode;
                    queuePostRenderEffect(()=>invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
                }
                if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) instance.a && queuePostRenderEffect(instance.a, parentSuspense);
                instance.isMounted = true;
                devtoolsComponentAdded(instance);
                initialVNode = container = anchor = null;
            } else {
                let { next , bu , u , parent , vnode  } = instance;
                {
                    const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
                    if (nonHydratedAsyncRoot) {
                        if (next) {
                            next.el = vnode.el;
                            updateComponentPreRender(instance, next, optimized);
                        }
                        nonHydratedAsyncRoot.asyncDep.then(()=>{
                            if (!instance.isUnmounted) componentUpdateFn();
                        });
                        return;
                    }
                }
                let originNext = next;
                let vnodeHook;
                pushWarningContext(next || instance.vnode);
                toggleRecurse(instance, false);
                if (next) {
                    next.el = vnode.el;
                    updateComponentPreRender(instance, next, optimized);
                } else next = vnode;
                if (bu) (0, _shared.invokeArrayFns)(bu);
                if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) invokeVNodeHook(vnodeHook, parent, next, vnode);
                toggleRecurse(instance, true);
                startMeasure(instance, `render`);
                const nextTree = renderComponentRoot(instance);
                endMeasure(instance, `render`);
                const prevTree = instance.subTree;
                instance.subTree = nextTree;
                startMeasure(instance, `patch`);
                patch(prevTree, nextTree, // parent may have changed if it's in a teleport
                hostParentNode(prevTree.el), // anchor may have changed if it's in a fragment
                getNextHostNode(prevTree), instance, parentSuspense, namespace);
                endMeasure(instance, `patch`);
                next.el = nextTree.el;
                if (originNext === null) updateHOCHostEl(instance, nextTree.el);
                if (u) queuePostRenderEffect(u, parentSuspense);
                if (vnodeHook = next.props && next.props.onVnodeUpdated) queuePostRenderEffect(()=>invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
                devtoolsComponentUpdated(instance);
                popWarningContext();
            }
        };
        instance.scope.on();
        const effect = instance.effect = new (0, _reactivity.ReactiveEffect)(componentUpdateFn);
        instance.scope.off();
        const update = instance.update = effect.run.bind(effect);
        const job = instance.job = effect.runIfDirty.bind(effect);
        job.i = instance;
        job.id = instance.uid;
        effect.scheduler = ()=>queueJob(job);
        toggleRecurse(instance, true);
        effect.onTrack = instance.rtc ? (e)=>(0, _shared.invokeArrayFns)(instance.rtc, e) : void 0;
        effect.onTrigger = instance.rtg ? (e)=>(0, _shared.invokeArrayFns)(instance.rtg, e) : void 0;
        update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized)=>{
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        (0, _reactivity.pauseTracking)();
        flushPreFlushCbs(instance);
        (0, _reactivity.resetTracking)();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false)=>{
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag , shapeFlag  } = n2;
        if (patchFlag > 0) {
            if (patchFlag & 128) {
                patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                return;
            } else if (patchFlag & 256) {
                patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                return;
            }
        }
        if (shapeFlag & 8) {
            if (prevShapeFlag & 16) unmountChildren(c1, parentComponent, parentSuspense);
            if (c2 !== c1) hostSetElementText(container, c2);
        } else if (prevShapeFlag & 16) {
            if (shapeFlag & 16) patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
            else unmountChildren(c1, parentComponent, parentSuspense, true);
        } else {
            if (prevShapeFlag & 8) hostSetElementText(container, "");
            if (shapeFlag & 16) mountChildren(c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
        }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)=>{
        c1 = c1 || (0, _shared.EMPTY_ARR);
        c2 = c2 || (0, _shared.EMPTY_ARR);
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for(i = 0; i < commonLength; i++){
            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
        }
        if (oldLength > newLength) unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
        else mountChildren(c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, commonLength);
    };
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)=>{
        let i = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1;
        let e2 = l2 - 1;
        while(i <= e1 && i <= e2){
            const n1 = c1[i];
            const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            if (isSameVNodeType(n1, n2)) patch(n1, n2, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
            else break;
            i++;
        }
        while(i <= e1 && i <= e2){
            const n1 = c1[e1];
            const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
            if (isSameVNodeType(n1, n2)) patch(n1, n2, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
            else break;
            e1--;
            e2--;
        }
        if (i > e1) {
            if (i <= e2) {
                const nextPos = e2 + 1;
                const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
                while(i <= e2){
                    patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                    i++;
                }
            }
        } else if (i > e2) while(i <= e1){
            unmount(c1[i], parentComponent, parentSuspense, true);
            i++;
        }
        else {
            const s1 = i;
            const s2 = i;
            const keyToNewIndexMap = /* @__PURE__ */ new Map();
            for(i = s2; i <= e2; i++){
                const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
                if (nextChild.key != null) {
                    if (keyToNewIndexMap.has(nextChild.key)) warn$1(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
                    keyToNewIndexMap.set(nextChild.key, i);
                }
            }
            let j;
            let patched = 0;
            const toBePatched = e2 - s2 + 1;
            let moved = false;
            let maxNewIndexSoFar = 0;
            const newIndexToOldIndexMap = new Array(toBePatched);
            for(i = 0; i < toBePatched; i++)newIndexToOldIndexMap[i] = 0;
            for(i = s1; i <= e1; i++){
                const prevChild = c1[i];
                if (patched >= toBePatched) {
                    unmount(prevChild, parentComponent, parentSuspense, true);
                    continue;
                }
                let newIndex;
                if (prevChild.key != null) newIndex = keyToNewIndexMap.get(prevChild.key);
                else {
                    for(j = s2; j <= e2; j++)if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                        newIndex = j;
                        break;
                    }
                }
                if (newIndex === void 0) unmount(prevChild, parentComponent, parentSuspense, true);
                else {
                    newIndexToOldIndexMap[newIndex - s2] = i + 1;
                    if (newIndex >= maxNewIndexSoFar) maxNewIndexSoFar = newIndex;
                    else moved = true;
                    patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                    patched++;
                }
            }
            const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : (0, _shared.EMPTY_ARR);
            j = increasingNewIndexSequence.length - 1;
            for(i = toBePatched - 1; i >= 0; i--){
                const nextIndex = s2 + i;
                const nextChild = c2[nextIndex];
                const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
                if (newIndexToOldIndexMap[i] === 0) patch(null, nextChild, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                else if (moved) {
                    if (j < 0 || i !== increasingNewIndexSequence[j]) move(nextChild, container, anchor, 2);
                    else j--;
                }
            }
        }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null)=>{
        const { el , type , transition , children , shapeFlag  } = vnode;
        if (shapeFlag & 6) {
            move(vnode.component.subTree, container, anchor, moveType);
            return;
        }
        if (shapeFlag & 128) {
            vnode.suspense.move(container, anchor, moveType);
            return;
        }
        if (shapeFlag & 64) {
            type.move(vnode, container, anchor, internals);
            return;
        }
        if (type === Fragment) {
            hostInsert(el, container, anchor);
            for(let i = 0; i < children.length; i++)move(children[i], container, anchor, moveType);
            hostInsert(vnode.anchor, container, anchor);
            return;
        }
        if (type === Static) {
            moveStaticNode(vnode, container, anchor);
            return;
        }
        const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
        if (needTransition2) {
            if (moveType === 0) {
                transition.beforeEnter(el);
                hostInsert(el, container, anchor);
                queuePostRenderEffect(()=>transition.enter(el), parentSuspense);
            } else {
                const { leave , delayLeave , afterLeave  } = transition;
                const remove2 = ()=>{
                    if (vnode.ctx.isUnmounted) hostRemove(el);
                    else hostInsert(el, container, anchor);
                };
                const performLeave = ()=>{
                    leave(el, ()=>{
                        remove2();
                        afterLeave && afterLeave();
                    });
                };
                if (delayLeave) delayLeave(el, remove2, performLeave);
                else performLeave();
            }
        } else hostInsert(el, container, anchor);
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false)=>{
        const { type , props , ref , children , dynamicChildren , shapeFlag , patchFlag , dirs , cacheIndex  } = vnode;
        if (patchFlag === -2) optimized = false;
        if (ref != null) {
            (0, _reactivity.pauseTracking)();
            setRef(ref, null, parentSuspense, vnode, true);
            (0, _reactivity.resetTracking)();
        }
        if (cacheIndex != null) parentComponent.renderCache[cacheIndex] = void 0;
        if (shapeFlag & 256) {
            parentComponent.ctx.deactivate(vnode);
            return;
        }
        const shouldInvokeDirs = shapeFlag & 1 && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) invokeVNodeHook(vnodeHook, parentComponent, vnode);
        if (shapeFlag & 6) unmountComponent(vnode.component, parentSuspense, doRemove);
        else {
            if (shapeFlag & 128) {
                vnode.suspense.unmount(parentSuspense, doRemove);
                return;
            }
            if (shouldInvokeDirs) invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
            if (shapeFlag & 64) vnode.type.remove(vnode, parentComponent, parentSuspense, internals, doRemove);
            else if (dynamicChildren && // #5154
            // when v-once is used inside a block, setBlockTracking(-1) marks the
            // parent block with hasOnce: true
            // so that it doesn't take the fast path during unmount - otherwise
            // components nested in v-once are never unmounted.
            !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
            (type !== Fragment || patchFlag > 0 && patchFlag & 64)) unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
            else if (type === Fragment && patchFlag & 384 || !optimized && shapeFlag & 16) unmountChildren(children, parentComponent, parentSuspense);
            if (doRemove) remove(vnode);
        }
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) queuePostRenderEffect(()=>{
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
        }, parentSuspense);
    };
    const remove = (vnode)=>{
        const { type , el , anchor , transition  } = vnode;
        if (type === Fragment) {
            if (vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) vnode.children.forEach((child)=>{
                if (child.type === Comment) hostRemove(child.el);
                else remove(child);
            });
            else removeFragment(el, anchor);
            return;
        }
        if (type === Static) {
            removeStaticNode(vnode);
            return;
        }
        const performRemove = ()=>{
            hostRemove(el);
            if (transition && !transition.persisted && transition.afterLeave) transition.afterLeave();
        };
        if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
            const { leave , delayLeave  } = transition;
            const performLeave = ()=>leave(el, performRemove);
            if (delayLeave) delayLeave(vnode.el, performRemove, performLeave);
            else performLeave();
        } else performRemove();
    };
    const removeFragment = (cur, end)=>{
        let next;
        while(cur !== end){
            next = hostNextSibling(cur);
            hostRemove(cur);
            cur = next;
        }
        hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove)=>{
        if (0, instance.type.__hmrId) unregisterHMR(instance);
        const { bum , scope , job , subTree , um , m , a , parent , slots: { __: slotCacheKeys  }  } = instance;
        invalidateMount(m);
        invalidateMount(a);
        if (bum) (0, _shared.invokeArrayFns)(bum);
        if (parent && (0, _shared.isArray)(slotCacheKeys)) slotCacheKeys.forEach((v1)=>{
            parent.renderCache[v1] = void 0;
        });
        scope.stop();
        if (job) {
            job.flags |= 8;
            unmount(subTree, instance, parentSuspense, doRemove);
        }
        if (um) queuePostRenderEffect(um, parentSuspense);
        queuePostRenderEffect(()=>{
            instance.isUnmounted = true;
        }, parentSuspense);
        if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
            parentSuspense.deps--;
            if (parentSuspense.deps === 0) parentSuspense.resolve();
        }
        devtoolsComponentRemoved(instance);
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0)=>{
        for(let i = start; i < children.length; i++)unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    };
    const getNextHostNode = (vnode)=>{
        if (vnode.shapeFlag & 6) return getNextHostNode(vnode.component.subTree);
        if (vnode.shapeFlag & 128) return vnode.suspense.next();
        const el = hostNextSibling(vnode.anchor || vnode.el);
        const teleportEnd = el && el[TeleportEndKey];
        return teleportEnd ? hostNextSibling(teleportEnd) : el;
    };
    let isFlushing = false;
    const render = (vnode, container, namespace)=>{
        if (vnode == null) {
            if (container._vnode) unmount(container._vnode, null, null, true);
        } else patch(container._vnode || null, vnode, container, null, null, null, namespace);
        container._vnode = vnode;
        if (!isFlushing) {
            isFlushing = true;
            flushPreFlushCbs();
            flushPostFlushCbs();
            isFlushing = false;
        }
    };
    const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
    };
    let hydrate;
    let hydrateNode;
    if (createHydrationFns) [hydrate, hydrateNode] = createHydrationFns(internals);
    return {
        render,
        hydrate,
        createApp: createAppAPI(render, hydrate)
    };
}
function resolveChildrenNamespace({ type , props  }, currentNamespace) {
    return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
}
function toggleRecurse({ effect , job  }, allowed) {
    if (allowed) {
        effect.flags |= 32;
        job.flags |= 4;
    } else {
        effect.flags &= -33;
        job.flags &= -5;
    }
}
function needTransition(parentSuspense, transition) {
    return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if ((0, _shared.isArray)(ch1) && (0, _shared.isArray)(ch2)) for(let i = 0; i < ch1.length; i++){
        const c1 = ch1[i];
        let c2 = ch2[i];
        if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
            if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
                c2 = ch2[i] = cloneIfMounted(ch2[i]);
                c2.el = c1.el;
            }
            if (!shallow && c2.patchFlag !== -2) traverseStaticChildren(c1, c2);
        }
        if (c2.type === Text) c2.el = c1.el;
        if (c2.type === Comment && !c2.el) c2.el = c1.el;
        c2.el && (c2.el.__vnode = c2);
    }
}
function getSequence(arr) {
    const p = arr.slice();
    const result = [
        0
    ];
    let i, j, u, v1, c;
    const len = arr.length;
    for(i = 0; i < len; i++){
        const arrI = arr[i];
        if (arrI !== 0) {
            j = result[result.length - 1];
            if (arr[j] < arrI) {
                p[i] = j;
                result.push(i);
                continue;
            }
            u = 0;
            v1 = result.length - 1;
            while(u < v1){
                c = u + v1 >> 1;
                if (arr[result[c]] < arrI) u = c + 1;
                else v1 = c;
            }
            if (arrI < arr[result[u]]) {
                if (u > 0) p[i] = result[u - 1];
                result[u] = i;
            }
        }
    }
    u = result.length;
    v1 = result[u - 1];
    while(u-- > 0){
        result[u] = v1;
        v1 = p[v1];
    }
    return result;
}
function locateNonHydratedAsyncRoot(instance) {
    const subComponent = instance.subTree.component;
    if (subComponent) {
        if (subComponent.asyncDep && !subComponent.asyncResolved) return subComponent;
        else return locateNonHydratedAsyncRoot(subComponent);
    }
}
function invalidateMount(hooks) {
    if (hooks) for(let i = 0; i < hooks.length; i++)hooks[i].flags |= 8;
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = ()=>{
    {
        const ctx = inject(ssrContextKey);
        if (!ctx) warn$1(`Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`);
        return ctx;
    }
};
function watchEffect(effect, options) {
    return doWatch(effect, null, options);
}
function watchPostEffect(effect, options) {
    return doWatch(effect, null, (0, _shared.extend)({}, options, {
        flush: "post"
    }));
}
function watchSyncEffect(effect, options) {
    return doWatch(effect, null, (0, _shared.extend)({}, options, {
        flush: "sync"
    }));
}
function watch(source, cb, options) {
    if (!(0, _shared.isFunction)(cb)) warn$1(`\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`);
    return doWatch(source, cb, options);
}
function doWatch(source, cb, options = (0, _shared.EMPTY_OBJ)) {
    const { immediate , deep , flush , once  } = options;
    if (!cb) {
        if (immediate !== void 0) warn$1(`watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`);
        if (deep !== void 0) warn$1(`watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`);
        if (once !== void 0) warn$1(`watch() "once" option is only respected when using the watch(source, callback, options?) signature.`);
    }
    const baseWatchOptions = (0, _shared.extend)({}, options);
    baseWatchOptions.onWarn = warn$1;
    const runsImmediately = cb && immediate || !cb && flush !== "post";
    let ssrCleanup;
    if (isInSSRComponentSetup) {
        if (flush === "sync") {
            const ctx = useSSRContext();
            ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
        } else if (!runsImmediately) {
            const watchStopHandle = ()=>{};
            watchStopHandle.stop = (0, _shared.NOOP);
            watchStopHandle.resume = (0, _shared.NOOP);
            watchStopHandle.pause = (0, _shared.NOOP);
            return watchStopHandle;
        }
    }
    const instance = currentInstance;
    baseWatchOptions.call = (fn, type, args)=>callWithAsyncErrorHandling(fn, instance, type, args);
    let isPre = false;
    if (flush === "post") baseWatchOptions.scheduler = (job)=>{
        queuePostRenderEffect(job, instance && instance.suspense);
    };
    else if (flush !== "sync") {
        isPre = true;
        baseWatchOptions.scheduler = (job, isFirstRun)=>{
            if (isFirstRun) job();
            else queueJob(job);
        };
    }
    baseWatchOptions.augmentJob = (job)=>{
        if (cb) job.flags |= 4;
        if (isPre) {
            job.flags |= 2;
            if (instance) {
                job.id = instance.uid;
                job.i = instance;
            }
        }
    };
    const watchHandle = (0, _reactivity.watch)(source, cb, baseWatchOptions);
    if (isInSSRComponentSetup) {
        if (ssrCleanup) ssrCleanup.push(watchHandle);
        else if (runsImmediately) watchHandle();
    }
    return watchHandle;
}
function instanceWatch(source, value, options) {
    const publicThis = this.proxy;
    const getter = (0, _shared.isString)(source) ? source.includes(".") ? createPathGetter(publicThis, source) : ()=>publicThis[source] : source.bind(publicThis, publicThis);
    let cb;
    if ((0, _shared.isFunction)(value)) cb = value;
    else {
        cb = value.handler;
        options = value;
    }
    const reset = setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    reset();
    return res;
}
function createPathGetter(ctx, path) {
    const segments = path.split(".");
    return ()=>{
        let cur = ctx;
        for(let i = 0; i < segments.length && cur; i++)cur = cur[segments[i]];
        return cur;
    };
}
function useModel(props, name, options = (0, _shared.EMPTY_OBJ)) {
    const i = getCurrentInstance();
    if (!i) {
        warn$1(`useModel() called without active instance.`);
        return (0, _reactivity.ref)();
    }
    const camelizedName = (0, _shared.camelize)(name);
    if (!i.propsOptions[0][camelizedName]) {
        warn$1(`useModel() called with prop "${name}" which is not declared.`);
        return (0, _reactivity.ref)();
    }
    const hyphenatedName = (0, _shared.hyphenate)(name);
    const modifiers = getModelModifiers(props, camelizedName);
    const res = (0, _reactivity.customRef)((track, trigger)=>{
        let localValue;
        let prevSetValue = (0, _shared.EMPTY_OBJ);
        let prevEmittedValue;
        watchSyncEffect(()=>{
            const propValue = props[camelizedName];
            if ((0, _shared.hasChanged)(localValue, propValue)) {
                localValue = propValue;
                trigger();
            }
        });
        return {
            get () {
                track();
                return options.get ? options.get(localValue) : localValue;
            },
            set (value) {
                const emittedValue = options.set ? options.set(value) : value;
                if (!(0, _shared.hasChanged)(emittedValue, localValue) && !(prevSetValue !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasChanged)(value, prevSetValue))) return;
                const rawProps = i.vnode.props;
                if (!(rawProps && // check if parent has passed v-model
                (name in rawProps || camelizedName in rawProps || hyphenatedName in rawProps) && (`onUpdate:${name}` in rawProps || `onUpdate:${camelizedName}` in rawProps || `onUpdate:${hyphenatedName}` in rawProps))) {
                    localValue = value;
                    trigger();
                }
                i.emit(`update:${name}`, emittedValue);
                if ((0, _shared.hasChanged)(value, emittedValue) && (0, _shared.hasChanged)(value, prevSetValue) && !(0, _shared.hasChanged)(emittedValue, prevEmittedValue)) trigger();
                prevSetValue = value;
                prevEmittedValue = emittedValue;
            }
        };
    });
    res[Symbol.iterator] = ()=>{
        let i2 = 0;
        return {
            next () {
                if (i2 < 2) return {
                    value: i2++ ? modifiers || (0, _shared.EMPTY_OBJ) : res,
                    done: false
                };
                else return {
                    done: true
                };
            }
        };
    };
    return res;
}
const getModelModifiers = (props, modelName)=>{
    return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${(0, _shared.camelize)(modelName)}Modifiers`] || props[`${(0, _shared.hyphenate)(modelName)}Modifiers`];
};
function emit(instance, event, ...rawArgs) {
    if (instance.isUnmounted) return;
    const props = instance.vnode.props || (0, _shared.EMPTY_OBJ);
    {
        const { emitsOptions , propsOptions: [propsOptions]  } = instance;
        if (emitsOptions) {
            if (!(event in emitsOptions) && true) {
                if (!propsOptions || !((0, _shared.toHandlerKey)((0, _shared.camelize)(event)) in propsOptions)) warn$1(`Component emitted event "${event}" but it is neither declared in the emits option nor as an "${(0, _shared.toHandlerKey)((0, _shared.camelize)(event))}" prop.`);
            } else {
                const validator = emitsOptions[event];
                if ((0, _shared.isFunction)(validator)) {
                    const isValid = validator(...rawArgs);
                    if (!isValid) warn$1(`Invalid event arguments: event validation failed for event "${event}".`);
                }
            }
        }
    }
    let args = rawArgs;
    const isModelListener = event.startsWith("update:");
    const modifiers = isModelListener && getModelModifiers(props, event.slice(7));
    if (modifiers) {
        if (modifiers.trim) args = rawArgs.map((a)=>(0, _shared.isString)(a) ? a.trim() : a);
        if (modifiers.number) args = rawArgs.map((0, _shared.looseToNumber));
    }
    devtoolsComponentEmit(instance, event, args);
    {
        const lowerCaseEvent = event.toLowerCase();
        if (lowerCaseEvent !== event && props[(0, _shared.toHandlerKey)(lowerCaseEvent)]) warn$1(`Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(instance, instance.type)} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${(0, _shared.hyphenate)(event)}" instead of "${event}".`);
    }
    let handlerName;
    let handler = props[handlerName = (0, _shared.toHandlerKey)(event)] || // also try camelCase event handler (#2249)
    props[handlerName = (0, _shared.toHandlerKey)((0, _shared.camelize)(event))];
    if (!handler && isModelListener) handler = props[handlerName = (0, _shared.toHandlerKey)((0, _shared.hyphenate)(event))];
    if (handler) callWithAsyncErrorHandling(handler, instance, 6, args);
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
        if (!instance.emitted) instance.emitted = {};
        else if (instance.emitted[handlerName]) return;
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(onceHandler, instance, 6, args);
    }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.emitsCache;
    const cached = cache.get(comp);
    if (cached !== void 0) return cached;
    const raw = comp.emits;
    let normalized = {};
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !(0, _shared.isFunction)(comp)) {
        const extendEmits = (raw2)=>{
            const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
            if (normalizedFromExtend) {
                hasExtends = true;
                (0, _shared.extend)(normalized, normalizedFromExtend);
            }
        };
        if (!asMixin && appContext.mixins.length) appContext.mixins.forEach(extendEmits);
        if (comp.extends) extendEmits(comp.extends);
        if (comp.mixins) comp.mixins.forEach(extendEmits);
    }
    if (!raw && !hasExtends) {
        if ((0, _shared.isObject)(comp)) cache.set(comp, null);
        return null;
    }
    if ((0, _shared.isArray)(raw)) raw.forEach((key)=>normalized[key] = null);
    else (0, _shared.extend)(normalized, raw);
    if ((0, _shared.isObject)(comp)) cache.set(comp, normalized);
    return normalized;
}
function isEmitListener(options, key) {
    if (!options || !(0, _shared.isOn)(key)) return false;
    key = key.slice(2).replace(/Once$/, "");
    return (0, _shared.hasOwn)(options, key[0].toLowerCase() + key.slice(1)) || (0, _shared.hasOwn)(options, (0, _shared.hyphenate)(key)) || (0, _shared.hasOwn)(options, key);
}
let accessedAttrs = false;
function markAttrsAccessed() {
    accessedAttrs = true;
}
function renderComponentRoot(instance) {
    const { type: Component , vnode , proxy , withProxy , propsOptions: [propsOptions] , slots , attrs , emit , render , renderCache , props , data , setupState , ctx , inheritAttrs  } = instance;
    const prev = setCurrentRenderingInstance(instance);
    let result;
    let fallthroughAttrs;
    accessedAttrs = false;
    try {
        if (vnode.shapeFlag & 4) {
            const proxyToUse = withProxy || proxy;
            const thisProxy = (0, setupState.__isScriptSetup) ? new Proxy(proxyToUse, {
                get (target, key, receiver) {
                    warn$1(`Property '${String(key)}' was accessed via 'this'. Avoid using 'this' in templates.`);
                    return Reflect.get(target, key, receiver);
                }
            }) : proxyToUse;
            result = normalizeVNode(render.call(thisProxy, proxyToUse, renderCache, (0, _reactivity.shallowReadonly)(props), setupState, data, ctx));
            fallthroughAttrs = attrs;
        } else {
            const render2 = Component;
            if (attrs === props) markAttrsAccessed();
            result = normalizeVNode(render2.length > 1 ? render2((0, _reactivity.shallowReadonly)(props), {
                get attrs () {
                    markAttrsAccessed();
                    return (0, _reactivity.shallowReadonly)(attrs);
                },
                slots,
                emit
            }) : render2((0, _reactivity.shallowReadonly)(props), null));
            fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
        }
    } catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1);
        result = createVNode(Comment);
    }
    let root = result;
    let setRoot = void 0;
    if (result.patchFlag > 0 && result.patchFlag & 2048) [root, setRoot] = getChildRoot(result);
    if (fallthroughAttrs && inheritAttrs !== false) {
        const keys = Object.keys(fallthroughAttrs);
        const { shapeFlag  } = root;
        if (keys.length) {
            if (shapeFlag & 7) {
                if (propsOptions && keys.some((0, _shared.isModelListener))) fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
                root = cloneVNode(root, fallthroughAttrs, false, true);
            } else if (!accessedAttrs && root.type !== Comment) {
                const allAttrs = Object.keys(attrs);
                const eventAttrs = [];
                const extraAttrs = [];
                for(let i = 0, l = allAttrs.length; i < l; i++){
                    const key = allAttrs[i];
                    if ((0, _shared.isOn)(key)) {
                        if (!(0, _shared.isModelListener)(key)) eventAttrs.push(key[2].toLowerCase() + key.slice(3));
                    } else extraAttrs.push(key);
                }
                if (extraAttrs.length) warn$1(`Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes.`);
                if (eventAttrs.length) warn$1(`Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`);
            }
        }
    }
    if (vnode.dirs) {
        if (!isElementRoot(root)) warn$1(`Runtime directive used on component with non-element root node. The directives will not function as intended.`);
        root = cloneVNode(root, null, false, true);
        root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    if (vnode.transition) {
        if (!isElementRoot(root)) warn$1(`Component inside <Transition> renders non-element root node that cannot be animated.`);
        setTransitionHooks(root, vnode.transition);
    }
    if (setRoot) setRoot(root);
    else result = root;
    setCurrentRenderingInstance(prev);
    return result;
}
const getChildRoot = (vnode)=>{
    const rawChildren = vnode.children;
    const dynamicChildren = vnode.dynamicChildren;
    const childRoot = filterSingleRoot(rawChildren, false);
    if (!childRoot) return [
        vnode,
        void 0
    ];
    else if (childRoot.patchFlag > 0 && childRoot.patchFlag & 2048) return getChildRoot(childRoot);
    const index = rawChildren.indexOf(childRoot);
    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
    const setRoot = (updatedRoot)=>{
        rawChildren[index] = updatedRoot;
        if (dynamicChildren) {
            if (dynamicIndex > -1) dynamicChildren[dynamicIndex] = updatedRoot;
            else if (updatedRoot.patchFlag > 0) vnode.dynamicChildren = [
                ...dynamicChildren,
                updatedRoot
            ];
        }
    };
    return [
        normalizeVNode(childRoot),
        setRoot
    ];
};
function filterSingleRoot(children, recurse = true) {
    let singleRoot;
    for(let i = 0; i < children.length; i++){
        const child = children[i];
        if (isVNode(child)) {
            if (child.type !== Comment || child.children === "v-if") {
                if (singleRoot) return;
                else {
                    singleRoot = child;
                    if (recurse && singleRoot.patchFlag > 0 && singleRoot.patchFlag & 2048) return filterSingleRoot(singleRoot.children);
                }
            }
        } else return;
    }
    return singleRoot;
}
const getFunctionalFallthrough = (attrs)=>{
    let res;
    for(const key in attrs)if (key === "class" || key === "style" || (0, _shared.isOn)(key)) (res || (res = {}))[key] = attrs[key];
    return res;
};
const filterModelListeners = (attrs, props)=>{
    const res = {};
    for(const key in attrs)if (!(0, _shared.isModelListener)(key) || !(key.slice(9) in props)) res[key] = attrs[key];
    return res;
};
const isElementRoot = (vnode)=>{
    return vnode.shapeFlag & 7 || vnode.type === Comment;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps , children: prevChildren , component  } = prevVNode;
    const { props: nextProps , children: nextChildren , patchFlag  } = nextVNode;
    const emits = component.emitsOptions;
    if ((prevChildren || nextChildren) && isHmrUpdating) return true;
    if (nextVNode.dirs || nextVNode.transition) return true;
    if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024) return true;
        if (patchFlag & 16) {
            if (!prevProps) return !!nextProps;
            return hasPropsChanged(prevProps, nextProps, emits);
        } else if (patchFlag & 8) {
            const dynamicProps = nextVNode.dynamicProps;
            for(let i = 0; i < dynamicProps.length; i++){
                const key = dynamicProps[i];
                if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) return true;
            }
        }
    } else {
        if (prevChildren || nextChildren) {
            if (!nextChildren || !nextChildren.$stable) return true;
        }
        if (prevProps === nextProps) return false;
        if (!prevProps) return !!nextProps;
        if (!nextProps) return true;
        return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) return true;
    for(let i = 0; i < nextKeys.length; i++){
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) return true;
    }
    return false;
}
function updateHOCHostEl({ vnode , parent  }, el) {
    while(parent){
        const root = parent.subTree;
        if (root.suspense && root.suspense.activeBranch === vnode) root.el = vnode.el;
        if (root === vnode) {
            (vnode = parent.vnode).el = el;
            parent = parent.parent;
        } else break;
    }
}
const isSuspense = (type)=>type.__isSuspense;
let suspenseId = 0;
const SuspenseImpl = {
    name: "Suspense",
    // In order to make Suspense tree-shakable, we need to avoid importing it
    // directly in the renderer. The renderer checks for the __isSuspense flag
    // on a vnode's type and calls the `process` method, passing in renderer
    // internals.
    __isSuspense: true,
    process (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
        if (n1 == null) mountSuspense(n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals);
        else {
            if (parentSuspense && parentSuspense.deps > 0 && !n1.suspense.isInFallback) {
                n2.suspense = n1.suspense;
                n2.suspense.vnode = n2;
                n2.el = n1.el;
                return;
            }
            patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, rendererInternals);
        }
    },
    hydrate: hydrateSuspense,
    normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl;
function triggerEvent(vnode, name) {
    const eventListener = vnode.props && vnode.props[name];
    if ((0, _shared.isFunction)(eventListener)) eventListener();
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
    const { p: patch , o: { createElement  }  } = rendererInternals;
    const hiddenContainer = createElement("div");
    const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals);
    patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, namespace, slotScopeIds);
    if (suspense.deps > 0) {
        triggerEvent(vnode, "onPending");
        triggerEvent(vnode, "onFallback");
        patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
        namespace, slotScopeIds);
        setActiveBranch(suspense, vnode.ssFallback);
    } else suspense.resolve(false, true);
}
function patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, { p: patch , um: unmount , o: { createElement  }  }) {
    const suspense = n2.suspense = n1.suspense;
    suspense.vnode = n2;
    n2.el = n1.el;
    const newBranch = n2.ssContent;
    const newFallback = n2.ssFallback;
    const { activeBranch , pendingBranch , isInFallback , isHydrating  } = suspense;
    if (pendingBranch) {
        suspense.pendingBranch = newBranch;
        if (isSameVNodeType(newBranch, pendingBranch)) {
            patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, namespace, slotScopeIds, optimized);
            if (suspense.deps <= 0) suspense.resolve();
            else if (isInFallback) {
                if (!isHydrating) {
                    patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                    namespace, slotScopeIds, optimized);
                    setActiveBranch(suspense, newFallback);
                }
            }
        } else {
            suspense.pendingId = suspenseId++;
            if (isHydrating) {
                suspense.isHydrating = false;
                suspense.activeBranch = pendingBranch;
            } else unmount(pendingBranch, parentComponent, suspense);
            suspense.deps = 0;
            suspense.effects.length = 0;
            suspense.hiddenContainer = createElement("div");
            if (isInFallback) {
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, namespace, slotScopeIds, optimized);
                if (suspense.deps <= 0) suspense.resolve();
                else {
                    patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                    namespace, slotScopeIds, optimized);
                    setActiveBranch(suspense, newFallback);
                }
            } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
                patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, namespace, slotScopeIds, optimized);
                suspense.resolve(true);
            } else {
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, namespace, slotScopeIds, optimized);
                if (suspense.deps <= 0) suspense.resolve();
            }
        }
    } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, namespace, slotScopeIds, optimized);
        setActiveBranch(suspense, newBranch);
    } else {
        triggerEvent(n2, "onPending");
        suspense.pendingBranch = newBranch;
        if (newBranch.shapeFlag & 512) suspense.pendingId = newBranch.component.suspenseId;
        else suspense.pendingId = suspenseId++;
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, namespace, slotScopeIds, optimized);
        if (suspense.deps <= 0) suspense.resolve();
        else {
            const { timeout , pendingId  } = suspense;
            if (timeout > 0) setTimeout(()=>{
                if (suspense.pendingId === pendingId) suspense.fallback(newFallback);
            }, timeout);
            else if (timeout === 0) suspense.fallback(newFallback);
        }
    }
}
let hasWarned = false;
function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
    if (!hasWarned) {
        hasWarned = true;
        console[console.info ? "info" : "log"](`<Suspense> is an experimental feature and its API will likely change.`);
    }
    const { p: patch , m: move , um: unmount , n: next , o: { parentNode , remove  }  } = rendererInternals;
    let parentSuspenseId;
    const isSuspensible = isVNodeSuspensible(vnode);
    if (isSuspensible) {
        if (parentSuspense && parentSuspense.pendingBranch) {
            parentSuspenseId = parentSuspense.pendingId;
            parentSuspense.deps++;
        }
    }
    const timeout = vnode.props ? (0, _shared.toNumber)(vnode.props.timeout) : void 0;
    assertNumber(timeout, `Suspense timeout`);
    const initialAnchor = anchor;
    const suspense = {
        vnode,
        parent: parentSuspense,
        parentComponent,
        namespace,
        container,
        hiddenContainer,
        deps: 0,
        pendingId: suspenseId++,
        timeout: typeof timeout === "number" ? timeout : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: !isHydrating,
        isHydrating,
        isUnmounted: false,
        effects: [],
        resolve (resume = false, sync = false) {
            if (!resume && !suspense.pendingBranch) throw new Error(`suspense.resolve() is called without a pending branch.`);
            if (suspense.isUnmounted) throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);
            const { vnode: vnode2 , activeBranch , pendingBranch , pendingId , effects , parentComponent: parentComponent2 , container: container2  } = suspense;
            let delayEnter = false;
            if (suspense.isHydrating) suspense.isHydrating = false;
            else if (!resume) {
                delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
                if (delayEnter) activeBranch.transition.afterLeave = ()=>{
                    if (pendingId === suspense.pendingId) {
                        move(pendingBranch, container2, anchor === initialAnchor ? next(activeBranch) : anchor, 0);
                        queuePostFlushCb(effects);
                    }
                };
                if (activeBranch) {
                    if (parentNode(activeBranch.el) === container2) anchor = next(activeBranch);
                    unmount(activeBranch, parentComponent2, suspense, true);
                }
                if (!delayEnter) move(pendingBranch, container2, anchor, 0);
            }
            setActiveBranch(suspense, pendingBranch);
            suspense.pendingBranch = null;
            suspense.isInFallback = false;
            let parent = suspense.parent;
            let hasUnresolvedAncestor = false;
            while(parent){
                if (parent.pendingBranch) {
                    parent.effects.push(...effects);
                    hasUnresolvedAncestor = true;
                    break;
                }
                parent = parent.parent;
            }
            if (!hasUnresolvedAncestor && !delayEnter) queuePostFlushCb(effects);
            suspense.effects = [];
            if (isSuspensible) {
                if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
                    parentSuspense.deps--;
                    if (parentSuspense.deps === 0 && !sync) parentSuspense.resolve();
                }
            }
            triggerEvent(vnode2, "onResolve");
        },
        fallback (fallbackVNode) {
            if (!suspense.pendingBranch) return;
            const { vnode: vnode2 , activeBranch , parentComponent: parentComponent2 , container: container2 , namespace: namespace2  } = suspense;
            triggerEvent(vnode2, "onFallback");
            const anchor2 = next(activeBranch);
            const mountFallback = ()=>{
                if (!suspense.isInFallback) return;
                patch(null, fallbackVNode, container2, anchor2, parentComponent2, null, // fallback tree will not have suspense context
                namespace2, slotScopeIds, optimized);
                setActiveBranch(suspense, fallbackVNode);
            };
            const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
            if (delayEnter) activeBranch.transition.afterLeave = mountFallback;
            suspense.isInFallback = true;
            unmount(activeBranch, parentComponent2, null, // no suspense so unmount hooks fire now
            true);
            if (!delayEnter) mountFallback();
        },
        move (container2, anchor2, type) {
            suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
            suspense.container = container2;
        },
        next () {
            return suspense.activeBranch && next(suspense.activeBranch);
        },
        registerDep (instance, setupRenderEffect, optimized2) {
            const isInPendingSuspense = !!suspense.pendingBranch;
            if (isInPendingSuspense) suspense.deps++;
            const hydratedEl = instance.vnode.el;
            instance.asyncDep.catch((err)=>{
                handleError(err, instance, 0);
            }).then((asyncSetupResult)=>{
                if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) return;
                instance.asyncResolved = true;
                const { vnode: vnode2  } = instance;
                pushWarningContext(vnode2);
                handleSetupResult(instance, asyncSetupResult, false);
                if (hydratedEl) vnode2.el = hydratedEl;
                const placeholder = !hydratedEl && instance.subTree.el;
                setupRenderEffect(instance, vnode2, // component may have been moved before resolve.
                // if this is not a hydration, instance.subTree will be the comment
                // placeholder.
                parentNode(hydratedEl || instance.subTree.el), // anchor will not be used if this is hydration, so only need to
                // consider the comment placeholder case.
                hydratedEl ? null : next(instance.subTree), suspense, namespace, optimized2);
                if (placeholder) remove(placeholder);
                updateHOCHostEl(instance, vnode2.el);
                popWarningContext();
                if (isInPendingSuspense && --suspense.deps === 0) suspense.resolve();
            });
        },
        unmount (parentSuspense2, doRemove) {
            suspense.isUnmounted = true;
            if (suspense.activeBranch) unmount(suspense.activeBranch, parentComponent, parentSuspense2, doRemove);
            if (suspense.pendingBranch) unmount(suspense.pendingBranch, parentComponent, parentSuspense2, doRemove);
        }
    };
    return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals, hydrateNode) {
    const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, // eslint-disable-next-line no-restricted-globals
    document.createElement("div"), null, namespace, slotScopeIds, optimized, rendererInternals, true);
    const result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);
    if (suspense.deps === 0) suspense.resolve(false, true);
    return result;
}
function normalizeSuspenseChildren(vnode) {
    const { shapeFlag , children  } = vnode;
    const isSlotChildren = shapeFlag & 32;
    vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
    vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
    let block;
    if ((0, _shared.isFunction)(s)) {
        const trackBlock = isBlockTreeEnabled && s._c;
        if (trackBlock) {
            s._d = false;
            openBlock();
        }
        s = s();
        if (trackBlock) {
            s._d = true;
            block = currentBlock;
            closeBlock();
        }
    }
    if ((0, _shared.isArray)(s)) {
        const singleChild = filterSingleRoot(s);
        if (!singleChild && s.filter((child)=>child !== NULL_DYNAMIC_COMPONENT).length > 0) warn$1(`<Suspense> slots expect a single root node.`);
        s = singleChild;
    }
    s = normalizeVNode(s);
    if (block && !s.dynamicChildren) s.dynamicChildren = block.filter((c)=>c !== s);
    return s;
}
function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
        if ((0, _shared.isArray)(fn)) suspense.effects.push(...fn);
        else suspense.effects.push(fn);
    } else queuePostFlushCb(fn);
}
function setActiveBranch(suspense, branch) {
    suspense.activeBranch = branch;
    const { vnode , parentComponent  } = suspense;
    let el = branch.el;
    while(!el && branch.component){
        branch = branch.component.subTree;
        el = branch.el;
    }
    vnode.el = el;
    if (parentComponent && parentComponent.subTree === vnode) {
        parentComponent.vnode.el = el;
        updateHOCHostEl(parentComponent, el);
    }
}
function isVNodeSuspensible(vnode) {
    const suspensible = vnode.props && vnode.props.suspensible;
    return suspensible != null && suspensible !== false;
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
    blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value, inVOnce = false) {
    isBlockTreeEnabled += value;
    if (value < 0 && currentBlock && inVOnce) currentBlock.hasOnce = true;
}
function setupBlock(vnode) {
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || (0, _shared.EMPTY_ARR) : null;
    closeBlock();
    if (isBlockTreeEnabled > 0 && currentBlock) currentBlock.push(vnode);
    return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true));
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
    return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true));
}
function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
    if (n2.shapeFlag & 6 && n1.component) {
        const dirtyInstances = hmrDirtyComponents.get(n2.type);
        if (dirtyInstances && dirtyInstances.has(n1.component)) {
            n1.shapeFlag &= -257;
            n2.shapeFlag &= -513;
            return false;
        }
    }
    return n1.type === n2.type && n1.key === n2.key;
}
let vnodeArgsTransformer;
function transformVNodeArgs(transformer) {
    vnodeArgsTransformer = transformer;
}
const createVNodeWithArgsTransform = (...args)=>{
    return _createVNode(...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args);
};
const normalizeKey = ({ key  })=>key != null ? key : null;
const normalizeRef = ({ ref , ref_key , ref_for  })=>{
    if (typeof ref === "number") ref = "" + ref;
    return ref != null ? (0, _shared.isString)(ref) || (0, _reactivity.isRef)(ref) || (0, _shared.isFunction)(ref) ? {
        i: currentRenderingInstance,
        r: ref,
        k: ref_key,
        f: !!ref_for
    } : ref : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetStart: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null,
        ctx: currentRenderingInstance
    };
    if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        if (shapeFlag & 128) type.normalize(vnode);
    } else if (children) vnode.shapeFlag |= (0, _shared.isString)(children) ? 8 : 16;
    if (vnode.key !== vnode.key) warn$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
    if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
    !isBlockNode && // has current parent block
    currentBlock && // presence of a patch flag indicates this node needs patching on updates.
    // component nodes also should always be patched, because even if the
    // component doesn't need to update, it needs to persist the instance on to
    // the next vnode so that it can be properly unmounted later.
    (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
    // vnode should not be considered dynamic due to handler caching.
    vnode.patchFlag !== 32) currentBlock.push(vnode);
    return vnode;
}
const createVNode = createVNodeWithArgsTransform;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
        if (!type) warn$1(`Invalid vnode type when creating vnode: ${type}.`);
        type = Comment;
    }
    if (isVNode(type)) {
        const cloned = cloneVNode(type, props, true);
        if (children) normalizeChildren(cloned, children);
        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
            if (cloned.shapeFlag & 6) currentBlock[currentBlock.indexOf(type)] = cloned;
            else currentBlock.push(cloned);
        }
        cloned.patchFlag = -2;
        return cloned;
    }
    if (isClassComponent(type)) type = type.__vccOpts;
    if (props) {
        props = guardReactiveProps(props);
        let { class: klass , style  } = props;
        if (klass && !(0, _shared.isString)(klass)) props.class = (0, _shared.normalizeClass)(klass);
        if ((0, _shared.isObject)(style)) {
            if ((0, _reactivity.isProxy)(style) && !(0, _shared.isArray)(style)) style = (0, _shared.extend)({}, style);
            props.style = (0, _shared.normalizeStyle)(style);
        }
    }
    const shapeFlag = (0, _shared.isString)(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : (0, _shared.isObject)(type) ? 4 : (0, _shared.isFunction)(type) ? 2 : 0;
    if (shapeFlag & 4 && (0, _reactivity.isProxy)(type)) {
        type = (0, _reactivity.toRaw)(type);
        warn$1(`Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`, `
Component that was made reactive: `, type);
    }
    return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
    if (!props) return null;
    return (0, _reactivity.isProxy)(props) || isInternalObject(props) ? (0, _shared.extend)({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
    const { props , ref , patchFlag , children , transition  } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref ? // #2078 in the case of <component :is="vnode" ref="extra"/>
        // if the vnode itself already has a ref, cloneVNode will need to merge
        // the refs so the single vnode can be set on multiple refs
        mergeRef && ref ? (0, _shared.isArray)(ref) ? ref.concat(normalizeRef(extraProps)) : [
            ref,
            normalizeRef(extraProps)
        ] : normalizeRef(extraProps) : ref,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children: patchFlag === -1 && (0, _shared.isArray)(children) ? children.map(deepCloneVNode) : children,
        target: vnode.target,
        targetStart: vnode.targetStart,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor,
        ctx: vnode.ctx,
        ce: vnode.ce
    };
    if (transition && cloneTransition) setTransitionHooks(cloned, transition.clone(cloned));
    return cloned;
}
function deepCloneVNode(vnode) {
    const cloned = cloneVNode(vnode);
    if ((0, _shared.isArray)(vnode.children)) cloned.children = vnode.children.map(deepCloneVNode);
    return cloned;
}
function createTextVNode(text = " ", flag = 0) {
    return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
    const vnode = createVNode(Static, null, content);
    vnode.staticCount = numberOfNodes;
    return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
    return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") return createVNode(Comment);
    else if ((0, _shared.isArray)(child)) return createVNode(Fragment, null, // #3666, avoid reference pollution when reusing vnode
    child.slice());
    else if (isVNode(child)) return cloneIfMounted(child);
    else return createVNode(Text, null, String(child));
}
function cloneIfMounted(child) {
    return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag  } = vnode;
    if (children == null) children = null;
    else if ((0, _shared.isArray)(children)) type = 16;
    else if (typeof children === "object") {
        if (shapeFlag & 65) {
            const slot = children.default;
            if (slot) {
                slot._c && (slot._d = false);
                normalizeChildren(vnode, slot());
                slot._c && (slot._d = true);
            }
            return;
        } else {
            type = 32;
            const slotFlag = children._;
            if (!slotFlag && !isInternalObject(children)) children._ctx = currentRenderingInstance;
            else if (slotFlag === 3 && currentRenderingInstance) {
                if (currentRenderingInstance.slots._ === 1) children._ = 1;
                else {
                    children._ = 2;
                    vnode.patchFlag |= 1024;
                }
            }
        }
    } else if ((0, _shared.isFunction)(children)) {
        children = {
            default: children,
            _ctx: currentRenderingInstance
        };
        type = 32;
    } else {
        children = String(children);
        if (shapeFlag & 64) {
            type = 16;
            children = [
                createTextVNode(children)
            ];
        } else type = 8;
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
}
function mergeProps(...args) {
    const ret = {};
    for(let i = 0; i < args.length; i++){
        const toMerge = args[i];
        for(const key in toMerge){
            if (key === "class") {
                if (ret.class !== toMerge.class) ret.class = (0, _shared.normalizeClass)([
                    ret.class,
                    toMerge.class
                ]);
            } else if (key === "style") ret.style = (0, _shared.normalizeStyle)([
                ret.style,
                toMerge.style
            ]);
            else if ((0, _shared.isOn)(key)) {
                const existing = ret[key];
                const incoming = toMerge[key];
                if (incoming && existing !== incoming && !((0, _shared.isArray)(existing) && existing.includes(incoming))) ret[key] = existing ? [].concat(existing, incoming) : incoming;
            } else if (key !== "") ret[key] = toMerge[key];
        }
    }
    return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7, [
        vnode,
        prevVNode
    ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
    const type = vnode.type;
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
        uid: uid++,
        vnode,
        type,
        parent,
        appContext,
        root: null,
        // to be immediately set
        next: null,
        subTree: null,
        // will be set synchronously right after creation
        effect: null,
        update: null,
        // will be set synchronously right after creation
        job: null,
        scope: new (0, _reactivity.EffectScope)(true),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        ids: parent ? parent.ids : [
            "",
            0,
            0
        ],
        accessCache: null,
        renderCache: [],
        // local resolved assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type, appContext),
        emitsOptions: normalizeEmitsOptions(type, appContext),
        // emit
        emit: null,
        // to be set immediately
        emitted: null,
        // props default value
        propsDefaults: (0, _shared.EMPTY_OBJ),
        // inheritAttrs
        inheritAttrs: type.inheritAttrs,
        // state
        ctx: (0, _shared.EMPTY_OBJ),
        data: (0, _shared.EMPTY_OBJ),
        props: (0, _shared.EMPTY_OBJ),
        attrs: (0, _shared.EMPTY_OBJ),
        slots: (0, _shared.EMPTY_OBJ),
        refs: (0, _shared.EMPTY_OBJ),
        setupState: (0, _shared.EMPTY_OBJ),
        setupContext: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    instance.ctx = createDevRenderContext(instance);
    instance.root = parent ? parent.root : instance;
    instance.emit = emit.bind(null, instance);
    if (vnode.ce) vnode.ce(instance);
    return instance;
}
let currentInstance = null;
const getCurrentInstance = ()=>currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
    const g = (0, _shared.getGlobalThis)();
    const registerGlobalSetter = (key, setter)=>{
        let setters;
        if (!(setters = g[key])) setters = g[key] = [];
        setters.push(setter);
        return (v1)=>{
            if (setters.length > 1) setters.forEach((set)=>set(v1));
            else setters[0](v1);
        };
    };
    internalSetCurrentInstance = registerGlobalSetter(`__VUE_INSTANCE_SETTERS__`, (v1)=>currentInstance = v1);
    setInSSRSetupState = registerGlobalSetter(`__VUE_SSR_SETTERS__`, (v1)=>isInSSRComponentSetup = v1);
}const setCurrentInstance = (instance)=>{
    const prev = currentInstance;
    internalSetCurrentInstance(instance);
    instance.scope.on();
    return ()=>{
        instance.scope.off();
        internalSetCurrentInstance(prev);
    };
};
const unsetCurrentInstance = ()=>{
    currentInstance && currentInstance.scope.off();
    internalSetCurrentInstance(null);
};
const isBuiltInTag = /* @__PURE__ */ (0, _shared.makeMap)("slot,component");
function validateComponentName(name, { isNativeTag  }) {
    if (isBuiltInTag(name) || isNativeTag(name)) warn$1("Do not use built-in or reserved HTML elements as component id: " + name);
}
function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false, optimized = false) {
    isSSR && setInSSRSetupState(isSSR);
    const { props , children  } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children, optimized || isSSR);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isSSR && setInSSRSetupState(false);
    return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
    var _a;
    const Component = instance.type;
    if (Component.name) validateComponentName(Component.name, instance.appContext.config);
    if (Component.components) {
        const names = Object.keys(Component.components);
        for(let i = 0; i < names.length; i++)validateComponentName(names[i], instance.appContext.config);
    }
    if (Component.directives) {
        const names = Object.keys(Component.directives);
        for(let i = 0; i < names.length; i++)validateDirectiveName(names[i]);
    }
    if (Component.compilerOptions && isRuntimeOnly()) warn$1(`"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`);
    instance.accessCache = /* @__PURE__ */ Object.create(null);
    instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
    exposePropsOnRenderContext(instance);
    const { setup  } = Component;
    if (setup) {
        (0, _reactivity.pauseTracking)();
        const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
        const reset = setCurrentInstance(instance);
        const setupResult = callWithErrorHandling(setup, instance, 0, [
            (0, _reactivity.shallowReadonly)(instance.props),
            setupContext
        ]);
        const isAsyncSetup = (0, _shared.isPromise)(setupResult);
        (0, _reactivity.resetTracking)();
        reset();
        if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) markAsyncBoundary(instance);
        if (isAsyncSetup) {
            setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
            if (isSSR) return setupResult.then((resolvedResult)=>{
                handleSetupResult(instance, resolvedResult, isSSR);
            }).catch((e)=>{
                handleError(e, instance, 0);
            });
            else {
                instance.asyncDep = setupResult;
                if (!instance.suspense) {
                    const name = (_a = Component.name) != null ? _a : "Anonymous";
                    warn$1(`Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`);
                }
            }
        } else handleSetupResult(instance, setupResult, isSSR);
    } else finishComponentSetup(instance, isSSR);
}
function handleSetupResult(instance, setupResult, isSSR) {
    if ((0, _shared.isFunction)(setupResult)) {
        if (instance.type.__ssrInlineRender) instance.ssrRender = setupResult;
        else instance.render = setupResult;
    } else if ((0, _shared.isObject)(setupResult)) {
        if (isVNode(setupResult)) warn$1(`setup() should not return VNodes directly - return a render function instead.`);
        instance.devtoolsRawSetupState = setupResult;
        instance.setupState = (0, _reactivity.proxyRefs)(setupResult);
        exposeSetupStateOnRenderContext(instance);
    } else if (setupResult !== void 0) warn$1(`setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`);
    finishComponentSetup(instance, isSSR);
}
let compile;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
    compile = _compile;
    installWithProxy = (i)=>{
        if (i.render._rc) i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    };
}
const isRuntimeOnly = ()=>!compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    if (!instance.render) {
        if (!isSSR && compile && !Component.render) {
            const template = Component.template || __VUE_OPTIONS_API__ && resolveMergedOptions(instance).template;
            if (template) {
                startMeasure(instance, `compile`);
                const { isCustomElement , compilerOptions  } = instance.appContext.config;
                const { delimiters , compilerOptions: componentCompilerOptions  } = Component;
                const finalCompilerOptions = (0, _shared.extend)((0, _shared.extend)({
                    isCustomElement,
                    delimiters
                }, compilerOptions), componentCompilerOptions);
                Component.render = compile(template, finalCompilerOptions);
                endMeasure(instance, `compile`);
            }
        }
        instance.render = Component.render || (0, _shared.NOOP);
        if (installWithProxy) installWithProxy(instance);
    }
    if (__VUE_OPTIONS_API__ && true) {
        const reset = setCurrentInstance(instance);
        (0, _reactivity.pauseTracking)();
        try {
            applyOptions(instance);
        } finally{
            (0, _reactivity.resetTracking)();
            reset();
        }
    }
    if (!Component.render && instance.render === (0, _shared.NOOP) && !isSSR) {
        if (!compile && Component.template) warn$1(`Component provided template option but runtime compilation is not supported in this build of Vue.` + ` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`);
        else warn$1(`Component is missing template or render function: `, Component);
    }
}
const attrsProxyHandlers = {
    get (target, key) {
        markAttrsAccessed();
        (0, _reactivity.track)(target, "get", "");
        return target[key];
    },
    set () {
        warn$1(`setupContext.attrs is readonly.`);
        return false;
    },
    deleteProperty () {
        warn$1(`setupContext.attrs is readonly.`);
        return false;
    }
};
function getSlotsProxy(instance) {
    return new Proxy(instance.slots, {
        get (target, key) {
            (0, _reactivity.track)(instance, "get", "$slots");
            return target[key];
        }
    });
}
function createSetupContext(instance) {
    const expose = (exposed)=>{
        if (instance.exposed) warn$1(`expose() should be called only once per setup().`);
        if (exposed != null) {
            let exposedType = typeof exposed;
            if (exposedType === "object") {
                if ((0, _shared.isArray)(exposed)) exposedType = "array";
                else if ((0, _reactivity.isRef)(exposed)) exposedType = "ref";
            }
            if (exposedType !== "object") warn$1(`expose() should be passed a plain object, received ${exposedType}.`);
        }
        instance.exposed = exposed || {};
    };
    {
        let attrsProxy;
        let slotsProxy;
        return Object.freeze({
            get attrs () {
                return attrsProxy || (attrsProxy = new Proxy(instance.attrs, attrsProxyHandlers));
            },
            get slots () {
                return slotsProxy || (slotsProxy = getSlotsProxy(instance));
            },
            get emit () {
                return (event, ...args)=>instance.emit(event, ...args);
            },
            expose
        });
    }
}
function getComponentPublicInstance(instance) {
    if (instance.exposed) return instance.exposeProxy || (instance.exposeProxy = new Proxy((0, _reactivity.proxyRefs)((0, _reactivity.markRaw)(instance.exposed)), {
        get (target, key) {
            if (key in target) return target[key];
            else if (key in publicPropertiesMap) return publicPropertiesMap[key](instance);
        },
        has (target, key) {
            return key in target || key in publicPropertiesMap;
        }
    }));
    else return instance.proxy;
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str)=>str.replace(classifyRE, (c)=>c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
    return (0, _shared.isFunction)(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
    let name = getComponentName(Component);
    if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) name = match[1];
    }
    if (!name && instance && instance.parent) {
        const inferFromRegistry = (registry)=>{
            for(const key in registry){
                if (registry[key] === Component) return key;
            }
        };
        name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
    return (0, _shared.isFunction)(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions)=>{
    const c = (0, _reactivity.computed)(getterOrOptions, debugOptions, isInSSRComponentSetup);
    {
        const i = getCurrentInstance();
        if (i && i.appContext.config.warnRecursiveComputed) c._warnRecursive = true;
    }
    return c;
};
function h(type, propsOrChildren, children) {
    const l = arguments.length;
    if (l === 2) {
        if ((0, _shared.isObject)(propsOrChildren) && !(0, _shared.isArray)(propsOrChildren)) {
            if (isVNode(propsOrChildren)) return createVNode(type, null, [
                propsOrChildren
            ]);
            return createVNode(type, propsOrChildren);
        } else return createVNode(type, null, propsOrChildren);
    } else {
        if (l > 3) children = Array.prototype.slice.call(arguments, 2);
        else if (l === 3 && isVNode(children)) children = [
            children
        ];
        return createVNode(type, propsOrChildren, children);
    }
}
function initCustomFormatter() {
    if (typeof window === "undefined") return;
    const vueStyle = {
        style: "color:#3ba776"
    };
    const numberStyle = {
        style: "color:#1677ff"
    };
    const stringStyle = {
        style: "color:#f5222d"
    };
    const keywordStyle = {
        style: "color:#eb2f96"
    };
    const formatter = {
        __vue_custom_formatter: true,
        header (obj) {
            if (!(0, _shared.isObject)(obj)) return null;
            if (obj.__isVue) return [
                "div",
                vueStyle,
                `VueInstance`
            ];
            else if ((0, _reactivity.isRef)(obj)) {
                (0, _reactivity.pauseTracking)();
                const value = obj.value;
                (0, _reactivity.resetTracking)();
                return [
                    "div",
                    {},
                    [
                        "span",
                        vueStyle,
                        genRefFlag(obj)
                    ],
                    "<",
                    formatValue(value),
                    `>`
                ];
            } else if ((0, _reactivity.isReactive)(obj)) return [
                "div",
                {},
                [
                    "span",
                    vueStyle,
                    (0, _reactivity.isShallow)(obj) ? "ShallowReactive" : "Reactive"
                ],
                "<",
                formatValue(obj),
                `>${(0, _reactivity.isReadonly)(obj) ? ` (readonly)` : ``}`
            ];
            else if ((0, _reactivity.isReadonly)(obj)) return [
                "div",
                {},
                [
                    "span",
                    vueStyle,
                    (0, _reactivity.isShallow)(obj) ? "ShallowReadonly" : "Readonly"
                ],
                "<",
                formatValue(obj),
                ">"
            ];
            return null;
        },
        hasBody (obj) {
            return obj && obj.__isVue;
        },
        body (obj) {
            if (obj && obj.__isVue) return [
                "div",
                {},
                ...formatInstance(obj.$)
            ];
        }
    };
    function formatInstance(instance) {
        const blocks = [];
        if (instance.type.props && instance.props) blocks.push(createInstanceBlock("props", (0, _reactivity.toRaw)(instance.props)));
        if (instance.setupState !== (0, _shared.EMPTY_OBJ)) blocks.push(createInstanceBlock("setup", instance.setupState));
        if (instance.data !== (0, _shared.EMPTY_OBJ)) blocks.push(createInstanceBlock("data", (0, _reactivity.toRaw)(instance.data)));
        const computed = extractKeys(instance, "computed");
        if (computed) blocks.push(createInstanceBlock("computed", computed));
        const injected = extractKeys(instance, "inject");
        if (injected) blocks.push(createInstanceBlock("injected", injected));
        blocks.push([
            "div",
            {},
            [
                "span",
                {
                    style: keywordStyle.style + ";opacity:0.66"
                },
                "$ (internal): "
            ],
            [
                "object",
                {
                    object: instance
                }
            ]
        ]);
        return blocks;
    }
    function createInstanceBlock(type, target) {
        target = (0, _shared.extend)({}, target);
        if (!Object.keys(target).length) return [
            "span",
            {}
        ];
        return [
            "div",
            {
                style: "line-height:1.25em;margin-bottom:0.6em"
            },
            [
                "div",
                {
                    style: "color:#476582"
                },
                type
            ],
            [
                "div",
                {
                    style: "padding-left:1.25em"
                },
                ...Object.keys(target).map((key)=>{
                    return [
                        "div",
                        {},
                        [
                            "span",
                            keywordStyle,
                            key + ": "
                        ],
                        formatValue(target[key], false)
                    ];
                })
            ]
        ];
    }
    function formatValue(v1, asRaw = true) {
        if (typeof v1 === "number") return [
            "span",
            numberStyle,
            v1
        ];
        else if (typeof v1 === "string") return [
            "span",
            stringStyle,
            JSON.stringify(v1)
        ];
        else if (typeof v1 === "boolean") return [
            "span",
            keywordStyle,
            v1
        ];
        else if ((0, _shared.isObject)(v1)) return [
            "object",
            {
                object: asRaw ? (0, _reactivity.toRaw)(v1) : v1
            }
        ];
        else return [
            "span",
            stringStyle,
            String(v1)
        ];
    }
    function extractKeys(instance, type) {
        const Comp = instance.type;
        if ((0, _shared.isFunction)(Comp)) return;
        const extracted = {};
        for(const key in instance.ctx)if (isKeyOfType(Comp, key, type)) extracted[key] = instance.ctx[key];
        return extracted;
    }
    function isKeyOfType(Comp, key, type) {
        const opts = Comp[type];
        if ((0, _shared.isArray)(opts) && opts.includes(key) || (0, _shared.isObject)(opts) && key in opts) return true;
        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) return true;
        if (Comp.mixins && Comp.mixins.some((m)=>isKeyOfType(m, key, type))) return true;
    }
    function genRefFlag(v1) {
        if ((0, _reactivity.isShallow)(v1)) return `ShallowRef`;
        if (v1.effect) return `ComputedRef`;
        return `Ref`;
    }
    if (window.devtoolsFormatters) window.devtoolsFormatters.push(formatter);
    else window.devtoolsFormatters = [
        formatter
    ];
}
function withMemo(memo, render, cache, index) {
    const cached = cache[index];
    if (cached && isMemoSame(cached, memo)) return cached;
    const ret = render();
    ret.memo = memo.slice();
    ret.cacheIndex = index;
    return cache[index] = ret;
}
function isMemoSame(cached, memo) {
    const prev = cached.memo;
    if (prev.length != memo.length) return false;
    for(let i = 0; i < prev.length; i++){
        if ((0, _shared.hasChanged)(prev[i], memo[i])) return false;
    }
    if (isBlockTreeEnabled > 0 && currentBlock) currentBlock.push(cached);
    return true;
}
const version = "3.5.16";
const warn = warn$1;
const ErrorTypeStrings = ErrorTypeStrings$1;
const devtools = devtools$1;
const setDevtoolsHook = setDevtoolsHook$1;
const _ssrUtils = {
    createComponentInstance,
    setupComponent,
    renderComponentRoot,
    setCurrentRenderingInstance,
    isVNode: isVNode,
    normalizeVNode,
    getComponentPublicInstance,
    ensureValidVNode,
    pushWarningContext,
    popWarningContext
};
const ssrUtils = _ssrUtils;
const resolveFilter = null;
const compatUtils = null;
const DeprecationTypes = null;

},{"@vue/reactivity":"fQHlL","@vue/shared":"g6heP","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"fQHlL":[function(require,module,exports) {
/**
* @vue/reactivity v3.5.16
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ARRAY_ITERATE_KEY", ()=>ARRAY_ITERATE_KEY);
parcelHelpers.export(exports, "EffectFlags", ()=>EffectFlags);
parcelHelpers.export(exports, "EffectScope", ()=>EffectScope);
parcelHelpers.export(exports, "ITERATE_KEY", ()=>ITERATE_KEY);
parcelHelpers.export(exports, "MAP_KEY_ITERATE_KEY", ()=>MAP_KEY_ITERATE_KEY);
parcelHelpers.export(exports, "ReactiveEffect", ()=>ReactiveEffect);
parcelHelpers.export(exports, "ReactiveFlags", ()=>ReactiveFlags);
parcelHelpers.export(exports, "TrackOpTypes", ()=>TrackOpTypes);
parcelHelpers.export(exports, "TriggerOpTypes", ()=>TriggerOpTypes);
parcelHelpers.export(exports, "WatchErrorCodes", ()=>WatchErrorCodes);
parcelHelpers.export(exports, "computed", ()=>computed);
parcelHelpers.export(exports, "customRef", ()=>customRef);
parcelHelpers.export(exports, "effect", ()=>effect);
parcelHelpers.export(exports, "effectScope", ()=>effectScope);
parcelHelpers.export(exports, "enableTracking", ()=>enableTracking);
parcelHelpers.export(exports, "getCurrentScope", ()=>getCurrentScope);
parcelHelpers.export(exports, "getCurrentWatcher", ()=>getCurrentWatcher);
parcelHelpers.export(exports, "isProxy", ()=>isProxy);
parcelHelpers.export(exports, "isReactive", ()=>isReactive);
parcelHelpers.export(exports, "isReadonly", ()=>isReadonly);
parcelHelpers.export(exports, "isRef", ()=>isRef);
parcelHelpers.export(exports, "isShallow", ()=>isShallow);
parcelHelpers.export(exports, "markRaw", ()=>markRaw);
parcelHelpers.export(exports, "onEffectCleanup", ()=>onEffectCleanup);
parcelHelpers.export(exports, "onScopeDispose", ()=>onScopeDispose);
parcelHelpers.export(exports, "onWatcherCleanup", ()=>onWatcherCleanup);
parcelHelpers.export(exports, "pauseTracking", ()=>pauseTracking);
parcelHelpers.export(exports, "proxyRefs", ()=>proxyRefs);
parcelHelpers.export(exports, "reactive", ()=>reactive);
parcelHelpers.export(exports, "reactiveReadArray", ()=>reactiveReadArray);
parcelHelpers.export(exports, "readonly", ()=>readonly);
parcelHelpers.export(exports, "ref", ()=>ref);
parcelHelpers.export(exports, "resetTracking", ()=>resetTracking);
parcelHelpers.export(exports, "shallowReactive", ()=>shallowReactive);
parcelHelpers.export(exports, "shallowReadArray", ()=>shallowReadArray);
parcelHelpers.export(exports, "shallowReadonly", ()=>shallowReadonly);
parcelHelpers.export(exports, "shallowRef", ()=>shallowRef);
parcelHelpers.export(exports, "stop", ()=>stop);
parcelHelpers.export(exports, "toRaw", ()=>toRaw);
parcelHelpers.export(exports, "toReactive", ()=>toReactive);
parcelHelpers.export(exports, "toReadonly", ()=>toReadonly);
parcelHelpers.export(exports, "toRef", ()=>toRef);
parcelHelpers.export(exports, "toRefs", ()=>toRefs);
parcelHelpers.export(exports, "toValue", ()=>toValue);
parcelHelpers.export(exports, "track", ()=>track);
parcelHelpers.export(exports, "traverse", ()=>traverse);
parcelHelpers.export(exports, "trigger", ()=>trigger);
parcelHelpers.export(exports, "triggerRef", ()=>triggerRef);
parcelHelpers.export(exports, "unref", ()=>unref);
parcelHelpers.export(exports, "watch", ()=>watch);
var _shared = require("@vue/shared");
function warn(msg, ...args) {
    console.warn(`[Vue warn] ${msg}`, ...args);
}
let activeEffectScope;
class EffectScope {
    constructor(detached = false){
        this.detached = detached;
        /**
     * @internal
     */ this._active = true;
        /**
     * @internal track `on` calls, allow `on` call multiple times
     */ this._on = 0;
        /**
     * @internal
     */ this.effects = [];
        /**
     * @internal
     */ this.cleanups = [];
        this._isPaused = false;
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
    get active() {
        return this._active;
    }
    pause() {
        if (this._active) {
            this._isPaused = true;
            let i, l;
            if (this.scopes) for(i = 0, l = this.scopes.length; i < l; i++)this.scopes[i].pause();
            for(i = 0, l = this.effects.length; i < l; i++)this.effects[i].pause();
        }
    }
    /**
   * Resumes the effect scope, including all child scopes and effects.
   */ resume() {
        if (this._active) {
            if (this._isPaused) {
                this._isPaused = false;
                let i, l;
                if (this.scopes) for(i = 0, l = this.scopes.length; i < l; i++)this.scopes[i].resume();
                for(i = 0, l = this.effects.length; i < l; i++)this.effects[i].resume();
            }
        }
    }
    run(fn) {
        if (this._active) {
            const currentEffectScope = activeEffectScope;
            try {
                activeEffectScope = this;
                return fn();
            } finally{
                activeEffectScope = currentEffectScope;
            }
        } else warn(`cannot run an inactive effect scope.`);
    }
    /**
   * This should only be called on non-detached scopes
   * @internal
   */ on() {
        if (++this._on === 1) {
            this.prevScope = activeEffectScope;
            activeEffectScope = this;
        }
    }
    /**
   * This should only be called on non-detached scopes
   * @internal
   */ off() {
        if (this._on > 0 && --this._on === 0) {
            activeEffectScope = this.prevScope;
            this.prevScope = void 0;
        }
    }
    stop(fromParent) {
        if (this._active) {
            this._active = false;
            let i, l;
            for(i = 0, l = this.effects.length; i < l; i++)this.effects[i].stop();
            this.effects.length = 0;
            for(i = 0, l = this.cleanups.length; i < l; i++)this.cleanups[i]();
            this.cleanups.length = 0;
            if (this.scopes) {
                for(i = 0, l = this.scopes.length; i < l; i++)this.scopes[i].stop(true);
                this.scopes.length = 0;
            }
            if (!this.detached && this.parent && !fromParent) {
                const last = this.parent.scopes.pop();
                if (last && last !== this) {
                    this.parent.scopes[this.index] = last;
                    last.index = this.index;
                }
            }
            this.parent = void 0;
        }
    }
}
function effectScope(detached) {
    return new EffectScope(detached);
}
function getCurrentScope() {
    return activeEffectScope;
}
function onScopeDispose(fn, failSilently = false) {
    if (activeEffectScope) activeEffectScope.cleanups.push(fn);
    else if (!failSilently) warn(`onScopeDispose() is called when there is no active effect scope to be associated with.`);
}
let activeSub;
const EffectFlags = {
    "ACTIVE": 1,
    "1": "ACTIVE",
    "RUNNING": 2,
    "2": "RUNNING",
    "TRACKING": 4,
    "4": "TRACKING",
    "NOTIFIED": 8,
    "8": "NOTIFIED",
    "DIRTY": 16,
    "16": "DIRTY",
    "ALLOW_RECURSE": 32,
    "32": "ALLOW_RECURSE",
    "PAUSED": 64,
    "64": "PAUSED",
    "EVALUATED": 128,
    "128": "EVALUATED"
};
const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
class ReactiveEffect {
    constructor(fn){
        this.fn = fn;
        /**
     * @internal
     */ this.deps = void 0;
        /**
     * @internal
     */ this.depsTail = void 0;
        /**
     * @internal
     */ this.flags = 5;
        /**
     * @internal
     */ this.next = void 0;
        /**
     * @internal
     */ this.cleanup = void 0;
        this.scheduler = void 0;
        if (activeEffectScope && activeEffectScope.active) activeEffectScope.effects.push(this);
    }
    pause() {
        this.flags |= 64;
    }
    resume() {
        if (this.flags & 64) {
            this.flags &= -65;
            if (pausedQueueEffects.has(this)) {
                pausedQueueEffects.delete(this);
                this.trigger();
            }
        }
    }
    /**
   * @internal
   */ notify() {
        if (this.flags & 2 && !(this.flags & 32)) return;
        if (!(this.flags & 8)) batch(this);
    }
    run() {
        if (!(this.flags & 1)) return this.fn();
        this.flags |= 2;
        cleanupEffect(this);
        prepareDeps(this);
        const prevEffect = activeSub;
        const prevShouldTrack = shouldTrack;
        activeSub = this;
        shouldTrack = true;
        try {
            return this.fn();
        } finally{
            if (activeSub !== this) warn("Active effect was not restored correctly - this is likely a Vue internal bug.");
            cleanupDeps(this);
            activeSub = prevEffect;
            shouldTrack = prevShouldTrack;
            this.flags &= -3;
        }
    }
    stop() {
        if (this.flags & 1) {
            for(let link = this.deps; link; link = link.nextDep)removeSub(link);
            this.deps = this.depsTail = void 0;
            cleanupEffect(this);
            this.onStop && this.onStop();
            this.flags &= -2;
        }
    }
    trigger() {
        if (this.flags & 64) pausedQueueEffects.add(this);
        else if (this.scheduler) this.scheduler();
        else this.runIfDirty();
    }
    /**
   * @internal
   */ runIfDirty() {
        if (isDirty(this)) this.run();
    }
    get dirty() {
        return isDirty(this);
    }
}
let batchDepth = 0;
let batchedSub;
let batchedComputed;
function batch(sub, isComputed = false) {
    sub.flags |= 8;
    if (isComputed) {
        sub.next = batchedComputed;
        batchedComputed = sub;
        return;
    }
    sub.next = batchedSub;
    batchedSub = sub;
}
function startBatch() {
    batchDepth++;
}
function endBatch() {
    if (--batchDepth > 0) return;
    if (batchedComputed) {
        let e = batchedComputed;
        batchedComputed = void 0;
        while(e){
            const next = e.next;
            e.next = void 0;
            e.flags &= -9;
            e = next;
        }
    }
    let error;
    while(batchedSub){
        let e = batchedSub;
        batchedSub = void 0;
        while(e){
            const next = e.next;
            e.next = void 0;
            e.flags &= -9;
            if (e.flags & 1) try {
                e.trigger();
            } catch (err) {
                if (!error) error = err;
            }
            e = next;
        }
    }
    if (error) throw error;
}
function prepareDeps(sub) {
    for(let link = sub.deps; link; link = link.nextDep){
        link.version = -1;
        link.prevActiveLink = link.dep.activeLink;
        link.dep.activeLink = link;
    }
}
function cleanupDeps(sub) {
    let head;
    let tail = sub.depsTail;
    let link = tail;
    while(link){
        const prev = link.prevDep;
        if (link.version === -1) {
            if (link === tail) tail = prev;
            removeSub(link);
            removeDep(link);
        } else head = link;
        link.dep.activeLink = link.prevActiveLink;
        link.prevActiveLink = void 0;
        link = prev;
    }
    sub.deps = head;
    sub.depsTail = tail;
}
function isDirty(sub) {
    for(let link = sub.deps; link; link = link.nextDep){
        if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) return true;
    }
    if (sub._dirty) return true;
    return false;
}
function refreshComputed(computed) {
    if (computed.flags & 4 && !(computed.flags & 16)) return;
    computed.flags &= -17;
    if (computed.globalVersion === globalVersion) return;
    computed.globalVersion = globalVersion;
    if (!computed.isSSR && computed.flags & 128 && (!computed.deps && !computed._dirty || !isDirty(computed))) return;
    computed.flags |= 2;
    const dep = computed.dep;
    const prevSub = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = computed;
    shouldTrack = true;
    try {
        prepareDeps(computed);
        const value = computed.fn(computed._value);
        if (dep.version === 0 || (0, _shared.hasChanged)(value, computed._value)) {
            computed.flags |= 128;
            computed._value = value;
            dep.version++;
        }
    } catch (err) {
        dep.version++;
        throw err;
    } finally{
        activeSub = prevSub;
        shouldTrack = prevShouldTrack;
        cleanupDeps(computed);
        computed.flags &= -3;
    }
}
function removeSub(link, soft = false) {
    const { dep , prevSub , nextSub  } = link;
    if (prevSub) {
        prevSub.nextSub = nextSub;
        link.prevSub = void 0;
    }
    if (nextSub) {
        nextSub.prevSub = prevSub;
        link.nextSub = void 0;
    }
    if (dep.subsHead === link) dep.subsHead = nextSub;
    if (dep.subs === link) {
        dep.subs = prevSub;
        if (!prevSub && dep.computed) {
            dep.computed.flags &= -5;
            for(let l = dep.computed.deps; l; l = l.nextDep)removeSub(l, true);
        }
    }
    if (!soft && !--dep.sc && dep.map) dep.map.delete(dep.key);
}
function removeDep(link) {
    const { prevDep , nextDep  } = link;
    if (prevDep) {
        prevDep.nextDep = nextDep;
        link.prevDep = void 0;
    }
    if (nextDep) {
        nextDep.prevDep = prevDep;
        link.nextDep = void 0;
    }
}
function effect(fn, options) {
    if (fn.effect instanceof ReactiveEffect) fn = fn.effect.fn;
    const e = new ReactiveEffect(fn);
    if (options) (0, _shared.extend)(e, options);
    try {
        e.run();
    } catch (err) {
        e.stop();
        throw err;
    }
    const runner = e.run.bind(e);
    runner.effect = e;
    return runner;
}
function stop(runner) {
    runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
}
function enableTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = true;
}
function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
}
function onEffectCleanup(fn, failSilently = false) {
    if (activeSub instanceof ReactiveEffect) activeSub.cleanup = fn;
    else if (!failSilently) warn(`onEffectCleanup() was called when there was no active effect to associate with.`);
}
function cleanupEffect(e) {
    const { cleanup  } = e;
    e.cleanup = void 0;
    if (cleanup) {
        const prevSub = activeSub;
        activeSub = void 0;
        try {
            cleanup();
        } finally{
            activeSub = prevSub;
        }
    }
}
let globalVersion = 0;
class Link {
    constructor(sub, dep){
        this.sub = sub;
        this.dep = dep;
        this.version = dep.version;
        this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
    }
}
class Dep {
    constructor(computed){
        this.computed = computed;
        this.version = 0;
        /**
     * Link between this dep and the current active effect
     */ this.activeLink = void 0;
        /**
     * Doubly linked list representing the subscribing effects (tail)
     */ this.subs = void 0;
        /**
     * For object property deps cleanup
     */ this.map = void 0;
        this.key = void 0;
        /**
     * Subscriber counter
     */ this.sc = 0;
        this.subsHead = void 0;
    }
    track(debugInfo) {
        if (!activeSub || !shouldTrack || activeSub === this.computed) return;
        let link = this.activeLink;
        if (link === void 0 || link.sub !== activeSub) {
            link = this.activeLink = new Link(activeSub, this);
            if (!activeSub.deps) activeSub.deps = activeSub.depsTail = link;
            else {
                link.prevDep = activeSub.depsTail;
                activeSub.depsTail.nextDep = link;
                activeSub.depsTail = link;
            }
            addSub(link);
        } else if (link.version === -1) {
            link.version = this.version;
            if (link.nextDep) {
                const next = link.nextDep;
                next.prevDep = link.prevDep;
                if (link.prevDep) link.prevDep.nextDep = next;
                link.prevDep = activeSub.depsTail;
                link.nextDep = void 0;
                activeSub.depsTail.nextDep = link;
                activeSub.depsTail = link;
                if (activeSub.deps === link) activeSub.deps = next;
            }
        }
        if (0, activeSub.onTrack) activeSub.onTrack((0, _shared.extend)({
            effect: activeSub
        }, debugInfo));
        return link;
    }
    trigger(debugInfo) {
        this.version++;
        globalVersion++;
        this.notify(debugInfo);
    }
    notify(debugInfo) {
        startBatch();
        try {
            for(let head = this.subsHead; head; head = head.nextSub)if (head.sub.onTrigger && !(head.sub.flags & 8)) head.sub.onTrigger((0, _shared.extend)({
                effect: head.sub
            }, debugInfo));
            for(let link = this.subs; link; link = link.prevSub)if (link.sub.notify()) link.sub.dep.notify();
        } finally{
            endBatch();
        }
    }
}
function addSub(link) {
    link.dep.sc++;
    if (link.sub.flags & 4) {
        const computed = link.dep.computed;
        if (computed && !link.dep.subs) {
            computed.flags |= 20;
            for(let l = computed.deps; l; l = l.nextDep)addSub(l);
        }
        const currentTail = link.dep.subs;
        if (currentTail !== link) {
            link.prevSub = currentTail;
            if (currentTail) currentTail.nextSub = link;
        }
        if (link.dep.subsHead === void 0) link.dep.subsHead = link;
        link.dep.subs = link;
    }
}
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol("Object iterate");
const MAP_KEY_ITERATE_KEY = Symbol("Map keys iterate");
const ARRAY_ITERATE_KEY = Symbol("Array iterate");
function track(target, type, key) {
    if (shouldTrack && activeSub) {
        let depsMap = targetMap.get(target);
        if (!depsMap) targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
        let dep = depsMap.get(key);
        if (!dep) {
            depsMap.set(key, dep = new Dep());
            dep.map = depsMap;
            dep.key = key;
        }
        dep.track({
            target,
            type,
            key
        });
    }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
        globalVersion++;
        return;
    }
    const run = (dep)=>{
        if (dep) dep.trigger({
            target,
            type,
            key,
            newValue,
            oldValue,
            oldTarget
        });
    };
    startBatch();
    if (type === "clear") depsMap.forEach(run);
    else {
        const targetIsArray = (0, _shared.isArray)(target);
        const isArrayIndex = targetIsArray && (0, _shared.isIntegerKey)(key);
        if (targetIsArray && key === "length") {
            const newLength = Number(newValue);
            depsMap.forEach((dep, key2)=>{
                if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !(0, _shared.isSymbol)(key2) && key2 >= newLength) run(dep);
            });
        } else {
            if (key !== void 0 || depsMap.has(void 0)) run(depsMap.get(key));
            if (isArrayIndex) run(depsMap.get(ARRAY_ITERATE_KEY));
            switch(type){
                case "add":
                    if (!targetIsArray) {
                        run(depsMap.get(ITERATE_KEY));
                        if ((0, _shared.isMap)(target)) run(depsMap.get(MAP_KEY_ITERATE_KEY));
                    } else if (isArrayIndex) run(depsMap.get("length"));
                    break;
                case "delete":
                    if (!targetIsArray) {
                        run(depsMap.get(ITERATE_KEY));
                        if ((0, _shared.isMap)(target)) run(depsMap.get(MAP_KEY_ITERATE_KEY));
                    }
                    break;
                case "set":
                    if ((0, _shared.isMap)(target)) run(depsMap.get(ITERATE_KEY));
                    break;
            }
        }
    }
    endBatch();
}
function getDepFromReactive(object, key) {
    const depMap = targetMap.get(object);
    return depMap && depMap.get(key);
}
function reactiveReadArray(array) {
    const raw = toRaw(array);
    if (raw === array) return raw;
    track(raw, "iterate", ARRAY_ITERATE_KEY);
    return isShallow(array) ? raw : raw.map(toReactive);
}
function shallowReadArray(arr) {
    track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
    return arr;
}
const arrayInstrumentations = {
    __proto__: null,
    [Symbol.iterator] () {
        return iterator(this, Symbol.iterator, toReactive);
    },
    concat (...args) {
        return reactiveReadArray(this).concat(...args.map((x)=>(0, _shared.isArray)(x) ? reactiveReadArray(x) : x));
    },
    entries () {
        return iterator(this, "entries", (value)=>{
            value[1] = toReactive(value[1]);
            return value;
        });
    },
    every (fn, thisArg) {
        return apply(this, "every", fn, thisArg, void 0, arguments);
    },
    filter (fn, thisArg) {
        return apply(this, "filter", fn, thisArg, (v)=>v.map(toReactive), arguments);
    },
    find (fn, thisArg) {
        return apply(this, "find", fn, thisArg, toReactive, arguments);
    },
    findIndex (fn, thisArg) {
        return apply(this, "findIndex", fn, thisArg, void 0, arguments);
    },
    findLast (fn, thisArg) {
        return apply(this, "findLast", fn, thisArg, toReactive, arguments);
    },
    findLastIndex (fn, thisArg) {
        return apply(this, "findLastIndex", fn, thisArg, void 0, arguments);
    },
    // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
    forEach (fn, thisArg) {
        return apply(this, "forEach", fn, thisArg, void 0, arguments);
    },
    includes (...args) {
        return searchProxy(this, "includes", args);
    },
    indexOf (...args) {
        return searchProxy(this, "indexOf", args);
    },
    join (separator) {
        return reactiveReadArray(this).join(separator);
    },
    // keys() iterator only reads `length`, no optimisation required
    lastIndexOf (...args) {
        return searchProxy(this, "lastIndexOf", args);
    },
    map (fn, thisArg) {
        return apply(this, "map", fn, thisArg, void 0, arguments);
    },
    pop () {
        return noTracking(this, "pop");
    },
    push (...args) {
        return noTracking(this, "push", args);
    },
    reduce (fn, ...args) {
        return reduce(this, "reduce", fn, args);
    },
    reduceRight (fn, ...args) {
        return reduce(this, "reduceRight", fn, args);
    },
    shift () {
        return noTracking(this, "shift");
    },
    // slice could use ARRAY_ITERATE but also seems to beg for range tracking
    some (fn, thisArg) {
        return apply(this, "some", fn, thisArg, void 0, arguments);
    },
    splice (...args) {
        return noTracking(this, "splice", args);
    },
    toReversed () {
        return reactiveReadArray(this).toReversed();
    },
    toSorted (comparer) {
        return reactiveReadArray(this).toSorted(comparer);
    },
    toSpliced (...args) {
        return reactiveReadArray(this).toSpliced(...args);
    },
    unshift (...args) {
        return noTracking(this, "unshift", args);
    },
    values () {
        return iterator(this, "values", toReactive);
    }
};
function iterator(self, method, wrapValue) {
    const arr = shallowReadArray(self);
    const iter = arr[method]();
    if (arr !== self && !isShallow(self)) {
        iter._next = iter.next;
        iter.next = ()=>{
            const result = iter._next();
            if (result.value) result.value = wrapValue(result.value);
            return result;
        };
    }
    return iter;
}
const arrayProto = Array.prototype;
function apply(self, method, fn, thisArg, wrappedRetFn, args) {
    const arr = shallowReadArray(self);
    const needsWrap = arr !== self && !isShallow(self);
    const methodFn = arr[method];
    if (methodFn !== arrayProto[method]) {
        const result2 = methodFn.apply(self, args);
        return needsWrap ? toReactive(result2) : result2;
    }
    let wrappedFn = fn;
    if (arr !== self) {
        if (needsWrap) wrappedFn = function(item, index) {
            return fn.call(this, toReactive(item), index, self);
        };
        else if (fn.length > 2) wrappedFn = function(item, index) {
            return fn.call(this, item, index, self);
        };
    }
    const result = methodFn.call(arr, wrappedFn, thisArg);
    return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
}
function reduce(self, method, fn, args) {
    const arr = shallowReadArray(self);
    let wrappedFn = fn;
    if (arr !== self) {
        if (!isShallow(self)) wrappedFn = function(acc, item, index) {
            return fn.call(this, acc, toReactive(item), index, self);
        };
        else if (fn.length > 3) wrappedFn = function(acc, item, index) {
            return fn.call(this, acc, item, index, self);
        };
    }
    return arr[method](wrappedFn, ...args);
}
function searchProxy(self, method, args) {
    const arr = toRaw(self);
    track(arr, "iterate", ARRAY_ITERATE_KEY);
    const res = arr[method](...args);
    if ((res === -1 || res === false) && isProxy(args[0])) {
        args[0] = toRaw(args[0]);
        return arr[method](...args);
    }
    return res;
}
function noTracking(self, method, args = []) {
    pauseTracking();
    startBatch();
    const res = toRaw(self)[method].apply(self, args);
    endBatch();
    resetTracking();
    return res;
}
const isNonTrackableKeys = /* @__PURE__ */ (0, _shared.makeMap)(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(/* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key)=>key !== "arguments" && key !== "caller").map((key)=>Symbol[key]).filter((0, _shared.isSymbol)));
function hasOwnProperty(key) {
    if (!(0, _shared.isSymbol)(key)) key = String(key);
    const obj = toRaw(this);
    track(obj, "has", key);
    return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
    constructor(_isReadonly = false, _isShallow = false){
        this._isReadonly = _isReadonly;
        this._isShallow = _isShallow;
    }
    get(target, key, receiver) {
        if (key === "__v_skip") return target["__v_skip"];
        const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
        if (key === "__v_isReactive") return !isReadonly2;
        else if (key === "__v_isReadonly") return isReadonly2;
        else if (key === "__v_isShallow") return isShallow2;
        else if (key === "__v_raw") {
            if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
            // this means the receiver is a user proxy of the reactive proxy
            Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) return target;
            return;
        }
        const targetIsArray = (0, _shared.isArray)(target);
        if (!isReadonly2) {
            let fn;
            if (targetIsArray && (fn = arrayInstrumentations[key])) return fn;
            if (key === "hasOwnProperty") return hasOwnProperty;
        }
        const res = Reflect.get(target, key, // if this is a proxy wrapping a ref, return methods using the raw ref
        // as receiver so that we don't have to call `toRaw` on the ref in all
        // its class methods
        isRef(target) ? target : receiver);
        if ((0, _shared.isSymbol)(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) return res;
        if (!isReadonly2) track(target, "get", key);
        if (isShallow2) return res;
        if (isRef(res)) return targetIsArray && (0, _shared.isIntegerKey)(key) ? res : res.value;
        if ((0, _shared.isObject)(res)) return isReadonly2 ? readonly(res) : reactive(res);
        return res;
    }
}
class MutableReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false){
        super(false, isShallow2);
    }
    set(target, key, value, receiver) {
        let oldValue = target[key];
        if (!this._isShallow) {
            const isOldValueReadonly = isReadonly(oldValue);
            if (!isShallow(value) && !isReadonly(value)) {
                oldValue = toRaw(oldValue);
                value = toRaw(value);
            }
            if (!(0, _shared.isArray)(target) && isRef(oldValue) && !isRef(value)) {
                if (isOldValueReadonly) return false;
                else {
                    oldValue.value = value;
                    return true;
                }
            }
        }
        const hadKey = (0, _shared.isArray)(target) && (0, _shared.isIntegerKey)(key) ? Number(key) < target.length : (0, _shared.hasOwn)(target, key);
        const result = Reflect.set(target, key, value, isRef(target) ? target : receiver);
        if (target === toRaw(receiver)) {
            if (!hadKey) trigger(target, "add", key, value);
            else if ((0, _shared.hasChanged)(value, oldValue)) trigger(target, "set", key, value, oldValue);
        }
        return result;
    }
    deleteProperty(target, key) {
        const hadKey = (0, _shared.hasOwn)(target, key);
        const oldValue = target[key];
        const result = Reflect.deleteProperty(target, key);
        if (result && hadKey) trigger(target, "delete", key, void 0, oldValue);
        return result;
    }
    has(target, key) {
        const result = Reflect.has(target, key);
        if (!(0, _shared.isSymbol)(key) || !builtInSymbols.has(key)) track(target, "has", key);
        return result;
    }
    ownKeys(target) {
        track(target, "iterate", (0, _shared.isArray)(target) ? "length" : ITERATE_KEY);
        return Reflect.ownKeys(target);
    }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false){
        super(true, isShallow2);
    }
    set(target, key) {
        warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
        return true;
    }
    deleteProperty(target, key) {
        warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
        return true;
    }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
const toShallow = (value)=>value;
const getProto = (v)=>Reflect.getPrototypeOf(v);
function createIterableMethod(method, isReadonly2, isShallow2) {
    return function(...args) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const targetIsMap = (0, _shared.isMap)(rawTarget);
        const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
        const isKeyOnly = method === "keys" && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
        return {
            // iterator protocol
            next () {
                const { value , done  } = innerIterator.next();
                return done ? {
                    value,
                    done
                } : {
                    value: isPair ? [
                        wrap(value[0]),
                        wrap(value[1])
                    ] : wrap(value),
                    done
                };
            },
            // iterable protocol
            [Symbol.iterator] () {
                return this;
            }
        };
    };
}
function createReadonlyMethod(type) {
    return function(...args) {
        {
            const key = args[0] ? `on key "${args[0]}" ` : ``;
            warn(`${(0, _shared.capitalize)(type)} operation ${key}failed: target is readonly.`, toRaw(this));
        }
        return type === "delete" ? false : type === "clear" ? void 0 : this;
    };
}
function createInstrumentations(readonly, shallow) {
    const instrumentations = {
        get (key) {
            const target = this["__v_raw"];
            const rawTarget = toRaw(target);
            const rawKey = toRaw(key);
            if (!readonly) {
                if ((0, _shared.hasChanged)(key, rawKey)) track(rawTarget, "get", key);
                track(rawTarget, "get", rawKey);
            }
            const { has  } = getProto(rawTarget);
            const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;
            if (has.call(rawTarget, key)) return wrap(target.get(key));
            else if (has.call(rawTarget, rawKey)) return wrap(target.get(rawKey));
            else if (target !== rawTarget) target.get(key);
        },
        get size () {
            const target = this["__v_raw"];
            !readonly && track(toRaw(target), "iterate", ITERATE_KEY);
            return Reflect.get(target, "size", target);
        },
        has (key) {
            const target = this["__v_raw"];
            const rawTarget = toRaw(target);
            const rawKey = toRaw(key);
            if (!readonly) {
                if ((0, _shared.hasChanged)(key, rawKey)) track(rawTarget, "has", key);
                track(rawTarget, "has", rawKey);
            }
            return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
        },
        forEach (callback, thisArg) {
            const observed = this;
            const target = observed["__v_raw"];
            const rawTarget = toRaw(target);
            const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;
            !readonly && track(rawTarget, "iterate", ITERATE_KEY);
            return target.forEach((value, key)=>{
                return callback.call(thisArg, wrap(value), wrap(key), observed);
            });
        }
    };
    (0, _shared.extend)(instrumentations, readonly ? {
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear")
    } : {
        add (value) {
            if (!shallow && !isShallow(value) && !isReadonly(value)) value = toRaw(value);
            const target = toRaw(this);
            const proto = getProto(target);
            const hadKey = proto.has.call(target, value);
            if (!hadKey) {
                target.add(value);
                trigger(target, "add", value, value);
            }
            return this;
        },
        set (key, value) {
            if (!shallow && !isShallow(value) && !isReadonly(value)) value = toRaw(value);
            const target = toRaw(this);
            const { has , get  } = getProto(target);
            let hadKey = has.call(target, key);
            if (!hadKey) {
                key = toRaw(key);
                hadKey = has.call(target, key);
            } else checkIdentityKeys(target, has, key);
            const oldValue = get.call(target, key);
            target.set(key, value);
            if (!hadKey) trigger(target, "add", key, value);
            else if ((0, _shared.hasChanged)(value, oldValue)) trigger(target, "set", key, value, oldValue);
            return this;
        },
        delete (key) {
            const target = toRaw(this);
            const { has , get  } = getProto(target);
            let hadKey = has.call(target, key);
            if (!hadKey) {
                key = toRaw(key);
                hadKey = has.call(target, key);
            } else checkIdentityKeys(target, has, key);
            const oldValue = get ? get.call(target, key) : void 0;
            const result = target.delete(key);
            if (hadKey) trigger(target, "delete", key, void 0, oldValue);
            return result;
        },
        clear () {
            const target = toRaw(this);
            const hadItems = target.size !== 0;
            const oldTarget = (0, _shared.isMap)(target) ? new Map(target) : new Set(target);
            const result = target.clear();
            if (hadItems) trigger(target, "clear", void 0, void 0, oldTarget);
            return result;
        }
    });
    const iteratorMethods = [
        "keys",
        "values",
        "entries",
        Symbol.iterator
    ];
    iteratorMethods.forEach((method)=>{
        instrumentations[method] = createIterableMethod(method, readonly, shallow);
    });
    return instrumentations;
}
function createInstrumentationGetter(isReadonly2, shallow) {
    const instrumentations = createInstrumentations(isReadonly2, shallow);
    return (target, key, receiver)=>{
        if (key === "__v_isReactive") return !isReadonly2;
        else if (key === "__v_isReadonly") return isReadonly2;
        else if (key === "__v_raw") return target;
        return Reflect.get((0, _shared.hasOwn)(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
    };
}
const mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has.call(target, rawKey)) {
        const type = (0, _shared.toRawType)(target);
        warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
    }
}
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
    switch(rawType){
        case "Object":
        case "Array":
            return 1 /* COMMON */ ;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
            return 2 /* COLLECTION */ ;
        default:
            return 0 /* INVALID */ ;
    }
}
function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 /* INVALID */  : targetTypeMap((0, _shared.toRawType)(value));
}
function reactive(target) {
    if (isReadonly(target)) return target;
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target) {
    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function shallowReadonly(target) {
    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!(0, _shared.isObject)(target)) {
        warn(`value cannot be made ${isReadonly2 ? "readonly" : "reactive"}: ${String(target)}`);
        return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) return target;
    const targetType = getTargetType(target);
    if (targetType === 0 /* INVALID */ ) return target;
    const existingProxy = proxyMap.get(target);
    if (existingProxy) return existingProxy;
    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */  ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
}
function isReactive(value) {
    if (isReadonly(value)) return isReactive(value["__v_raw"]);
    return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
    return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
    return value ? !!value["__v_raw"] : false;
}
function toRaw(observed) {
    const raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
    if (!(0, _shared.hasOwn)(value, "__v_skip") && Object.isExtensible(value)) (0, _shared.def)(value, "__v_skip", true);
    return value;
}
const toReactive = (value)=>(0, _shared.isObject)(value) ? reactive(value) : value;
const toReadonly = (value)=>(0, _shared.isObject)(value) ? readonly(value) : value;
function isRef(r) {
    return r ? r["__v_isRef"] === true : false;
}
function ref(value) {
    return createRef(value, false);
}
function shallowRef(value) {
    return createRef(value, true);
}
function createRef(rawValue, shallow) {
    if (isRef(rawValue)) return rawValue;
    return new RefImpl(rawValue, shallow);
}
class RefImpl {
    constructor(value, isShallow2){
        this.dep = new Dep();
        this["__v_isRef"] = true;
        this["__v_isShallow"] = false;
        this._rawValue = isShallow2 ? value : toRaw(value);
        this._value = isShallow2 ? value : toReactive(value);
        this["__v_isShallow"] = isShallow2;
    }
    get value() {
        this.dep.track({
            target: this,
            type: "get",
            key: "value"
        });
        return this._value;
    }
    set value(newValue) {
        const oldValue = this._rawValue;
        const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
        newValue = useDirectValue ? newValue : toRaw(newValue);
        if ((0, _shared.hasChanged)(newValue, oldValue)) {
            this._rawValue = newValue;
            this._value = useDirectValue ? newValue : toReactive(newValue);
            this.dep.trigger({
                target: this,
                type: "set",
                key: "value",
                newValue,
                oldValue
            });
        }
    }
}
function triggerRef(ref2) {
    if (ref2.dep) ref2.dep.trigger({
        target: ref2,
        type: "set",
        key: "value",
        newValue: ref2._value
    });
}
function unref(ref2) {
    return isRef(ref2) ? ref2.value : ref2;
}
function toValue(source) {
    return (0, _shared.isFunction)(source) ? source() : unref(source);
}
const shallowUnwrapHandlers = {
    get: (target, key, receiver)=>key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver)=>{
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
        } else return Reflect.set(target, key, value, receiver);
    }
};
function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
    constructor(factory){
        this["__v_isRef"] = true;
        this._value = void 0;
        const dep = this.dep = new Dep();
        const { get , set  } = factory(dep.track.bind(dep), dep.trigger.bind(dep));
        this._get = get;
        this._set = set;
    }
    get value() {
        return this._value = this._get();
    }
    set value(newVal) {
        this._set(newVal);
    }
}
function customRef(factory) {
    return new CustomRefImpl(factory);
}
function toRefs(object) {
    if (!isProxy(object)) warn(`toRefs() expects a reactive object but received a plain one.`);
    const ret = (0, _shared.isArray)(object) ? new Array(object.length) : {};
    for(const key in object)ret[key] = propertyToRef(object, key);
    return ret;
}
class ObjectRefImpl {
    constructor(_object, _key, _defaultValue){
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this["__v_isRef"] = true;
        this._value = void 0;
    }
    get value() {
        const val = this._object[this._key];
        return this._value = val === void 0 ? this._defaultValue : val;
    }
    set value(newVal) {
        this._object[this._key] = newVal;
    }
    get dep() {
        return getDepFromReactive(toRaw(this._object), this._key);
    }
}
class GetterRefImpl {
    constructor(_getter){
        this._getter = _getter;
        this["__v_isRef"] = true;
        this["__v_isReadonly"] = true;
        this._value = void 0;
    }
    get value() {
        return this._value = this._getter();
    }
}
function toRef(source, key, defaultValue) {
    if (isRef(source)) return source;
    else if ((0, _shared.isFunction)(source)) return new GetterRefImpl(source);
    else if ((0, _shared.isObject)(source) && arguments.length > 1) return propertyToRef(source, key, defaultValue);
    else return ref(source);
}
function propertyToRef(source, key, defaultValue) {
    const val = source[key];
    return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}
class ComputedRefImpl {
    constructor(fn, setter, isSSR){
        this.fn = fn;
        this.setter = setter;
        /**
     * @internal
     */ this._value = void 0;
        /**
     * @internal
     */ this.dep = new Dep(this);
        /**
     * @internal
     */ this.__v_isRef = true;
        // TODO isolatedDeclarations "__v_isReadonly"
        // A computed is also a subscriber that tracks other deps
        /**
     * @internal
     */ this.deps = void 0;
        /**
     * @internal
     */ this.depsTail = void 0;
        /**
     * @internal
     */ this.flags = 16;
        /**
     * @internal
     */ this.globalVersion = globalVersion - 1;
        /**
     * @internal
     */ this.next = void 0;
        // for backwards compat
        this.effect = this;
        this["__v_isReadonly"] = !setter;
        this.isSSR = isSSR;
    }
    /**
   * @internal
   */ notify() {
        this.flags |= 16;
        if (!(this.flags & 8) && // avoid infinite self recursion
        activeSub !== this) {
            batch(this, true);
            return true;
        }
    }
    get value() {
        const link = this.dep.track({
            target: this,
            type: "get",
            key: "value"
        });
        refreshComputed(this);
        if (link) link.version = this.dep.version;
        return this._value;
    }
    set value(newValue) {
        if (this.setter) this.setter(newValue);
        else warn("Write operation failed: computed value is readonly");
    }
}
function computed(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    if ((0, _shared.isFunction)(getterOrOptions)) getter = getterOrOptions;
    else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, isSSR);
    if (debugOptions && !isSSR) {
        cRef.onTrack = debugOptions.onTrack;
        cRef.onTrigger = debugOptions.onTrigger;
    }
    return cRef;
}
const TrackOpTypes = {
    "GET": "get",
    "HAS": "has",
    "ITERATE": "iterate"
};
const TriggerOpTypes = {
    "SET": "set",
    "ADD": "add",
    "DELETE": "delete",
    "CLEAR": "clear"
};
const ReactiveFlags = {
    "SKIP": "__v_skip",
    "IS_REACTIVE": "__v_isReactive",
    "IS_READONLY": "__v_isReadonly",
    "IS_SHALLOW": "__v_isShallow",
    "RAW": "__v_raw",
    "IS_REF": "__v_isRef"
};
const WatchErrorCodes = {
    "WATCH_GETTER": 2,
    "2": "WATCH_GETTER",
    "WATCH_CALLBACK": 3,
    "3": "WATCH_CALLBACK",
    "WATCH_CLEANUP": 4,
    "4": "WATCH_CLEANUP"
};
const INITIAL_WATCHER_VALUE = {};
const cleanupMap = /* @__PURE__ */ new WeakMap();
let activeWatcher = void 0;
function getCurrentWatcher() {
    return activeWatcher;
}
function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
    if (owner) {
        let cleanups = cleanupMap.get(owner);
        if (!cleanups) cleanupMap.set(owner, cleanups = []);
        cleanups.push(cleanupFn);
    } else if (!failSilently) warn(`onWatcherCleanup() was called when there was no active watcher to associate with.`);
}
function watch(source, cb, options = (0, _shared.EMPTY_OBJ)) {
    const { immediate , deep , once , scheduler , augmentJob , call  } = options;
    const warnInvalidSource = (s)=>{
        (options.onWarn || warn)(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`);
    };
    const reactiveGetter = (source2)=>{
        if (deep) return source2;
        if (isShallow(source2) || deep === false || deep === 0) return traverse(source2, 1);
        return traverse(source2);
    };
    let effect;
    let getter;
    let cleanup;
    let boundCleanup;
    let forceTrigger = false;
    let isMultiSource = false;
    if (isRef(source)) {
        getter = ()=>source.value;
        forceTrigger = isShallow(source);
    } else if (isReactive(source)) {
        getter = ()=>reactiveGetter(source);
        forceTrigger = true;
    } else if ((0, _shared.isArray)(source)) {
        isMultiSource = true;
        forceTrigger = source.some((s)=>isReactive(s) || isShallow(s));
        getter = ()=>source.map((s)=>{
                if (isRef(s)) return s.value;
                else if (isReactive(s)) return reactiveGetter(s);
                else if ((0, _shared.isFunction)(s)) return call ? call(s, 2) : s();
                else warnInvalidSource(s);
            });
    } else if ((0, _shared.isFunction)(source)) {
        if (cb) getter = call ? ()=>call(source, 2) : source;
        else getter = ()=>{
            if (cleanup) {
                pauseTracking();
                try {
                    cleanup();
                } finally{
                    resetTracking();
                }
            }
            const currentEffect = activeWatcher;
            activeWatcher = effect;
            try {
                return call ? call(source, 3, [
                    boundCleanup
                ]) : source(boundCleanup);
            } finally{
                activeWatcher = currentEffect;
            }
        };
    } else {
        getter = (0, _shared.NOOP);
        warnInvalidSource(source);
    }
    if (cb && deep) {
        const baseGetter = getter;
        const depth = deep === true ? Infinity : deep;
        getter = ()=>traverse(baseGetter(), depth);
    }
    const scope = getCurrentScope();
    const watchHandle = ()=>{
        effect.stop();
        if (scope && scope.active) (0, _shared.remove)(scope.effects, effect);
    };
    if (once && cb) {
        const _cb = cb;
        cb = (...args)=>{
            _cb(...args);
            watchHandle();
        };
    }
    let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
    const job = (immediateFirstRun)=>{
        if (!(effect.flags & 1) || !effect.dirty && !immediateFirstRun) return;
        if (cb) {
            const newValue = effect.run();
            if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i)=>(0, _shared.hasChanged)(v, oldValue[i])) : (0, _shared.hasChanged)(newValue, oldValue))) {
                if (cleanup) cleanup();
                const currentWatcher = activeWatcher;
                activeWatcher = effect;
                try {
                    const args = [
                        newValue,
                        // pass undefined as the old value when it's changed for the first time
                        oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
                        boundCleanup
                    ];
                    oldValue = newValue;
                    call ? call(cb, 3, args) : // @ts-expect-error
                    cb(...args);
                } finally{
                    activeWatcher = currentWatcher;
                }
            }
        } else effect.run();
    };
    if (augmentJob) augmentJob(job);
    effect = new ReactiveEffect(getter);
    effect.scheduler = scheduler ? ()=>scheduler(job, false) : job;
    boundCleanup = (fn)=>onWatcherCleanup(fn, false, effect);
    cleanup = effect.onStop = ()=>{
        const cleanups = cleanupMap.get(effect);
        if (cleanups) {
            if (call) call(cleanups, 4);
            else for (const cleanup2 of cleanups)cleanup2();
            cleanupMap.delete(effect);
        }
    };
    effect.onTrack = options.onTrack;
    effect.onTrigger = options.onTrigger;
    if (cb) {
        if (immediate) job(true);
        else oldValue = effect.run();
    } else if (scheduler) scheduler(job.bind(null, true), true);
    else effect.run();
    watchHandle.pause = effect.pause.bind(effect);
    watchHandle.resume = effect.resume.bind(effect);
    watchHandle.stop = watchHandle;
    return watchHandle;
}
function traverse(value, depth = Infinity, seen) {
    if (depth <= 0 || !(0, _shared.isObject)(value) || value["__v_skip"]) return value;
    seen = seen || /* @__PURE__ */ new Set();
    if (seen.has(value)) return value;
    seen.add(value);
    depth--;
    if (isRef(value)) traverse(value.value, depth, seen);
    else if ((0, _shared.isArray)(value)) for(let i = 0; i < value.length; i++)traverse(value[i], depth, seen);
    else if ((0, _shared.isSet)(value) || (0, _shared.isMap)(value)) value.forEach((v)=>{
        traverse(v, depth, seen);
    });
    else if ((0, _shared.isPlainObject)(value)) {
        for(const key in value)traverse(value[key], depth, seen);
        for (const key of Object.getOwnPropertySymbols(value))if (Object.prototype.propertyIsEnumerable.call(value, key)) traverse(value[key], depth, seen);
    }
    return value;
}

},{"@vue/shared":"dLq0X","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"dLq0X":[function(require,module,exports) {
/**
* @vue/shared v3.5.16
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/ /*! #__NO_SIDE_EFFECTS__ */ // @__NO_SIDE_EFFECTS__
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EMPTY_ARR", ()=>EMPTY_ARR);
parcelHelpers.export(exports, "EMPTY_OBJ", ()=>EMPTY_OBJ);
parcelHelpers.export(exports, "NO", ()=>NO);
parcelHelpers.export(exports, "NOOP", ()=>NOOP);
parcelHelpers.export(exports, "PatchFlagNames", ()=>PatchFlagNames);
parcelHelpers.export(exports, "PatchFlags", ()=>PatchFlags);
parcelHelpers.export(exports, "ShapeFlags", ()=>ShapeFlags);
parcelHelpers.export(exports, "SlotFlags", ()=>SlotFlags);
parcelHelpers.export(exports, "camelize", ()=>camelize);
parcelHelpers.export(exports, "capitalize", ()=>capitalize);
parcelHelpers.export(exports, "cssVarNameEscapeSymbolsRE", ()=>cssVarNameEscapeSymbolsRE);
parcelHelpers.export(exports, "def", ()=>def);
parcelHelpers.export(exports, "escapeHtml", ()=>escapeHtml);
parcelHelpers.export(exports, "escapeHtmlComment", ()=>escapeHtmlComment);
parcelHelpers.export(exports, "extend", ()=>extend);
parcelHelpers.export(exports, "genCacheKey", ()=>genCacheKey);
parcelHelpers.export(exports, "genPropsAccessExp", ()=>genPropsAccessExp);
parcelHelpers.export(exports, "generateCodeFrame", ()=>generateCodeFrame);
parcelHelpers.export(exports, "getEscapedCssVarName", ()=>getEscapedCssVarName);
parcelHelpers.export(exports, "getGlobalThis", ()=>getGlobalThis);
parcelHelpers.export(exports, "hasChanged", ()=>hasChanged);
parcelHelpers.export(exports, "hasOwn", ()=>hasOwn);
parcelHelpers.export(exports, "hyphenate", ()=>hyphenate);
parcelHelpers.export(exports, "includeBooleanAttr", ()=>includeBooleanAttr);
parcelHelpers.export(exports, "invokeArrayFns", ()=>invokeArrayFns);
parcelHelpers.export(exports, "isArray", ()=>isArray);
parcelHelpers.export(exports, "isBooleanAttr", ()=>isBooleanAttr);
parcelHelpers.export(exports, "isBuiltInDirective", ()=>isBuiltInDirective);
parcelHelpers.export(exports, "isDate", ()=>isDate);
parcelHelpers.export(exports, "isFunction", ()=>isFunction);
parcelHelpers.export(exports, "isGloballyAllowed", ()=>isGloballyAllowed);
parcelHelpers.export(exports, "isGloballyWhitelisted", ()=>isGloballyWhitelisted);
parcelHelpers.export(exports, "isHTMLTag", ()=>isHTMLTag);
parcelHelpers.export(exports, "isIntegerKey", ()=>isIntegerKey);
parcelHelpers.export(exports, "isKnownHtmlAttr", ()=>isKnownHtmlAttr);
parcelHelpers.export(exports, "isKnownMathMLAttr", ()=>isKnownMathMLAttr);
parcelHelpers.export(exports, "isKnownSvgAttr", ()=>isKnownSvgAttr);
parcelHelpers.export(exports, "isMap", ()=>isMap);
parcelHelpers.export(exports, "isMathMLTag", ()=>isMathMLTag);
parcelHelpers.export(exports, "isModelListener", ()=>isModelListener);
parcelHelpers.export(exports, "isObject", ()=>isObject);
parcelHelpers.export(exports, "isOn", ()=>isOn);
parcelHelpers.export(exports, "isPlainObject", ()=>isPlainObject);
parcelHelpers.export(exports, "isPromise", ()=>isPromise);
parcelHelpers.export(exports, "isRegExp", ()=>isRegExp);
parcelHelpers.export(exports, "isRenderableAttrValue", ()=>isRenderableAttrValue);
parcelHelpers.export(exports, "isReservedProp", ()=>isReservedProp);
parcelHelpers.export(exports, "isSSRSafeAttrName", ()=>isSSRSafeAttrName);
parcelHelpers.export(exports, "isSVGTag", ()=>isSVGTag);
parcelHelpers.export(exports, "isSet", ()=>isSet);
parcelHelpers.export(exports, "isSpecialBooleanAttr", ()=>isSpecialBooleanAttr);
parcelHelpers.export(exports, "isString", ()=>isString);
parcelHelpers.export(exports, "isSymbol", ()=>isSymbol);
parcelHelpers.export(exports, "isVoidTag", ()=>isVoidTag);
parcelHelpers.export(exports, "looseEqual", ()=>looseEqual);
parcelHelpers.export(exports, "looseIndexOf", ()=>looseIndexOf);
parcelHelpers.export(exports, "looseToNumber", ()=>looseToNumber);
parcelHelpers.export(exports, "makeMap", ()=>makeMap);
parcelHelpers.export(exports, "normalizeClass", ()=>normalizeClass);
parcelHelpers.export(exports, "normalizeProps", ()=>normalizeProps);
parcelHelpers.export(exports, "normalizeStyle", ()=>normalizeStyle);
parcelHelpers.export(exports, "objectToString", ()=>objectToString);
parcelHelpers.export(exports, "parseStringStyle", ()=>parseStringStyle);
parcelHelpers.export(exports, "propsToAttrMap", ()=>propsToAttrMap);
parcelHelpers.export(exports, "remove", ()=>remove);
parcelHelpers.export(exports, "slotFlagsText", ()=>slotFlagsText);
parcelHelpers.export(exports, "stringifyStyle", ()=>stringifyStyle);
parcelHelpers.export(exports, "toDisplayString", ()=>toDisplayString);
parcelHelpers.export(exports, "toHandlerKey", ()=>toHandlerKey);
parcelHelpers.export(exports, "toNumber", ()=>toNumber);
parcelHelpers.export(exports, "toRawType", ()=>toRawType);
parcelHelpers.export(exports, "toTypeString", ()=>toTypeString);
var global = arguments[3];
function makeMap(str) {
    const map = /* @__PURE__ */ Object.create(null);
    for (const key of str.split(","))map[key] = 1;
    return (val)=>val in map;
}
const EMPTY_OBJ = Object.freeze({});
const EMPTY_ARR = Object.freeze([]);
const NOOP = ()=>{};
const NO = ()=>false;
const isOn = (key)=>key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
    (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key)=>key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el)=>{
    const i = arr.indexOf(el);
    if (i > -1) arr.splice(i, 1);
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key)=>hasOwnProperty.call(val, key);
const isArray = Array.isArray;
const isMap = (val)=>toTypeString(val) === "[object Map]";
const isSet = (val)=>toTypeString(val) === "[object Set]";
const isDate = (val)=>toTypeString(val) === "[object Date]";
const isRegExp = (val)=>toTypeString(val) === "[object RegExp]";
const isFunction = (val)=>typeof val === "function";
const isString = (val)=>typeof val === "string";
const isSymbol = (val)=>typeof val === "symbol";
const isObject = (val)=>val !== null && typeof val === "object";
const isPromise = (val)=>{
    return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value)=>objectToString.call(value);
const toRawType = (value)=>{
    return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val)=>toTypeString(val) === "[object Object]";
const isIntegerKey = (key)=>isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(// the leading comma is intentional so empty string "" is also included
",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
const isBuiltInDirective = /* @__PURE__ */ makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo");
const cacheStringFunction = (fn)=>{
    const cache = /* @__PURE__ */ Object.create(null);
    return (str)=>{
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str)=>{
    return str.replace(camelizeRE, (_, c)=>c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str)=>str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize = cacheStringFunction((str)=>{
    return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction((str)=>{
    const s = str ? `on${capitalize(str)}` : ``;
    return s;
});
const hasChanged = (value, oldValue)=>!Object.is(value, oldValue);
const invokeArrayFns = (fns, ...arg)=>{
    for(let i = 0; i < fns.length; i++)fns[i](...arg);
};
const def = (obj, key, value, writable = false)=>{
    Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        writable,
        value
    });
};
const looseToNumber = (val)=>{
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
};
const toNumber = (val)=>{
    const n = isString(val) ? Number(val) : NaN;
    return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = ()=>{
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
const identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function genPropsAccessExp(name) {
    return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;
}
function genCacheKey(source, options) {
    return source + JSON.stringify(options, (_, val)=>typeof val === "function" ? val.toString() : val);
}
const PatchFlags = {
    "TEXT": 1,
    "1": "TEXT",
    "CLASS": 2,
    "2": "CLASS",
    "STYLE": 4,
    "4": "STYLE",
    "PROPS": 8,
    "8": "PROPS",
    "FULL_PROPS": 16,
    "16": "FULL_PROPS",
    "NEED_HYDRATION": 32,
    "32": "NEED_HYDRATION",
    "STABLE_FRAGMENT": 64,
    "64": "STABLE_FRAGMENT",
    "KEYED_FRAGMENT": 128,
    "128": "KEYED_FRAGMENT",
    "UNKEYED_FRAGMENT": 256,
    "256": "UNKEYED_FRAGMENT",
    "NEED_PATCH": 512,
    "512": "NEED_PATCH",
    "DYNAMIC_SLOTS": 1024,
    "1024": "DYNAMIC_SLOTS",
    "DEV_ROOT_FRAGMENT": 2048,
    "2048": "DEV_ROOT_FRAGMENT",
    "CACHED": -1,
    "-1": "CACHED",
    "BAIL": -2,
    "-2": "BAIL"
};
const PatchFlagNames = {
    [1]: `TEXT`,
    [2]: `CLASS`,
    [4]: `STYLE`,
    [8]: `PROPS`,
    [16]: `FULL_PROPS`,
    [32]: `NEED_HYDRATION`,
    [64]: `STABLE_FRAGMENT`,
    [128]: `KEYED_FRAGMENT`,
    [256]: `UNKEYED_FRAGMENT`,
    [512]: `NEED_PATCH`,
    [1024]: `DYNAMIC_SLOTS`,
    [2048]: `DEV_ROOT_FRAGMENT`,
    [-1]: `HOISTED`,
    [-2]: `BAIL`
};
const ShapeFlags = {
    "ELEMENT": 1,
    "1": "ELEMENT",
    "FUNCTIONAL_COMPONENT": 2,
    "2": "FUNCTIONAL_COMPONENT",
    "STATEFUL_COMPONENT": 4,
    "4": "STATEFUL_COMPONENT",
    "TEXT_CHILDREN": 8,
    "8": "TEXT_CHILDREN",
    "ARRAY_CHILDREN": 16,
    "16": "ARRAY_CHILDREN",
    "SLOTS_CHILDREN": 32,
    "32": "SLOTS_CHILDREN",
    "TELEPORT": 64,
    "64": "TELEPORT",
    "SUSPENSE": 128,
    "128": "SUSPENSE",
    "COMPONENT_SHOULD_KEEP_ALIVE": 256,
    "256": "COMPONENT_SHOULD_KEEP_ALIVE",
    "COMPONENT_KEPT_ALIVE": 512,
    "512": "COMPONENT_KEPT_ALIVE",
    "COMPONENT": 6,
    "6": "COMPONENT"
};
const SlotFlags = {
    "STABLE": 1,
    "1": "STABLE",
    "DYNAMIC": 2,
    "2": "DYNAMIC",
    "FORWARDED": 3,
    "3": "FORWARDED"
};
const slotFlagsText = {
    [1]: "STABLE",
    [2]: "DYNAMIC",
    [3]: "FORWARDED"
};
const GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol";
const isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);
const isGloballyWhitelisted = isGloballyAllowed;
const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
    start = Math.max(0, Math.min(start, source.length));
    end = Math.max(0, Math.min(end, source.length));
    if (start > end) return "";
    let lines = source.split(/(\r?\n)/);
    const newlineSequences = lines.filter((_, idx)=>idx % 2 === 1);
    lines = lines.filter((_, idx)=>idx % 2 === 0);
    let count = 0;
    const res = [];
    for(let i = 0; i < lines.length; i++){
        count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
        if (count >= start) {
            for(let j = i - range; j <= i + range || end > count; j++){
                if (j < 0 || j >= lines.length) continue;
                const line = j + 1;
                res.push(`${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
                const lineLength = lines[j].length;
                const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
                if (j === i) {
                    const pad = start - (count - (lineLength + newLineSeqLength));
                    const length = Math.max(1, end > count ? lineLength - pad : end - start);
                    res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
                } else if (j > i) {
                    if (end > count) {
                        const length = Math.max(Math.min(end - count, lineLength), 1);
                        res.push(`   |  ` + "^".repeat(length));
                    }
                    count += lineLength + newLineSeqLength;
                }
            }
            break;
        }
    }
    return res.join("\n");
}
function normalizeStyle(value) {
    if (isArray(value)) {
        const res = {};
        for(let i = 0; i < value.length; i++){
            const item = value[i];
            const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
            if (normalized) for(const key in normalized)res[key] = normalized[key];
        }
        return res;
    } else if (isString(value) || isObject(value)) return value;
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
    const ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item)=>{
        if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return ret;
}
function stringifyStyle(styles) {
    if (!styles) return "";
    if (isString(styles)) return styles;
    let ret = "";
    for(const key in styles){
        const value = styles[key];
        if (isString(value) || typeof value === "number") {
            const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
            ret += `${normalizedKey}:${value};`;
        }
    }
    return ret;
}
function normalizeClass(value) {
    let res = "";
    if (isString(value)) res = value;
    else if (isArray(value)) for(let i = 0; i < value.length; i++){
        const normalized = normalizeClass(value[i]);
        if (normalized) res += normalized + " ";
    }
    else if (isObject(value)) {
        for(const name in value)if (value[name]) res += name + " ";
    }
    return res.trim();
}
function normalizeProps(props) {
    if (!props) return null;
    let { class: klass , style  } = props;
    if (klass && !isString(klass)) props.class = normalizeClass(klass);
    if (style) props.style = normalizeStyle(style);
    return props;
}
const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
const isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
const isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
const isBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
function includeBooleanAttr(value) {
    return !!value || value === "";
}
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
    if (attrValidationCache.hasOwnProperty(name)) return attrValidationCache[name];
    const isUnsafe = unsafeAttrCharRE.test(name);
    if (isUnsafe) console.error(`unsafe attribute name: ${name}`);
    return attrValidationCache[name] = !isUnsafe;
}
const propsToAttrMap = {
    acceptCharset: "accept-charset",
    className: "class",
    htmlFor: "for",
    httpEquiv: "http-equiv"
};
const isKnownHtmlAttr = /* @__PURE__ */ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`);
const isKnownSvgAttr = /* @__PURE__ */ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);
const isKnownMathMLAttr = /* @__PURE__ */ makeMap(`accent,accentunder,actiontype,align,alignmentscope,altimg,altimg-height,altimg-valign,altimg-width,alttext,bevelled,close,columnsalign,columnlines,columnspan,denomalign,depth,dir,display,displaystyle,encoding,equalcolumns,equalrows,fence,fontstyle,fontweight,form,frame,framespacing,groupalign,height,href,id,indentalign,indentalignfirst,indentalignlast,indentshift,indentshiftfirst,indentshiftlast,indextype,justify,largetop,largeop,lquote,lspace,mathbackground,mathcolor,mathsize,mathvariant,maxsize,minlabelspacing,mode,other,overflow,position,rowalign,rowlines,rowspan,rquote,rspace,scriptlevel,scriptminsize,scriptsizemultiplier,selection,separator,separators,shift,side,src,stackalign,stretchy,subscriptshift,superscriptshift,symmetric,voffset,width,widths,xlink:href,xlink:show,xlink:type,xmlns`);
function isRenderableAttrValue(value) {
    if (value == null) return false;
    const type = typeof value;
    return type === "string" || type === "number" || type === "boolean";
}
const escapeRE = /["'&<>]/;
function escapeHtml(string) {
    const str = "" + string;
    const match = escapeRE.exec(str);
    if (!match) return str;
    let html = "";
    let escaped;
    let index;
    let lastIndex = 0;
    for(index = match.index; index < str.length; index++){
        switch(str.charCodeAt(index)){
            case 34:
                escaped = "&quot;";
                break;
            case 38:
                escaped = "&amp;";
                break;
            case 39:
                escaped = "&#39;";
                break;
            case 60:
                escaped = "&lt;";
                break;
            case 62:
                escaped = "&gt;";
                break;
            default:
                continue;
        }
        if (lastIndex !== index) html += str.slice(lastIndex, index);
        lastIndex = index + 1;
        html += escaped;
    }
    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
    return src.replace(commentStripRE, "");
}
const cssVarNameEscapeSymbolsRE = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g;
function getEscapedCssVarName(key, doubleEscape) {
    return key.replace(cssVarNameEscapeSymbolsRE, (s)=>doubleEscape ? s === '"' ? '\\\\\\"' : `\\\\${s}` : `\\${s}`);
}
function looseCompareArrays(a, b) {
    if (a.length !== b.length) return false;
    let equal = true;
    for(let i = 0; equal && i < a.length; i++)equal = looseEqual(a[i], b[i]);
    return equal;
}
function looseEqual(a, b) {
    if (a === b) return true;
    let aValidType = isDate(a);
    let bValidType = isDate(b);
    if (aValidType || bValidType) return aValidType && bValidType ? a.getTime() === b.getTime() : false;
    aValidType = isSymbol(a);
    bValidType = isSymbol(b);
    if (aValidType || bValidType) return a === b;
    aValidType = isArray(a);
    bValidType = isArray(b);
    if (aValidType || bValidType) return aValidType && bValidType ? looseCompareArrays(a, b) : false;
    aValidType = isObject(a);
    bValidType = isObject(b);
    if (aValidType || bValidType) {
        if (!aValidType || !bValidType) return false;
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) return false;
        for(const key in a){
            const aHasKey = a.hasOwnProperty(key);
            const bHasKey = b.hasOwnProperty(key);
            if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) return false;
        }
    }
    return String(a) === String(b);
}
function looseIndexOf(arr, val) {
    return arr.findIndex((item)=>looseEqual(item, val));
}
const isRef = (val)=>{
    return !!(val && val["__v_isRef"] === true);
};
const toDisplayString = (val)=>{
    return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val)=>{
    if (isRef(val)) return replacer(_key, val.value);
    else if (isMap(val)) return {
        [`Map(${val.size})`]: [
            ...val.entries()
        ].reduce((entries, [key, val2], i)=>{
            entries[stringifySymbol(key, i) + " =>"] = val2;
            return entries;
        }, {})
    };
    else if (isSet(val)) return {
        [`Set(${val.size})`]: [
            ...val.values()
        ].map((v)=>stringifySymbol(v))
    };
    else if (isSymbol(val)) return stringifySymbol(val);
    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) return String(val);
    return val;
};
const stringifySymbol = (v, i = "")=>{
    var _a;
    return(// Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"boKlo":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"g6heP":[function(require,module,exports) {
/**
* @vue/shared v3.5.16
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/ /*! #__NO_SIDE_EFFECTS__ */ // @__NO_SIDE_EFFECTS__
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EMPTY_ARR", ()=>EMPTY_ARR);
parcelHelpers.export(exports, "EMPTY_OBJ", ()=>EMPTY_OBJ);
parcelHelpers.export(exports, "NO", ()=>NO);
parcelHelpers.export(exports, "NOOP", ()=>NOOP);
parcelHelpers.export(exports, "PatchFlagNames", ()=>PatchFlagNames);
parcelHelpers.export(exports, "PatchFlags", ()=>PatchFlags);
parcelHelpers.export(exports, "ShapeFlags", ()=>ShapeFlags);
parcelHelpers.export(exports, "SlotFlags", ()=>SlotFlags);
parcelHelpers.export(exports, "camelize", ()=>camelize);
parcelHelpers.export(exports, "capitalize", ()=>capitalize);
parcelHelpers.export(exports, "cssVarNameEscapeSymbolsRE", ()=>cssVarNameEscapeSymbolsRE);
parcelHelpers.export(exports, "def", ()=>def);
parcelHelpers.export(exports, "escapeHtml", ()=>escapeHtml);
parcelHelpers.export(exports, "escapeHtmlComment", ()=>escapeHtmlComment);
parcelHelpers.export(exports, "extend", ()=>extend);
parcelHelpers.export(exports, "genCacheKey", ()=>genCacheKey);
parcelHelpers.export(exports, "genPropsAccessExp", ()=>genPropsAccessExp);
parcelHelpers.export(exports, "generateCodeFrame", ()=>generateCodeFrame);
parcelHelpers.export(exports, "getEscapedCssVarName", ()=>getEscapedCssVarName);
parcelHelpers.export(exports, "getGlobalThis", ()=>getGlobalThis);
parcelHelpers.export(exports, "hasChanged", ()=>hasChanged);
parcelHelpers.export(exports, "hasOwn", ()=>hasOwn);
parcelHelpers.export(exports, "hyphenate", ()=>hyphenate);
parcelHelpers.export(exports, "includeBooleanAttr", ()=>includeBooleanAttr);
parcelHelpers.export(exports, "invokeArrayFns", ()=>invokeArrayFns);
parcelHelpers.export(exports, "isArray", ()=>isArray);
parcelHelpers.export(exports, "isBooleanAttr", ()=>isBooleanAttr);
parcelHelpers.export(exports, "isBuiltInDirective", ()=>isBuiltInDirective);
parcelHelpers.export(exports, "isDate", ()=>isDate);
parcelHelpers.export(exports, "isFunction", ()=>isFunction);
parcelHelpers.export(exports, "isGloballyAllowed", ()=>isGloballyAllowed);
parcelHelpers.export(exports, "isGloballyWhitelisted", ()=>isGloballyWhitelisted);
parcelHelpers.export(exports, "isHTMLTag", ()=>isHTMLTag);
parcelHelpers.export(exports, "isIntegerKey", ()=>isIntegerKey);
parcelHelpers.export(exports, "isKnownHtmlAttr", ()=>isKnownHtmlAttr);
parcelHelpers.export(exports, "isKnownMathMLAttr", ()=>isKnownMathMLAttr);
parcelHelpers.export(exports, "isKnownSvgAttr", ()=>isKnownSvgAttr);
parcelHelpers.export(exports, "isMap", ()=>isMap);
parcelHelpers.export(exports, "isMathMLTag", ()=>isMathMLTag);
parcelHelpers.export(exports, "isModelListener", ()=>isModelListener);
parcelHelpers.export(exports, "isObject", ()=>isObject);
parcelHelpers.export(exports, "isOn", ()=>isOn);
parcelHelpers.export(exports, "isPlainObject", ()=>isPlainObject);
parcelHelpers.export(exports, "isPromise", ()=>isPromise);
parcelHelpers.export(exports, "isRegExp", ()=>isRegExp);
parcelHelpers.export(exports, "isRenderableAttrValue", ()=>isRenderableAttrValue);
parcelHelpers.export(exports, "isReservedProp", ()=>isReservedProp);
parcelHelpers.export(exports, "isSSRSafeAttrName", ()=>isSSRSafeAttrName);
parcelHelpers.export(exports, "isSVGTag", ()=>isSVGTag);
parcelHelpers.export(exports, "isSet", ()=>isSet);
parcelHelpers.export(exports, "isSpecialBooleanAttr", ()=>isSpecialBooleanAttr);
parcelHelpers.export(exports, "isString", ()=>isString);
parcelHelpers.export(exports, "isSymbol", ()=>isSymbol);
parcelHelpers.export(exports, "isVoidTag", ()=>isVoidTag);
parcelHelpers.export(exports, "looseEqual", ()=>looseEqual);
parcelHelpers.export(exports, "looseIndexOf", ()=>looseIndexOf);
parcelHelpers.export(exports, "looseToNumber", ()=>looseToNumber);
parcelHelpers.export(exports, "makeMap", ()=>makeMap);
parcelHelpers.export(exports, "normalizeClass", ()=>normalizeClass);
parcelHelpers.export(exports, "normalizeProps", ()=>normalizeProps);
parcelHelpers.export(exports, "normalizeStyle", ()=>normalizeStyle);
parcelHelpers.export(exports, "objectToString", ()=>objectToString);
parcelHelpers.export(exports, "parseStringStyle", ()=>parseStringStyle);
parcelHelpers.export(exports, "propsToAttrMap", ()=>propsToAttrMap);
parcelHelpers.export(exports, "remove", ()=>remove);
parcelHelpers.export(exports, "slotFlagsText", ()=>slotFlagsText);
parcelHelpers.export(exports, "stringifyStyle", ()=>stringifyStyle);
parcelHelpers.export(exports, "toDisplayString", ()=>toDisplayString);
parcelHelpers.export(exports, "toHandlerKey", ()=>toHandlerKey);
parcelHelpers.export(exports, "toNumber", ()=>toNumber);
parcelHelpers.export(exports, "toRawType", ()=>toRawType);
parcelHelpers.export(exports, "toTypeString", ()=>toTypeString);
var global = arguments[3];
function makeMap(str) {
    const map = /* @__PURE__ */ Object.create(null);
    for (const key of str.split(","))map[key] = 1;
    return (val)=>val in map;
}
const EMPTY_OBJ = Object.freeze({});
const EMPTY_ARR = Object.freeze([]);
const NOOP = ()=>{};
const NO = ()=>false;
const isOn = (key)=>key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
    (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key)=>key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el)=>{
    const i = arr.indexOf(el);
    if (i > -1) arr.splice(i, 1);
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key)=>hasOwnProperty.call(val, key);
const isArray = Array.isArray;
const isMap = (val)=>toTypeString(val) === "[object Map]";
const isSet = (val)=>toTypeString(val) === "[object Set]";
const isDate = (val)=>toTypeString(val) === "[object Date]";
const isRegExp = (val)=>toTypeString(val) === "[object RegExp]";
const isFunction = (val)=>typeof val === "function";
const isString = (val)=>typeof val === "string";
const isSymbol = (val)=>typeof val === "symbol";
const isObject = (val)=>val !== null && typeof val === "object";
const isPromise = (val)=>{
    return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value)=>objectToString.call(value);
const toRawType = (value)=>{
    return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val)=>toTypeString(val) === "[object Object]";
const isIntegerKey = (key)=>isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(// the leading comma is intentional so empty string "" is also included
",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
const isBuiltInDirective = /* @__PURE__ */ makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo");
const cacheStringFunction = (fn)=>{
    const cache = /* @__PURE__ */ Object.create(null);
    return (str)=>{
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str)=>{
    return str.replace(camelizeRE, (_, c)=>c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str)=>str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize = cacheStringFunction((str)=>{
    return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction((str)=>{
    const s = str ? `on${capitalize(str)}` : ``;
    return s;
});
const hasChanged = (value, oldValue)=>!Object.is(value, oldValue);
const invokeArrayFns = (fns, ...arg)=>{
    for(let i = 0; i < fns.length; i++)fns[i](...arg);
};
const def = (obj, key, value, writable = false)=>{
    Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        writable,
        value
    });
};
const looseToNumber = (val)=>{
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
};
const toNumber = (val)=>{
    const n = isString(val) ? Number(val) : NaN;
    return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = ()=>{
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
const identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function genPropsAccessExp(name) {
    return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;
}
function genCacheKey(source, options) {
    return source + JSON.stringify(options, (_, val)=>typeof val === "function" ? val.toString() : val);
}
const PatchFlags = {
    "TEXT": 1,
    "1": "TEXT",
    "CLASS": 2,
    "2": "CLASS",
    "STYLE": 4,
    "4": "STYLE",
    "PROPS": 8,
    "8": "PROPS",
    "FULL_PROPS": 16,
    "16": "FULL_PROPS",
    "NEED_HYDRATION": 32,
    "32": "NEED_HYDRATION",
    "STABLE_FRAGMENT": 64,
    "64": "STABLE_FRAGMENT",
    "KEYED_FRAGMENT": 128,
    "128": "KEYED_FRAGMENT",
    "UNKEYED_FRAGMENT": 256,
    "256": "UNKEYED_FRAGMENT",
    "NEED_PATCH": 512,
    "512": "NEED_PATCH",
    "DYNAMIC_SLOTS": 1024,
    "1024": "DYNAMIC_SLOTS",
    "DEV_ROOT_FRAGMENT": 2048,
    "2048": "DEV_ROOT_FRAGMENT",
    "CACHED": -1,
    "-1": "CACHED",
    "BAIL": -2,
    "-2": "BAIL"
};
const PatchFlagNames = {
    [1]: `TEXT`,
    [2]: `CLASS`,
    [4]: `STYLE`,
    [8]: `PROPS`,
    [16]: `FULL_PROPS`,
    [32]: `NEED_HYDRATION`,
    [64]: `STABLE_FRAGMENT`,
    [128]: `KEYED_FRAGMENT`,
    [256]: `UNKEYED_FRAGMENT`,
    [512]: `NEED_PATCH`,
    [1024]: `DYNAMIC_SLOTS`,
    [2048]: `DEV_ROOT_FRAGMENT`,
    [-1]: `HOISTED`,
    [-2]: `BAIL`
};
const ShapeFlags = {
    "ELEMENT": 1,
    "1": "ELEMENT",
    "FUNCTIONAL_COMPONENT": 2,
    "2": "FUNCTIONAL_COMPONENT",
    "STATEFUL_COMPONENT": 4,
    "4": "STATEFUL_COMPONENT",
    "TEXT_CHILDREN": 8,
    "8": "TEXT_CHILDREN",
    "ARRAY_CHILDREN": 16,
    "16": "ARRAY_CHILDREN",
    "SLOTS_CHILDREN": 32,
    "32": "SLOTS_CHILDREN",
    "TELEPORT": 64,
    "64": "TELEPORT",
    "SUSPENSE": 128,
    "128": "SUSPENSE",
    "COMPONENT_SHOULD_KEEP_ALIVE": 256,
    "256": "COMPONENT_SHOULD_KEEP_ALIVE",
    "COMPONENT_KEPT_ALIVE": 512,
    "512": "COMPONENT_KEPT_ALIVE",
    "COMPONENT": 6,
    "6": "COMPONENT"
};
const SlotFlags = {
    "STABLE": 1,
    "1": "STABLE",
    "DYNAMIC": 2,
    "2": "DYNAMIC",
    "FORWARDED": 3,
    "3": "FORWARDED"
};
const slotFlagsText = {
    [1]: "STABLE",
    [2]: "DYNAMIC",
    [3]: "FORWARDED"
};
const GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol";
const isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);
const isGloballyWhitelisted = isGloballyAllowed;
const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
    start = Math.max(0, Math.min(start, source.length));
    end = Math.max(0, Math.min(end, source.length));
    if (start > end) return "";
    let lines = source.split(/(\r?\n)/);
    const newlineSequences = lines.filter((_, idx)=>idx % 2 === 1);
    lines = lines.filter((_, idx)=>idx % 2 === 0);
    let count = 0;
    const res = [];
    for(let i = 0; i < lines.length; i++){
        count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
        if (count >= start) {
            for(let j = i - range; j <= i + range || end > count; j++){
                if (j < 0 || j >= lines.length) continue;
                const line = j + 1;
                res.push(`${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
                const lineLength = lines[j].length;
                const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
                if (j === i) {
                    const pad = start - (count - (lineLength + newLineSeqLength));
                    const length = Math.max(1, end > count ? lineLength - pad : end - start);
                    res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
                } else if (j > i) {
                    if (end > count) {
                        const length = Math.max(Math.min(end - count, lineLength), 1);
                        res.push(`   |  ` + "^".repeat(length));
                    }
                    count += lineLength + newLineSeqLength;
                }
            }
            break;
        }
    }
    return res.join("\n");
}
function normalizeStyle(value) {
    if (isArray(value)) {
        const res = {};
        for(let i = 0; i < value.length; i++){
            const item = value[i];
            const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
            if (normalized) for(const key in normalized)res[key] = normalized[key];
        }
        return res;
    } else if (isString(value) || isObject(value)) return value;
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
    const ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item)=>{
        if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return ret;
}
function stringifyStyle(styles) {
    if (!styles) return "";
    if (isString(styles)) return styles;
    let ret = "";
    for(const key in styles){
        const value = styles[key];
        if (isString(value) || typeof value === "number") {
            const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
            ret += `${normalizedKey}:${value};`;
        }
    }
    return ret;
}
function normalizeClass(value) {
    let res = "";
    if (isString(value)) res = value;
    else if (isArray(value)) for(let i = 0; i < value.length; i++){
        const normalized = normalizeClass(value[i]);
        if (normalized) res += normalized + " ";
    }
    else if (isObject(value)) {
        for(const name in value)if (value[name]) res += name + " ";
    }
    return res.trim();
}
function normalizeProps(props) {
    if (!props) return null;
    let { class: klass , style  } = props;
    if (klass && !isString(klass)) props.class = normalizeClass(klass);
    if (style) props.style = normalizeStyle(style);
    return props;
}
const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
const isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
const isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
const isBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
function includeBooleanAttr(value) {
    return !!value || value === "";
}
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
    if (attrValidationCache.hasOwnProperty(name)) return attrValidationCache[name];
    const isUnsafe = unsafeAttrCharRE.test(name);
    if (isUnsafe) console.error(`unsafe attribute name: ${name}`);
    return attrValidationCache[name] = !isUnsafe;
}
const propsToAttrMap = {
    acceptCharset: "accept-charset",
    className: "class",
    htmlFor: "for",
    httpEquiv: "http-equiv"
};
const isKnownHtmlAttr = /* @__PURE__ */ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`);
const isKnownSvgAttr = /* @__PURE__ */ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);
const isKnownMathMLAttr = /* @__PURE__ */ makeMap(`accent,accentunder,actiontype,align,alignmentscope,altimg,altimg-height,altimg-valign,altimg-width,alttext,bevelled,close,columnsalign,columnlines,columnspan,denomalign,depth,dir,display,displaystyle,encoding,equalcolumns,equalrows,fence,fontstyle,fontweight,form,frame,framespacing,groupalign,height,href,id,indentalign,indentalignfirst,indentalignlast,indentshift,indentshiftfirst,indentshiftlast,indextype,justify,largetop,largeop,lquote,lspace,mathbackground,mathcolor,mathsize,mathvariant,maxsize,minlabelspacing,mode,other,overflow,position,rowalign,rowlines,rowspan,rquote,rspace,scriptlevel,scriptminsize,scriptsizemultiplier,selection,separator,separators,shift,side,src,stackalign,stretchy,subscriptshift,superscriptshift,symmetric,voffset,width,widths,xlink:href,xlink:show,xlink:type,xmlns`);
function isRenderableAttrValue(value) {
    if (value == null) return false;
    const type = typeof value;
    return type === "string" || type === "number" || type === "boolean";
}
const escapeRE = /["'&<>]/;
function escapeHtml(string) {
    const str = "" + string;
    const match = escapeRE.exec(str);
    if (!match) return str;
    let html = "";
    let escaped;
    let index;
    let lastIndex = 0;
    for(index = match.index; index < str.length; index++){
        switch(str.charCodeAt(index)){
            case 34:
                escaped = "&quot;";
                break;
            case 38:
                escaped = "&amp;";
                break;
            case 39:
                escaped = "&#39;";
                break;
            case 60:
                escaped = "&lt;";
                break;
            case 62:
                escaped = "&gt;";
                break;
            default:
                continue;
        }
        if (lastIndex !== index) html += str.slice(lastIndex, index);
        lastIndex = index + 1;
        html += escaped;
    }
    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
    return src.replace(commentStripRE, "");
}
const cssVarNameEscapeSymbolsRE = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g;
function getEscapedCssVarName(key, doubleEscape) {
    return key.replace(cssVarNameEscapeSymbolsRE, (s)=>doubleEscape ? s === '"' ? '\\\\\\"' : `\\\\${s}` : `\\${s}`);
}
function looseCompareArrays(a, b) {
    if (a.length !== b.length) return false;
    let equal = true;
    for(let i = 0; equal && i < a.length; i++)equal = looseEqual(a[i], b[i]);
    return equal;
}
function looseEqual(a, b) {
    if (a === b) return true;
    let aValidType = isDate(a);
    let bValidType = isDate(b);
    if (aValidType || bValidType) return aValidType && bValidType ? a.getTime() === b.getTime() : false;
    aValidType = isSymbol(a);
    bValidType = isSymbol(b);
    if (aValidType || bValidType) return a === b;
    aValidType = isArray(a);
    bValidType = isArray(b);
    if (aValidType || bValidType) return aValidType && bValidType ? looseCompareArrays(a, b) : false;
    aValidType = isObject(a);
    bValidType = isObject(b);
    if (aValidType || bValidType) {
        if (!aValidType || !bValidType) return false;
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) return false;
        for(const key in a){
            const aHasKey = a.hasOwnProperty(key);
            const bHasKey = b.hasOwnProperty(key);
            if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) return false;
        }
    }
    return String(a) === String(b);
}
function looseIndexOf(arr, val) {
    return arr.findIndex((item)=>looseEqual(item, val));
}
const isRef = (val)=>{
    return !!(val && val["__v_isRef"] === true);
};
const toDisplayString = (val)=>{
    return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val)=>{
    if (isRef(val)) return replacer(_key, val.value);
    else if (isMap(val)) return {
        [`Map(${val.size})`]: [
            ...val.entries()
        ].reduce((entries, [key, val2], i)=>{
            entries[stringifySymbol(key, i) + " =>"] = val2;
            return entries;
        }, {})
    };
    else if (isSet(val)) return {
        [`Set(${val.size})`]: [
            ...val.values()
        ].map((v)=>stringifySymbol(v))
    };
    else if (isSymbol(val)) return stringifySymbol(val);
    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) return String(val);
    return val;
};
const stringifySymbol = (v, i = "")=>{
    var _a;
    return(// Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"din1v":[function(require,module,exports) {
/**
* @vue/shared v3.5.16
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/ /*! #__NO_SIDE_EFFECTS__ */ // @__NO_SIDE_EFFECTS__
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EMPTY_ARR", ()=>EMPTY_ARR);
parcelHelpers.export(exports, "EMPTY_OBJ", ()=>EMPTY_OBJ);
parcelHelpers.export(exports, "NO", ()=>NO);
parcelHelpers.export(exports, "NOOP", ()=>NOOP);
parcelHelpers.export(exports, "PatchFlagNames", ()=>PatchFlagNames);
parcelHelpers.export(exports, "PatchFlags", ()=>PatchFlags);
parcelHelpers.export(exports, "ShapeFlags", ()=>ShapeFlags);
parcelHelpers.export(exports, "SlotFlags", ()=>SlotFlags);
parcelHelpers.export(exports, "camelize", ()=>camelize);
parcelHelpers.export(exports, "capitalize", ()=>capitalize);
parcelHelpers.export(exports, "cssVarNameEscapeSymbolsRE", ()=>cssVarNameEscapeSymbolsRE);
parcelHelpers.export(exports, "def", ()=>def);
parcelHelpers.export(exports, "escapeHtml", ()=>escapeHtml);
parcelHelpers.export(exports, "escapeHtmlComment", ()=>escapeHtmlComment);
parcelHelpers.export(exports, "extend", ()=>extend);
parcelHelpers.export(exports, "genCacheKey", ()=>genCacheKey);
parcelHelpers.export(exports, "genPropsAccessExp", ()=>genPropsAccessExp);
parcelHelpers.export(exports, "generateCodeFrame", ()=>generateCodeFrame);
parcelHelpers.export(exports, "getEscapedCssVarName", ()=>getEscapedCssVarName);
parcelHelpers.export(exports, "getGlobalThis", ()=>getGlobalThis);
parcelHelpers.export(exports, "hasChanged", ()=>hasChanged);
parcelHelpers.export(exports, "hasOwn", ()=>hasOwn);
parcelHelpers.export(exports, "hyphenate", ()=>hyphenate);
parcelHelpers.export(exports, "includeBooleanAttr", ()=>includeBooleanAttr);
parcelHelpers.export(exports, "invokeArrayFns", ()=>invokeArrayFns);
parcelHelpers.export(exports, "isArray", ()=>isArray);
parcelHelpers.export(exports, "isBooleanAttr", ()=>isBooleanAttr);
parcelHelpers.export(exports, "isBuiltInDirective", ()=>isBuiltInDirective);
parcelHelpers.export(exports, "isDate", ()=>isDate);
parcelHelpers.export(exports, "isFunction", ()=>isFunction);
parcelHelpers.export(exports, "isGloballyAllowed", ()=>isGloballyAllowed);
parcelHelpers.export(exports, "isGloballyWhitelisted", ()=>isGloballyWhitelisted);
parcelHelpers.export(exports, "isHTMLTag", ()=>isHTMLTag);
parcelHelpers.export(exports, "isIntegerKey", ()=>isIntegerKey);
parcelHelpers.export(exports, "isKnownHtmlAttr", ()=>isKnownHtmlAttr);
parcelHelpers.export(exports, "isKnownMathMLAttr", ()=>isKnownMathMLAttr);
parcelHelpers.export(exports, "isKnownSvgAttr", ()=>isKnownSvgAttr);
parcelHelpers.export(exports, "isMap", ()=>isMap);
parcelHelpers.export(exports, "isMathMLTag", ()=>isMathMLTag);
parcelHelpers.export(exports, "isModelListener", ()=>isModelListener);
parcelHelpers.export(exports, "isObject", ()=>isObject);
parcelHelpers.export(exports, "isOn", ()=>isOn);
parcelHelpers.export(exports, "isPlainObject", ()=>isPlainObject);
parcelHelpers.export(exports, "isPromise", ()=>isPromise);
parcelHelpers.export(exports, "isRegExp", ()=>isRegExp);
parcelHelpers.export(exports, "isRenderableAttrValue", ()=>isRenderableAttrValue);
parcelHelpers.export(exports, "isReservedProp", ()=>isReservedProp);
parcelHelpers.export(exports, "isSSRSafeAttrName", ()=>isSSRSafeAttrName);
parcelHelpers.export(exports, "isSVGTag", ()=>isSVGTag);
parcelHelpers.export(exports, "isSet", ()=>isSet);
parcelHelpers.export(exports, "isSpecialBooleanAttr", ()=>isSpecialBooleanAttr);
parcelHelpers.export(exports, "isString", ()=>isString);
parcelHelpers.export(exports, "isSymbol", ()=>isSymbol);
parcelHelpers.export(exports, "isVoidTag", ()=>isVoidTag);
parcelHelpers.export(exports, "looseEqual", ()=>looseEqual);
parcelHelpers.export(exports, "looseIndexOf", ()=>looseIndexOf);
parcelHelpers.export(exports, "looseToNumber", ()=>looseToNumber);
parcelHelpers.export(exports, "makeMap", ()=>makeMap);
parcelHelpers.export(exports, "normalizeClass", ()=>normalizeClass);
parcelHelpers.export(exports, "normalizeProps", ()=>normalizeProps);
parcelHelpers.export(exports, "normalizeStyle", ()=>normalizeStyle);
parcelHelpers.export(exports, "objectToString", ()=>objectToString);
parcelHelpers.export(exports, "parseStringStyle", ()=>parseStringStyle);
parcelHelpers.export(exports, "propsToAttrMap", ()=>propsToAttrMap);
parcelHelpers.export(exports, "remove", ()=>remove);
parcelHelpers.export(exports, "slotFlagsText", ()=>slotFlagsText);
parcelHelpers.export(exports, "stringifyStyle", ()=>stringifyStyle);
parcelHelpers.export(exports, "toDisplayString", ()=>toDisplayString);
parcelHelpers.export(exports, "toHandlerKey", ()=>toHandlerKey);
parcelHelpers.export(exports, "toNumber", ()=>toNumber);
parcelHelpers.export(exports, "toRawType", ()=>toRawType);
parcelHelpers.export(exports, "toTypeString", ()=>toTypeString);
var global = arguments[3];
function makeMap(str) {
    const map = /* @__PURE__ */ Object.create(null);
    for (const key of str.split(","))map[key] = 1;
    return (val)=>val in map;
}
const EMPTY_OBJ = Object.freeze({});
const EMPTY_ARR = Object.freeze([]);
const NOOP = ()=>{};
const NO = ()=>false;
const isOn = (key)=>key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
    (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key)=>key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el)=>{
    const i = arr.indexOf(el);
    if (i > -1) arr.splice(i, 1);
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key)=>hasOwnProperty.call(val, key);
const isArray = Array.isArray;
const isMap = (val)=>toTypeString(val) === "[object Map]";
const isSet = (val)=>toTypeString(val) === "[object Set]";
const isDate = (val)=>toTypeString(val) === "[object Date]";
const isRegExp = (val)=>toTypeString(val) === "[object RegExp]";
const isFunction = (val)=>typeof val === "function";
const isString = (val)=>typeof val === "string";
const isSymbol = (val)=>typeof val === "symbol";
const isObject = (val)=>val !== null && typeof val === "object";
const isPromise = (val)=>{
    return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value)=>objectToString.call(value);
const toRawType = (value)=>{
    return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val)=>toTypeString(val) === "[object Object]";
const isIntegerKey = (key)=>isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(// the leading comma is intentional so empty string "" is also included
",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
const isBuiltInDirective = /* @__PURE__ */ makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo");
const cacheStringFunction = (fn)=>{
    const cache = /* @__PURE__ */ Object.create(null);
    return (str)=>{
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str)=>{
    return str.replace(camelizeRE, (_, c)=>c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str)=>str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize = cacheStringFunction((str)=>{
    return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction((str)=>{
    const s = str ? `on${capitalize(str)}` : ``;
    return s;
});
const hasChanged = (value, oldValue)=>!Object.is(value, oldValue);
const invokeArrayFns = (fns, ...arg)=>{
    for(let i = 0; i < fns.length; i++)fns[i](...arg);
};
const def = (obj, key, value, writable = false)=>{
    Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        writable,
        value
    });
};
const looseToNumber = (val)=>{
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
};
const toNumber = (val)=>{
    const n = isString(val) ? Number(val) : NaN;
    return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = ()=>{
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
const identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function genPropsAccessExp(name) {
    return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;
}
function genCacheKey(source, options) {
    return source + JSON.stringify(options, (_, val)=>typeof val === "function" ? val.toString() : val);
}
const PatchFlags = {
    "TEXT": 1,
    "1": "TEXT",
    "CLASS": 2,
    "2": "CLASS",
    "STYLE": 4,
    "4": "STYLE",
    "PROPS": 8,
    "8": "PROPS",
    "FULL_PROPS": 16,
    "16": "FULL_PROPS",
    "NEED_HYDRATION": 32,
    "32": "NEED_HYDRATION",
    "STABLE_FRAGMENT": 64,
    "64": "STABLE_FRAGMENT",
    "KEYED_FRAGMENT": 128,
    "128": "KEYED_FRAGMENT",
    "UNKEYED_FRAGMENT": 256,
    "256": "UNKEYED_FRAGMENT",
    "NEED_PATCH": 512,
    "512": "NEED_PATCH",
    "DYNAMIC_SLOTS": 1024,
    "1024": "DYNAMIC_SLOTS",
    "DEV_ROOT_FRAGMENT": 2048,
    "2048": "DEV_ROOT_FRAGMENT",
    "CACHED": -1,
    "-1": "CACHED",
    "BAIL": -2,
    "-2": "BAIL"
};
const PatchFlagNames = {
    [1]: `TEXT`,
    [2]: `CLASS`,
    [4]: `STYLE`,
    [8]: `PROPS`,
    [16]: `FULL_PROPS`,
    [32]: `NEED_HYDRATION`,
    [64]: `STABLE_FRAGMENT`,
    [128]: `KEYED_FRAGMENT`,
    [256]: `UNKEYED_FRAGMENT`,
    [512]: `NEED_PATCH`,
    [1024]: `DYNAMIC_SLOTS`,
    [2048]: `DEV_ROOT_FRAGMENT`,
    [-1]: `HOISTED`,
    [-2]: `BAIL`
};
const ShapeFlags = {
    "ELEMENT": 1,
    "1": "ELEMENT",
    "FUNCTIONAL_COMPONENT": 2,
    "2": "FUNCTIONAL_COMPONENT",
    "STATEFUL_COMPONENT": 4,
    "4": "STATEFUL_COMPONENT",
    "TEXT_CHILDREN": 8,
    "8": "TEXT_CHILDREN",
    "ARRAY_CHILDREN": 16,
    "16": "ARRAY_CHILDREN",
    "SLOTS_CHILDREN": 32,
    "32": "SLOTS_CHILDREN",
    "TELEPORT": 64,
    "64": "TELEPORT",
    "SUSPENSE": 128,
    "128": "SUSPENSE",
    "COMPONENT_SHOULD_KEEP_ALIVE": 256,
    "256": "COMPONENT_SHOULD_KEEP_ALIVE",
    "COMPONENT_KEPT_ALIVE": 512,
    "512": "COMPONENT_KEPT_ALIVE",
    "COMPONENT": 6,
    "6": "COMPONENT"
};
const SlotFlags = {
    "STABLE": 1,
    "1": "STABLE",
    "DYNAMIC": 2,
    "2": "DYNAMIC",
    "FORWARDED": 3,
    "3": "FORWARDED"
};
const slotFlagsText = {
    [1]: "STABLE",
    [2]: "DYNAMIC",
    [3]: "FORWARDED"
};
const GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol";
const isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);
const isGloballyWhitelisted = isGloballyAllowed;
const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
    start = Math.max(0, Math.min(start, source.length));
    end = Math.max(0, Math.min(end, source.length));
    if (start > end) return "";
    let lines = source.split(/(\r?\n)/);
    const newlineSequences = lines.filter((_, idx)=>idx % 2 === 1);
    lines = lines.filter((_, idx)=>idx % 2 === 0);
    let count = 0;
    const res = [];
    for(let i = 0; i < lines.length; i++){
        count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
        if (count >= start) {
            for(let j = i - range; j <= i + range || end > count; j++){
                if (j < 0 || j >= lines.length) continue;
                const line = j + 1;
                res.push(`${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
                const lineLength = lines[j].length;
                const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
                if (j === i) {
                    const pad = start - (count - (lineLength + newLineSeqLength));
                    const length = Math.max(1, end > count ? lineLength - pad : end - start);
                    res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
                } else if (j > i) {
                    if (end > count) {
                        const length = Math.max(Math.min(end - count, lineLength), 1);
                        res.push(`   |  ` + "^".repeat(length));
                    }
                    count += lineLength + newLineSeqLength;
                }
            }
            break;
        }
    }
    return res.join("\n");
}
function normalizeStyle(value) {
    if (isArray(value)) {
        const res = {};
        for(let i = 0; i < value.length; i++){
            const item = value[i];
            const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
            if (normalized) for(const key in normalized)res[key] = normalized[key];
        }
        return res;
    } else if (isString(value) || isObject(value)) return value;
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
    const ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item)=>{
        if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return ret;
}
function stringifyStyle(styles) {
    if (!styles) return "";
    if (isString(styles)) return styles;
    let ret = "";
    for(const key in styles){
        const value = styles[key];
        if (isString(value) || typeof value === "number") {
            const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
            ret += `${normalizedKey}:${value};`;
        }
    }
    return ret;
}
function normalizeClass(value) {
    let res = "";
    if (isString(value)) res = value;
    else if (isArray(value)) for(let i = 0; i < value.length; i++){
        const normalized = normalizeClass(value[i]);
        if (normalized) res += normalized + " ";
    }
    else if (isObject(value)) {
        for(const name in value)if (value[name]) res += name + " ";
    }
    return res.trim();
}
function normalizeProps(props) {
    if (!props) return null;
    let { class: klass , style  } = props;
    if (klass && !isString(klass)) props.class = normalizeClass(klass);
    if (style) props.style = normalizeStyle(style);
    return props;
}
const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
const isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
const isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
const isBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
function includeBooleanAttr(value) {
    return !!value || value === "";
}
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
    if (attrValidationCache.hasOwnProperty(name)) return attrValidationCache[name];
    const isUnsafe = unsafeAttrCharRE.test(name);
    if (isUnsafe) console.error(`unsafe attribute name: ${name}`);
    return attrValidationCache[name] = !isUnsafe;
}
const propsToAttrMap = {
    acceptCharset: "accept-charset",
    className: "class",
    htmlFor: "for",
    httpEquiv: "http-equiv"
};
const isKnownHtmlAttr = /* @__PURE__ */ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`);
const isKnownSvgAttr = /* @__PURE__ */ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);
const isKnownMathMLAttr = /* @__PURE__ */ makeMap(`accent,accentunder,actiontype,align,alignmentscope,altimg,altimg-height,altimg-valign,altimg-width,alttext,bevelled,close,columnsalign,columnlines,columnspan,denomalign,depth,dir,display,displaystyle,encoding,equalcolumns,equalrows,fence,fontstyle,fontweight,form,frame,framespacing,groupalign,height,href,id,indentalign,indentalignfirst,indentalignlast,indentshift,indentshiftfirst,indentshiftlast,indextype,justify,largetop,largeop,lquote,lspace,mathbackground,mathcolor,mathsize,mathvariant,maxsize,minlabelspacing,mode,other,overflow,position,rowalign,rowlines,rowspan,rquote,rspace,scriptlevel,scriptminsize,scriptsizemultiplier,selection,separator,separators,shift,side,src,stackalign,stretchy,subscriptshift,superscriptshift,symmetric,voffset,width,widths,xlink:href,xlink:show,xlink:type,xmlns`);
function isRenderableAttrValue(value) {
    if (value == null) return false;
    const type = typeof value;
    return type === "string" || type === "number" || type === "boolean";
}
const escapeRE = /["'&<>]/;
function escapeHtml(string) {
    const str = "" + string;
    const match = escapeRE.exec(str);
    if (!match) return str;
    let html = "";
    let escaped;
    let index;
    let lastIndex = 0;
    for(index = match.index; index < str.length; index++){
        switch(str.charCodeAt(index)){
            case 34:
                escaped = "&quot;";
                break;
            case 38:
                escaped = "&amp;";
                break;
            case 39:
                escaped = "&#39;";
                break;
            case 60:
                escaped = "&lt;";
                break;
            case 62:
                escaped = "&gt;";
                break;
            default:
                continue;
        }
        if (lastIndex !== index) html += str.slice(lastIndex, index);
        lastIndex = index + 1;
        html += escaped;
    }
    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
    return src.replace(commentStripRE, "");
}
const cssVarNameEscapeSymbolsRE = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g;
function getEscapedCssVarName(key, doubleEscape) {
    return key.replace(cssVarNameEscapeSymbolsRE, (s)=>doubleEscape ? s === '"' ? '\\\\\\"' : `\\\\${s}` : `\\${s}`);
}
function looseCompareArrays(a, b) {
    if (a.length !== b.length) return false;
    let equal = true;
    for(let i = 0; equal && i < a.length; i++)equal = looseEqual(a[i], b[i]);
    return equal;
}
function looseEqual(a, b) {
    if (a === b) return true;
    let aValidType = isDate(a);
    let bValidType = isDate(b);
    if (aValidType || bValidType) return aValidType && bValidType ? a.getTime() === b.getTime() : false;
    aValidType = isSymbol(a);
    bValidType = isSymbol(b);
    if (aValidType || bValidType) return a === b;
    aValidType = isArray(a);
    bValidType = isArray(b);
    if (aValidType || bValidType) return aValidType && bValidType ? looseCompareArrays(a, b) : false;
    aValidType = isObject(a);
    bValidType = isObject(b);
    if (aValidType || bValidType) {
        if (!aValidType || !bValidType) return false;
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) return false;
        for(const key in a){
            const aHasKey = a.hasOwnProperty(key);
            const bHasKey = b.hasOwnProperty(key);
            if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) return false;
        }
    }
    return String(a) === String(b);
}
function looseIndexOf(arr, val) {
    return arr.findIndex((item)=>looseEqual(item, val));
}
const isRef = (val)=>{
    return !!(val && val["__v_isRef"] === true);
};
const toDisplayString = (val)=>{
    return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val)=>{
    if (isRef(val)) return replacer(_key, val.value);
    else if (isMap(val)) return {
        [`Map(${val.size})`]: [
            ...val.entries()
        ].reduce((entries, [key, val2], i)=>{
            entries[stringifySymbol(key, i) + " =>"] = val2;
            return entries;
        }, {})
    };
    else if (isSet(val)) return {
        [`Set(${val.size})`]: [
            ...val.values()
        ].map((v)=>stringifySymbol(v))
    };
    else if (isSymbol(val)) return stringifySymbol(val);
    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) return String(val);
    return val;
};
const stringifySymbol = (v, i = "")=>{
    var _a;
    return(// Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"afUQj":[function(require,module,exports) {
/*!
 * pinia v2.3.1
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MutationType", ()=>MutationType);
parcelHelpers.export(exports, "PiniaVuePlugin", ()=>PiniaVuePlugin);
parcelHelpers.export(exports, "acceptHMRUpdate", ()=>acceptHMRUpdate);
parcelHelpers.export(exports, "createPinia", ()=>createPinia);
parcelHelpers.export(exports, "defineStore", ()=>defineStore);
parcelHelpers.export(exports, "disposePinia", ()=>disposePinia);
parcelHelpers.export(exports, "getActivePinia", ()=>getActivePinia);
parcelHelpers.export(exports, "mapActions", ()=>mapActions);
parcelHelpers.export(exports, "mapGetters", ()=>mapGetters);
parcelHelpers.export(exports, "mapState", ()=>mapState);
parcelHelpers.export(exports, "mapStores", ()=>mapStores);
parcelHelpers.export(exports, "mapWritableState", ()=>mapWritableState);
parcelHelpers.export(exports, "setActivePinia", ()=>setActivePinia);
parcelHelpers.export(exports, "setMapStoreSuffix", ()=>setMapStoreSuffix);
parcelHelpers.export(exports, "shouldHydrate", ()=>shouldHydrate);
parcelHelpers.export(exports, "skipHydrate", ()=>skipHydrate);
parcelHelpers.export(exports, "storeToRefs", ()=>storeToRefs);
var _vueDemi = require("vue-demi");
var _devtoolsApi = require("@vue/devtools-api");
var global = arguments[3];
/**
 * setActivePinia must be called to handle SSR at the top of functions like
 * `fetch`, `setup`, `serverPrefetch` and others
 */ let activePinia;
/**
 * Sets or unsets the active pinia. Used in SSR and internally when calling
 * actions and getters
 *
 * @param pinia - Pinia instance
 */ // @ts-expect-error: cannot constrain the type of the return
const setActivePinia = (pinia)=>activePinia = pinia;
/**
 * Get the currently active pinia if there is any.
 */ const getActivePinia = ()=>(0, _vueDemi.hasInjectionContext)() && (0, _vueDemi.inject)(piniaSymbol) || activePinia;
const piniaSymbol = Symbol("pinia");
function isPlainObject(// eslint-disable-next-line @typescript-eslint/no-explicit-any
o) {
    return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
}
// type DeepReadonly<T> = { readonly [P in keyof T]: DeepReadonly<T[P]> }
// TODO: can we change these to numbers?
/**
 * Possible types for SubscriptionCallback
 */ var MutationType;
(function(MutationType) {
    /**
     * Direct mutation of the state:
     *
     * - `store.name = 'new name'`
     * - `store.$state.name = 'new name'`
     * - `store.list.push('new item')`
     */ MutationType["direct"] = "direct";
    /**
     * Mutated the state with `$patch` and an object
     *
     * - `store.$patch({ name: 'newName' })`
     */ MutationType["patchObject"] = "patch object";
    /**
     * Mutated the state with `$patch` and a function
     *
     * - `store.$patch(state => state.name = 'newName')`
     */ MutationType["patchFunction"] = "patch function";
// maybe reset? for $state = {} and $reset
})(MutationType || (MutationType = {}));
const IS_CLIENT = typeof window !== "undefined";
/*
 * FileSaver.js A saveAs() FileSaver implementation.
 *
 * Originally by Eli Grey, adapted as an ESM module by Eduardo San Martin
 * Morote.
 *
 * License : MIT
 */ // The one and only way of getting global scope in all environments
// https://stackoverflow.com/q/3277182/1008999
const _global = /*#__PURE__*/ (()=>typeof window === "object" && window.window === window ? window : typeof self === "object" && self.self === self ? self : typeof global === "object" && global.global === global ? global : typeof globalThis === "object" ? globalThis : {
        HTMLElement: null
    })();
function bom(blob, { autoBom =false  } = {}) {
    // prepend BOM for UTF-8 XML and text/* types (including HTML)
    // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
    if (autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) return new Blob([
        String.fromCharCode(0xfeff),
        blob
    ], {
        type: blob.type
    });
    return blob;
}
function download(url, name, opts) {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    xhr.responseType = "blob";
    xhr.onload = function() {
        saveAs(xhr.response, name, opts);
    };
    xhr.onerror = function() {
        console.error("could not download file");
    };
    xhr.send();
}
function corsEnabled(url) {
    const xhr = new XMLHttpRequest();
    // use sync to avoid popup blocker
    xhr.open("HEAD", url, false);
    try {
        xhr.send();
    } catch (e) {}
    return xhr.status >= 200 && xhr.status <= 299;
}
// `a.click()` doesn't work for all browsers (#465)
function click(node) {
    try {
        node.dispatchEvent(new MouseEvent("click"));
    } catch (e) {
        const evt = document.createEvent("MouseEvents");
        evt.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);
        node.dispatchEvent(evt);
    }
}
const _navigator = typeof navigator === "object" ? navigator : {
    userAgent: ""
};
// Detect WebView inside a native macOS app by ruling out all browsers
// We just need to check for 'Safari' because all other browsers (besides Firefox) include that too
// https://www.whatismybrowser.com/guides/the-latest-user-agent/macos
const isMacOSWebView = /*#__PURE__*/ (()=>/Macintosh/.test(_navigator.userAgent) && /AppleWebKit/.test(_navigator.userAgent) && !/Safari/.test(_navigator.userAgent))();
const saveAs = !IS_CLIENT ? ()=>{} // noop
 : typeof HTMLAnchorElement !== "undefined" && "download" in HTMLAnchorElement.prototype && !isMacOSWebView ? downloadSaveAs : "msSaveOrOpenBlob" in _navigator ? msSaveAs : fileSaverSaveAs;
function downloadSaveAs(blob, name = "download", opts) {
    const a = document.createElement("a");
    a.download = name;
    a.rel = "noopener"; // tabnabbing
    // TODO: detect chrome extensions & packaged apps
    // a.target = '_blank'
    if (typeof blob === "string") {
        // Support regular links
        a.href = blob;
        if (a.origin !== location.origin) {
            if (corsEnabled(a.href)) download(blob, name, opts);
            else {
                a.target = "_blank";
                click(a);
            }
        } else click(a);
    } else {
        // Support blobs
        a.href = URL.createObjectURL(blob);
        setTimeout(function() {
            URL.revokeObjectURL(a.href);
        }, 4e4); // 40s
        setTimeout(function() {
            click(a);
        }, 0);
    }
}
function msSaveAs(blob, name = "download", opts) {
    if (typeof blob === "string") {
        if (corsEnabled(blob)) download(blob, name, opts);
        else {
            const a = document.createElement("a");
            a.href = blob;
            a.target = "_blank";
            setTimeout(function() {
                click(a);
            });
        }
    } else // @ts-ignore: works on windows
    navigator.msSaveOrOpenBlob(bom(blob, opts), name);
}
function fileSaverSaveAs(blob, name, opts, popup) {
    // Open a popup immediately do go around popup blocker
    // Mostly only available on user interaction and the fileReader is async so...
    popup = popup || open("", "_blank");
    if (popup) popup.document.title = popup.document.body.innerText = "downloading...";
    if (typeof blob === "string") return download(blob, name, opts);
    const force = blob.type === "application/octet-stream";
    const isSafari = /constructor/i.test(String(_global.HTMLElement)) || "safari" in _global;
    const isChromeIOS = /CriOS\/[\d]+/.test(navigator.userAgent);
    if ((isChromeIOS || force && isSafari || isMacOSWebView) && typeof FileReader !== "undefined") {
        // Safari doesn't allow downloading of blob URLs
        const reader = new FileReader();
        reader.onloadend = function() {
            let url = reader.result;
            if (typeof url !== "string") {
                popup = null;
                throw new Error("Wrong reader.result type");
            }
            url = isChromeIOS ? url : url.replace(/^data:[^;]*;/, "data:attachment/file;");
            if (popup) popup.location.href = url;
            else location.assign(url);
            popup = null; // reverse-tabnabbing #460
        };
        reader.readAsDataURL(blob);
    } else {
        const url = URL.createObjectURL(blob);
        if (popup) popup.location.assign(url);
        else location.href = url;
        popup = null; // reverse-tabnabbing #460
        setTimeout(function() {
            URL.revokeObjectURL(url);
        }, 4e4); // 40s
    }
}
/**
 * Shows a toast or console.log
 *
 * @param message - message to log
 * @param type - different color of the tooltip
 */ function toastMessage(message, type) {
    const piniaMessage = "\uD83C\uDF4D " + message;
    if (typeof __VUE_DEVTOOLS_TOAST__ === "function") // No longer available :(
    __VUE_DEVTOOLS_TOAST__(piniaMessage, type);
    else if (type === "error") console.error(piniaMessage);
    else if (type === "warn") console.warn(piniaMessage);
    else console.log(piniaMessage);
}
function isPinia(o) {
    return "_a" in o && "install" in o;
}
/**
 * This file contain devtools actions, they are not Pinia actions.
 */ // ---
function checkClipboardAccess() {
    if (!("clipboard" in navigator)) {
        toastMessage(`Your browser doesn't support the Clipboard API`, "error");
        return true;
    }
}
function checkNotFocusedError(error) {
    if (error instanceof Error && error.message.toLowerCase().includes("document is not focused")) {
        toastMessage('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', "warn");
        return true;
    }
    return false;
}
async function actionGlobalCopyState(pinia) {
    if (checkClipboardAccess()) return;
    try {
        await navigator.clipboard.writeText(JSON.stringify(pinia.state.value));
        toastMessage("Global state copied to clipboard.");
    } catch (error) {
        if (checkNotFocusedError(error)) return;
        toastMessage(`Failed to serialize the state. Check the console for more details.`, "error");
        console.error(error);
    }
}
async function actionGlobalPasteState(pinia) {
    if (checkClipboardAccess()) return;
    try {
        loadStoresState(pinia, JSON.parse(await navigator.clipboard.readText()));
        toastMessage("Global state pasted from clipboard.");
    } catch (error) {
        if (checkNotFocusedError(error)) return;
        toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, "error");
        console.error(error);
    }
}
async function actionGlobalSaveState(pinia) {
    try {
        saveAs(new Blob([
            JSON.stringify(pinia.state.value)
        ], {
            type: "text/plain;charset=utf-8"
        }), "pinia-state.json");
    } catch (error) {
        toastMessage(`Failed to export the state as JSON. Check the console for more details.`, "error");
        console.error(error);
    }
}
let fileInput;
function getFileOpener() {
    if (!fileInput) {
        fileInput = document.createElement("input");
        fileInput.type = "file";
        fileInput.accept = ".json";
    }
    function openFile() {
        return new Promise((resolve, reject)=>{
            fileInput.onchange = async ()=>{
                const files = fileInput.files;
                if (!files) return resolve(null);
                const file = files.item(0);
                if (!file) return resolve(null);
                return resolve({
                    text: await file.text(),
                    file
                });
            };
            // @ts-ignore: TODO: changed from 4.3 to 4.4
            fileInput.oncancel = ()=>resolve(null);
            fileInput.onerror = reject;
            fileInput.click();
        });
    }
    return openFile;
}
async function actionGlobalOpenStateFile(pinia) {
    try {
        const open1 = getFileOpener();
        const result = await open1();
        if (!result) return;
        const { text , file  } = result;
        loadStoresState(pinia, JSON.parse(text));
        toastMessage(`Global state imported from "${file.name}".`);
    } catch (error) {
        toastMessage(`Failed to import the state from JSON. Check the console for more details.`, "error");
        console.error(error);
    }
}
function loadStoresState(pinia, state) {
    for(const key in state){
        const storeState = pinia.state.value[key];
        // store is already instantiated, patch it
        if (storeState) Object.assign(storeState, state[key]);
        else // store is not instantiated, set the initial state
        pinia.state.value[key] = state[key];
    }
}
function formatDisplay(display) {
    return {
        _custom: {
            display
        }
    };
}
const PINIA_ROOT_LABEL = "\uD83C\uDF4D Pinia (root)";
const PINIA_ROOT_ID = "_root";
function formatStoreForInspectorTree(store) {
    return isPinia(store) ? {
        id: PINIA_ROOT_ID,
        label: PINIA_ROOT_LABEL
    } : {
        id: store.$id,
        label: store.$id
    };
}
function formatStoreForInspectorState(store) {
    if (isPinia(store)) {
        const storeNames = Array.from(store._s.keys());
        const storeMap = store._s;
        const state = {
            state: storeNames.map((storeId)=>({
                    editable: true,
                    key: storeId,
                    value: store.state.value[storeId]
                })),
            getters: storeNames.filter((id)=>storeMap.get(id)._getters).map((id)=>{
                const store = storeMap.get(id);
                return {
                    editable: false,
                    key: id,
                    value: store._getters.reduce((getters, key)=>{
                        getters[key] = store[key];
                        return getters;
                    }, {})
                };
            })
        };
        return state;
    }
    const state = {
        state: Object.keys(store.$state).map((key)=>({
                editable: true,
                key,
                value: store.$state[key]
            }))
    };
    // avoid adding empty getters
    if (store._getters && store._getters.length) state.getters = store._getters.map((getterName)=>({
            editable: false,
            key: getterName,
            value: store[getterName]
        }));
    if (store._customProperties.size) state.customProperties = Array.from(store._customProperties).map((key)=>({
            editable: true,
            key,
            value: store[key]
        }));
    return state;
}
function formatEventData(events) {
    if (!events) return {};
    if (Array.isArray(events)) // TODO: handle add and delete for arrays and objects
    return events.reduce((data, event)=>{
        data.keys.push(event.key);
        data.operations.push(event.type);
        data.oldValue[event.key] = event.oldValue;
        data.newValue[event.key] = event.newValue;
        return data;
    }, {
        oldValue: {},
        keys: [],
        operations: [],
        newValue: {}
    });
    else return {
        operation: formatDisplay(events.type),
        key: formatDisplay(events.key),
        oldValue: events.oldValue,
        newValue: events.newValue
    };
}
function formatMutationType(type) {
    switch(type){
        case MutationType.direct:
            return "mutation";
        case MutationType.patchFunction:
            return "$patch";
        case MutationType.patchObject:
            return "$patch";
        default:
            return "unknown";
    }
}
// timeline can be paused when directly changing the state
let isTimelineActive = true;
const componentStateTypes = [];
const MUTATIONS_LAYER_ID = "pinia:mutations";
const INSPECTOR_ID = "pinia";
const { assign: assign$1  } = Object;
/**
 * Gets the displayed name of a store in devtools
 *
 * @param id - id of the store
 * @returns a formatted string
 */ const getStoreType = (id)=>"\uD83C\uDF4D " + id;
/**
 * Add the pinia plugin without any store. Allows displaying a Pinia plugin tab
 * as soon as it is added to the application.
 *
 * @param app - Vue application
 * @param pinia - pinia instance
 */ function registerPiniaDevtools(app, pinia) {
    (0, _devtoolsApi.setupDevtoolsPlugin)({
        id: "dev.esm.pinia",
        label: "Pinia \uD83C\uDF4D",
        logo: "https://pinia.vuejs.org/logo.svg",
        packageName: "pinia",
        homepage: "https://pinia.vuejs.org",
        componentStateTypes,
        app
    }, (api)=>{
        if (typeof api.now !== "function") toastMessage("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.");
        api.addTimelineLayer({
            id: MUTATIONS_LAYER_ID,
            label: `Pinia \ud83c`,
            color: 0xe5df88
        });
        api.addInspector({
            id: INSPECTOR_ID,
            label: "Pinia \uD83C\uDF4D",
            icon: "storage",
            treeFilterPlaceholder: "Search stores",
            actions: [
                {
                    icon: "content_copy",
                    action: ()=>{
                        actionGlobalCopyState(pinia);
                    },
                    tooltip: "Serialize and copy the state"
                },
                {
                    icon: "content_paste",
                    action: async ()=>{
                        await actionGlobalPasteState(pinia);
                        api.sendInspectorTree(INSPECTOR_ID);
                        api.sendInspectorState(INSPECTOR_ID);
                    },
                    tooltip: "Replace the state with the content of your clipboard"
                },
                {
                    icon: "save",
                    action: ()=>{
                        actionGlobalSaveState(pinia);
                    },
                    tooltip: "Save the state as a JSON file"
                },
                {
                    icon: "folder_open",
                    action: async ()=>{
                        await actionGlobalOpenStateFile(pinia);
                        api.sendInspectorTree(INSPECTOR_ID);
                        api.sendInspectorState(INSPECTOR_ID);
                    },
                    tooltip: "Import the state from a JSON file"
                }
            ],
            nodeActions: [
                {
                    icon: "restore",
                    tooltip: 'Reset the state (with "$reset")',
                    action: (nodeId)=>{
                        const store = pinia._s.get(nodeId);
                        if (!store) toastMessage(`Cannot reset "${nodeId}" store because it wasn't found.`, "warn");
                        else if (typeof store.$reset !== "function") toastMessage(`Cannot reset "${nodeId}" store because it doesn't have a "$reset" method implemented.`, "warn");
                        else {
                            store.$reset();
                            toastMessage(`Store "${nodeId}" reset.`);
                        }
                    }
                }
            ]
        });
        api.on.inspectComponent((payload, ctx)=>{
            const proxy = payload.componentInstance && payload.componentInstance.proxy;
            if (proxy && proxy._pStores) {
                const piniaStores = payload.componentInstance.proxy._pStores;
                Object.values(piniaStores).forEach((store)=>{
                    payload.instanceData.state.push({
                        type: getStoreType(store.$id),
                        key: "state",
                        editable: true,
                        value: store._isOptionsAPI ? {
                            _custom: {
                                value: (0, _vueDemi.toRaw)(store.$state),
                                actions: [
                                    {
                                        icon: "restore",
                                        tooltip: "Reset the state of this store",
                                        action: ()=>store.$reset()
                                    }
                                ]
                            }
                        } : Object.keys(store.$state).reduce((state, key)=>{
                            state[key] = store.$state[key];
                            return state;
                        }, {})
                    });
                    if (store._getters && store._getters.length) payload.instanceData.state.push({
                        type: getStoreType(store.$id),
                        key: "getters",
                        editable: false,
                        value: store._getters.reduce((getters, key)=>{
                            try {
                                getters[key] = store[key];
                            } catch (error) {
                                // @ts-expect-error: we just want to show it in devtools
                                getters[key] = error;
                            }
                            return getters;
                        }, {})
                    });
                });
            }
        });
        api.on.getInspectorTree((payload)=>{
            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
                let stores = [
                    pinia
                ];
                stores = stores.concat(Array.from(pinia._s.values()));
                payload.rootNodes = (payload.filter ? stores.filter((store)=>"$id" in store ? store.$id.toLowerCase().includes(payload.filter.toLowerCase()) : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase())) : stores).map(formatStoreForInspectorTree);
            }
        });
        // Expose pinia instance as $pinia to window
        globalThis.$pinia = pinia;
        api.on.getInspectorState((payload)=>{
            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
                const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia : pinia._s.get(payload.nodeId);
                if (!inspectedStore) // this could be the selected store restored for a different project
                // so it's better not to say anything here
                return;
                if (inspectedStore) {
                    // Expose selected store as $store to window
                    if (payload.nodeId !== PINIA_ROOT_ID) globalThis.$store = (0, _vueDemi.toRaw)(inspectedStore);
                    payload.state = formatStoreForInspectorState(inspectedStore);
                }
            }
        });
        api.on.editInspectorState((payload, ctx)=>{
            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
                const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia : pinia._s.get(payload.nodeId);
                if (!inspectedStore) return toastMessage(`store "${payload.nodeId}" not found`, "error");
                const { path  } = payload;
                if (!isPinia(inspectedStore)) // access only the state
                {
                    if (path.length !== 1 || !inspectedStore._customProperties.has(path[0]) || path[0] in inspectedStore.$state) path.unshift("$state");
                } else // Root access, we can omit the `.value` because the devtools API does it for us
                path.unshift("state");
                isTimelineActive = false;
                payload.set(inspectedStore, path, payload.state.value);
                isTimelineActive = true;
            }
        });
        api.on.editComponentState((payload)=>{
            if (payload.type.startsWith("\uD83C\uDF4D")) {
                const storeId = payload.type.replace(/^\ud83c\s*/, "");
                const store = pinia._s.get(storeId);
                if (!store) return toastMessage(`store "${storeId}" not found`, "error");
                const { path  } = payload;
                if (path[0] !== "state") return toastMessage(`Invalid path for store "${storeId}":\n${path}\nOnly state can be modified.`);
                // rewrite the first entry to be able to directly set the state as
                // well as any other path
                path[0] = "$state";
                isTimelineActive = false;
                payload.set(store, path, payload.state.value);
                isTimelineActive = true;
            }
        });
    });
}
function addStoreToDevtools(app, store) {
    if (!componentStateTypes.includes(getStoreType(store.$id))) componentStateTypes.push(getStoreType(store.$id));
    (0, _devtoolsApi.setupDevtoolsPlugin)({
        id: "dev.esm.pinia",
        label: "Pinia \uD83C\uDF4D",
        logo: "https://pinia.vuejs.org/logo.svg",
        packageName: "pinia",
        homepage: "https://pinia.vuejs.org",
        componentStateTypes,
        app,
        settings: {
            logStoreChanges: {
                label: "Notify about new/deleted stores",
                type: "boolean",
                defaultValue: true
            }
        }
    }, (api)=>{
        // gracefully handle errors
        const now = typeof api.now === "function" ? api.now.bind(api) : Date.now;
        store.$onAction(({ after , onError , name , args  })=>{
            const groupId = runningActionId++;
            api.addTimelineEvent({
                layerId: MUTATIONS_LAYER_ID,
                event: {
                    time: now(),
                    title: "\uD83D\uDEEB " + name,
                    subtitle: "start",
                    data: {
                        store: formatDisplay(store.$id),
                        action: formatDisplay(name),
                        args
                    },
                    groupId
                }
            });
            after((result)=>{
                activeAction = undefined;
                api.addTimelineEvent({
                    layerId: MUTATIONS_LAYER_ID,
                    event: {
                        time: now(),
                        title: "\uD83D\uDEEC " + name,
                        subtitle: "end",
                        data: {
                            store: formatDisplay(store.$id),
                            action: formatDisplay(name),
                            args,
                            result
                        },
                        groupId
                    }
                });
            });
            onError((error)=>{
                activeAction = undefined;
                api.addTimelineEvent({
                    layerId: MUTATIONS_LAYER_ID,
                    event: {
                        time: now(),
                        logType: "error",
                        title: "\uD83D\uDCA5 " + name,
                        subtitle: "end",
                        data: {
                            store: formatDisplay(store.$id),
                            action: formatDisplay(name),
                            args,
                            error
                        },
                        groupId
                    }
                });
            });
        }, true);
        store._customProperties.forEach((name)=>{
            (0, _vueDemi.watch)(()=>(0, _vueDemi.unref)(store[name]), (newValue, oldValue)=>{
                api.notifyComponentUpdate();
                api.sendInspectorState(INSPECTOR_ID);
                if (isTimelineActive) api.addTimelineEvent({
                    layerId: MUTATIONS_LAYER_ID,
                    event: {
                        time: now(),
                        title: "Change",
                        subtitle: name,
                        data: {
                            newValue,
                            oldValue
                        },
                        groupId: activeAction
                    }
                });
            }, {
                deep: true
            });
        });
        store.$subscribe(({ events , type  }, state)=>{
            api.notifyComponentUpdate();
            api.sendInspectorState(INSPECTOR_ID);
            if (!isTimelineActive) return;
            // rootStore.state[store.id] = state
            const eventData = {
                time: now(),
                title: formatMutationType(type),
                data: assign$1({
                    store: formatDisplay(store.$id)
                }, formatEventData(events)),
                groupId: activeAction
            };
            if (type === MutationType.patchFunction) eventData.subtitle = "\u2935\ufe0f";
            else if (type === MutationType.patchObject) eventData.subtitle = "\uD83E\uDDE9";
            else if (events && !Array.isArray(events)) eventData.subtitle = events.type;
            if (events) eventData.data["rawEvent(s)"] = {
                _custom: {
                    display: "DebuggerEvent",
                    type: "object",
                    tooltip: "raw DebuggerEvent[]",
                    value: events
                }
            };
            api.addTimelineEvent({
                layerId: MUTATIONS_LAYER_ID,
                event: eventData
            });
        }, {
            detached: true,
            flush: "sync"
        });
        const hotUpdate = store._hotUpdate;
        store._hotUpdate = (0, _vueDemi.markRaw)((newStore)=>{
            hotUpdate(newStore);
            api.addTimelineEvent({
                layerId: MUTATIONS_LAYER_ID,
                event: {
                    time: now(),
                    title: "\uD83D\uDD25 " + store.$id,
                    subtitle: "HMR update",
                    data: {
                        store: formatDisplay(store.$id),
                        info: formatDisplay(`HMR update`)
                    }
                }
            });
            // update the devtools too
            api.notifyComponentUpdate();
            api.sendInspectorTree(INSPECTOR_ID);
            api.sendInspectorState(INSPECTOR_ID);
        });
        const { $dispose  } = store;
        store.$dispose = ()=>{
            $dispose();
            api.notifyComponentUpdate();
            api.sendInspectorTree(INSPECTOR_ID);
            api.sendInspectorState(INSPECTOR_ID);
            api.getSettings().logStoreChanges && toastMessage(`Disposed "${store.$id}" store \ud83d`);
        };
        // trigger an update so it can display new registered stores
        api.notifyComponentUpdate();
        api.sendInspectorTree(INSPECTOR_ID);
        api.sendInspectorState(INSPECTOR_ID);
        api.getSettings().logStoreChanges && toastMessage(`"${store.$id}" store installed \ud83c`);
    });
}
let runningActionId = 0;
let activeAction;
/**
 * Patches a store to enable action grouping in devtools by wrapping the store with a Proxy that is passed as the
 * context of all actions, allowing us to set `runningAction` on each access and effectively associating any state
 * mutation to the action.
 *
 * @param store - store to patch
 * @param actionNames - list of actionst to patch
 */ function patchActionForGrouping(store, actionNames, wrapWithProxy) {
    // original actions of the store as they are given by pinia. We are going to override them
    const actions = actionNames.reduce((storeActions, actionName)=>{
        // use toRaw to avoid tracking #541
        storeActions[actionName] = (0, _vueDemi.toRaw)(store)[actionName];
        return storeActions;
    }, {});
    for(const actionName in actions)store[actionName] = function() {
        // the running action id is incremented in a before action hook
        const _actionId = runningActionId;
        const trackedStore = wrapWithProxy ? new Proxy(store, {
            get (...args) {
                activeAction = _actionId;
                return Reflect.get(...args);
            },
            set (...args) {
                activeAction = _actionId;
                return Reflect.set(...args);
            }
        }) : store;
        // For Setup Stores we need https://github.com/tc39/proposal-async-context
        activeAction = _actionId;
        const retValue = actions[actionName].apply(trackedStore, arguments);
        // this is safer as async actions in Setup Stores would associate mutations done outside of the action
        activeAction = undefined;
        return retValue;
    };
}
/**
 * pinia.use(devtoolsPlugin)
 */ function devtoolsPlugin({ app , store , options  }) {
    // HMR module
    if (store.$id.startsWith("__hot:")) return;
    // detect option api vs setup api
    store._isOptionsAPI = !!options.state;
    // Do not overwrite actions mocked by @pinia/testing (#2298)
    if (!store._p._testing) {
        patchActionForGrouping(store, Object.keys(options.actions), store._isOptionsAPI);
        // Upgrade the HMR to also update the new actions
        const originalHotUpdate = store._hotUpdate;
        (0, _vueDemi.toRaw)(store)._hotUpdate = function(newStore) {
            originalHotUpdate.apply(this, arguments);
            patchActionForGrouping(store, Object.keys(newStore._hmrPayload.actions), !!store._isOptionsAPI);
        };
    }
    addStoreToDevtools(app, // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?
    store);
}
/**
 * Creates a Pinia instance to be used by the application
 */ function createPinia() {
    const scope = (0, _vueDemi.effectScope)(true);
    // NOTE: here we could check the window object for a state and directly set it
    // if there is anything like it with Vue 3 SSR
    const state = scope.run(()=>(0, _vueDemi.ref)({}));
    let _p = [];
    // plugins added before calling app.use(pinia)
    let toBeInstalled = [];
    const pinia = (0, _vueDemi.markRaw)({
        install (app) {
            // this allows calling useStore() outside of a component setup after
            // installing pinia's plugin
            setActivePinia(pinia);
            if (!(0, _vueDemi.isVue2)) {
                pinia._a = app;
                app.provide(piniaSymbol, pinia);
                app.config.globalProperties.$pinia = pinia;
                /* istanbul ignore else */ if (IS_CLIENT) registerPiniaDevtools(app, pinia);
                toBeInstalled.forEach((plugin)=>_p.push(plugin));
                toBeInstalled = [];
            }
        },
        use (plugin) {
            if (!this._a && !(0, _vueDemi.isVue2)) toBeInstalled.push(plugin);
            else _p.push(plugin);
            return this;
        },
        _p,
        // it's actually undefined here
        // @ts-expect-error
        _a: null,
        _e: scope,
        _s: new Map(),
        state
    });
    // pinia devtools rely on dev only features so they cannot be forced unless
    // the dev build of Vue is used. Avoid old browsers like IE11.
    if (IS_CLIENT && typeof Proxy !== "undefined") pinia.use(devtoolsPlugin);
    return pinia;
}
/**
 * Dispose a Pinia instance by stopping its effectScope and removing the state, plugins and stores. This is mostly
 * useful in tests, with both a testing pinia or a regular pinia and in applications that use multiple pinia instances.
 * Once disposed, the pinia instance cannot be used anymore.
 *
 * @param pinia - pinia instance
 */ function disposePinia(pinia) {
    pinia._e.stop();
    pinia._s.clear();
    pinia._p.splice(0);
    pinia.state.value = {};
    // @ts-expect-error: non valid
    pinia._a = null;
}
/**
 * Checks if a function is a `StoreDefinition`.
 *
 * @param fn - object to test
 * @returns true if `fn` is a StoreDefinition
 */ const isUseStore = (fn)=>{
    return typeof fn === "function" && typeof fn.$id === "string";
};
/**
 * Mutates in place `newState` with `oldState` to _hot update_ it. It will
 * remove any key not existing in `newState` and recursively merge plain
 * objects.
 *
 * @param newState - new state object to be patched
 * @param oldState - old state that should be used to patch newState
 * @returns - newState
 */ function patchObject(newState, oldState) {
    // no need to go through symbols because they cannot be serialized anyway
    for(const key in oldState){
        const subPatch = oldState[key];
        // skip the whole sub tree
        if (!(key in newState)) continue;
        const targetValue = newState[key];
        if (isPlainObject(targetValue) && isPlainObject(subPatch) && !(0, _vueDemi.isRef)(subPatch) && !(0, _vueDemi.isReactive)(subPatch)) newState[key] = patchObject(targetValue, subPatch);
        else // objects are either a bit more complex (e.g. refs) or primitives, so we
        // just set the whole thing
        if (0, _vueDemi.isVue2) (0, _vueDemi.set)(newState, key, subPatch);
        else newState[key] = subPatch;
    }
    return newState;
}
/**
 * Creates an _accept_ function to pass to `import.meta.hot` in Vite applications.
 *
 * @example
 * ```js
 * const useUser = defineStore(...)
 * if (import.meta.hot) {
 *   import.meta.hot.accept(acceptHMRUpdate(useUser, import.meta.hot))
 * }
 * ```
 *
 * @param initialUseStore - return of the defineStore to hot update
 * @param hot - `import.meta.hot`
 */ function acceptHMRUpdate(initialUseStore, hot) {
    return (newModule)=>{
        const pinia = hot.data.pinia || initialUseStore._pinia;
        if (!pinia) // this store is still not used
        return;
        // preserve the pinia instance across loads
        hot.data.pinia = pinia;
        // console.log('got data', newStore)
        for(const exportName in newModule){
            const useStore = newModule[exportName];
            // console.log('checking for', exportName)
            if (isUseStore(useStore) && pinia._s.has(useStore.$id)) {
                // console.log('Accepting update for', useStore.$id)
                const id = useStore.$id;
                if (id !== initialUseStore.$id) {
                    console.warn(`The id of the store changed from "${initialUseStore.$id}" to "${id}". Reloading.`);
                    // return import.meta.hot.invalidate()
                    return hot.invalidate();
                }
                const existingStore = pinia._s.get(id);
                if (!existingStore) {
                    console.log(`[Pinia]: skipping hmr because store doesn't exist yet`);
                    return;
                }
                useStore(pinia, existingStore);
            }
        }
    };
}
const noop = ()=>{};
function addSubscription(subscriptions, callback, detached, onCleanup = noop) {
    subscriptions.push(callback);
    const removeSubscription = ()=>{
        const idx = subscriptions.indexOf(callback);
        if (idx > -1) {
            subscriptions.splice(idx, 1);
            onCleanup();
        }
    };
    if (!detached && (0, _vueDemi.getCurrentScope)()) (0, _vueDemi.onScopeDispose)(removeSubscription);
    return removeSubscription;
}
function triggerSubscriptions(subscriptions, ...args) {
    subscriptions.slice().forEach((callback)=>{
        callback(...args);
    });
}
const fallbackRunWithContext = (fn)=>fn();
/**
 * Marks a function as an action for `$onAction`
 * @internal
 */ const ACTION_MARKER = Symbol();
/**
 * Action name symbol. Allows to add a name to an action after defining it
 * @internal
 */ const ACTION_NAME = Symbol();
function mergeReactiveObjects(target, patchToApply) {
    // Handle Map instances
    if (target instanceof Map && patchToApply instanceof Map) patchToApply.forEach((value, key)=>target.set(key, value));
    else if (target instanceof Set && patchToApply instanceof Set) // Handle Set instances
    patchToApply.forEach(target.add, target);
    // no need to go through symbols because they cannot be serialized anyway
    for(const key in patchToApply){
        if (!patchToApply.hasOwnProperty(key)) continue;
        const subPatch = patchToApply[key];
        const targetValue = target[key];
        if (isPlainObject(targetValue) && isPlainObject(subPatch) && target.hasOwnProperty(key) && !(0, _vueDemi.isRef)(subPatch) && !(0, _vueDemi.isReactive)(subPatch)) // NOTE: here I wanted to warn about inconsistent types but it's not possible because in setup stores one might
        // start the value of a property as a certain type e.g. a Map, and then for some reason, during SSR, change that
        // to `undefined`. When trying to hydrate, we want to override the Map with `undefined`.
        target[key] = mergeReactiveObjects(targetValue, subPatch);
        else // @ts-expect-error: subPatch is a valid value
        target[key] = subPatch;
    }
    return target;
}
const skipHydrateSymbol = Symbol("pinia:skipHydration");
/**
 * Tells Pinia to skip the hydration process of a given object. This is useful in setup stores (only) when you return a
 * stateful object in the store but it isn't really state. e.g. returning a router instance in a setup store.
 *
 * @param obj - target object
 * @returns obj
 */ function skipHydrate(obj) {
    return Object.defineProperty(obj, skipHydrateSymbol, {});
}
/**
 * Returns whether a value should be hydrated
 *
 * @param obj - target variable
 * @returns true if `obj` should be hydrated
 */ function shouldHydrate(obj) {
    return !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
}
const { assign  } = Object;
function isComputed(o) {
    return !!((0, _vueDemi.isRef)(o) && o.effect);
}
function createOptionsStore(id, options, pinia, hot) {
    const { state , actions , getters  } = options;
    const initialState = pinia.state.value[id];
    let store;
    function setup() {
        if (!initialState && !hot) {
            /* istanbul ignore if */ if (0, _vueDemi.isVue2) (0, _vueDemi.set)(pinia.state.value, id, state ? state() : {});
            else pinia.state.value[id] = state ? state() : {};
        }
        // avoid creating a state in pinia.state.value
        const localState = hot ? (0, _vueDemi.toRefs)((0, _vueDemi.ref)(state ? state() : {}).value) : (0, _vueDemi.toRefs)(pinia.state.value[id]);
        return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name)=>{
            if (name in localState) console.warn(`[\ud83c]: A getter cannot have the same name as another state property. Rename one of them. Found with "${name}" in store "${id}".`);
            computedGetters[name] = (0, _vueDemi.markRaw)((0, _vueDemi.computed)(()=>{
                setActivePinia(pinia);
                // it was created just before
                const store = pinia._s.get(id);
                // allow cross using stores
                /* istanbul ignore if */ if ((0, _vueDemi.isVue2) && !store._r) return;
                // @ts-expect-error
                // return getters![name].call(context, context)
                // TODO: avoid reading the getter while assigning with a global variable
                return getters[name].call(store, store);
            }));
            return computedGetters;
        }, {}));
    }
    store = createSetupStore(id, setup, options, pinia, hot, true);
    return store;
}
function createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {
    let scope;
    const optionsForPlugin = assign({
        actions: {}
    }, options);
    /* istanbul ignore if */ if (!pinia._e.active) throw new Error("Pinia destroyed");
    // watcher options for $subscribe
    const $subscribeOptions = {
        deep: true
    };
    /* istanbul ignore else */ if (!(0, _vueDemi.isVue2)) $subscribeOptions.onTrigger = (event)=>{
        /* istanbul ignore else */ if (isListening) debuggerEvents = event;
        else if (isListening == false && !store._hotUpdating) {
            // let patch send all the events together later
            /* istanbul ignore else */ if (Array.isArray(debuggerEvents)) debuggerEvents.push(event);
            else console.error("\uD83C\uDF4D debuggerEvents should be an array. This is most likely an internal Pinia bug.");
        }
    };
    // internal state
    let isListening; // set to true at the end
    let isSyncListening; // set to true at the end
    let subscriptions = [];
    let actionSubscriptions = [];
    let debuggerEvents;
    const initialState = pinia.state.value[$id];
    // avoid setting the state for option stores if it is set
    // by the setup
    if (!isOptionsStore && !initialState && !hot) {
        /* istanbul ignore if */ if (0, _vueDemi.isVue2) (0, _vueDemi.set)(pinia.state.value, $id, {});
        else pinia.state.value[$id] = {};
    }
    const hotState = (0, _vueDemi.ref)({});
    // avoid triggering too many listeners
    // https://github.com/vuejs/pinia/issues/1129
    let activeListener;
    function $patch(partialStateOrMutator) {
        let subscriptionMutation;
        isListening = isSyncListening = false;
        debuggerEvents = [];
        if (typeof partialStateOrMutator === "function") {
            partialStateOrMutator(pinia.state.value[$id]);
            subscriptionMutation = {
                type: MutationType.patchFunction,
                storeId: $id,
                events: debuggerEvents
            };
        } else {
            mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);
            subscriptionMutation = {
                type: MutationType.patchObject,
                payload: partialStateOrMutator,
                storeId: $id,
                events: debuggerEvents
            };
        }
        const myListenerId = activeListener = Symbol();
        (0, _vueDemi.nextTick)().then(()=>{
            if (activeListener === myListenerId) isListening = true;
        });
        isSyncListening = true;
        // because we paused the watcher, we need to manually call the subscriptions
        triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);
    }
    const $reset = isOptionsStore ? function $reset() {
        const { state  } = options;
        const newState = state ? state() : {};
        // we use a patch to group all changes into one single subscription
        this.$patch(($state)=>{
            // @ts-expect-error: FIXME: shouldn't error?
            assign($state, newState);
        });
    } : ()=>{
        throw new Error(`\ud83c: Store "${$id}" is built using the setup syntax and does not implement $reset().`);
    };
    function $dispose() {
        scope.stop();
        subscriptions = [];
        actionSubscriptions = [];
        pinia._s.delete($id);
    }
    /**
     * Helper that wraps function so it can be tracked with $onAction
     * @param fn - action to wrap
     * @param name - name of the action
     */ const action = (fn, name = "")=>{
        if (ACTION_MARKER in fn) {
            fn[ACTION_NAME] = name;
            return fn;
        }
        const wrappedAction = function() {
            setActivePinia(pinia);
            const args = Array.from(arguments);
            const afterCallbackList = [];
            const onErrorCallbackList = [];
            function after(callback) {
                afterCallbackList.push(callback);
            }
            function onError(callback) {
                onErrorCallbackList.push(callback);
            }
            // @ts-expect-error
            triggerSubscriptions(actionSubscriptions, {
                args,
                name: wrappedAction[ACTION_NAME],
                store,
                after,
                onError
            });
            let ret;
            try {
                ret = fn.apply(this && this.$id === $id ? this : store, args);
            // handle sync errors
            } catch (error) {
                triggerSubscriptions(onErrorCallbackList, error);
                throw error;
            }
            if (ret instanceof Promise) return ret.then((value)=>{
                triggerSubscriptions(afterCallbackList, value);
                return value;
            }).catch((error)=>{
                triggerSubscriptions(onErrorCallbackList, error);
                return Promise.reject(error);
            });
            // trigger after callbacks
            triggerSubscriptions(afterCallbackList, ret);
            return ret;
        };
        wrappedAction[ACTION_MARKER] = true;
        wrappedAction[ACTION_NAME] = name; // will be set later
        // @ts-expect-error: we are intentionally limiting the returned type to just Fn
        // because all the added properties are internals that are exposed through `$onAction()` only
        return wrappedAction;
    };
    const _hmrPayload = /*#__PURE__*/ (0, _vueDemi.markRaw)({
        actions: {},
        getters: {},
        state: [],
        hotState
    });
    const partialStore = {
        _p: pinia,
        // _s: scope,
        $id,
        $onAction: addSubscription.bind(null, actionSubscriptions),
        $patch,
        $reset,
        $subscribe (callback, options = {}) {
            const removeSubscription = addSubscription(subscriptions, callback, options.detached, ()=>stopWatcher());
            const stopWatcher = scope.run(()=>(0, _vueDemi.watch)(()=>pinia.state.value[$id], (state)=>{
                    if (options.flush === "sync" ? isSyncListening : isListening) callback({
                        storeId: $id,
                        type: MutationType.direct,
                        events: debuggerEvents
                    }, state);
                }, assign({}, $subscribeOptions, options)));
            return removeSubscription;
        },
        $dispose
    };
    /* istanbul ignore if */ if (0, _vueDemi.isVue2) // start as non ready
    partialStore._r = false;
    const store = (0, _vueDemi.reactive)(assign({
        _hmrPayload,
        _customProperties: (0, _vueDemi.markRaw)(new Set())
    }, partialStore));
    // store the partial store now so the setup of stores can instantiate each other before they are finished without
    // creating infinite loops.
    pinia._s.set($id, store);
    const runWithContext = pinia._a && pinia._a.runWithContext || fallbackRunWithContext;
    // TODO: idea create skipSerialize that marks properties as non serializable and they are skipped
    const setupStore = runWithContext(()=>pinia._e.run(()=>(scope = (0, _vueDemi.effectScope)()).run(()=>setup({
                    action
                }))));
    // overwrite existing actions to support $onAction
    for(const key in setupStore){
        const prop = setupStore[key];
        if ((0, _vueDemi.isRef)(prop) && !isComputed(prop) || (0, _vueDemi.isReactive)(prop)) {
            // mark it as a piece of state to be serialized
            if (hot) (0, _vueDemi.set)(hotState.value, key, (0, _vueDemi.toRef)(setupStore, key));
            else if (!isOptionsStore) {
                // in setup stores we must hydrate the state and sync pinia state tree with the refs the user just created
                if (initialState && shouldHydrate(prop)) {
                    if ((0, _vueDemi.isRef)(prop)) prop.value = initialState[key];
                    else // probably a reactive object, lets recursively assign
                    // @ts-expect-error: prop is unknown
                    mergeReactiveObjects(prop, initialState[key]);
                }
                // transfer the ref to the pinia state to keep everything in sync
                /* istanbul ignore if */ if (0, _vueDemi.isVue2) (0, _vueDemi.set)(pinia.state.value[$id], key, prop);
                else pinia.state.value[$id][key] = prop;
            }
            _hmrPayload.state.push(key);
        // action
        } else if (typeof prop === "function") {
            const actionValue = hot ? prop : action(prop, key);
            // this a hot module replacement store because the hotUpdate method needs
            // to do it with the right context
            /* istanbul ignore if */ if (0, _vueDemi.isVue2) (0, _vueDemi.set)(setupStore, key, actionValue);
            else // @ts-expect-error
            setupStore[key] = actionValue;
            _hmrPayload.actions[key] = prop;
            // list actions so they can be used in plugins
            // @ts-expect-error
            optionsForPlugin.actions[key] = prop;
        } else // add getters for devtools
        if (isComputed(prop)) {
            _hmrPayload.getters[key] = isOptionsStore ? options.getters[key] : prop;
            if (IS_CLIENT) {
                const getters = setupStore._getters || // @ts-expect-error: same
                (setupStore._getters = (0, _vueDemi.markRaw)([]));
                getters.push(key);
            }
        }
    }
    // add the state, getters, and action properties
    /* istanbul ignore if */ if (0, _vueDemi.isVue2) Object.keys(setupStore).forEach((key)=>{
        (0, _vueDemi.set)(store, key, setupStore[key]);
    });
    else {
        assign(store, setupStore);
        // allows retrieving reactive objects with `storeToRefs()`. Must be called after assigning to the reactive object.
        // Make `storeToRefs()` work with `reactive()` #799
        assign((0, _vueDemi.toRaw)(store), setupStore);
    }
    // use this instead of a computed with setter to be able to create it anywhere
    // without linking the computed lifespan to wherever the store is first
    // created.
    Object.defineProperty(store, "$state", {
        get: ()=>hot ? hotState.value : pinia.state.value[$id],
        set: (state)=>{
            /* istanbul ignore if */ if (hot) throw new Error("cannot set hotState");
            $patch(($state)=>{
                // @ts-expect-error: FIXME: shouldn't error?
                assign($state, state);
            });
        }
    });
    store._hotUpdate = (0, _vueDemi.markRaw)((newStore)=>{
        store._hotUpdating = true;
        newStore._hmrPayload.state.forEach((stateKey)=>{
            if (stateKey in store.$state) {
                const newStateTarget = newStore.$state[stateKey];
                const oldStateSource = store.$state[stateKey];
                if (typeof newStateTarget === "object" && isPlainObject(newStateTarget) && isPlainObject(oldStateSource)) patchObject(newStateTarget, oldStateSource);
                else // transfer the ref
                newStore.$state[stateKey] = oldStateSource;
            }
            // patch direct access properties to allow store.stateProperty to work as
            // store.$state.stateProperty
            (0, _vueDemi.set)(store, stateKey, (0, _vueDemi.toRef)(newStore.$state, stateKey));
        });
        // remove deleted state properties
        Object.keys(store.$state).forEach((stateKey)=>{
            if (!(stateKey in newStore.$state)) (0, _vueDemi.del)(store, stateKey);
        });
        // avoid devtools logging this as a mutation
        isListening = false;
        isSyncListening = false;
        pinia.state.value[$id] = (0, _vueDemi.toRef)(newStore._hmrPayload, "hotState");
        isSyncListening = true;
        (0, _vueDemi.nextTick)().then(()=>{
            isListening = true;
        });
        for(const actionName in newStore._hmrPayload.actions){
            const actionFn = newStore[actionName];
            (0, _vueDemi.set)(store, actionName, action(actionFn, actionName));
        }
        // TODO: does this work in both setup and option store?
        for(const getterName in newStore._hmrPayload.getters){
            const getter = newStore._hmrPayload.getters[getterName];
            const getterValue = isOptionsStore ? (0, _vueDemi.computed)(()=>{
                setActivePinia(pinia);
                return getter.call(store, store);
            }) : getter;
            (0, _vueDemi.set)(store, getterName, getterValue);
        }
        // remove deleted getters
        Object.keys(store._hmrPayload.getters).forEach((key)=>{
            if (!(key in newStore._hmrPayload.getters)) (0, _vueDemi.del)(store, key);
        });
        // remove old actions
        Object.keys(store._hmrPayload.actions).forEach((key)=>{
            if (!(key in newStore._hmrPayload.actions)) (0, _vueDemi.del)(store, key);
        });
        // update the values used in devtools and to allow deleting new properties later on
        store._hmrPayload = newStore._hmrPayload;
        store._getters = newStore._getters;
        store._hotUpdating = false;
    });
    if (IS_CLIENT) {
        const nonEnumerable = {
            writable: true,
            configurable: true,
            // avoid warning on devtools trying to display this property
            enumerable: false
        };
        [
            "_p",
            "_hmrPayload",
            "_getters",
            "_customProperties"
        ].forEach((p)=>{
            Object.defineProperty(store, p, assign({
                value: store[p]
            }, nonEnumerable));
        });
    }
    /* istanbul ignore if */ if (0, _vueDemi.isVue2) // mark the store as ready before plugins
    store._r = true;
    // apply all plugins
    pinia._p.forEach((extender)=>{
        /* istanbul ignore else */ if (IS_CLIENT) {
            const extensions = scope.run(()=>extender({
                    store: store,
                    app: pinia._a,
                    pinia,
                    options: optionsForPlugin
                }));
            Object.keys(extensions || {}).forEach((key)=>store._customProperties.add(key));
            assign(store, extensions);
        } else assign(store, scope.run(()=>extender({
                store: store,
                app: pinia._a,
                pinia,
                options: optionsForPlugin
            })));
    });
    if ((0, store.$state) && typeof store.$state === "object" && typeof store.$state.constructor === "function" && !store.$state.constructor.toString().includes("[native code]")) console.warn(`[\ud83c]: The "state" must be a plain object. It cannot be\n` + `\tstate: () => new MyClass()\n` + `Found in store "${store.$id}".`);
    // only apply hydrate to option stores with an initial state in pinia
    if (initialState && isOptionsStore && options.hydrate) options.hydrate(store.$state, initialState);
    isListening = true;
    isSyncListening = true;
    return store;
}
// allows unused stores to be tree shaken
/*! #__NO_SIDE_EFFECTS__ */ function defineStore(// TODO: add proper types from above
idOrOptions, setup, setupOptions) {
    let id;
    let options;
    const isSetupStore = typeof setup === "function";
    if (typeof idOrOptions === "string") {
        id = idOrOptions;
        // the option store setup will contain the actual options in this case
        options = isSetupStore ? setupOptions : setup;
    } else {
        options = idOrOptions;
        id = idOrOptions.id;
        if (typeof id !== "string") throw new Error(`[\ud83c]: "defineStore()" must be passed a store id as its first argument.`);
    }
    function useStore(pinia, hot) {
        const hasContext = (0, _vueDemi.hasInjectionContext)();
        pinia = pinia || (hasContext ? (0, _vueDemi.inject)(piniaSymbol, null) : null);
        if (pinia) setActivePinia(pinia);
        if (!activePinia) throw new Error(`[\ud83c]: "getActivePinia()" was called but there was no active Pinia. Are you trying to use a store before calling "app.use(pinia)"?\n` + `See https://pinia.vuejs.org/core-concepts/outside-component-usage.html for help.\n` + `This will fail in production.`);
        pinia = activePinia;
        if (!pinia._s.has(id)) {
            // creating the store registers it in `pinia._s`
            if (isSetupStore) createSetupStore(id, setup, options, pinia);
            else createOptionsStore(id, options, pinia);
            // @ts-expect-error: not the right inferred type
            useStore._pinia = pinia;
        }
        const store = pinia._s.get(id);
        if (hot) {
            const hotId = "__hot:" + id;
            const newStore = isSetupStore ? createSetupStore(hotId, setup, options, pinia, true) : createOptionsStore(hotId, assign({}, options), pinia, true);
            hot._hotUpdate(newStore);
            // cleanup the state properties and the store from the cache
            delete pinia.state.value[hotId];
            pinia._s.delete(hotId);
        }
        if (IS_CLIENT) {
            const currentInstance = (0, _vueDemi.getCurrentInstance)();
            // save stores in instances to access them devtools
            if (currentInstance && currentInstance.proxy && // avoid adding stores that are just built for hot module replacement
            !hot) {
                const vm = currentInstance.proxy;
                const cache = "_pStores" in vm ? vm._pStores : vm._pStores = {};
                cache[id] = store;
            }
        }
        // StoreGeneric cannot be casted towards Store
        return store;
    }
    useStore.$id = id;
    return useStore;
}
let mapStoreSuffix = "Store";
/**
 * Changes the suffix added by `mapStores()`. Can be set to an empty string.
 * Defaults to `"Store"`. Make sure to extend the MapStoresCustomization
 * interface if you are using TypeScript.
 *
 * @param suffix - new suffix
 */ function setMapStoreSuffix(suffix // could be 'Store' but that would be annoying for JS
) {
    mapStoreSuffix = suffix;
}
/**
 * Allows using stores without the composition API (`setup()`) by generating an
 * object to be spread in the `computed` field of a component. It accepts a list
 * of store definitions.
 *
 * @example
 * ```js
 * export default {
 *   computed: {
 *     // other computed properties
 *     ...mapStores(useUserStore, useCartStore)
 *   },
 *
 *   created() {
 *     this.userStore // store with id "user"
 *     this.cartStore // store with id "cart"
 *   }
 * }
 * ```
 *
 * @param stores - list of stores to map to an object
 */ function mapStores(...stores) {
    if (Array.isArray(stores[0])) {
        console.warn(`[\ud83c]: Directly pass all stores to "mapStores()" without putting them in an array:\n` + `Replace\n` + `\tmapStores([useAuthStore, useCartStore])\n` + `with\n` + `\tmapStores(useAuthStore, useCartStore)\n` + `This will fail in production if not fixed.`);
        stores = stores[0];
    }
    return stores.reduce((reduced, useStore)=>{
        // @ts-expect-error: $id is added by defineStore
        reduced[useStore.$id + mapStoreSuffix] = function() {
            return useStore(this.$pinia);
        };
        return reduced;
    }, {});
}
/**
 * Allows using state and getters from one store without using the composition
 * API (`setup()`) by generating an object to be spread in the `computed` field
 * of a component.
 *
 * @param useStore - store to map from
 * @param keysOrMapper - array or object
 */ function mapState(useStore, keysOrMapper) {
    return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key)=>{
        reduced[key] = function() {
            // @ts-expect-error: FIXME: should work?
            return useStore(this.$pinia)[key];
        };
        return reduced;
    }, {}) : Object.keys(keysOrMapper).reduce((reduced, key)=>{
        // @ts-expect-error
        reduced[key] = function() {
            const store = useStore(this.$pinia);
            const storeKey = keysOrMapper[key];
            // for some reason TS is unable to infer the type of storeKey to be a
            // function
            return typeof storeKey === "function" ? storeKey.call(this, store) : store[storeKey];
        };
        return reduced;
    }, {});
}
/**
 * Alias for `mapState()`. You should use `mapState()` instead.
 * @deprecated use `mapState()` instead.
 */ const mapGetters = mapState;
/**
 * Allows directly using actions from your store without using the composition
 * API (`setup()`) by generating an object to be spread in the `methods` field
 * of a component.
 *
 * @param useStore - store to map from
 * @param keysOrMapper - array or object
 */ function mapActions(useStore, keysOrMapper) {
    return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key)=>{
        // @ts-expect-error
        reduced[key] = function(...args) {
            // @ts-expect-error: FIXME: should work?
            return useStore(this.$pinia)[key](...args);
        };
        return reduced;
    }, {}) : Object.keys(keysOrMapper).reduce((reduced, key)=>{
        // @ts-expect-error
        reduced[key] = function(...args) {
            // @ts-expect-error: FIXME: should work?
            return useStore(this.$pinia)[keysOrMapper[key]](...args);
        };
        return reduced;
    }, {});
}
/**
 * Allows using state and getters from one store without using the composition
 * API (`setup()`) by generating an object to be spread in the `computed` field
 * of a component.
 *
 * @param useStore - store to map from
 * @param keysOrMapper - array or object
 */ function mapWritableState(useStore, keysOrMapper) {
    return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key)=>{
        reduced[key] = {
            get () {
                return useStore(this.$pinia)[key];
            },
            set (value) {
                return useStore(this.$pinia)[key] = value;
            }
        };
        return reduced;
    }, {}) : Object.keys(keysOrMapper).reduce((reduced, key)=>{
        reduced[key] = {
            get () {
                return useStore(this.$pinia)[keysOrMapper[key]];
            },
            set (value) {
                return useStore(this.$pinia)[keysOrMapper[key]] = value;
            }
        };
        return reduced;
    }, {});
}
/**
 * Creates an object of references with all the state, getters, and plugin-added
 * state properties of the store. Similar to `toRefs()` but specifically
 * designed for Pinia stores so methods and non reactive properties are
 * completely ignored.
 *
 * @param store - store to extract the refs from
 */ function storeToRefs(store) {
    // See https://github.com/vuejs/pinia/issues/852
    // It's easier to just use toRefs() even if it includes more stuff
    if (0, _vueDemi.isVue2) // @ts-expect-error: toRefs include methods and others
    return (0, _vueDemi.toRefs)(store);
    else {
        const rawStore = (0, _vueDemi.toRaw)(store);
        const refs = {};
        for(const key in rawStore){
            const value = rawStore[key];
            // There is no native method to check for a computed
            // https://github.com/vuejs/core/pull/4165
            if (value.effect) // @ts-expect-error: too hard to type correctly
            refs[key] = // ...
            (0, _vueDemi.computed)({
                get: ()=>store[key],
                set (value) {
                    store[key] = value;
                }
            });
            else if ((0, _vueDemi.isRef)(value) || (0, _vueDemi.isReactive)(value)) // @ts-expect-error: the key is state or getter
            refs[key] = // ---
            (0, _vueDemi.toRef)(store, key);
        }
        return refs;
    }
}
/**
 * Vue 2 Plugin that must be installed for pinia to work. Note **you don't need
 * this plugin if you are using Nuxt.js**. Use the `buildModule` instead:
 * https://pinia.vuejs.org/ssr/nuxt.html.
 *
 * @example
 * ```js
 * import Vue from 'vue'
 * import { PiniaVuePlugin, createPinia } from 'pinia'
 *
 * Vue.use(PiniaVuePlugin)
 * const pinia = createPinia()
 *
 * new Vue({
 *   el: '#app',
 *   // ...
 *   pinia,
 * })
 * ```
 *
 * @param _Vue - `Vue` imported from 'vue'.
 */ const PiniaVuePlugin = function(_Vue) {
    // Equivalent of
    // app.config.globalProperties.$pinia = pinia
    _Vue.mixin({
        beforeCreate () {
            const options = this.$options;
            if (options.pinia) {
                const pinia = options.pinia;
                // HACK: taken from provide(): https://github.com/vuejs/composition-api/blob/main/src/apis/inject.ts#L31
                /* istanbul ignore else */ if (!this._provided) {
                    const provideCache = {};
                    Object.defineProperty(this, "_provided", {
                        get: ()=>provideCache,
                        set: (v)=>Object.assign(provideCache, v)
                    });
                }
                this._provided[piniaSymbol] = pinia;
                // propagate the pinia instance in an SSR friendly way
                // avoid adding it to nuxt twice
                /* istanbul ignore else */ if (!this.$pinia) this.$pinia = pinia;
                pinia._a = this;
                if (IS_CLIENT) // this allows calling useStore() outside of a component setup after
                // installing pinia's plugin
                setActivePinia(pinia);
                if (IS_CLIENT) registerPiniaDevtools(pinia._a, pinia);
            } else if (!this.$pinia && options.parent && options.parent.$pinia) this.$pinia = options.parent.$pinia;
        },
        destroyed () {
            delete this._pStores;
        }
    });
};

},{"vue-demi":"1O62H","@vue/devtools-api":"6123S","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"1O62H":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "set", ()=>set);
parcelHelpers.export(exports, "del", ()=>del);
parcelHelpers.export(exports, "Vue", ()=>_vue);
parcelHelpers.export(exports, "Vue2", ()=>Vue2);
parcelHelpers.export(exports, "isVue2", ()=>isVue2);
parcelHelpers.export(exports, "isVue3", ()=>isVue3);
parcelHelpers.export(exports, "install", ()=>install);
var _vue = require("vue");
parcelHelpers.exportAll(_vue, exports);
var isVue2 = false;
var isVue3 = true;
var Vue2 = undefined;
function install() {}
function set(target, key, val) {
    if (Array.isArray(target)) {
        target.length = Math.max(target.length, key);
        target.splice(key, 1, val);
        return val;
    }
    target[key] = val;
    return val;
}
function del(target, key) {
    if (Array.isArray(target)) {
        target.splice(key, 1);
        return;
    }
    delete target[key];
}

},{"vue":"dmrjI","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"6123S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setupDevtoolsPlugin", ()=>setupDevtoolsPlugin);
var _envJs = require("./env.js");
var _constJs = require("./const.js");
var _proxyJs = require("./proxy.js");
var _indexJs = require("./api/index.js");
parcelHelpers.exportAll(_indexJs, exports);
var _pluginJs = require("./plugin.js");
parcelHelpers.exportAll(_pluginJs, exports);
var _timeJs = require("./time.js");
parcelHelpers.exportAll(_timeJs, exports);
function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
    const descriptor = pluginDescriptor;
    const target = (0, _envJs.getTarget)();
    const hook = (0, _envJs.getDevtoolsGlobalHook)();
    const enableProxy = (0, _envJs.isProxyAvailable) && descriptor.enableEarlyProxy;
    if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) hook.emit((0, _constJs.HOOK_SETUP), pluginDescriptor, setupFn);
    else {
        const proxy = enableProxy ? new (0, _proxyJs.ApiProxy)(descriptor, hook) : null;
        const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
        list.push({
            pluginDescriptor: descriptor,
            setupFn,
            proxy
        });
        if (proxy) setupFn(proxy.proxiedTarget);
    }
}

},{"./env.js":"5Y878","./const.js":"iz9IK","./proxy.js":"gsc56","./api/index.js":false,"./plugin.js":false,"./time.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"5Y878":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getDevtoolsGlobalHook", ()=>getDevtoolsGlobalHook);
parcelHelpers.export(exports, "getTarget", ()=>getTarget);
parcelHelpers.export(exports, "isProxyAvailable", ()=>isProxyAvailable);
function getDevtoolsGlobalHook() {
    return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function getTarget() {
    // @ts-expect-error navigator and windows are not available in all environments
    return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : {};
}
const isProxyAvailable = typeof Proxy === "function";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"iz9IK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "HOOK_SETUP", ()=>HOOK_SETUP);
parcelHelpers.export(exports, "HOOK_PLUGIN_SETTINGS_SET", ()=>HOOK_PLUGIN_SETTINGS_SET);
const HOOK_SETUP = "devtools-plugin:setup";
const HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"gsc56":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ApiProxy", ()=>ApiProxy);
var _constJs = require("./const.js");
var _timeJs = require("./time.js");
class ApiProxy {
    constructor(plugin, hook){
        this.target = null;
        this.targetQueue = [];
        this.onQueue = [];
        this.plugin = plugin;
        this.hook = hook;
        const defaultSettings = {};
        if (plugin.settings) for(const id in plugin.settings){
            const item = plugin.settings[id];
            defaultSettings[id] = item.defaultValue;
        }
        const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
        let currentSettings = Object.assign({}, defaultSettings);
        try {
            const raw = localStorage.getItem(localSettingsSaveId);
            const data = JSON.parse(raw);
            Object.assign(currentSettings, data);
        } catch (e) {
        // noop
        }
        this.fallbacks = {
            getSettings () {
                return currentSettings;
            },
            setSettings (value) {
                try {
                    localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
                } catch (e) {
                // noop
                }
                currentSettings = value;
            },
            now () {
                return (0, _timeJs.now)();
            }
        };
        if (hook) hook.on((0, _constJs.HOOK_PLUGIN_SETTINGS_SET), (pluginId, value)=>{
            if (pluginId === this.plugin.id) this.fallbacks.setSettings(value);
        });
        this.proxiedOn = new Proxy({}, {
            get: (_target, prop)=>{
                if (this.target) return this.target.on[prop];
                else return (...args)=>{
                    this.onQueue.push({
                        method: prop,
                        args
                    });
                };
            }
        });
        this.proxiedTarget = new Proxy({}, {
            get: (_target, prop)=>{
                if (this.target) return this.target[prop];
                else if (prop === "on") return this.proxiedOn;
                else if (Object.keys(this.fallbacks).includes(prop)) return (...args)=>{
                    this.targetQueue.push({
                        method: prop,
                        args,
                        resolve: ()=>{}
                    });
                    return this.fallbacks[prop](...args);
                };
                else return (...args)=>{
                    return new Promise((resolve)=>{
                        this.targetQueue.push({
                            method: prop,
                            args,
                            resolve
                        });
                    });
                };
            }
        });
    }
    async setRealTarget(target) {
        this.target = target;
        for (const item of this.onQueue)this.target.on[item.method](...item.args);
        for (const item of this.targetQueue)item.resolve(await this.target[item.method](...item.args));
    }
}

},{"./const.js":"iz9IK","./time.js":"l4NYm","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"l4NYm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isPerformanceSupported", ()=>isPerformanceSupported);
parcelHelpers.export(exports, "now", ()=>now);
let supported;
let perf;
function isPerformanceSupported() {
    var _a;
    if (supported !== undefined) return supported;
    if (typeof window !== "undefined" && window.performance) {
        supported = true;
        perf = window.performance;
    } else if (typeof globalThis !== "undefined" && ((_a = globalThis.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {
        supported = true;
        perf = globalThis.perf_hooks.performance;
    } else supported = false;
    return supported;
}
function now() {
    return isPerformanceSupported() ? perf.now() : Date.now();
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"6q3A1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "$gettext", ()=>$gettext);
parcelHelpers.export(exports, "i18nPlugin", ()=>i18nPlugin);
function $gettext(text) {
    let res = "";
    try {
        const key = text.replace(/[^A-Za-z0-9_]/g, "_");
        res = chrome.i18n.getMessage(key) || text;
    } catch (e) {
        res = text;
    }
    return res;
}
const i18nPlugin = {
    install (app) {
        /* eslint-disable no-param-reassign */ app.config.globalProperties.$gettext = $gettext;
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"6gHZ2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _vue = require("vue");
var _pinia = require("pinia");
var _storage = require("@plasmohq/storage");
var _config = require("@/config");
const useStore = (0, _pinia.defineStore)("store", ()=>{
    const storage = new (0, _storage.Storage)();
    const config = (0, _vue.ref)((0, _config.defaultConfig));
    // selected text
    const selectedText = (0, _vue.ref)("");
    const setSelectedText = (text)=>{
        selectedText.value = text;
    };
    async function initConfig() {
        const storedConfig = await storage.get((0, _config.WEBPILOT_CONFIG_STORAGE_KEY));
        if (storedConfig && typeof storedConfig === "object") {
            config.value = storedConfig;
            // For old users who have saved some old data, perform some data correction
            if (config.value.apiOrigin === undefined) config.value.apiOrigin = "personal";
            if (config.value.selfHostUrl === (0, _config.WEBPILOT_OPENAI).HOST_URL) config.value.selfHostUrl = "";
            if (!config.value.latestAskedQuestionPromptIndex && !config.value.latestTextSelectionPromptIndex && !config.value.AskedQuestionPrompts && !config.value.TextSelectionPrompts) {
                config.value.latestAskedQuestionPromptIndex = (0, _config.defaultConfig).latestAskedQuestionPromptIndex;
                config.value.latestTextSelectionPromptIndex = (0, _config.defaultConfig).latestTextSelectionPromptIndex;
                config.value.AskedQuestionPrompts = (0, _config.defaultConfig).AskedQuestionPrompts;
                config.value.TextSelectionPrompts = (0, _config.defaultConfig).TextSelectionPrompts;
                saveToLocalStorage(config.value);
            }
        }
    }
    function saveToLocalStorage(config) {
        storage.set((0, _config.WEBPILOT_CONFIG_STORAGE_KEY), config);
    }
    // The current setConfig method requires each tab to be reloaded for the updates in options to take effect
    // Gradually replace setConfig and setPrompts methods with updateConfig, to fetch the latest LocalStorage each time
    async function updateConfig(newConfig) {
        const storedConfig = await storage.get((0, _config.WEBPILOT_CONFIG_STORAGE_KEY)) || config.value;
        config.value = {
            ...storedConfig,
            ...newConfig
        };
        saveToLocalStorage(config.value);
    }
    function setConfig(newConfig) {
        config.value = newConfig;
        saveToLocalStorage(config.value);
    }
    function setPrompts(type, prompts) {
        if (!type) return;
        config.value = {
            ...config.value,
            [type]: prompts
        };
        saveToLocalStorage(config.value);
    }
    return {
        config,
        selectedText,
        initConfig,
        setSelectedText,
        updateConfig,
        setPrompts,
        setConfig
    };
});
exports.default = useStore;

},{"vue":"dmrjI","pinia":"afUQj","@plasmohq/storage":"4Xe2t","@/config":"2jxI9","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"4Xe2t":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BaseStorage", ()=>o);
parcelHelpers.export(exports, "Storage", ()=>g);
var _pify = require("pify");
var _pifyDefault = parcelHelpers.interopDefault(_pify);
var l = ()=>{
    try {
        let e = globalThis.navigator?.userAgent.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
        if (e[1] === "Chrome") return parseInt(e[2]) < 100 || globalThis.chrome.runtime?.getManifest()?.manifest_version === 2;
    } catch  {
        return !1;
    }
    return !1;
};
var o = class {
    #r;
    #t;
    get primaryClient() {
        return this.#t;
    }
    #e;
    get secondaryClient() {
        return this.#e;
    }
    #a;
    get area() {
        return this.#a;
    }
    get hasWebApi() {
        try {
            return typeof window < "u" && !!window.localStorage;
        } catch (e) {
            return console.error(e), !1;
        }
    }
    #s = new Map;
    #i;
    get copiedKeySet() {
        return this.#i;
    }
    isCopied = (e)=>this.hasWebApi && (this.allCopied || this.copiedKeySet.has(e));
    #n = !1;
    get allCopied() {
        return this.#n;
    }
    getExtStorageApi = ()=>globalThis.browser?.storage || globalThis.chrome?.storage;
    get hasExtensionApi() {
        try {
            return !!this.getExtStorageApi();
        } catch (e) {
            return console.error(e), !1;
        }
    }
    isWatchSupported = ()=>this.hasExtensionApi;
    keyNamespace = "";
    isValidKey = (e)=>e.startsWith(this.keyNamespace);
    getNamespacedKey = (e)=>`${this.keyNamespace}${e}`;
    getUnnamespacedKey = (e)=>e.slice(this.keyNamespace.length);
    serde = {
        serializer: JSON.stringify,
        deserializer: JSON.parse
    };
    constructor({ area: e = "sync" , allCopied: t = !1 , copiedKeyList: s = [] , serde: r = {}  } = {}){
        this.setCopiedKeySet(s), this.#a = e, this.#n = t, this.serde = {
            ...this.serde,
            ...r
        };
        try {
            this.hasWebApi && (t || s.length > 0) && (this.#e = window.localStorage);
        } catch  {}
        try {
            this.hasExtensionApi && (this.#r = this.getExtStorageApi(), l() ? this.#t = (0, _pifyDefault.default)(this.#r[this.area], {
                exclude: [
                    "getBytesInUse"
                ],
                errorFirst: !1
            }) : this.#t = this.#r[this.area]);
        } catch  {}
    }
    setCopiedKeySet(e) {
        this.#i = new Set(e);
    }
    rawGetAll = ()=>this.#t?.get();
    getAll = async ()=>{
        let e = await this.rawGetAll();
        return Object.entries(e).filter(([t])=>this.isValidKey(t)).reduce((t, [s, r])=>(t[this.getUnnamespacedKey(s)] = r, t), {});
    };
    copy = async (e)=>{
        let t = e === void 0;
        if (!t && !this.copiedKeySet.has(e) || !this.allCopied || !this.hasExtensionApi) return !1;
        let s = this.allCopied ? await this.rawGetAll() : await this.#t.get((t ? [
            ...this.copiedKeySet
        ] : [
            e
        ]).map(this.getNamespacedKey));
        if (!s) return !1;
        let r = !1;
        for(let a in s){
            let i = s[a], n = this.#e?.getItem(a);
            this.#e?.setItem(a, i), r ||= i !== n;
        }
        return r;
    };
    rawGet = async (e)=>(await this.rawGetMany([
            e
        ]))[e];
    rawGetMany = async (e)=>this.hasExtensionApi ? await this.#t.get(e) : e.filter(this.isCopied).reduce((t, s)=>(t[s] = this.#e?.getItem(s), t), {});
    rawSet = async (e, t)=>await this.rawSetMany({
            [e]: t
        });
    rawSetMany = async (e)=>(this.#e && Object.entries(e).filter(([t])=>this.isCopied(t)).forEach(([t, s])=>this.#e.setItem(t, s)), this.hasExtensionApi && await this.#t.set(e), null);
    clear = async (e = !1)=>{
        e && this.#e?.clear(), await this.#t.clear();
    };
    rawRemove = async (e)=>{
        await this.rawRemoveMany([
            e
        ]);
    };
    rawRemoveMany = async (e)=>{
        this.#e && e.filter(this.isCopied).forEach((t)=>this.#e.removeItem(t)), this.hasExtensionApi && await this.#t.remove(e);
    };
    removeAll = async ()=>{
        let e = await this.getAll(), t = Object.keys(e);
        await this.removeMany(t);
    };
    watch = (e)=>{
        let t = this.isWatchSupported();
        return t && this.#o(e), t;
    };
    #o = (e)=>{
        for(let t in e){
            let s = this.getNamespacedKey(t), r = this.#s.get(s)?.callbackSet || new Set;
            if (r.add(e[t]), r.size > 1) continue;
            let a = (i, n)=>{
                if (n !== this.area || !i[s]) return;
                let h = this.#s.get(s);
                if (!h) throw new Error(`Storage comms does not exist for nsKey: ${s}`);
                Promise.all([
                    this.parseValue(i[s].newValue),
                    this.parseValue(i[s].oldValue)
                ]).then(([y, d])=>{
                    for (let p of h.callbackSet)p({
                        newValue: y,
                        oldValue: d
                    }, n);
                });
            };
            this.#r.onChanged.addListener(a), this.#s.set(s, {
                callbackSet: r,
                listener: a
            });
        }
    };
    unwatch = (e)=>{
        let t = this.isWatchSupported();
        return t && this.#c(e), t;
    };
    #c(e) {
        for(let t in e){
            let s = this.getNamespacedKey(t), r = e[t], a = this.#s.get(s);
            a && (a.callbackSet.delete(r), a.callbackSet.size === 0 && (this.#s.delete(s), this.#r.onChanged.removeListener(a.listener)));
        }
    }
    unwatchAll = ()=>this.#h();
    #h() {
        this.#s.forEach(({ listener: e  })=>this.#r.onChanged.removeListener(e)), this.#s.clear();
    }
    async getItem(e) {
        return this.get(e);
    }
    async getItems(e) {
        return await this.getMany(e);
    }
    async setItem(e, t) {
        await this.set(e, t);
    }
    async setItems(e) {
        await await this.setMany(e);
    }
    async removeItem(e) {
        return this.remove(e);
    }
    async removeItems(e) {
        return await this.removeMany(e);
    }
}, g = class extends o {
    get = async (e)=>{
        let t = this.getNamespacedKey(e), s = await this.rawGet(t);
        return this.parseValue(s);
    };
    getMany = async (e)=>{
        let t = e.map(this.getNamespacedKey), s = await this.rawGetMany(t), r = await Promise.all(Object.values(s).map(this.parseValue));
        return Object.keys(s).reduce((a, i, n)=>(a[this.getUnnamespacedKey(i)] = r[n], a), {});
    };
    set = async (e, t)=>{
        let s = this.getNamespacedKey(e), r = this.serde.serializer(t);
        return this.rawSet(s, r);
    };
    setMany = async (e)=>{
        let t = Object.entries(e).reduce((s, [r, a])=>(s[this.getNamespacedKey(r)] = this.serde.serializer(a), s), {});
        return await this.rawSetMany(t);
    };
    remove = async (e)=>{
        let t = this.getNamespacedKey(e);
        return this.rawRemove(t);
    };
    removeMany = async (e)=>{
        let t = e.map(this.getNamespacedKey);
        return await this.rawRemoveMany(t);
    };
    setNamespace = (e)=>{
        this.keyNamespace = e;
    };
    parseValue = async (e)=>{
        try {
            if (e !== void 0) return this.serde.deserializer(e);
        } catch (t) {
            console.error(t);
        }
    };
};

},{"pify":"fA13J","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"fA13J":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>pify);
const processFunction = (function_, options, proxy, unwrapped)=>function(...arguments_) {
        const P = options.promiseModule;
        return new P((resolve, reject)=>{
            if (options.multiArgs) arguments_.push((...result)=>{
                if (options.errorFirst) {
                    if (result[0]) reject(result);
                    else {
                        result.shift();
                        resolve(result);
                    }
                } else resolve(result);
            });
            else if (options.errorFirst) arguments_.push((error, result)=>{
                if (error) reject(error);
                else resolve(result);
            });
            else arguments_.push(resolve);
            const self = this === proxy ? unwrapped : this;
            Reflect.apply(function_, self, arguments_);
        });
    };
const filterCache = new WeakMap();
function pify(input, options) {
    options = {
        exclude: [
            /.+(?:Sync|Stream)$/
        ],
        errorFirst: true,
        promiseModule: Promise,
        ...options
    };
    const objectType = typeof input;
    if (!(input !== null && (objectType === "object" || objectType === "function"))) throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? "null" : objectType}\``);
    const filter = (target, key)=>{
        let cached = filterCache.get(target);
        if (!cached) {
            cached = {};
            filterCache.set(target, cached);
        }
        if (key in cached) return cached[key];
        const match = (pattern)=>typeof pattern === "string" || typeof key === "symbol" ? key === pattern : pattern.test(key);
        const descriptor = Reflect.getOwnPropertyDescriptor(target, key);
        const writableOrConfigurableOwn = descriptor === undefined || descriptor.writable || descriptor.configurable;
        const included = options.include ? options.include.some((element)=>match(element)) : !options.exclude.some((element)=>match(element));
        const shouldFilter = included && writableOrConfigurableOwn;
        cached[key] = shouldFilter;
        return shouldFilter;
    };
    const cache = new WeakMap();
    const proxy = new Proxy(input, {
        apply (target, thisArg, args) {
            const cached = cache.get(target);
            if (cached) return Reflect.apply(cached, thisArg, args);
            const pified = options.excludeMain ? target : processFunction(target, options, proxy, target);
            cache.set(target, pified);
            return Reflect.apply(pified, thisArg, args);
        },
        get (target, key) {
            const property = target[key];
            // eslint-disable-next-line no-use-extend-native/no-use-extend-native
            if (!filter(target, key) || property === Function.prototype[key]) return property;
            const cached = cache.get(property);
            if (cached) return cached;
            if (typeof property === "function") {
                const pified = processFunction(property, options, proxy, target);
                cache.set(property, pified);
                return pified;
            }
            return property;
        }
    });
    return proxy;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"2jxI9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WEBPILOT_CONFIG_STORAGE_KEY", ()=>WEBPILOT_CONFIG_STORAGE_KEY);
parcelHelpers.export(exports, "OPENAI_BASE_URL", ()=>OPENAI_BASE_URL);
parcelHelpers.export(exports, "API_PATH", ()=>API_PATH);
parcelHelpers.export(exports, "defaultConfig", ()=>defaultConfig);
parcelHelpers.export(exports, "MESSAGING_EVENT", ()=>MESSAGING_EVENT);
parcelHelpers.export(exports, "SUPER_BUTTON_STATUS", ()=>SUPER_BUTTON_STATUS);
parcelHelpers.export(exports, "WEBPILOT_OPENAI", ()=>WEBPILOT_OPENAI);
parcelHelpers.export(exports, "LAST_PROMPT_STORAGE_KEY", ()=>LAST_PROMPT_STORAGE_KEY);
parcelHelpers.export(exports, "API_ORIGINS", ()=>API_ORIGINS);
parcelHelpers.export(exports, "SERVER_NAME", ()=>SERVER_NAME);
parcelHelpers.export(exports, "SERVER_TYPE", ()=>SERVER_TYPE);
parcelHelpers.export(exports, "OPTIONS_PAGE_TAB_NAME", ()=>OPTIONS_PAGE_TAB_NAME);
var _i18N = require("./utils/i18n");
const WEBPILOT_CONFIG_STORAGE_KEY = "WEBPILOT_CONFIG_STORAGE_KEY";
const OPENAI_BASE_URL = "https://api.openai.com";
const API_PATH = "/v1/chat/completions";
const defaultConfig = {
    /**
   * general: use webpilot
   * personal: use openai or third party
   * */ apiOrigin: "general",
    /** Open AI or selfhost api key */ authKey: "",
    /** Is auth succeeded */ isAuth: false,
    /** If user not set token at welcome page set false */ isFinishSetup: false,
    /** When select text (by mouse or keyboard) show popup */ autoPopup: false,
    /** Self host url */ selfHostUrl: "",
    /** Azure specify ApiVersion */ azureApiVersion: "",
    /** Azure specify deploymentID */ azureDeploymentID: "",
    /** Custom shortcut for show popup (akspage) */ customShortcut: [
        "Control",
        "`"
    ],
    /** Chose display mode
   * popUp
   * sideBar */ displayMode: "popUp",
    /** Show shortcut state, once trigger popup by shortcut set to false */ showShortcutTips: true,
    /** Last select preset prompt index. For auto select at popup. */ latestAskedQuestionPromptIndex: 0,
    latestTextSelectionPromptIndex: 0,
    /** Custom preset prompts */ AskedQuestionPrompts: [
        {
            title: (0, _i18N.$gettext)("Summarize"),
            command: (0, _i18N.$gettext)("Summarize in English, concise and clear")
        },
        {
            title: (0, _i18N.$gettext)("SEO"),
            command: (0, _i18N.$gettext)("Generate a list of 10 long-tail keywords for SEO, related to this page")
        },
        {
            title: (0, _i18N.$gettext)("Solve"),
            command: (0, _i18N.$gettext)("Find the questions/todo on the page, analyze them step by step, and provide a complete solution in the end. If a specified starting point is given, use it directly without changing.")
        }
    ],
    TextSelectionPrompts: [
        {
            title: (0, _i18N.$gettext)("Explain"),
            command: (0, _i18N.$gettext)("Explain it in English using words a middle schooler can understand")
        },
        {
            title: (0, _i18N.$gettext)("Refine"),
            command: (0, _i18N.$gettext)("Refine text, review and revise problems in spelling, grammar, punctuation, word usage, and sentence structure")
        },
        {
            title: (0, _i18N.$gettext)("Draw"),
            command: (0, _i18N.$gettext)(`Let's draw an image about this. You need to write in English without word wraps and headlines, without connection words. back to back separated with commas: [1], [2], [3], [4] {environment}, [5], [6] {style settings}
        Replace [1] with the subject "A image of ";
        Replace [2] with the sentence you mentioned;
        Replace [3] with a list of creative detailed descriptions about [element]; 
        Replace [4] with a list of detailed descriptions about the environment of the scene;
        Replace [5] with a list of detailed descriptions about the mood/feelings and atmosphere of the scene;
        Replace [6] with an appropriate director or artist. If he/she is a historical figure, include his/her country and dynasty.
        Simply write the without explanation, replace the content inside the brackets with details about the content/word inside the brackets and delete the brackets. Repeat that for every bracket in the prompt, complex prompt for an AI-based text to image program that converts a prompt about a topic into an image. The outcome depends on the prompt's coherence. The topic of the whole scene is always dependent on the subject that is replaced with [element], always start the prompt with "/imagine prompt:", don't use any line breaks, Proper grammar is unnecessary and details can be listed.
        Do not show things like "[1]""[element]" in your response.`)
        }
    ],
    /* Model type, for now use open ai template */ model: {
        model: "gpt-4o-mini",
        temperature: 1,
        top_p: 0.9,
        frequency_penalty: 0,
        presence_penalty: 0,
        stop: "<|endoftext|>"
    }
};
const MESSAGING_EVENT = {
    SHOW_POPUP: "MESSAGING_EVENT"
};
const SUPER_BUTTON_STATUS = {
    pending: "pending",
    generating: "generating",
    done: "done"
};
const WEBPILOT_OPENAI = {
    AUTH_KEY: "KEY_PLACEHOLDER",
    HOST_URL: "https://api.webpilotai.com/api/webpilot",
    MODEL: "gpt-4o-mini"
};
const LAST_PROMPT_STORAGE_KEY = {
    COMMON: "LAST_COMMON",
    SELECTED: "LAST_SELECTED"
};
const API_ORIGINS = {
    /** Webpilot Server */ GENERAL: "general",
    /** OpenAI server or proxy */ OPENAI: "openAI",
    /** Selfhost server */ OPENAI_PROXY: "OpenAIProxy",
    /** Azure server */ AZURE: "azure"
};
const SERVER_NAME = {
    OPENAI_OFFICIAL: "OPENAI_OFFICIAL",
    OPENAI_PROXY: "OPENAI_PROXY",
    AZURE_PROXY: "AZURE_PROXY"
};
const SERVER_TYPE = {
    [SERVER_NAME.OPENAI_OFFICIAL]: "OpenAI Official",
    [SERVER_NAME.OPENAI_PROXY]: "OpenAI Proxy",
    [SERVER_NAME.AZURE_PROXY]: "Azure Proxy"
};
const OPTIONS_PAGE_TAB_NAME = {
    ACCOUNT: "ACCOUNT",
    EXTENSION: "EXTENSION",
    ABOUT: "ABOUT"
};

},{"./utils/i18n":"6q3A1","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"3fjDl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require("7fee18c6d2e79cf5");
    if (script.__esModule) script = script.default;
    script.render = require("9361f26efe07ff2a").render;
    script.__cssModules = require("7db43ac083aa2cce").default;
    require("7638f319bcbe5e3e").default(script);
    script.__scopeId = "data-v-65f623";
    script.__file = "/Users/mahbubislammahim/Desktop/Development/Webpilot/src/popup/componetns/WebpilotPopup.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "65f623-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("65f623-hmr", script)) __VUE_HMR_RUNTIME__.reload("65f623-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"7fee18c6d2e79cf5":"3rtDx","9361f26efe07ff2a":"eujuA","7db43ac083aa2cce":"fV5z7","7638f319bcbe5e3e":"a48Dg","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"3rtDx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _resetScss = require("@assets/styles/reset.scss");
// import {onBeforeMount} from 'vue'
// import {sendToBackground} from '@plasmohq/messaging'
var _i18N = require("@/utils/i18n");
var _headerPanelVue = require("@/components/HeaderPanel.vue");
var _headerPanelVueDefault = parcelHelpers.interopDefault(_headerPanelVue);
var _webpilotAlertVue = require("@/components/WebpilotAlert.vue");
var _webpilotAlertVueDefault = parcelHelpers.interopDefault(_webpilotAlertVue);
var _tipsShortcutVue = require("@/components/TipsShortcut.vue");
var _tipsShortcutVueDefault = parcelHelpers.interopDefault(_tipsShortcutVue);
// import useStore from '@/stores/store'
// const store = useStore()
// onBeforeMount(async () => {
//   // check welcode guide
//   if (!store.config.isFinishSetup || !store.config.isAuth) {
//     const [tab] = await chrome.tabs.query({
//       active: true,
//       currentWindow: true,
//     })
//     const currentUrl = tab?.url
//     // can't get current open page url
//     if (currentUrl === undefined) return
//     const signURL = 'https://account.webpilot.ai/'
//     const welcomeUrl = chrome?.runtime?.getURL('tabs/index.html')
//     // aready in welcome page
//     if (currentUrl === signURL || currentUrl === welcomeUrl) {
//       closeWindow()
//       return
//     }
//     chrome.tabs.create({url: signURL})
//     closeWindow()
//     // window.open(welcomeUrl)
//   }
//   // options \u9875\u9762\u4f1a\u5224\u65ad isAuth\uff0c\u8fd9\u91cc\u903b\u8f91\u65e0\u6548\u4e86
//   // check auth state
//   // if (!store.config.isAuth) {
//   //   sendToBackground({name: 'openSetting'})
//   //   closeWindow()
//   //   return
//   // }
//   // check current page
//   // const isKeepOpen = await sendToBackground({
//   //   name: 'popupCheck',
//   // })
//   // if (!isKeepOpen) window.close()
// })
exports.default = {
    __name: "WebpilotPopup",
    setup (__props, { expose: __expose  }) {
        __expose();
        const closeWindow = ()=>{
            window.close();
        };
        const __returned__ = {
            closeWindow,
            get $gettext () {
                return 0, _i18N.$gettext;
            },
            HeaderPanel: (0, _headerPanelVueDefault.default),
            WebpilotAlert: (0, _webpilotAlertVueDefault.default),
            TipsShortcut: (0, _tipsShortcutVueDefault.default)
        };
        Object.defineProperty(__returned__, "__isScriptSetup", {
            enumerable: false,
            value: true
        });
        return __returned__;
    }
};

},{"@assets/styles/reset.scss":"6AOpP","@/utils/i18n":"6q3A1","@/components/HeaderPanel.vue":"1qufo","@/components/WebpilotAlert.vue":"iGRiO","@/components/TipsShortcut.vue":"7dyjF","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"6AOpP":[function() {},{}],"1qufo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require("6a119b9e148368e");
    if (script.__esModule) script = script.default;
    script.render = require("8d94b22099415a19").render;
    script.__cssModules = require("b13eef3006d524b8").default;
    require("6a087f272b417bbe").default(script);
    script.__scopeId = "data-v-f6fb50";
    script.__file = "/Users/mahbubislammahim/Desktop/Development/Webpilot/src/components/HeaderPanel.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "f6fb50-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("f6fb50-hmr", script)) __VUE_HMR_RUNTIME__.reload("f6fb50-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"6a119b9e148368e":"2AERW","8d94b22099415a19":"9NGvj","b13eef3006d524b8":"3IQCi","6a087f272b417bbe":"2hYoE","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"2AERW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _messaging = require("@plasmohq/messaging");
var _vue3Popper = require("vue3-popper");
var _vue3PopperDefault = parcelHelpers.interopDefault(_vue3Popper);
var _iconPng = require("~assets/icon/icon.png");
var _iconPngDefault = parcelHelpers.interopDefault(_iconPng);
var _interactiveIconVue = require("./InteractiveIcon/InteractiveIcon.vue");
var _interactiveIconVueDefault = parcelHelpers.interopDefault(_interactiveIconVue);
exports.default = {
    __name: "HeaderPanel",
    emits: [
        "onClose"
    ],
    setup (__props, { expose: __expose , emit: emits  }) {
        __expose();
        const openSettingPage = ()=>{
            (0, _messaging.sendToBackground)({
                name: "openSetting"
            });
        };
        const closePopup = ()=>{
            emits("onClose");
        };
        const __returned__ = {
            emits,
            openSettingPage,
            closePopup,
            get sendToBackground () {
                return 0, _messaging.sendToBackground;
            },
            get Popper () {
                return 0, _vue3PopperDefault.default;
            },
            get SamsungLogo () {
                return 0, _iconPngDefault.default;
            },
            InteractiveIcon: (0, _interactiveIconVueDefault.default)
        };
        Object.defineProperty(__returned__, "__isScriptSetup", {
            enumerable: false,
            value: true
        });
        return __returned__;
    }
};

},{"@plasmohq/messaging":"k3omK","vue3-popper":"gHnmV","./InteractiveIcon/InteractiveIcon.vue":"3COT6","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo","~assets/icon/icon.png":"6qnSn"}],"k3omK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "relay", ()=>S);
parcelHelpers.export(exports, "relayMessage", ()=>u);
parcelHelpers.export(exports, "sendToActiveContentScript", ()=>h);
parcelHelpers.export(exports, "sendToBackground", ()=>x);
parcelHelpers.export(exports, "sendToBackgroundViaRelay", ()=>w);
parcelHelpers.export(exports, "sendToContentScript", ()=>M);
parcelHelpers.export(exports, "sendViaRelay", ()=>O);
var _nanoid = require("nanoid");
var l = globalThis.browser?.runtime || globalThis.chrome?.runtime, d = globalThis.browser?.tabs || globalThis.chrome?.tabs, m = ()=>{
    if (!l) throw new Error("Extension runtime is not available");
    return l;
}, i = ()=>{
    if (!d) throw new Error("Extension tabs API is not available");
    return d;
}, c = async ()=>{
    let e = i(), [a] = await e.query({
        active: !0,
        currentWindow: !0
    });
    return a;
}, g = (e, a)=>!a.__internal && e.source === globalThis.window && e.data.name === a.name && (a.relayId === void 0 || e.data.relayId === a.relayId);
var y = (e, a, n = globalThis.window)=>{
    let r = async (s)=>{
        if (g(s, e) && !s.data.relayed) {
            let o = {
                name: e.name,
                relayId: e.relayId,
                body: s.data.body
            }, t = await a?.(o);
            n.postMessage({
                name: e.name,
                relayId: e.relayId,
                instanceId: s.data.instanceId,
                body: t,
                relayed: !0
            }, {
                targetOrigin: e.targetOrigin || "/"
            });
        }
    };
    return n.addEventListener("message", r), ()=>n.removeEventListener("message", r);
}, p = (e, a = globalThis.window)=>new Promise((n, r)=>{
        let s = (0, _nanoid.nanoid)(), o = new AbortController;
        a.addEventListener("message", (t)=>{
            g(t, e) && t.data.relayed && t.data.instanceId === s && (n(t.data.body), o.abort());
        }, {
            signal: o.signal
        }), a.postMessage({
            ...e,
            instanceId: s
        }, {
            targetOrigin: e.targetOrigin || "/"
        });
    });
var x = async (e)=>m().sendMessage(e), M = async (e)=>{
    let a = typeof e.tabId == "number" ? e.tabId : (await c()).id;
    return i().sendMessage(a, e);
}, h = M, u = (e)=>y(e, x), S = u, w = p, O = w;

},{"nanoid":"E2pqo","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"E2pqo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "urlAlphabet", ()=>(0, _indexJs.urlAlphabet));
parcelHelpers.export(exports, "random", ()=>random);
parcelHelpers.export(exports, "customRandom", ()=>customRandom);
parcelHelpers.export(exports, "customAlphabet", ()=>customAlphabet);
parcelHelpers.export(exports, "nanoid", ()=>nanoid);
var _indexJs = require("./url-alphabet/index.js");
let random = (bytes)=>crypto.getRandomValues(new Uint8Array(bytes));
let customRandom = (alphabet, defaultSize, getRandom)=>{
    let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
    let step = -~(1.6 * mask * defaultSize / alphabet.length);
    return (size = defaultSize)=>{
        let id = "";
        while(true){
            let bytes = getRandom(step);
            let j = step;
            while(j--){
                id += alphabet[bytes[j] & mask] || "";
                if (id.length === size) return id;
            }
        }
    };
};
let customAlphabet = (alphabet, size = 21)=>customRandom(alphabet, size, random);
let nanoid = (size = 21)=>crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte)=>{
        byte &= 63;
        if (byte < 36) id += byte.toString(36);
        else if (byte < 62) id += (byte - 26).toString(36).toUpperCase();
        else if (byte > 62) id += "-";
        else id += "_";
        return id;
    }, "");

},{"./url-alphabet/index.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"gHnmV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// also be used as directives, etc. - eg. import { RollupDemoDirective } from 'rollup-demo';
// export const RollupDemoDirective = directive;
parcelHelpers.export(exports, "default", ()=>entry_esm);
var _vue = require("vue");
/**
 * Returns a function, that, as long as it continues to be invoked, will not
 * be triggered. The function will be called after it stops being called for
 * N milliseconds. If `immediate` is passed, trigger the function on the
 * leading edge, instead of the trailing. The function also has a property 'clear' 
 * that is a function which will clear the timer to prevent previously scheduled executions. 
 *
 * @source underscore.js
 * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
 * @param {Function} function to wrap
 * @param {Number} timeout in ms (`100`)
 * @param {Boolean} whether to execute at the beginning (`false`)
 * @api public
 */ function debounce$1(func, wait, immediate) {
    var timeout, args, context, timestamp, result;
    if (null == wait) wait = 100;
    function later() {
        var last = Date.now() - timestamp;
        if (last < wait && last >= 0) timeout = setTimeout(later, wait - last);
        else {
            timeout = null;
            if (!immediate) {
                result = func.apply(context, args);
                context = args = null;
            }
        }
    }
    var debounced = function() {
        context = this;
        args = arguments;
        timestamp = Date.now();
        var callNow = immediate && !timeout;
        if (!timeout) timeout = setTimeout(later, wait);
        if (callNow) {
            result = func.apply(context, args);
            context = args = null;
        }
        return result;
    };
    debounced.clear = function() {
        if (timeout) {
            clearTimeout(timeout);
            timeout = null;
        }
    };
    debounced.flush = function() {
        if (timeout) {
            result = func.apply(context, args);
            context = args = null;
            clearTimeout(timeout);
            timeout = null;
        }
    };
    return debounced;
}
// Adds compatibility for ES modules
debounce$1.debounce = debounce$1;
var debounce_1 = debounce$1;
function useEventListener(target, event, handler) {
    if ((0, _vue.isRef)(target)) (0, _vue.watch)(target, (value, oldValue)=>{
        oldValue === null || oldValue === void 0 || oldValue.removeEventListener(event, handler);
        value === null || value === void 0 || value.addEventListener(event, handler);
    });
    else (0, _vue.onMounted)(()=>{
        target.addEventListener(event, handler);
    });
    (0, _vue.onBeforeUnmount)(()=>{
        var _unref;
        (_unref = (0, _vue.unref)(target)) === null || _unref === void 0 || _unref.removeEventListener(event, handler);
    });
}
function useClickAway(target, handler) {
    const event = "pointerdown";
    if (typeof window === "undefined" || !window) return;
    const listener = (event)=>{
        const el = (0, _vue.unref)(target);
        if (!el) return;
        if (el === event.target || event.composedPath().includes(el)) return;
        handler(event);
    };
    return useEventListener(window, event, listener);
}
function useContent(slots, popperNode, content) {
    let observer = null;
    const hasContent = (0, _vue.ref)(false);
    (0, _vue.onMounted)(()=>{
        if (slots.content !== undefined || content.value) hasContent.value = true;
        observer = new MutationObserver(checkContent);
        observer.observe(popperNode.value, {
            childList: true,
            subtree: true
        });
    });
    (0, _vue.onBeforeUnmount)(()=>observer.disconnect());
    /**
   * Watch the content prop
   */ (0, _vue.watch)(content, (content)=>{
        if (content) hasContent.value = true;
        else hasContent.value = false;
    });
    /**
   * Check the content slot
   */ const checkContent = ()=>{
        if (slots.content) hasContent.value = true;
        else hasContent.value = false;
    };
    return {
        hasContent
    };
}
// import { isHTMLElement } from './instanceOf';
function getBoundingClientRect(element, includeScale) {
    var rect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1; // FIXME:
    // `offsetWidth` returns an integer while `getBoundingClientRect`
    // returns a float. This results in `scaleX` or `scaleY` being
    // non-1 when it should be for elements that aren't a full pixel in
    // width or height.
    // if (isHTMLElement(element) && includeScale) {
    //   const offsetHeight = element.offsetHeight;
    //   const offsetWidth = element.offsetWidth;
    //   // Do not attempt to divide by 0, otherwise we get `Infinity` as scale
    //   // Fallback to 1 in case both values are `0`
    //   if (offsetWidth > 0) {
    //     scaleX = rect.width / offsetWidth || 1;
    //   }
    //   if (offsetHeight > 0) {
    //     scaleY = rect.height / offsetHeight || 1;
    //   }
    // }
    return {
        width: rect.width / scaleX,
        height: rect.height / scaleY,
        top: rect.top / scaleY,
        right: rect.right / scaleX,
        bottom: rect.bottom / scaleY,
        left: rect.left / scaleX,
        x: rect.left / scaleX,
        y: rect.top / scaleY
    };
}
function getWindow(node) {
    if (node == null) return window;
    if (node.toString() !== "[object Window]") {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
}
function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
        scrollLeft: scrollLeft,
        scrollTop: scrollTop
    };
}
function isElement(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
    // IE 11 has no ShadowRoot
    if (typeof ShadowRoot === "undefined") return false;
    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
}
function getHTMLElementScroll(element) {
    return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
    };
}
function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) return getWindowScroll(node);
    else return getHTMLElementScroll(node);
}
function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
}
function getDocumentElement(element) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}
function getWindowScrollBarX(element) {
    // If <html> has a CSS width greater than the viewport, then this will be
    // incorrect for RTL.
    // Popper 1 is broken in this case and never had a bug report so let's assume
    // it's not an issue. I don't think anyone ever specifies width on <html>
    // anyway.
    // Browsers where the left scrollbar doesn't cause an issue report `0` for
    // this (e.g. Edge 2019, IE11, Safari)
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getComputedStyle(element) {
    return getWindow(element).getComputedStyle(element);
}
function isScrollParent(element) {
    // Firefox wants us to check `-x` and `-y` variations as well
    var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = rect.width / element.offsetWidth || 1;
    var scaleY = rect.height / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) isFixed = false;
    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement);
    var scroll = {
        scrollLeft: 0,
        scrollTop: 0
    };
    var offsets = {
        x: 0,
        y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
        isScrollParent(documentElement)) scroll = getNodeScroll(offsetParent);
        if (isHTMLElement(offsetParent)) {
            offsets = getBoundingClientRect(offsetParent);
            offsets.x += offsetParent.clientLeft;
            offsets.y += offsetParent.clientTop;
        } else if (documentElement) offsets.x = getWindowScrollBarX(documentElement);
    }
    return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
    };
}
// means it doesn't take into account transforms.
function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
    // Fixes https://github.com/popperjs/popper-core/issues/1223
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (Math.abs(clientRect.width - width) <= 1) width = clientRect.width;
    if (Math.abs(clientRect.height - height) <= 1) height = clientRect.height;
    return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width: width,
        height: height
    };
}
function getParentNode(element) {
    if (getNodeName(element) === "html") return element;
    return(// $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element) // fallback
    );
}
function getScrollParent(node) {
    if ([
        "html",
        "body",
        "#document"
    ].indexOf(getNodeName(node)) >= 0) // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
    if (isHTMLElement(node) && isScrollParent(node)) return node;
    return getScrollParent(getParentNode(node));
}
/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/ function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) list = [];
    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [
        win
    ].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}
function isTableElement(element) {
    return [
        "table",
        "td",
        "th"
    ].indexOf(getNodeName(element)) >= 0;
}
function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle(element).position === "fixed") return null;
    return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block
function getContainingBlock(element) {
    var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
    var isIE = navigator.userAgent.indexOf("Trident") !== -1;
    if (isIE && isHTMLElement(element)) {
        // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
        var elementCss = getComputedStyle(element);
        if (elementCss.position === "fixed") return null;
    }
    var currentNode = getParentNode(element);
    while(isHTMLElement(currentNode) && [
        "html",
        "body"
    ].indexOf(getNodeName(currentNode)) < 0){
        var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that
        // create a containing block.
        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
        if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || [
            "transform",
            "perspective"
        ].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") return currentNode;
        else currentNode = currentNode.parentNode;
    }
    return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.
function getOffsetParent(element) {
    var window1 = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);
    while(offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static")offsetParent = getTrueOffsetParent(offsetParent);
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) return window1;
    return offsetParent || getContainingBlock(element) || window1;
}
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [
    top,
    bottom,
    right,
    left
];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /*#__PURE__*/ basePlacements.reduce(function(acc, placement) {
    return acc.concat([
        placement + "-" + start,
        placement + "-" + end
    ]);
}, []);
var placements = /*#__PURE__*/ [].concat(basePlacements, [
    auto
]).reduce(function(acc, placement) {
    return acc.concat([
        placement,
        placement + "-" + start,
        placement + "-" + end
    ]);
}, []); // modifiers that need to read the DOM
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead"; // pure-logic modifiers
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain"; // modifier with the purpose to write to the DOM (or write into a framework state)
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [
    beforeRead,
    read,
    afterRead,
    beforeMain,
    main,
    afterMain,
    beforeWrite,
    write,
    afterWrite
];
function order(modifiers) {
    var map = new Map();
    var visited = new Set();
    var result = [];
    modifiers.forEach(function(modifier) {
        map.set(modifier.name, modifier);
    }); // On visiting object, check for its dependencies and visit them recursively
    function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function(dep) {
            if (!visited.has(dep)) {
                var depModifier = map.get(dep);
                if (depModifier) sort(depModifier);
            }
        });
        result.push(modifier);
    }
    modifiers.forEach(function(modifier) {
        if (!visited.has(modifier.name)) // check for visited object
        sort(modifier);
    });
    return result;
}
function orderModifiers(modifiers) {
    // order based on dependencies
    var orderedModifiers = order(modifiers); // order based on phase
    return modifierPhases.reduce(function(acc, phase) {
        return acc.concat(orderedModifiers.filter(function(modifier) {
            return modifier.phase === phase;
        }));
    }, []);
}
function debounce(fn) {
    var pending;
    return function() {
        if (!pending) pending = new Promise(function(resolve) {
            Promise.resolve().then(function() {
                pending = undefined;
                resolve(fn());
            });
        });
        return pending;
    };
}
function getBasePlacement(placement) {
    return placement.split("-")[0];
}
function mergeByName(modifiers) {
    var merged = modifiers.reduce(function(merged, current) {
        var existing = merged[current.name];
        merged[current.name] = existing ? Object.assign({}, existing, current, {
            options: Object.assign({}, existing.options, current.options),
            data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged;
    }, {}); // IE11 does not support Object.values
    return Object.keys(merged).map(function(key) {
        return merged[key];
    });
}
function getViewportRect(element) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
    // can be obscured underneath it.
    // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
    // if it isn't open, so if this isn't available, the popper will be detected
    // to overflow the bottom of the screen too early.
    if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
        // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
        // errors due to floating point numbers, so we need to check precision.
        // Safari returns a number <= 0, usually < -1 when pinch-zoomed
        // Feature detection fails in mobile emulation mode in Chrome.
        // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
        // 0.001
        // Fallback here: "Not Safari" userAgent
        if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
            x = visualViewport.offsetLeft;
            y = visualViewport.offsetTop;
        }
    }
    return {
        width: width,
        height: height,
        x: x + getWindowScrollBarX(element),
        y: y
    };
}
var max = Math.max;
var min = Math.min;
var round = Math.round;
// of the `<html>` and `<body>` rect bounds if horizontally scrollable
function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y = -winScroll.scrollTop;
    if (getComputedStyle(body || html).direction === "rtl") x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
    return {
        width: width,
        height: height,
        x: x,
        y: y
    };
}
function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method
    if (parent.contains(child)) return true;
    else if (rootNode && isShadowRoot(rootNode)) {
        var next = child;
        do {
            if (next && parent.isSameNode(next)) return true;
             // $FlowFixMe[prop-missing]: need a better way to handle this...
            next = next.parentNode || next.host;
        }while (next);
    } // Give up, the result is false
    return false;
}
function rectToClientRect(rect) {
    return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
    });
}
function getInnerBoundingClientRect(element) {
    var rect = getBoundingClientRect(element);
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
}
function getClientRectFromMixedType(element, clippingParent) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`
function getClippingParents(element) {
    var clippingParents = listScrollParents(getParentNode(element));
    var canEscapeClipping = [
        "absolute",
        "fixed"
    ].indexOf(getComputedStyle(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
    if (!isElement(clipperElement)) return [];
     // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414
    return clippingParents.filter(function(clippingParent) {
        return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
    });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents
function getClippingRect(element, boundary, rootBoundary) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
    var clippingParents = [].concat(mainClippingParents, [
        rootBoundary
    ]);
    var firstClippingParent = clippingParents[0];
    var clippingRect = clippingParents.reduce(function(accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent);
        accRect.top = max(rect.top, accRect.top);
        accRect.right = min(rect.right, accRect.right);
        accRect.bottom = min(rect.bottom, accRect.bottom);
        accRect.left = max(rect.left, accRect.left);
        return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
}
function getVariation(placement) {
    return placement.split("-")[1];
}
function getMainAxisFromPlacement(placement) {
    return [
        "top",
        "bottom"
    ].indexOf(placement) >= 0 ? "x" : "y";
}
function computeOffsets(_ref) {
    var reference = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference.x + reference.width / 2 - element.width / 2;
    var commonY = reference.y + reference.height / 2 - element.height / 2;
    var offsets;
    switch(basePlacement){
        case top:
            offsets = {
                x: commonX,
                y: reference.y - element.height
            };
            break;
        case bottom:
            offsets = {
                x: commonX,
                y: reference.y + reference.height
            };
            break;
        case right:
            offsets = {
                x: reference.x + reference.width,
                y: commonY
            };
            break;
        case left:
            offsets = {
                x: reference.x - element.width,
                y: commonY
            };
            break;
        default:
            offsets = {
                x: reference.x,
                y: reference.y
            };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
        var len = mainAxis === "y" ? "height" : "width";
        switch(variation){
            case start:
                offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
                break;
            case end:
                offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
                break;
        }
    }
    return offsets;
}
function getFreshSideObject() {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    };
}
function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys) {
    return keys.reduce(function(hashMap, key) {
        hashMap[key] = value;
        return hashMap;
    }, {});
}
function detectOverflow(state, options) {
    if (options === void 0) options = {};
    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets = computeOffsets({
        reference: referenceClientRect,
        element: popperRect,
        strategy: "absolute",
        placement: placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
    // 0 or negative = within the clipping rect
    var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element
    if (elementContext === popper && offsetData) {
        var offset = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function(key) {
            var multiply = [
                right,
                bottom
            ].indexOf(key) >= 0 ? 1 : -1;
            var axis = [
                top,
                bottom
            ].indexOf(key) >= 0 ? "y" : "x";
            overflowOffsets[key] += offset[axis] * multiply;
        });
    }
    return overflowOffsets;
}
var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
};
function areValidElements() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
    return !args.some(function(element) {
        return !(element && typeof element.getBoundingClientRect === "function");
    });
}
function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) generatorOptions = {};
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper(reference, popper, options) {
        if (options === void 0) options = defaultOptions;
        var state = {
            placement: "bottom",
            orderedModifiers: [],
            options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
            modifiersData: {},
            elements: {
                reference: reference,
                popper: popper
            },
            attributes: {},
            styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
            state: state,
            setOptions: function setOptions(setOptionsAction) {
                var options = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
                cleanupModifierEffects();
                state.options = Object.assign({}, defaultOptions, state.options, options);
                state.scrollParents = {
                    reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
                    popper: listScrollParents(popper)
                }; // Orders the modifiers based on their dependencies and `phase`
                // properties
                var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers
                state.orderedModifiers = orderedModifiers.filter(function(m) {
                    return m.enabled;
                }); // Validate the provided modifiers so that the consumer will get warned
                runModifierEffects();
                return instance.update();
            },
            // Sync update \u2013 it will always be executed, even if not necessary. This
            // is useful for low frequency updates where sync behavior simplifies the
            // logic.
            // For high frequency updates (e.g. `resize` and `scroll` events), always
            // prefer the async Popper#update method
            forceUpdate: function forceUpdate() {
                if (isDestroyed) return;
                var _state$elements = state.elements, reference = _state$elements.reference, popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
                // anymore
                if (!areValidElements(reference, popper)) return;
                 // Store the reference and popper rects to be read by modifiers
                state.rects = {
                    reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === "fixed"),
                    popper: getLayoutRect(popper)
                }; // Modifiers have the ability to reset the current update cycle. The
                // most common use case for this is the `flip` modifier changing the
                // placement, which then needs to re-run all the modifiers, because the
                // logic was previously ran for the previous placement and is therefore
                // stale/incorrect
                state.reset = false;
                state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
                // is filled with the initial data specified by the modifier. This means
                // it doesn't persist and is fresh on each update.
                // To ensure persistent data, use `${name}#persistent`
                state.orderedModifiers.forEach(function(modifier) {
                    return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
                });
                for(var index = 0; index < state.orderedModifiers.length; index++){
                    if (state.reset === true) {
                        state.reset = false;
                        index = -1;
                        continue;
                    }
                    var _state$orderedModifie = state.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
                    if (typeof fn === "function") state = fn({
                        state: state,
                        options: _options,
                        name: name,
                        instance: instance
                    }) || state;
                }
            },
            // Async and optimistically optimized update \u2013 it will not be executed if
            // not necessary (debounced to run at most once-per-tick)
            update: debounce(function() {
                return new Promise(function(resolve) {
                    instance.forceUpdate();
                    resolve(state);
                });
            }),
            destroy: function destroy() {
                cleanupModifierEffects();
                isDestroyed = true;
            }
        };
        if (!areValidElements(reference, popper)) return instance;
        instance.setOptions(options).then(function(state) {
            if (!isDestroyed && options.onFirstUpdate) options.onFirstUpdate(state);
        }); // Modifiers have the ability to execute arbitrary code before the first
        // update cycle runs. They will be executed in the same order as the update
        // cycle. This is useful when a modifier adds some persistent data that
        // other modifiers need to use, but the modifier is run after the dependent
        // one.
        function runModifierEffects() {
            state.orderedModifiers.forEach(function(_ref3) {
                var name = _ref3.name, _ref3$options = _ref3.options, options = _ref3$options === void 0 ? {} : _ref3$options, effect = _ref3.effect;
                if (typeof effect === "function") {
                    var cleanupFn = effect({
                        state: state,
                        name: name,
                        instance: instance,
                        options: options
                    });
                    var noopFn = function noopFn() {};
                    effectCleanupFns.push(cleanupFn || noopFn);
                }
            });
        }
        function cleanupModifierEffects() {
            effectCleanupFns.forEach(function(fn) {
                return fn();
            });
            effectCleanupFns = [];
        }
        return instance;
    };
}
var passive = {
    passive: true
};
function effect$2(_ref) {
    var state = _ref.state, instance = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window1 = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance.update, passive);
    });
    if (resize) window1.addEventListener("resize", instance.update, passive);
    return function() {
        if (scroll) scrollParents.forEach(function(scrollParent) {
            scrollParent.removeEventListener("scroll", instance.update, passive);
        });
        if (resize) window1.removeEventListener("resize", instance.update, passive);
    };
} // eslint-disable-next-line import/no-unused-modules
var eventListeners = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {},
    effect: effect$2,
    data: {}
};
function popperOffsets(_ref) {
    var state = _ref.state, name = _ref.name;
    // Offsets are the actual position the popper needs to have to be
    // properly positioned near its reference element
    // This is the most basic placement, and will be adjusted by
    // the modifiers in the next step
    state.modifiersData[name] = computeOffsets({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: "absolute",
        placement: state.placement
    });
} // eslint-disable-next-line import/no-unused-modules
var popperOffsets$1 = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {}
};
var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.
function roundOffsetsByDPR(_ref) {
    var x = _ref.x, y = _ref.y;
    var win = window;
    var dpr = win.devicePixelRatio || 1;
    return {
        x: round(round(x * dpr) / dpr) || 0,
        y: round(round(y * dpr) / dpr) || 0
    };
}
function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets;
    var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === "function" ? roundOffsets(offsets) : offsets, _ref3$x = _ref3.x, x = _ref3$x === void 0 ? 0 : _ref3$x, _ref3$y = _ref3.y, y = _ref3$y === void 0 ? 0 : _ref3$y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top;
    var win = window;
    if (adaptive) {
        var offsetParent = getOffsetParent(popper);
        var heightProp = "clientHeight";
        var widthProp = "clientWidth";
        if (offsetParent === getWindow(popper)) {
            offsetParent = getDocumentElement(popper);
            if (getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
                heightProp = "scrollHeight";
                widthProp = "scrollWidth";
            }
        } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it
        offsetParent;
        if (placement === top || (placement === left || placement === right) && variation === end) {
            sideY = bottom; // $FlowFixMe[prop-missing]
            y -= offsetParent[heightProp] - popperRect.height;
            y *= gpuAcceleration ? 1 : -1;
        }
        if (placement === left || (placement === top || placement === bottom) && variation === end) {
            sideX = right; // $FlowFixMe[prop-missing]
            x -= offsetParent[widthProp] - popperRect.width;
            x *= gpuAcceleration ? 1 : -1;
        }
    }
    var commonStyles = Object.assign({
        position: position
    }, adaptive && unsetSides);
    if (gpuAcceleration) {
        var _Object$assign;
        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref4) {
    var state = _ref4.state, options = _ref4.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    var commonStyles = {
        placement: getBasePlacement(state.placement),
        variation: getVariation(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration: gpuAcceleration
    };
    if (state.modifiersData.popperOffsets != null) state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive: adaptive,
        roundOffsets: roundOffsets
    })));
    if (state.modifiersData.arrow != null) state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets: roundOffsets
    })));
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
        "data-popper-placement": state.placement
    });
} // eslint-disable-next-line import/no-unused-modules
var computeStyles$1 = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
};
// and applies them to the HTMLElements such as popper and arrow
function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name) {
        var style = state.styles[name] || {};
        var attributes = state.attributes[name] || {};
        var element = state.elements[name]; // arrow is optional + virtual elements
        if (!isHTMLElement(element) || !getNodeName(element)) return;
         // Flow doesn't support to extend this property, but it's the most
        // effective way to apply styles to an HTMLElement
        // $FlowFixMe[cannot-write]
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(name) {
            var value = attributes[name];
            if (value === false) element.removeAttribute(name);
            else element.setAttribute(name, value === true ? "" : value);
        });
    });
}
function effect$1(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
        popper: {
            position: state.options.strategy,
            left: "0",
            top: "0",
            margin: "0"
        },
        arrow: {
            position: "absolute"
        },
        reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) Object.assign(state.elements.arrow.style, initialStyles.arrow);
    return function() {
        Object.keys(state.elements).forEach(function(name) {
            var element = state.elements[name];
            var attributes = state.attributes[name] || {};
            var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them
            var style = styleProperties.reduce(function(style, property) {
                style[property] = "";
                return style;
            }, {}); // arrow is optional + virtual elements
            if (!isHTMLElement(element) || !getNodeName(element)) return;
            Object.assign(element.style, style);
            Object.keys(attributes).forEach(function(attribute) {
                element.removeAttribute(attribute);
            });
        });
    };
} // eslint-disable-next-line import/no-unused-modules
var applyStyles$1 = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect: effect$1,
    requires: [
        "computeStyles"
    ]
};
var defaultModifiers = [
    eventListeners,
    popperOffsets$1,
    computeStyles$1,
    applyStyles$1
];
var createPopper = /*#__PURE__*/ popperGenerator({
    defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules
function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
}
function within(min$1, value, max$1) {
    return max(min$1, min(value, max$1));
}
function preventOverflow(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        altBoundary: altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
        placement: state.placement
    })) : tetherOffset;
    var data = {
        x: 0,
        y: 0
    };
    if (!popperOffsets) return;
    if (checkMainAxis || checkAltAxis) {
        var mainSide = mainAxis === "y" ? top : left;
        var altSide = mainAxis === "y" ? bottom : right;
        var len = mainAxis === "y" ? "height" : "width";
        var offset = popperOffsets[mainAxis];
        var min$1 = popperOffsets[mainAxis] + overflow[mainSide];
        var max$1 = popperOffsets[mainAxis] - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === start ? referenceRect[len] : popperRect[len];
        var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
        // outside the reference bounds
        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
            width: 0,
            height: 0
        };
        var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
        // to include its full size in the calculation. If the reference is small
        // and near the edge of a boundary, the popper can overflow even if the
        // reference is not overflowing as well (e.g. virtual elements with no
        // width or height)
        var arrowLen = within(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
        var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;
        if (checkMainAxis) {
            var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
            popperOffsets[mainAxis] = preventedOffset;
            data[mainAxis] = preventedOffset - offset;
        }
        if (checkAltAxis) {
            var _mainSide = mainAxis === "x" ? top : left;
            var _altSide = mainAxis === "x" ? bottom : right;
            var _offset = popperOffsets[altAxis];
            var _min = _offset + overflow[_mainSide];
            var _max = _offset - overflow[_altSide];
            var _preventedOffset = within(tether ? min(_min, tetherMin) : _min, _offset, tether ? max(_max, tetherMax) : _max);
            popperOffsets[altAxis] = _preventedOffset;
            data[altAxis] = _preventedOffset - _offset;
        }
    }
    state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules
var preventOverflow$1 = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: [
        "offset"
    ]
};
var hash$1 = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
};
function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
        return hash$1[matched];
    });
}
var hash = {
    start: "end",
    end: "start"
};
function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
        return hash[matched];
    });
}
function computeAutoPlacement(state, options) {
    if (options === void 0) options = {};
    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement) {
        return getVariation(placement) === variation;
    }) : basePlacements;
    var allowedPlacements = placements$1.filter(function(placement) {
        return allowedAutoPlacements.indexOf(placement) >= 0;
    });
    if (allowedPlacements.length === 0) allowedPlacements = placements$1;
     // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...
    var overflows = allowedPlacements.reduce(function(acc, placement) {
        acc[placement] = detectOverflow(state, {
            placement: placement,
            boundary: boundary,
            rootBoundary: rootBoundary,
            padding: padding
        })[getBasePlacement(placement)];
        return acc;
    }, {});
    return Object.keys(overflows).sort(function(a, b) {
        return overflows[a] - overflows[b];
    });
}
function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) return [];
    var oppositePlacement = getOppositePlacement(placement);
    return [
        getOppositeVariationPlacement(placement),
        oppositePlacement,
        getOppositeVariationPlacement(oppositePlacement)
    ];
}
function flip(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    if (state.modifiersData[name]._skip) return;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [
        getOppositePlacement(preferredPlacement)
    ] : getExpandedFallbackPlacements(preferredPlacement));
    var placements = [
        preferredPlacement
    ].concat(fallbackPlacements).reduce(function(acc, placement) {
        return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
            placement: placement,
            boundary: boundary,
            rootBoundary: rootBoundary,
            padding: padding,
            flipVariations: flipVariations,
            allowedAutoPlacements: allowedAutoPlacements
        }) : placement);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements[0];
    for(var i = 0; i < placements.length; i++){
        var placement = placements[i];
        var _basePlacement = getBasePlacement(placement);
        var isStartVariation = getVariation(placement) === start;
        var isVertical = [
            top,
            bottom
        ].indexOf(_basePlacement) >= 0;
        var len = isVertical ? "width" : "height";
        var overflow = detectOverflow(state, {
            placement: placement,
            boundary: boundary,
            rootBoundary: rootBoundary,
            altBoundary: altBoundary,
            padding: padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
        if (referenceRect[len] > popperRect[len]) mainVariationSide = getOppositePlacement(mainVariationSide);
        var altVariationSide = getOppositePlacement(mainVariationSide);
        var checks = [];
        if (checkMainAxis) checks.push(overflow[_basePlacement] <= 0);
        if (checkAltAxis) checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        if (checks.every(function(check) {
            return check;
        })) {
            firstFittingPlacement = placement;
            makeFallbackChecks = false;
            break;
        }
        checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
        // `2` may be desired in some cases \u2013 research later
        var numberOfChecks = flipVariations ? 3 : 1;
        var _loop = function _loop(_i) {
            var fittingPlacement = placements.find(function(placement) {
                var checks = checksMap.get(placement);
                if (checks) return checks.slice(0, _i).every(function(check) {
                    return check;
                });
            });
            if (fittingPlacement) {
                firstFittingPlacement = fittingPlacement;
                return "break";
            }
        };
        for(var _i = numberOfChecks; _i > 0; _i--){
            var _ret = _loop(_i);
            if (_ret === "break") break;
        }
    }
    if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
    }
} // eslint-disable-next-line import/no-unused-modules
var flip$1 = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: flip,
    requiresIfExists: [
        "offset"
    ],
    data: {
        _skip: false
    }
};
function distanceAndSkiddingToXY(placement, rects, offset) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [
        left,
        top
    ].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset === "function" ? offset(Object.assign({}, rects, {
        placement: placement
    })) : offset, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [
        left,
        right
    ].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
    } : {
        x: skidding,
        y: distance
    };
}
function offset(_ref2) {
    var state = _ref2.state, options = _ref2.options, name = _ref2.name;
    var _options$offset = options.offset, offset = _options$offset === void 0 ? [
        0,
        0
    ] : _options$offset;
    var data = placements.reduce(function(acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
        return acc;
    }, {});
    var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x;
        state.modifiersData.popperOffsets.y += y;
    }
    state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules
var offset$1 = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: [
        "popperOffsets"
    ],
    fn: offset
};
var toPaddingObject = function toPaddingObject(padding, state) {
    padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
        placement: state.placement
    })) : padding;
    return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name = _ref.name, options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [
        left,
        right
    ].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets) return;
    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === "y" ? top : left;
    var maxProp = axis === "y" ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
    var startDiff = popperOffsets[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
    // outside of the popper bounds
    var min = paddingObject[minProp];
    var max = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset = within(min, center, max); // Prevents breaking syntax highlighting...
    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}
function effect(_ref2) {
    var state = _ref2.state, options = _ref2.options;
    var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) return;
     // CSS selector
    if (typeof arrowElement === "string") {
        arrowElement = state.elements.popper.querySelector(arrowElement);
        if (!arrowElement) return;
    }
    if (!contains(state.elements.popper, arrowElement)) return;
    state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules
var arrow$1 = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: arrow,
    effect: effect,
    requires: [
        "popperOffsets"
    ],
    requiresIfExists: [
        "preventOverflow"
    ]
};
const toInt = (x)=>parseInt(x, 10);
function usePopper({ arrowPadding , emit , locked , offsetDistance , offsetSkid , placement , popperNode , triggerNode  }) {
    const state = (0, _vue.reactive)({
        isOpen: false,
        popperInstance: null
    }); // Enable or disable event listeners to optimize performance.
    const setPopperEventListeners = (enabled)=>{
        var _state$popperInstance;
        (_state$popperInstance = state.popperInstance) === null || _state$popperInstance === void 0 || _state$popperInstance.setOptions((options)=>({
                ...options,
                modifiers: [
                    ...options.modifiers,
                    {
                        name: "eventListeners",
                        enabled
                    }
                ]
            }));
    };
    const enablePopperEventListeners = ()=>setPopperEventListeners(true);
    const disablePopperEventListeners = ()=>setPopperEventListeners(false);
    const close = ()=>{
        if (!state.isOpen) return;
        state.isOpen = false;
        emit("close:popper");
    };
    const open = ()=>{
        if (state.isOpen) return;
        state.isOpen = true;
        emit("open:popper");
    }; // When isOpen or placement change
    (0, _vue.watch)([
        ()=>state.isOpen,
        placement
    ], async ([isOpen])=>{
        if (isOpen) {
            await initializePopper();
            enablePopperEventListeners();
        } else disablePopperEventListeners();
    });
    const initializePopper = async ()=>{
        await (0, _vue.nextTick)();
        state.popperInstance = createPopper(triggerNode.value, popperNode.value, {
            placement: placement.value,
            modifiers: [
                preventOverflow$1,
                flip$1,
                {
                    name: "flip",
                    enabled: !locked.value
                },
                arrow$1,
                {
                    name: "arrow",
                    options: {
                        padding: toInt(arrowPadding.value)
                    }
                },
                offset$1,
                {
                    name: "offset",
                    options: {
                        offset: [
                            toInt(offsetSkid.value),
                            toInt(offsetDistance.value)
                        ]
                    }
                }
            ]
        }); // Update its position
        state.popperInstance.update();
    };
    (0, _vue.onBeforeUnmount)(()=>{
        var _state$popperInstance2;
        (_state$popperInstance2 = state.popperInstance) === null || _state$popperInstance2 === void 0 || _state$popperInstance2.destroy();
    });
    return {
        ...(0, _vue.toRefs)(state),
        open,
        close
    };
}
const _hoisted_1$1 = {
    id: "arrow",
    "data-popper-arrow": ""
};
function render(_ctx, _cache) {
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_1$1);
}
function styleInject(css, ref) {
    if (ref === void 0) ref = {};
    var insertAt = ref.insertAt;
    if (!css || typeof document === "undefined") return;
    var head = document.head || document.getElementsByTagName("head")[0];
    var style = document.createElement("style");
    style.type = "text/css";
    if (insertAt === "top") {
        if (head.firstChild) head.insertBefore(style, head.firstChild);
        else head.appendChild(style);
    } else head.appendChild(style);
    if (style.styleSheet) style.styleSheet.cssText = css;
    else style.appendChild(document.createTextNode(css));
}
var css_248z$1 = '\n#arrow[data-v-20b7fd4a],\n  #arrow[data-v-20b7fd4a]::before {\n    transition: background 250ms ease-in-out;\n    position: absolute;\n    width: calc(10px - var(--popper-theme-border-width, 0px));\n    height: calc(10px - var(--popper-theme-border-width, 0px));\n    box-sizing: border-box;\n    background: var(--popper-theme-background-color);\n}\n#arrow[data-v-20b7fd4a] {\n    visibility: hidden;\n}\n#arrow[data-v-20b7fd4a]::before {\n    visibility: visible;\n    content: "";\n    transform: rotate(45deg);\n}\n\n  /* Top arrow */\n.popper[data-popper-placement^="top"] > #arrow[data-v-20b7fd4a] {\n    bottom: -5px;\n}\n.popper[data-popper-placement^="top"] > #arrow[data-v-20b7fd4a]::before {\n    border-right: var(--popper-theme-border-width)\n      var(--popper-theme-border-style) var(--popper-theme-border-color);\n    border-bottom: var(--popper-theme-border-width)\n      var(--popper-theme-border-style) var(--popper-theme-border-color);\n}\n\n  /* Bottom arrow */\n.popper[data-popper-placement^="bottom"] > #arrow[data-v-20b7fd4a] {\n    top: -5px;\n}\n.popper[data-popper-placement^="bottom"] > #arrow[data-v-20b7fd4a]::before {\n    border-left: var(--popper-theme-border-width)\n      var(--popper-theme-border-style) var(--popper-theme-border-color);\n    border-top: var(--popper-theme-border-width)\n      var(--popper-theme-border-style) var(--popper-theme-border-color);\n}\n\n  /* Left arrow */\n.popper[data-popper-placement^="left"] > #arrow[data-v-20b7fd4a] {\n    right: -5px;\n}\n.popper[data-popper-placement^="left"] > #arrow[data-v-20b7fd4a]::before {\n    border-right: var(--popper-theme-border-width)\n      var(--popper-theme-border-style) var(--popper-theme-border-color);\n    border-top: var(--popper-theme-border-width)\n      var(--popper-theme-border-style) var(--popper-theme-border-color);\n}\n\n  /* Right arrow */\n.popper[data-popper-placement^="right"] > #arrow[data-v-20b7fd4a] {\n    left: -5px;\n}\n';
styleInject(css_248z$1);
const script$1 = {};
script$1.render = render;
script$1.__scopeId = "data-v-20b7fd4a";
var Arrow = script$1;
const _hoisted_1 = [
    "onKeyup"
];
var script = {
    props: {
        /**
     * Preferred placement (the "auto" placements will choose the side with most space.)
     */ placement: {
            type: String,
            default: "bottom",
            validator: function(value) {
                return [
                    "auto",
                    "auto-start",
                    "auto-end",
                    "top",
                    "top-start",
                    "top-end",
                    "bottom",
                    "bottom-start",
                    "bottom-end",
                    "right",
                    "right-start",
                    "right-end",
                    "left",
                    "left-start",
                    "left-end"
                ].includes(value);
            }
        },
        /**
     * Disables automatically closing the popover when the user clicks away from it
     */ disableClickAway: {
            type: Boolean,
            default: false
        },
        /**
     * Offset in pixels along the trigger element
     */ offsetSkid: {
            type: String,
            default: "0"
        },
        /**
     * Offset in pixels away from the trigger element
     */ offsetDistance: {
            type: String,
            default: "12"
        },
        /**
     * Trigger the popper on hover
     */ hover: {
            type: Boolean,
            default: false
        },
        /**
     * Manually open/close the Popper, other events are ignored if this prop is set
     */ show: {
            type: Boolean,
            default: null
        },
        /**
     * Disables the Popper. If it was already open, it will be closed.
     */ disabled: {
            type: Boolean,
            default: false
        },
        /**
     * Open the Popper after a delay (ms).
     */ openDelay: {
            type: [
                Number,
                String
            ],
            default: 0
        },
        /**
     * Close the Popper after a delay (ms).
     */ closeDelay: {
            type: [
                Number,
                String
            ],
            default: 0
        },
        /**
     * The z-index of the Popper.
     */ zIndex: {
            type: [
                Number,
                String
            ],
            default: 9999
        },
        /**
     * Display an arrow on the popper
     */ arrow: {
            type: Boolean,
            default: false
        },
        /**
     * Stop arrow from reaching the edge of the popper
     */ arrowPadding: {
            type: String,
            default: "0"
        },
        /**
     * If the Popper should be interactive, it will close when clicked/hovered if false
     */ interactive: {
            type: Boolean,
            default: true
        },
        /**
     * Lock the Popper into place, it will not flip dynamically when it runs out of space if true
     */ locked: {
            type: Boolean,
            default: false
        },
        /**
     * If the content is just a simple string, it can be passed in as a prop
     */ content: {
            type: String,
            default: null
        }
    },
    emits: [
        "open:popper",
        "close:popper"
    ],
    setup (__props, { emit  }) {
        const props = __props;
        (0, _vue.useCssVars)((_ctx)=>({
                "c81fc0a4": __props.zIndex
            }));
        const slots = (0, _vue.useSlots)();
        const popperContainerNode = (0, _vue.ref)(null);
        const popperNode = (0, _vue.ref)(null);
        const triggerNode = (0, _vue.ref)(null);
        const modifiedIsOpen = (0, _vue.ref)(false);
        (0, _vue.onMounted)(()=>{
            const children = slots.default();
            if (children && children.length > 1) return console.error(`[Popper]: The <Popper> component expects only one child element at its root. You passed ${children.length} child nodes.`);
        });
        const { arrowPadding , closeDelay , content , disableClickAway , disabled , interactive , locked , offsetDistance , offsetSkid , openDelay , placement , show  } = (0, _vue.toRefs)(props);
        const { isOpen , open , close  } = usePopper({
            arrowPadding,
            emit,
            locked,
            offsetDistance,
            offsetSkid,
            placement,
            popperNode,
            triggerNode
        });
        const { hasContent  } = useContent(slots, popperNode, content);
        const manualMode = (0, _vue.computed)(()=>show.value !== null);
        const invalid = (0, _vue.computed)(()=>disabled.value || !hasContent.value);
        const shouldShowPopper = (0, _vue.computed)(()=>isOpen.value && !invalid.value);
        const enableClickAway = (0, _vue.computed)(()=>!disableClickAway.value && !manualMode.value); // Add an invisible border to keep the Popper open when hovering from the trigger into it
        const interactiveStyle = (0, _vue.computed)(()=>interactive.value ? `border: ${offsetDistance.value}px solid transparent; margin: -${offsetDistance.value}px;` : null);
        const openPopperDebounce = debounce_1.debounce(open, openDelay.value);
        const closePopperDebounce = debounce_1.debounce(close, closeDelay.value);
        const openPopper = async ()=>{
            if (invalid.value || manualMode.value) return;
            closePopperDebounce.clear();
            openPopperDebounce();
        };
        const closePopper = async ()=>{
            if (manualMode.value) return;
            openPopperDebounce.clear();
            closePopperDebounce();
        };
        const togglePopper = ()=>{
            isOpen.value ? closePopper() : openPopper();
        };
        /**
     * If Popper is open, we automatically close it if it becomes
     * disabled or without content.
     */ (0, _vue.watch)([
            hasContent,
            disabled
        ], ([hasContent, disabled])=>{
            if (isOpen.value && (!hasContent || disabled)) close();
        });
        /**
     * In order to eliminate flickering or visibly empty Poppers due to
     * the transition when using the isOpen slot property, we need to return a
     * separate debounced value based on isOpen.
     */ (0, _vue.watch)(isOpen, (isOpen)=>{
            if (isOpen) modifiedIsOpen.value = true;
            else debounce_1.debounce(()=>{
                modifiedIsOpen.value = false;
            }, 200);
        });
        /**
     * Watch for manual mode.
     */ (0, _vue.watchEffect)(()=>{
            if (manualMode.value) show.value ? openPopperDebounce() : closePopperDebounce();
        });
        /**
     * Use click away if it should be enabled.
     */ (0, _vue.watchEffect)(()=>{
            if (enableClickAway.value) useClickAway(popperContainerNode, closePopper);
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: "inline-block",
                style: (0, _vue.normalizeStyle)((0, _vue.unref)(interactiveStyle)),
                onMouseleave: _cache[2] || (_cache[2] = ($event)=>__props.hover && closePopper()),
                ref: (_value, _refs)=>{
                    _refs["popperContainerNode"] = _value;
                    popperContainerNode.value = _value;
                }
            }, [
                (0, _vue.createElementVNode)("div", {
                    ref: (_value, _refs)=>{
                        _refs["triggerNode"] = _value;
                        triggerNode.value = _value;
                    },
                    onMouseover: _cache[0] || (_cache[0] = ($event)=>__props.hover && openPopper()),
                    onClick: togglePopper,
                    onFocus: openPopper,
                    onKeyup: (0, _vue.withKeys)(closePopper, [
                        "esc"
                    ])
                }, [
                    (0, _vue.renderSlot)(_ctx.$slots, "default")
                ], 40, _hoisted_1),
                (0, _vue.createVNode)((0, _vue.Transition), {
                    name: "fade"
                }, {
                    default: (0, _vue.withCtx)(()=>[
                            (0, _vue.withDirectives)((0, _vue.createElementVNode)("div", {
                                onClick: _cache[1] || (_cache[1] = ($event)=>!(0, _vue.unref)(interactive) && closePopper()),
                                class: "popper",
                                ref: (_value, _refs)=>{
                                    _refs["popperNode"] = _value;
                                    popperNode.value = _value;
                                }
                            }, [
                                (0, _vue.renderSlot)(_ctx.$slots, "content", {
                                    close: (0, _vue.unref)(close),
                                    isOpen: modifiedIsOpen.value
                                }, ()=>[
                                        (0, _vue.createTextVNode)((0, _vue.toDisplayString)((0, _vue.unref)(content)), 1)
                                    ]),
                                __props.arrow ? ((0, _vue.openBlock)(), (0, _vue.createBlock)(Arrow, {
                                    key: 0
                                })) : (0, _vue.createCommentVNode)("", true)
                            ], 512), [
                                [
                                    (0, _vue.vShow),
                                    (0, _vue.unref)(shouldShowPopper)
                                ]
                            ])
                        ]),
                    _: 3
                })
            ], 36);
        };
    }
};
var css_248z = "\n.inline-block[data-v-5784ed69] {\n    display: inline-block;\n}\n.popper[data-v-5784ed69] {\n    transition: background 250ms ease-in-out;\n    background: var(--popper-theme-background-color);\n    padding: var(--popper-theme-padding);\n    color: var(--popper-theme-text-color);\n    border-radius: var(--popper-theme-border-radius);\n    border-width: var(--popper-theme-border-width);\n    border-style: var(--popper-theme-border-style);\n    border-color: var(--popper-theme-border-color);\n    box-shadow: var(--popper-theme-box-shadow);\n    z-index: var(--c81fc0a4);\n}\n.popper[data-v-5784ed69]:hover,\n  .popper:hover > #arrow[data-v-5784ed69]::before {\n    background: var(--popper-theme-background-color-hover);\n}\n.inline-block[data-v-5784ed69] {\n    display: inline-block;\n}\n.fade-enter-active[data-v-5784ed69],\n  .fade-leave-active[data-v-5784ed69] {\n    transition: opacity 0.2s ease;\n}\n.fade-enter-from[data-v-5784ed69],\n  .fade-leave-to[data-v-5784ed69] {\n    opacity: 0;\n}\n";
styleInject(css_248z);
script.__scopeId = "data-v-5784ed69";
// IIFE injects install function into component, allowing component
// to be registered via Vue.use() as well as Vue.component(),
var entry_esm = /*#__PURE__*/ (()=>{
    // Get component instance
    const installable = script; // Attach install function executed by Vue.use()
    installable.install = (app)=>{
        app.component("Popper", installable);
    };
    return installable;
})(); // It's possible to expose named exports when writing components that can

},{"vue":"dmrjI","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"3COT6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require("e7f432b5122ad7b2");
    if (script.__esModule) script = script.default;
    script.render = require("d749e7ad50c73f79").render;
    script.__cssModules = require("e55089ac0531806f").default;
    require("e65c4942d1349935").default(script);
    script.__scopeId = "data-v-c36ef3";
    script.__file = "/Users/mahbubislammahim/Desktop/Development/Webpilot/src/components/InteractiveIcon/InteractiveIcon.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "c36ef3-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("c36ef3-hmr", script)) __VUE_HMR_RUNTIME__.reload("c36ef3-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"e7f432b5122ad7b2":"4bwY0","d749e7ad50c73f79":"bpEe2","e55089ac0531806f":"9L6d4","e65c4942d1349935":"2BL3b","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"4bwY0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _vue = require("vue");
var _core = require("@vueuse/core");
exports.default = {
    __name: "InteractiveIcon",
    props: {
        type: {
            type: String,
            default: ""
        },
        disable: {
            type: String,
            default: ""
        },
        hoverDelay: {
            type: Number,
            default: 0
        },
        clickDelay: {
            type: Number,
            default: 0
        },
        label: {
            type: String,
            default: ""
        },
        size: {
            type: Number,
            default: 24
        },
        // value 0 means do not handle hover state
        // value 1 implies control hover state as a normal state
        // value 2 implies control hover state as an active state
        hoverState: {
            type: Number,
            default: 0
        }
    },
    setup (__props, { expose: __expose  }) {
        __expose();
        const props = __props;
        const ICON_STATE = {
            DEFAULT: "default",
            HOVER: "hover",
            CLICK: "click",
            DISABLE: "disable"
        };
        const node = (0, _vue.ref)(null);
        const isHovered = (0, _vue.ref)(false);
        const isClicked = (0, _vue.ref)(false);
        const delayHover = (0, _core.useElementHover)(node);
        const { pressed: delayClick  } = (0, _core.useMousePressed)({
            target: node
        });
        const state = (0, _vue.computed)(()=>{
            if (props.disable) return ICON_STATE.DISABLE;
            if (isClicked.value) return ICON_STATE.CLICK;
            if (isHovered.value) return ICON_STATE.HOVER;
            return ICON_STATE.DEFAULT;
        });
        const iconClassName = (0, _vue.computed)(()=>{
            if (!props.hoverState) return `img-${props.type}--${state.value}`;
            if (props.hoverState === 2) return `img-${props.type}--hover`;
            return `img-${props.type}--default`;
        });
        let hoverTimer = null;
        (0, _vue.watch)(delayHover, (currentState)=>{
            if (props.hoverState > 0) return;
            if (props.hoverDelay === 0) isHovered.value = currentState;
            else if (!currentState) hoverTimer = setTimeout(()=>isHovered.value = false, props.hoverDelay);
            else {
                clearTimeout(hoverTimer);
                isHovered.value = true;
            }
        });
        let clickTimer = null;
        (0, _vue.watch)(delayClick, (currentState)=>{
            if (props.hoverDelay === 0) isClicked.value = currentState;
            else if (!currentState) clickTimer = setTimeout(()=>isClicked.value = false, props.hoverDelay);
            else {
                clearTimeout(clickTimer);
                isClicked.value = true;
            }
        });
        const __returned__ = {
            ICON_STATE,
            node,
            isHovered,
            isClicked,
            delayHover,
            delayClick,
            props,
            state,
            iconClassName,
            get hoverTimer () {
                return hoverTimer;
            },
            set hoverTimer (v){
                hoverTimer = v;
            },
            get clickTimer () {
                return clickTimer;
            },
            set clickTimer (v){
                clickTimer = v;
            },
            ref: (0, _vue.ref),
            computed: (0, _vue.computed),
            watch: (0, _vue.watch),
            get useMousePressed () {
                return 0, _core.useMousePressed;
            },
            get useElementHover () {
                return 0, _core.useElementHover;
            }
        };
        Object.defineProperty(__returned__, "__isScriptSetup", {
            enumerable: false,
            value: true
        });
        return __returned__;
    }
};

},{"vue":"dmrjI","@vueuse/core":"fa5y9","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"fa5y9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DefaultMagicKeysAliasMap", ()=>DefaultMagicKeysAliasMap);
parcelHelpers.export(exports, "StorageSerializers", ()=>StorageSerializers);
parcelHelpers.export(exports, "TransitionPresets", ()=>TransitionPresets);
parcelHelpers.export(exports, "asyncComputed", ()=>computedAsync);
parcelHelpers.export(exports, "breakpointsAntDesign", ()=>breakpointsAntDesign);
parcelHelpers.export(exports, "breakpointsBootstrapV5", ()=>breakpointsBootstrapV5);
parcelHelpers.export(exports, "breakpointsMasterCss", ()=>breakpointsMasterCss);
parcelHelpers.export(exports, "breakpointsPrimeFlex", ()=>breakpointsPrimeFlex);
parcelHelpers.export(exports, "breakpointsQuasar", ()=>breakpointsQuasar);
parcelHelpers.export(exports, "breakpointsSematic", ()=>breakpointsSematic);
parcelHelpers.export(exports, "breakpointsTailwind", ()=>breakpointsTailwind);
parcelHelpers.export(exports, "breakpointsVuetify", ()=>breakpointsVuetify);
parcelHelpers.export(exports, "breakpointsVuetifyV2", ()=>breakpointsVuetifyV2);
parcelHelpers.export(exports, "breakpointsVuetifyV3", ()=>breakpointsVuetifyV3);
parcelHelpers.export(exports, "cloneFnJSON", ()=>cloneFnJSON);
parcelHelpers.export(exports, "computedAsync", ()=>computedAsync);
parcelHelpers.export(exports, "computedInject", ()=>computedInject);
parcelHelpers.export(exports, "createFetch", ()=>createFetch);
parcelHelpers.export(exports, "createReusableTemplate", ()=>createReusableTemplate);
parcelHelpers.export(exports, "createTemplatePromise", ()=>createTemplatePromise);
parcelHelpers.export(exports, "createUnrefFn", ()=>createUnrefFn);
parcelHelpers.export(exports, "customStorageEventName", ()=>customStorageEventName);
parcelHelpers.export(exports, "defaultDocument", ()=>defaultDocument);
parcelHelpers.export(exports, "defaultLocation", ()=>defaultLocation);
parcelHelpers.export(exports, "defaultNavigator", ()=>defaultNavigator);
parcelHelpers.export(exports, "defaultWindow", ()=>defaultWindow);
parcelHelpers.export(exports, "executeTransition", ()=>executeTransition);
parcelHelpers.export(exports, "formatTimeAgo", ()=>formatTimeAgo);
parcelHelpers.export(exports, "getSSRHandler", ()=>getSSRHandler);
parcelHelpers.export(exports, "mapGamepadToXbox360Controller", ()=>mapGamepadToXbox360Controller);
parcelHelpers.export(exports, "onClickOutside", ()=>onClickOutside);
parcelHelpers.export(exports, "onKeyDown", ()=>onKeyDown);
parcelHelpers.export(exports, "onKeyPressed", ()=>onKeyPressed);
parcelHelpers.export(exports, "onKeyStroke", ()=>onKeyStroke);
parcelHelpers.export(exports, "onKeyUp", ()=>onKeyUp);
parcelHelpers.export(exports, "onLongPress", ()=>onLongPress);
parcelHelpers.export(exports, "onStartTyping", ()=>onStartTyping);
parcelHelpers.export(exports, "setSSRHandler", ()=>setSSRHandler);
parcelHelpers.export(exports, "templateRef", ()=>templateRef);
parcelHelpers.export(exports, "unrefElement", ()=>unrefElement);
parcelHelpers.export(exports, "useActiveElement", ()=>useActiveElement);
parcelHelpers.export(exports, "useAnimate", ()=>useAnimate);
parcelHelpers.export(exports, "useAsyncQueue", ()=>useAsyncQueue);
parcelHelpers.export(exports, "useAsyncState", ()=>useAsyncState);
parcelHelpers.export(exports, "useBase64", ()=>useBase64);
parcelHelpers.export(exports, "useBattery", ()=>useBattery);
parcelHelpers.export(exports, "useBluetooth", ()=>useBluetooth);
parcelHelpers.export(exports, "useBreakpoints", ()=>useBreakpoints);
parcelHelpers.export(exports, "useBroadcastChannel", ()=>useBroadcastChannel);
parcelHelpers.export(exports, "useBrowserLocation", ()=>useBrowserLocation);
parcelHelpers.export(exports, "useCached", ()=>useCached);
parcelHelpers.export(exports, "useClipboard", ()=>useClipboard);
parcelHelpers.export(exports, "useClipboardItems", ()=>useClipboardItems);
parcelHelpers.export(exports, "useCloned", ()=>useCloned);
parcelHelpers.export(exports, "useColorMode", ()=>useColorMode);
parcelHelpers.export(exports, "useConfirmDialog", ()=>useConfirmDialog);
parcelHelpers.export(exports, "useCssVar", ()=>useCssVar);
parcelHelpers.export(exports, "useCurrentElement", ()=>useCurrentElement);
parcelHelpers.export(exports, "useCycleList", ()=>useCycleList);
parcelHelpers.export(exports, "useDark", ()=>useDark);
parcelHelpers.export(exports, "useDebouncedRefHistory", ()=>useDebouncedRefHistory);
parcelHelpers.export(exports, "useDeviceMotion", ()=>useDeviceMotion);
parcelHelpers.export(exports, "useDeviceOrientation", ()=>useDeviceOrientation);
parcelHelpers.export(exports, "useDevicePixelRatio", ()=>useDevicePixelRatio);
parcelHelpers.export(exports, "useDevicesList", ()=>useDevicesList);
parcelHelpers.export(exports, "useDisplayMedia", ()=>useDisplayMedia);
parcelHelpers.export(exports, "useDocumentVisibility", ()=>useDocumentVisibility);
parcelHelpers.export(exports, "useDraggable", ()=>useDraggable);
parcelHelpers.export(exports, "useDropZone", ()=>useDropZone);
parcelHelpers.export(exports, "useElementBounding", ()=>useElementBounding);
parcelHelpers.export(exports, "useElementByPoint", ()=>useElementByPoint);
parcelHelpers.export(exports, "useElementHover", ()=>useElementHover);
parcelHelpers.export(exports, "useElementSize", ()=>useElementSize);
parcelHelpers.export(exports, "useElementVisibility", ()=>useElementVisibility);
parcelHelpers.export(exports, "useEventBus", ()=>useEventBus);
parcelHelpers.export(exports, "useEventListener", ()=>useEventListener);
parcelHelpers.export(exports, "useEventSource", ()=>useEventSource);
parcelHelpers.export(exports, "useEyeDropper", ()=>useEyeDropper);
parcelHelpers.export(exports, "useFavicon", ()=>useFavicon);
parcelHelpers.export(exports, "useFetch", ()=>useFetch);
parcelHelpers.export(exports, "useFileDialog", ()=>useFileDialog);
parcelHelpers.export(exports, "useFileSystemAccess", ()=>useFileSystemAccess);
parcelHelpers.export(exports, "useFocus", ()=>useFocus);
parcelHelpers.export(exports, "useFocusWithin", ()=>useFocusWithin);
parcelHelpers.export(exports, "useFps", ()=>useFps);
parcelHelpers.export(exports, "useFullscreen", ()=>useFullscreen);
parcelHelpers.export(exports, "useGamepad", ()=>useGamepad);
parcelHelpers.export(exports, "useGeolocation", ()=>useGeolocation);
parcelHelpers.export(exports, "useIdle", ()=>useIdle);
parcelHelpers.export(exports, "useImage", ()=>useImage);
parcelHelpers.export(exports, "useInfiniteScroll", ()=>useInfiniteScroll);
parcelHelpers.export(exports, "useIntersectionObserver", ()=>useIntersectionObserver);
parcelHelpers.export(exports, "useKeyModifier", ()=>useKeyModifier);
parcelHelpers.export(exports, "useLocalStorage", ()=>useLocalStorage);
parcelHelpers.export(exports, "useMagicKeys", ()=>useMagicKeys);
parcelHelpers.export(exports, "useManualRefHistory", ()=>useManualRefHistory);
parcelHelpers.export(exports, "useMediaControls", ()=>useMediaControls);
parcelHelpers.export(exports, "useMediaQuery", ()=>useMediaQuery);
parcelHelpers.export(exports, "useMemoize", ()=>useMemoize);
parcelHelpers.export(exports, "useMemory", ()=>useMemory);
parcelHelpers.export(exports, "useMounted", ()=>useMounted);
parcelHelpers.export(exports, "useMouse", ()=>useMouse);
parcelHelpers.export(exports, "useMouseInElement", ()=>useMouseInElement);
parcelHelpers.export(exports, "useMousePressed", ()=>useMousePressed);
parcelHelpers.export(exports, "useMutationObserver", ()=>useMutationObserver);
parcelHelpers.export(exports, "useNavigatorLanguage", ()=>useNavigatorLanguage);
parcelHelpers.export(exports, "useNetwork", ()=>useNetwork);
parcelHelpers.export(exports, "useNow", ()=>useNow);
parcelHelpers.export(exports, "useObjectUrl", ()=>useObjectUrl);
parcelHelpers.export(exports, "useOffsetPagination", ()=>useOffsetPagination);
parcelHelpers.export(exports, "useOnline", ()=>useOnline);
parcelHelpers.export(exports, "usePageLeave", ()=>usePageLeave);
parcelHelpers.export(exports, "useParallax", ()=>useParallax);
parcelHelpers.export(exports, "useParentElement", ()=>useParentElement);
parcelHelpers.export(exports, "usePerformanceObserver", ()=>usePerformanceObserver);
parcelHelpers.export(exports, "usePermission", ()=>usePermission);
parcelHelpers.export(exports, "usePointer", ()=>usePointer);
parcelHelpers.export(exports, "usePointerLock", ()=>usePointerLock);
parcelHelpers.export(exports, "usePointerSwipe", ()=>usePointerSwipe);
parcelHelpers.export(exports, "usePreferredColorScheme", ()=>usePreferredColorScheme);
parcelHelpers.export(exports, "usePreferredContrast", ()=>usePreferredContrast);
parcelHelpers.export(exports, "usePreferredDark", ()=>usePreferredDark);
parcelHelpers.export(exports, "usePreferredLanguages", ()=>usePreferredLanguages);
parcelHelpers.export(exports, "usePreferredReducedMotion", ()=>usePreferredReducedMotion);
parcelHelpers.export(exports, "usePrevious", ()=>usePrevious);
parcelHelpers.export(exports, "useRafFn", ()=>useRafFn);
parcelHelpers.export(exports, "useRefHistory", ()=>useRefHistory);
parcelHelpers.export(exports, "useResizeObserver", ()=>useResizeObserver);
parcelHelpers.export(exports, "useScreenOrientation", ()=>useScreenOrientation);
parcelHelpers.export(exports, "useScreenSafeArea", ()=>useScreenSafeArea);
parcelHelpers.export(exports, "useScriptTag", ()=>useScriptTag);
parcelHelpers.export(exports, "useScroll", ()=>useScroll);
parcelHelpers.export(exports, "useScrollLock", ()=>useScrollLock);
parcelHelpers.export(exports, "useSessionStorage", ()=>useSessionStorage);
parcelHelpers.export(exports, "useShare", ()=>useShare);
parcelHelpers.export(exports, "useSorted", ()=>useSorted);
parcelHelpers.export(exports, "useSpeechRecognition", ()=>useSpeechRecognition);
parcelHelpers.export(exports, "useSpeechSynthesis", ()=>useSpeechSynthesis);
parcelHelpers.export(exports, "useStepper", ()=>useStepper);
parcelHelpers.export(exports, "useStorage", ()=>useStorage);
parcelHelpers.export(exports, "useStorageAsync", ()=>useStorageAsync);
parcelHelpers.export(exports, "useStyleTag", ()=>useStyleTag);
parcelHelpers.export(exports, "useSupported", ()=>useSupported);
parcelHelpers.export(exports, "useSwipe", ()=>useSwipe);
parcelHelpers.export(exports, "useTemplateRefsList", ()=>useTemplateRefsList);
parcelHelpers.export(exports, "useTextDirection", ()=>useTextDirection);
parcelHelpers.export(exports, "useTextSelection", ()=>useTextSelection);
parcelHelpers.export(exports, "useTextareaAutosize", ()=>useTextareaAutosize);
parcelHelpers.export(exports, "useThrottledRefHistory", ()=>useThrottledRefHistory);
parcelHelpers.export(exports, "useTimeAgo", ()=>useTimeAgo);
parcelHelpers.export(exports, "useTimeoutPoll", ()=>useTimeoutPoll);
parcelHelpers.export(exports, "useTimestamp", ()=>useTimestamp);
parcelHelpers.export(exports, "useTitle", ()=>useTitle);
parcelHelpers.export(exports, "useTransition", ()=>useTransition);
parcelHelpers.export(exports, "useUrlSearchParams", ()=>useUrlSearchParams);
parcelHelpers.export(exports, "useUserMedia", ()=>useUserMedia);
parcelHelpers.export(exports, "useVModel", ()=>useVModel);
parcelHelpers.export(exports, "useVModels", ()=>useVModels);
parcelHelpers.export(exports, "useVibrate", ()=>useVibrate);
parcelHelpers.export(exports, "useVirtualList", ()=>useVirtualList);
parcelHelpers.export(exports, "useWakeLock", ()=>useWakeLock);
parcelHelpers.export(exports, "useWebNotification", ()=>useWebNotification);
parcelHelpers.export(exports, "useWebSocket", ()=>useWebSocket);
parcelHelpers.export(exports, "useWebWorker", ()=>useWebWorker);
parcelHelpers.export(exports, "useWebWorkerFn", ()=>useWebWorkerFn);
parcelHelpers.export(exports, "useWindowFocus", ()=>useWindowFocus);
parcelHelpers.export(exports, "useWindowScroll", ()=>useWindowScroll);
parcelHelpers.export(exports, "useWindowSize", ()=>useWindowSize);
var _shared = require("@vueuse/shared");
parcelHelpers.exportAll(_shared, exports);
var _vueDemi = require("vue-demi");
var global = arguments[3];
function computedAsync(evaluationCallback, initialState, optionsOrRef) {
    let options;
    if ((0, _vueDemi.isRef)(optionsOrRef)) options = {
        evaluating: optionsOrRef
    };
    else options = optionsOrRef || {};
    const { lazy =false , evaluating , shallow =true , onError =(0, _shared.noop)  } = options;
    const started = (0, _vueDemi.ref)(!lazy);
    const current = shallow ? (0, _vueDemi.shallowRef)(initialState) : (0, _vueDemi.ref)(initialState);
    let counter = 0;
    (0, _vueDemi.watchEffect)(async (onInvalidate)=>{
        if (!started.value) return;
        counter++;
        const counterAtBeginning = counter;
        let hasFinished = false;
        if (evaluating) Promise.resolve().then(()=>{
            evaluating.value = true;
        });
        try {
            const result = await evaluationCallback((cancelCallback)=>{
                onInvalidate(()=>{
                    if (evaluating) evaluating.value = false;
                    if (!hasFinished) cancelCallback();
                });
            });
            if (counterAtBeginning === counter) current.value = result;
        } catch (e) {
            onError(e);
        } finally{
            if (evaluating && counterAtBeginning === counter) evaluating.value = false;
            hasFinished = true;
        }
    });
    if (lazy) return (0, _vueDemi.computed)(()=>{
        started.value = true;
        return current.value;
    });
    else return current;
}
function computedInject(key, options, defaultSource, treatDefaultAsFactory) {
    let source = (0, _vueDemi.inject)(key);
    if (defaultSource) source = (0, _vueDemi.inject)(key, defaultSource);
    if (treatDefaultAsFactory) source = (0, _vueDemi.inject)(key, defaultSource, treatDefaultAsFactory);
    if (typeof options === "function") return (0, _vueDemi.computed)((ctx)=>options(source, ctx));
    else return (0, _vueDemi.computed)({
        get: (ctx)=>options.get(source, ctx),
        set: options.set
    });
}
function createReusableTemplate(options = {}) {
    if (!(0, _vueDemi.isVue3) && !(0, _vueDemi.version).startsWith("2.7.")) throw new Error("[VueUse] createReusableTemplate only works in Vue 2.7 or above.");
    const { inheritAttrs =true  } = options;
    const render = (0, _vueDemi.shallowRef)();
    const define = /* #__PURE__ */ (0, _vueDemi.defineComponent)({
        setup (_, { slots  }) {
            return ()=>{
                render.value = slots.default;
            };
        }
    });
    const reuse = /* #__PURE__ */ (0, _vueDemi.defineComponent)({
        inheritAttrs,
        setup (_, { attrs , slots  }) {
            return ()=>{
                var _a;
                if (!render.value && true) throw new Error("[VueUse] Failed to find the definition of reusable template");
                const vnode = (_a = render.value) == null ? void 0 : _a.call(render, {
                    ...keysToCamelKebabCase(attrs),
                    $slots: slots
                });
                return inheritAttrs && (vnode == null ? void 0 : vnode.length) === 1 ? vnode[0] : vnode;
            };
        }
    });
    return (0, _shared.makeDestructurable)({
        define,
        reuse
    }, [
        define,
        reuse
    ]);
}
function keysToCamelKebabCase(obj) {
    const newObj = {};
    for(const key in obj)newObj[(0, _shared.camelize)(key)] = obj[key];
    return newObj;
}
function createTemplatePromise(options = {}) {
    if (!(0, _vueDemi.isVue3)) throw new Error("[VueUse] createTemplatePromise only works in Vue 3 or above.");
    let index = 0;
    const instances = (0, _vueDemi.ref)([]);
    function create(...args) {
        const props = (0, _vueDemi.shallowReactive)({
            key: index++,
            args,
            promise: void 0,
            resolve: ()=>{},
            reject: ()=>{},
            isResolving: false,
            options
        });
        instances.value.push(props);
        props.promise = new Promise((_resolve, _reject)=>{
            props.resolve = (v)=>{
                props.isResolving = true;
                return _resolve(v);
            };
            props.reject = _reject;
        }).finally(()=>{
            props.promise = void 0;
            const index2 = instances.value.indexOf(props);
            if (index2 !== -1) instances.value.splice(index2, 1);
        });
        return props.promise;
    }
    function start(...args) {
        if (options.singleton && instances.value.length > 0) return instances.value[0].promise;
        return create(...args);
    }
    const component = /* #__PURE__ */ (0, _vueDemi.defineComponent)((_, { slots  })=>{
        const renderList = ()=>instances.value.map((props)=>{
                var _a;
                return (0, _vueDemi.h)((0, _vueDemi.Fragment), {
                    key: props.key
                }, (_a = slots.default) == null ? void 0 : _a.call(slots, props));
            });
        if (options.transition) return ()=>(0, _vueDemi.h)((0, _vueDemi.TransitionGroup), options.transition, renderList);
        return renderList;
    });
    component.start = start;
    return component;
}
function createUnrefFn(fn) {
    return function(...args) {
        return fn.apply(this, args.map((i)=>(0, _shared.toValue)(i)));
    };
}
function unrefElement(elRef) {
    var _a;
    const plain = (0, _shared.toValue)(elRef);
    return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}
const defaultWindow = (0, _shared.isClient) ? window : void 0;
const defaultDocument = (0, _shared.isClient) ? window.document : void 0;
const defaultNavigator = (0, _shared.isClient) ? window.navigator : void 0;
const defaultLocation = (0, _shared.isClient) ? window.location : void 0;
function useEventListener(...args) {
    let target;
    let events;
    let listeners;
    let options;
    if (typeof args[0] === "string" || Array.isArray(args[0])) {
        [events, listeners, options] = args;
        target = defaultWindow;
    } else [target, events, listeners, options] = args;
    if (!target) return 0, _shared.noop;
    if (!Array.isArray(events)) events = [
        events
    ];
    if (!Array.isArray(listeners)) listeners = [
        listeners
    ];
    const cleanups = [];
    const cleanup = ()=>{
        cleanups.forEach((fn)=>fn());
        cleanups.length = 0;
    };
    const register = (el, event, listener, options2)=>{
        el.addEventListener(event, listener, options2);
        return ()=>el.removeEventListener(event, listener, options2);
    };
    const stopWatch = (0, _vueDemi.watch)(()=>[
            unrefElement(target),
            (0, _shared.toValue)(options)
        ], ([el, options2])=>{
        cleanup();
        if (!el) return;
        const optionsClone = (0, _shared.isObject)(options2) ? {
            ...options2
        } : options2;
        cleanups.push(...events.flatMap((event)=>{
            return listeners.map((listener)=>register(el, event, listener, optionsClone));
        }));
    }, {
        immediate: true,
        flush: "post"
    });
    const stop = ()=>{
        stopWatch();
        cleanup();
    };
    (0, _shared.tryOnScopeDispose)(stop);
    return stop;
}
let _iOSWorkaround = false;
function onClickOutside(target, handler, options = {}) {
    const { window: window1 = defaultWindow , ignore =[] , capture =true , detectIframe =false  } = options;
    if (!window1) return 0, _shared.noop;
    if ((0, _shared.isIOS) && !_iOSWorkaround) {
        _iOSWorkaround = true;
        Array.from(window1.document.body.children).forEach((el)=>el.addEventListener("click", (0, _shared.noop)));
        window1.document.documentElement.addEventListener("click", (0, _shared.noop));
    }
    let shouldListen = true;
    const shouldIgnore = (event)=>{
        return ignore.some((target2)=>{
            if (typeof target2 === "string") return Array.from(window1.document.querySelectorAll(target2)).some((el)=>el === event.target || event.composedPath().includes(el));
            else {
                const el = unrefElement(target2);
                return el && (event.target === el || event.composedPath().includes(el));
            }
        });
    };
    const listener = (event)=>{
        const el = unrefElement(target);
        if (!el || el === event.target || event.composedPath().includes(el)) return;
        if (event.detail === 0) shouldListen = !shouldIgnore(event);
        if (!shouldListen) {
            shouldListen = true;
            return;
        }
        handler(event);
    };
    const cleanup = [
        useEventListener(window1, "click", listener, {
            passive: true,
            capture
        }),
        useEventListener(window1, "pointerdown", (e)=>{
            const el = unrefElement(target);
            shouldListen = !shouldIgnore(e) && !!(el && !e.composedPath().includes(el));
        }, {
            passive: true
        }),
        detectIframe && useEventListener(window1, "blur", (event)=>{
            setTimeout(()=>{
                var _a;
                const el = unrefElement(target);
                if (((_a = window1.document.activeElement) == null ? void 0 : _a.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window1.document.activeElement))) handler(event);
            }, 0);
        })
    ].filter(Boolean);
    const stop = ()=>cleanup.forEach((fn)=>fn());
    return stop;
}
function createKeyPredicate(keyFilter) {
    if (typeof keyFilter === "function") return keyFilter;
    else if (typeof keyFilter === "string") return (event)=>event.key === keyFilter;
    else if (Array.isArray(keyFilter)) return (event)=>keyFilter.includes(event.key);
    return ()=>true;
}
function onKeyStroke(...args) {
    let key;
    let handler;
    let options = {};
    if (args.length === 3) {
        key = args[0];
        handler = args[1];
        options = args[2];
    } else if (args.length === 2) {
        if (typeof args[1] === "object") {
            key = true;
            handler = args[0];
            options = args[1];
        } else {
            key = args[0];
            handler = args[1];
        }
    } else {
        key = true;
        handler = args[0];
    }
    const { target =defaultWindow , eventName ="keydown" , passive =false , dedupe =false  } = options;
    const predicate = createKeyPredicate(key);
    const listener = (e)=>{
        if (e.repeat && (0, _shared.toValue)(dedupe)) return;
        if (predicate(e)) handler(e);
    };
    return useEventListener(target, eventName, listener, passive);
}
function onKeyDown(key, handler, options = {}) {
    return onKeyStroke(key, handler, {
        ...options,
        eventName: "keydown"
    });
}
function onKeyPressed(key, handler, options = {}) {
    return onKeyStroke(key, handler, {
        ...options,
        eventName: "keypress"
    });
}
function onKeyUp(key, handler, options = {}) {
    return onKeyStroke(key, handler, {
        ...options,
        eventName: "keyup"
    });
}
const DEFAULT_DELAY = 500;
const DEFAULT_THRESHOLD = 10;
function onLongPress(target, handler, options) {
    var _a, _b;
    const elementRef = (0, _vueDemi.computed)(()=>unrefElement(target));
    let timeout;
    let posStart;
    let startTimestamp;
    let hasLongPressed = false;
    function clear() {
        if (timeout) {
            clearTimeout(timeout);
            timeout = void 0;
        }
        posStart = void 0;
        startTimestamp = void 0;
        hasLongPressed = false;
    }
    function onRelease(ev) {
        var _a2, _b2, _c;
        const [_startTimestamp, _posStart, _hasLongPressed] = [
            startTimestamp,
            posStart,
            hasLongPressed
        ];
        clear();
        if (!(options == null ? void 0 : options.onMouseUp) || !_posStart || !_startTimestamp) return;
        if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value) return;
        if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent) ev.preventDefault();
        if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop) ev.stopPropagation();
        const dx = ev.x - _posStart.x;
        const dy = ev.y - _posStart.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        options.onMouseUp(ev.timeStamp - _startTimestamp, distance, _hasLongPressed);
    }
    function onDown(ev) {
        var _a2, _b2, _c, _d;
        if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value) return;
        clear();
        if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent) ev.preventDefault();
        if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop) ev.stopPropagation();
        posStart = {
            x: ev.x,
            y: ev.y
        };
        startTimestamp = ev.timeStamp;
        timeout = setTimeout(()=>{
            hasLongPressed = true;
            handler(ev);
        }, (_d = options == null ? void 0 : options.delay) != null ? _d : DEFAULT_DELAY);
    }
    function onMove(ev) {
        var _a2, _b2, _c, _d;
        if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value) return;
        if (!posStart || (options == null ? void 0 : options.distanceThreshold) === false) return;
        if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent) ev.preventDefault();
        if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop) ev.stopPropagation();
        const dx = ev.x - posStart.x;
        const dy = ev.y - posStart.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance >= ((_d = options == null ? void 0 : options.distanceThreshold) != null ? _d : DEFAULT_THRESHOLD)) clear();
    }
    const listenerOptions = {
        capture: (_a = options == null ? void 0 : options.modifiers) == null ? void 0 : _a.capture,
        once: (_b = options == null ? void 0 : options.modifiers) == null ? void 0 : _b.once
    };
    const cleanup = [
        useEventListener(elementRef, "pointerdown", onDown, listenerOptions),
        useEventListener(elementRef, "pointermove", onMove, listenerOptions),
        useEventListener(elementRef, [
            "pointerup",
            "pointerleave"
        ], onRelease, listenerOptions)
    ];
    const stop = ()=>cleanup.forEach((fn)=>fn());
    return stop;
}
function isFocusedElementEditable() {
    const { activeElement , body  } = document;
    if (!activeElement) return false;
    if (activeElement === body) return false;
    switch(activeElement.tagName){
        case "INPUT":
        case "TEXTAREA":
            return true;
    }
    return activeElement.hasAttribute("contenteditable");
}
function isTypedCharValid({ keyCode , metaKey , ctrlKey , altKey  }) {
    if (metaKey || ctrlKey || altKey) return false;
    if (keyCode >= 48 && keyCode <= 57) return true;
    if (keyCode >= 65 && keyCode <= 90) return true;
    if (keyCode >= 97 && keyCode <= 122) return true;
    return false;
}
function onStartTyping(callback, options = {}) {
    const { document: document2 = defaultDocument  } = options;
    const keydown = (event)=>{
        !isFocusedElementEditable() && isTypedCharValid(event) && callback(event);
    };
    if (document2) useEventListener(document2, "keydown", keydown, {
        passive: true
    });
}
function templateRef(key, initialValue = null) {
    const instance = (0, _vueDemi.getCurrentInstance)();
    let _trigger = ()=>{};
    const element = (0, _vueDemi.customRef)((track, trigger)=>{
        _trigger = trigger;
        return {
            get () {
                var _a, _b;
                track();
                return (_b = (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.$refs[key]) != null ? _b : initialValue;
            },
            set () {}
        };
    });
    (0, _shared.tryOnMounted)(_trigger);
    (0, _vueDemi.onUpdated)(_trigger);
    return element;
}
function useMounted() {
    const isMounted = (0, _vueDemi.ref)(false);
    const instance = (0, _vueDemi.getCurrentInstance)();
    if (instance) (0, _vueDemi.onMounted)(()=>{
        isMounted.value = true;
    }, (0, _vueDemi.isVue2) ? void 0 : instance);
    return isMounted;
}
function useSupported(callback) {
    const isMounted = useMounted();
    return (0, _vueDemi.computed)(()=>{
        isMounted.value;
        return Boolean(callback());
    });
}
function useMutationObserver(target, callback, options = {}) {
    const { window: window1 = defaultWindow , ...mutationOptions } = options;
    let observer;
    const isSupported = useSupported(()=>window1 && "MutationObserver" in window1);
    const cleanup = ()=>{
        if (observer) {
            observer.disconnect();
            observer = void 0;
        }
    };
    const targets = (0, _vueDemi.computed)(()=>{
        const value = (0, _shared.toValue)(target);
        const items = (Array.isArray(value) ? value : [
            value
        ]).map(unrefElement).filter((0, _shared.notNullish));
        return new Set(items);
    });
    const stopWatch = (0, _vueDemi.watch)(()=>targets.value, (targets2)=>{
        cleanup();
        if (isSupported.value && targets2.size) {
            observer = new MutationObserver(callback);
            targets2.forEach((el)=>observer.observe(el, mutationOptions));
        }
    }, {
        immediate: true,
        flush: "post"
    });
    const takeRecords = ()=>{
        return observer == null ? void 0 : observer.takeRecords();
    };
    const stop = ()=>{
        cleanup();
        stopWatch();
    };
    (0, _shared.tryOnScopeDispose)(stop);
    return {
        isSupported,
        stop,
        takeRecords
    };
}
function useActiveElement(options = {}) {
    var _a;
    const { window: window1 = defaultWindow , deep =true , triggerOnRemoval =false  } = options;
    const document1 = (_a = options.document) != null ? _a : window1 == null ? void 0 : window1.document;
    const getDeepActiveElement = ()=>{
        var _a2;
        let element = document1 == null ? void 0 : document1.activeElement;
        if (deep) while(element == null ? void 0 : element.shadowRoot)element = (_a2 = element == null ? void 0 : element.shadowRoot) == null ? void 0 : _a2.activeElement;
        return element;
    };
    const activeElement = (0, _vueDemi.ref)();
    const trigger = ()=>{
        activeElement.value = getDeepActiveElement();
    };
    if (window1) {
        useEventListener(window1, "blur", (event)=>{
            if (event.relatedTarget !== null) return;
            trigger();
        }, true);
        useEventListener(window1, "focus", trigger, true);
    }
    if (triggerOnRemoval) useMutationObserver(document1, (mutations)=>{
        mutations.filter((m)=>m.removedNodes.length).map((n)=>Array.from(n.removedNodes)).flat().forEach((node)=>{
            if (node === activeElement.value) trigger();
        });
    }, {
        childList: true,
        subtree: true
    });
    trigger();
    return activeElement;
}
function useRafFn(fn, options = {}) {
    const { immediate =true , fpsLimit , window: window1 = defaultWindow  } = options;
    const isActive = (0, _vueDemi.ref)(false);
    const intervalLimit = fpsLimit ? 1e3 / fpsLimit : null;
    let previousFrameTimestamp = 0;
    let rafId = null;
    function loop(timestamp) {
        if (!isActive.value || !window1) return;
        if (!previousFrameTimestamp) previousFrameTimestamp = timestamp;
        const delta = timestamp - previousFrameTimestamp;
        if (intervalLimit && delta < intervalLimit) {
            rafId = window1.requestAnimationFrame(loop);
            return;
        }
        previousFrameTimestamp = timestamp;
        fn({
            delta,
            timestamp
        });
        rafId = window1.requestAnimationFrame(loop);
    }
    function resume() {
        if (!isActive.value && window1) {
            isActive.value = true;
            previousFrameTimestamp = 0;
            rafId = window1.requestAnimationFrame(loop);
        }
    }
    function pause() {
        isActive.value = false;
        if (rafId != null && window1) {
            window1.cancelAnimationFrame(rafId);
            rafId = null;
        }
    }
    if (immediate) resume();
    (0, _shared.tryOnScopeDispose)(pause);
    return {
        isActive: (0, _vueDemi.readonly)(isActive),
        pause,
        resume
    };
}
function useAnimate(target, keyframes, options) {
    let config;
    let animateOptions;
    if ((0, _shared.isObject)(options)) {
        config = options;
        animateOptions = (0, _shared.objectOmit)(options, [
            "window",
            "immediate",
            "commitStyles",
            "persist",
            "onReady",
            "onError"
        ]);
    } else {
        config = {
            duration: options
        };
        animateOptions = options;
    }
    const { window: window1 = defaultWindow , immediate =true , commitStyles , persist , playbackRate: _playbackRate = 1 , onReady , onError =(e)=>{
        console.error(e);
    }  } = config;
    const isSupported = useSupported(()=>window1 && HTMLElement && "animate" in HTMLElement.prototype);
    const animate = (0, _vueDemi.shallowRef)(void 0);
    const store = (0, _vueDemi.shallowReactive)({
        startTime: null,
        currentTime: null,
        timeline: null,
        playbackRate: _playbackRate,
        pending: false,
        playState: immediate ? "idle" : "paused",
        replaceState: "active"
    });
    const pending = (0, _vueDemi.computed)(()=>store.pending);
    const playState = (0, _vueDemi.computed)(()=>store.playState);
    const replaceState = (0, _vueDemi.computed)(()=>store.replaceState);
    const startTime = (0, _vueDemi.computed)({
        get () {
            return store.startTime;
        },
        set (value) {
            store.startTime = value;
            if (animate.value) animate.value.startTime = value;
        }
    });
    const currentTime = (0, _vueDemi.computed)({
        get () {
            return store.currentTime;
        },
        set (value) {
            store.currentTime = value;
            if (animate.value) {
                animate.value.currentTime = value;
                syncResume();
            }
        }
    });
    const timeline = (0, _vueDemi.computed)({
        get () {
            return store.timeline;
        },
        set (value) {
            store.timeline = value;
            if (animate.value) animate.value.timeline = value;
        }
    });
    const playbackRate = (0, _vueDemi.computed)({
        get () {
            return store.playbackRate;
        },
        set (value) {
            store.playbackRate = value;
            if (animate.value) animate.value.playbackRate = value;
        }
    });
    const play = ()=>{
        if (animate.value) try {
            animate.value.play();
            syncResume();
        } catch (e) {
            syncPause();
            onError(e);
        }
        else update();
    };
    const pause = ()=>{
        var _a;
        try {
            (_a = animate.value) == null || _a.pause();
            syncPause();
        } catch (e) {
            onError(e);
        }
    };
    const reverse = ()=>{
        var _a;
        !animate.value && update();
        try {
            (_a = animate.value) == null || _a.reverse();
            syncResume();
        } catch (e) {
            syncPause();
            onError(e);
        }
    };
    const finish = ()=>{
        var _a;
        try {
            (_a = animate.value) == null || _a.finish();
            syncPause();
        } catch (e) {
            onError(e);
        }
    };
    const cancel = ()=>{
        var _a;
        try {
            (_a = animate.value) == null || _a.cancel();
            syncPause();
        } catch (e) {
            onError(e);
        }
    };
    (0, _vueDemi.watch)(()=>unrefElement(target), (el)=>{
        el && update();
    });
    (0, _vueDemi.watch)(()=>keyframes, (value)=>{
        !animate.value && update();
        if (!unrefElement(target) && animate.value) animate.value.effect = new KeyframeEffect(unrefElement(target), (0, _shared.toValue)(value), animateOptions);
    }, {
        deep: true
    });
    (0, _shared.tryOnMounted)(()=>{
        (0, _vueDemi.nextTick)(()=>update(true));
    });
    (0, _shared.tryOnScopeDispose)(cancel);
    function update(init) {
        const el = unrefElement(target);
        if (!isSupported.value || !el) return;
        if (!animate.value) animate.value = el.animate((0, _shared.toValue)(keyframes), animateOptions);
        if (persist) animate.value.persist();
        if (_playbackRate !== 1) animate.value.playbackRate = _playbackRate;
        if (init && !immediate) animate.value.pause();
        else syncResume();
        onReady == null || onReady(animate.value);
    }
    useEventListener(animate, [
        "cancel",
        "finish",
        "remove"
    ], syncPause);
    useEventListener(animate, "finish", ()=>{
        var _a;
        if (commitStyles) (_a = animate.value) == null || _a.commitStyles();
    });
    const { resume: resumeRef , pause: pauseRef  } = useRafFn(()=>{
        if (!animate.value) return;
        store.pending = animate.value.pending;
        store.playState = animate.value.playState;
        store.replaceState = animate.value.replaceState;
        store.startTime = animate.value.startTime;
        store.currentTime = animate.value.currentTime;
        store.timeline = animate.value.timeline;
        store.playbackRate = animate.value.playbackRate;
    }, {
        immediate: false
    });
    function syncResume() {
        if (isSupported.value) resumeRef();
    }
    function syncPause() {
        if (isSupported.value && window1) window1.requestAnimationFrame(pauseRef);
    }
    return {
        isSupported,
        animate,
        // actions
        play,
        pause,
        reverse,
        finish,
        cancel,
        // state
        pending,
        playState,
        replaceState,
        startTime,
        currentTime,
        timeline,
        playbackRate
    };
}
function useAsyncQueue(tasks, options) {
    const { interrupt =true , onError =(0, _shared.noop) , onFinished =(0, _shared.noop) , signal  } = options || {};
    const promiseState = {
        aborted: "aborted",
        fulfilled: "fulfilled",
        pending: "pending",
        rejected: "rejected"
    };
    const initialResult = Array.from(Array.from({
        length: tasks.length
    }), ()=>({
            state: promiseState.pending,
            data: null
        }));
    const result = (0, _vueDemi.reactive)(initialResult);
    const activeIndex = (0, _vueDemi.ref)(-1);
    if (!tasks || tasks.length === 0) {
        onFinished();
        return {
            activeIndex,
            result
        };
    }
    function updateResult(state, res) {
        activeIndex.value++;
        result[activeIndex.value].data = res;
        result[activeIndex.value].state = state;
    }
    tasks.reduce((prev, curr)=>{
        return prev.then((prevRes)=>{
            var _a;
            if (signal == null ? void 0 : signal.aborted) {
                updateResult(promiseState.aborted, new Error("aborted"));
                return;
            }
            if (((_a = result[activeIndex.value]) == null ? void 0 : _a.state) === promiseState.rejected && interrupt) {
                onFinished();
                return;
            }
            const done = curr(prevRes).then((currentRes)=>{
                updateResult(promiseState.fulfilled, currentRes);
                activeIndex.value === tasks.length - 1 && onFinished();
                return currentRes;
            });
            if (!signal) return done;
            return Promise.race([
                done,
                whenAborted(signal)
            ]);
        }).catch((e)=>{
            if (signal == null ? void 0 : signal.aborted) {
                updateResult(promiseState.aborted, e);
                return e;
            }
            updateResult(promiseState.rejected, e);
            onError();
            return e;
        });
    }, Promise.resolve());
    return {
        activeIndex,
        result
    };
}
function whenAborted(signal) {
    return new Promise((resolve, reject)=>{
        const error = new Error("aborted");
        if (signal.aborted) reject(error);
        else signal.addEventListener("abort", ()=>reject(error), {
            once: true
        });
    });
}
function useAsyncState(promise, initialState, options) {
    const { immediate =true , delay =0 , onError =(0, _shared.noop) , onSuccess =(0, _shared.noop) , resetOnExecute =true , shallow =true , throwError  } = options != null ? options : {};
    const state = shallow ? (0, _vueDemi.shallowRef)(initialState) : (0, _vueDemi.ref)(initialState);
    const isReady = (0, _vueDemi.ref)(false);
    const isLoading = (0, _vueDemi.ref)(false);
    const error = (0, _vueDemi.shallowRef)(void 0);
    async function execute(delay2 = 0, ...args) {
        if (resetOnExecute) state.value = initialState;
        error.value = void 0;
        isReady.value = false;
        isLoading.value = true;
        if (delay2 > 0) await (0, _shared.promiseTimeout)(delay2);
        const _promise = typeof promise === "function" ? promise(...args) : promise;
        try {
            const data = await _promise;
            state.value = data;
            isReady.value = true;
            onSuccess(data);
        } catch (e) {
            error.value = e;
            onError(e);
            if (throwError) throw e;
        } finally{
            isLoading.value = false;
        }
        return state.value;
    }
    if (immediate) execute(delay);
    const shell = {
        state,
        isReady,
        isLoading,
        error,
        execute
    };
    function waitUntilIsLoaded() {
        return new Promise((resolve, reject)=>{
            (0, _shared.until)(isLoading).toBe(false).then(()=>resolve(shell)).catch(reject);
        });
    }
    return {
        ...shell,
        then (onFulfilled, onRejected) {
            return waitUntilIsLoaded().then(onFulfilled, onRejected);
        }
    };
}
const defaults = {
    array: (v)=>JSON.stringify(v),
    object: (v)=>JSON.stringify(v),
    set: (v)=>JSON.stringify(Array.from(v)),
    map: (v)=>JSON.stringify(Object.fromEntries(v)),
    null: ()=>""
};
function getDefaultSerialization(target) {
    if (!target) return defaults.null;
    if (target instanceof Map) return defaults.map;
    else if (target instanceof Set) return defaults.set;
    else if (Array.isArray(target)) return defaults.array;
    else return defaults.object;
}
function useBase64(target, options) {
    const base64 = (0, _vueDemi.ref)("");
    const promise = (0, _vueDemi.ref)();
    function execute() {
        if (!(0, _shared.isClient)) return;
        promise.value = new Promise((resolve, reject)=>{
            try {
                const _target = (0, _shared.toValue)(target);
                if (_target == null) resolve("");
                else if (typeof _target === "string") resolve(blobToBase64(new Blob([
                    _target
                ], {
                    type: "text/plain"
                })));
                else if (_target instanceof Blob) resolve(blobToBase64(_target));
                else if (_target instanceof ArrayBuffer) resolve(window.btoa(String.fromCharCode(...new Uint8Array(_target))));
                else if (_target instanceof HTMLCanvasElement) resolve(_target.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));
                else if (_target instanceof HTMLImageElement) {
                    const img = _target.cloneNode(false);
                    img.crossOrigin = "Anonymous";
                    imgLoaded(img).then(()=>{
                        const canvas = document.createElement("canvas");
                        const ctx = canvas.getContext("2d");
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        resolve(canvas.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));
                    }).catch(reject);
                } else if (typeof _target === "object") {
                    const _serializeFn = (options == null ? void 0 : options.serializer) || getDefaultSerialization(_target);
                    const serialized = _serializeFn(_target);
                    return resolve(blobToBase64(new Blob([
                        serialized
                    ], {
                        type: "application/json"
                    })));
                } else reject(new Error("target is unsupported types"));
            } catch (error) {
                reject(error);
            }
        });
        promise.value.then((res)=>base64.value = res);
        return promise.value;
    }
    if ((0, _vueDemi.isRef)(target) || typeof target === "function") (0, _vueDemi.watch)(target, execute, {
        immediate: true
    });
    else execute();
    return {
        base64,
        promise,
        execute
    };
}
function imgLoaded(img) {
    return new Promise((resolve, reject)=>{
        if (!img.complete) {
            img.onload = ()=>{
                resolve();
            };
            img.onerror = reject;
        } else resolve();
    });
}
function blobToBase64(blob) {
    return new Promise((resolve, reject)=>{
        const fr = new FileReader();
        fr.onload = (e)=>{
            resolve(e.target.result);
        };
        fr.onerror = reject;
        fr.readAsDataURL(blob);
    });
}
function useBattery(options = {}) {
    const { navigator =defaultNavigator  } = options;
    const events = [
        "chargingchange",
        "chargingtimechange",
        "dischargingtimechange",
        "levelchange"
    ];
    const isSupported = useSupported(()=>navigator && "getBattery" in navigator && typeof navigator.getBattery === "function");
    const charging = (0, _vueDemi.ref)(false);
    const chargingTime = (0, _vueDemi.ref)(0);
    const dischargingTime = (0, _vueDemi.ref)(0);
    const level = (0, _vueDemi.ref)(1);
    let battery;
    function updateBatteryInfo() {
        charging.value = this.charging;
        chargingTime.value = this.chargingTime || 0;
        dischargingTime.value = this.dischargingTime || 0;
        level.value = this.level;
    }
    if (isSupported.value) navigator.getBattery().then((_battery)=>{
        battery = _battery;
        updateBatteryInfo.call(battery);
        useEventListener(battery, events, updateBatteryInfo, {
            passive: true
        });
    });
    return {
        isSupported,
        charging,
        chargingTime,
        dischargingTime,
        level
    };
}
function useBluetooth(options) {
    let { acceptAllDevices =false  } = options || {};
    const { filters , optionalServices , navigator =defaultNavigator  } = options || {};
    const isSupported = useSupported(()=>navigator && "bluetooth" in navigator);
    const device = (0, _vueDemi.shallowRef)(void 0);
    const error = (0, _vueDemi.shallowRef)(null);
    (0, _vueDemi.watch)(device, ()=>{
        connectToBluetoothGATTServer();
    });
    async function requestDevice() {
        if (!isSupported.value) return;
        error.value = null;
        if (filters && filters.length > 0) acceptAllDevices = false;
        try {
            device.value = await (navigator == null ? void 0 : navigator.bluetooth.requestDevice({
                acceptAllDevices,
                filters,
                optionalServices
            }));
        } catch (err) {
            error.value = err;
        }
    }
    const server = (0, _vueDemi.ref)();
    const isConnected = (0, _vueDemi.computed)(()=>{
        var _a;
        return ((_a = server.value) == null ? void 0 : _a.connected) || false;
    });
    async function connectToBluetoothGATTServer() {
        error.value = null;
        if (device.value && device.value.gatt) {
            device.value.addEventListener("gattserverdisconnected", ()=>{});
            try {
                server.value = await device.value.gatt.connect();
            } catch (err) {
                error.value = err;
            }
        }
    }
    (0, _shared.tryOnMounted)(()=>{
        var _a;
        if (device.value) (_a = device.value.gatt) == null || _a.connect();
    });
    (0, _shared.tryOnScopeDispose)(()=>{
        var _a;
        if (device.value) (_a = device.value.gatt) == null || _a.disconnect();
    });
    return {
        isSupported,
        isConnected,
        // Device:
        device,
        requestDevice,
        // Server:
        server,
        // Errors:
        error
    };
}
function useMediaQuery(query, options = {}) {
    const { window: window1 = defaultWindow  } = options;
    const isSupported = useSupported(()=>window1 && "matchMedia" in window1 && typeof window1.matchMedia === "function");
    let mediaQuery;
    const matches = (0, _vueDemi.ref)(false);
    const handler = (event)=>{
        matches.value = event.matches;
    };
    const cleanup = ()=>{
        if (!mediaQuery) return;
        if ("removeEventListener" in mediaQuery) mediaQuery.removeEventListener("change", handler);
        else mediaQuery.removeListener(handler);
    };
    const stopWatch = (0, _vueDemi.watchEffect)(()=>{
        if (!isSupported.value) return;
        cleanup();
        mediaQuery = window1.matchMedia((0, _shared.toValue)(query));
        if ("addEventListener" in mediaQuery) mediaQuery.addEventListener("change", handler);
        else mediaQuery.addListener(handler);
        matches.value = mediaQuery.matches;
    });
    (0, _shared.tryOnScopeDispose)(()=>{
        stopWatch();
        cleanup();
        mediaQuery = void 0;
    });
    return matches;
}
const breakpointsTailwind = {
    "sm": 640,
    "md": 768,
    "lg": 1024,
    "xl": 1280,
    "2xl": 1536
};
const breakpointsBootstrapV5 = {
    xs: 0,
    sm: 576,
    md: 768,
    lg: 992,
    xl: 1200,
    xxl: 1400
};
const breakpointsVuetifyV2 = {
    xs: 0,
    sm: 600,
    md: 960,
    lg: 1264,
    xl: 1904
};
const breakpointsVuetifyV3 = {
    xs: 0,
    sm: 600,
    md: 960,
    lg: 1280,
    xl: 1920,
    xxl: 2560
};
const breakpointsVuetify = breakpointsVuetifyV2;
const breakpointsAntDesign = {
    xs: 480,
    sm: 576,
    md: 768,
    lg: 992,
    xl: 1200,
    xxl: 1600
};
const breakpointsQuasar = {
    xs: 0,
    sm: 600,
    md: 1024,
    lg: 1440,
    xl: 1920
};
const breakpointsSematic = {
    mobileS: 320,
    mobileM: 375,
    mobileL: 425,
    tablet: 768,
    laptop: 1024,
    laptopL: 1440,
    desktop4K: 2560
};
const breakpointsMasterCss = {
    "3xs": 360,
    "2xs": 480,
    "xs": 600,
    "sm": 768,
    "md": 1024,
    "lg": 1280,
    "xl": 1440,
    "2xl": 1600,
    "3xl": 1920,
    "4xl": 2560
};
const breakpointsPrimeFlex = {
    sm: 576,
    md: 768,
    lg: 992,
    xl: 1200
};
function useBreakpoints(breakpoints, options = {}) {
    function getValue(k, delta) {
        let v = (0, _shared.toValue)(breakpoints[(0, _shared.toValue)(k)]);
        if (delta != null) v = (0, _shared.increaseWithUnit)(v, delta);
        if (typeof v === "number") v = `${v}px`;
        return v;
    }
    const { window: window1 = defaultWindow , strategy ="min-width"  } = options;
    function match(query) {
        if (!window1) return false;
        return window1.matchMedia(query).matches;
    }
    const greaterOrEqual = (k)=>{
        return useMediaQuery(()=>`(min-width: ${getValue(k)})`, options);
    };
    const smallerOrEqual = (k)=>{
        return useMediaQuery(()=>`(max-width: ${getValue(k)})`, options);
    };
    const shortcutMethods = Object.keys(breakpoints).reduce((shortcuts, k)=>{
        Object.defineProperty(shortcuts, k, {
            get: ()=>strategy === "min-width" ? greaterOrEqual(k) : smallerOrEqual(k),
            enumerable: true,
            configurable: true
        });
        return shortcuts;
    }, {});
    function current() {
        const points = Object.keys(breakpoints).map((i)=>[
                i,
                greaterOrEqual(i)
            ]);
        return (0, _vueDemi.computed)(()=>points.filter(([, v])=>v.value).map(([k])=>k));
    }
    return Object.assign(shortcutMethods, {
        greaterOrEqual,
        smallerOrEqual,
        greater (k) {
            return useMediaQuery(()=>`(min-width: ${getValue(k, 0.1)})`, options);
        },
        smaller (k) {
            return useMediaQuery(()=>`(max-width: ${getValue(k, -0.1)})`, options);
        },
        between (a, b) {
            return useMediaQuery(()=>`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`, options);
        },
        isGreater (k) {
            return match(`(min-width: ${getValue(k, 0.1)})`);
        },
        isGreaterOrEqual (k) {
            return match(`(min-width: ${getValue(k)})`);
        },
        isSmaller (k) {
            return match(`(max-width: ${getValue(k, -0.1)})`);
        },
        isSmallerOrEqual (k) {
            return match(`(max-width: ${getValue(k)})`);
        },
        isInBetween (a, b) {
            return match(`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`);
        },
        current,
        active () {
            const bps = current();
            return (0, _vueDemi.computed)(()=>bps.value.length === 0 ? "" : bps.value.at(-1));
        }
    });
}
function useBroadcastChannel(options) {
    const { name , window: window1 = defaultWindow  } = options;
    const isSupported = useSupported(()=>window1 && "BroadcastChannel" in window1);
    const isClosed = (0, _vueDemi.ref)(false);
    const channel = (0, _vueDemi.ref)();
    const data = (0, _vueDemi.ref)();
    const error = (0, _vueDemi.shallowRef)(null);
    const post = (data2)=>{
        if (channel.value) channel.value.postMessage(data2);
    };
    const close = ()=>{
        if (channel.value) channel.value.close();
        isClosed.value = true;
    };
    if (isSupported.value) (0, _shared.tryOnMounted)(()=>{
        error.value = null;
        channel.value = new BroadcastChannel(name);
        channel.value.addEventListener("message", (e)=>{
            data.value = e.data;
        }, {
            passive: true
        });
        channel.value.addEventListener("messageerror", (e)=>{
            error.value = e;
        }, {
            passive: true
        });
        channel.value.addEventListener("close", ()=>{
            isClosed.value = true;
        });
    });
    (0, _shared.tryOnScopeDispose)(()=>{
        close();
    });
    return {
        isSupported,
        channel,
        data,
        post,
        close,
        error,
        isClosed
    };
}
const WRITABLE_PROPERTIES = [
    "hash",
    "host",
    "hostname",
    "href",
    "pathname",
    "port",
    "protocol",
    "search"
];
function useBrowserLocation(options = {}) {
    const { window: window1 = defaultWindow  } = options;
    const refs = Object.fromEntries(WRITABLE_PROPERTIES.map((key)=>[
            key,
            (0, _vueDemi.ref)()
        ]));
    for (const [key, ref2] of (0, _shared.objectEntries)(refs))(0, _vueDemi.watch)(ref2, (value)=>{
        if (!(window1 == null ? void 0 : window1.location) || window1.location[key] === value) return;
        window1.location[key] = value;
    });
    const buildState = (trigger)=>{
        var _a;
        const { state: state2 , length  } = (window1 == null ? void 0 : window1.history) || {};
        const { origin  } = (window1 == null ? void 0 : window1.location) || {};
        for (const key of WRITABLE_PROPERTIES)refs[key].value = (_a = window1 == null ? void 0 : window1.location) == null ? void 0 : _a[key];
        return (0, _vueDemi.reactive)({
            trigger,
            state: state2,
            length,
            origin,
            ...refs
        });
    };
    const state = (0, _vueDemi.ref)(buildState("load"));
    if (window1) {
        useEventListener(window1, "popstate", ()=>state.value = buildState("popstate"), {
            passive: true
        });
        useEventListener(window1, "hashchange", ()=>state.value = buildState("hashchange"), {
            passive: true
        });
    }
    return state;
}
function useCached(refValue, comparator = (a, b)=>a === b, watchOptions) {
    const cachedValue = (0, _vueDemi.ref)(refValue.value);
    (0, _vueDemi.watch)(()=>refValue.value, (value)=>{
        if (!comparator(value, cachedValue.value)) cachedValue.value = value;
    }, watchOptions);
    return cachedValue;
}
function usePermission(permissionDesc, options = {}) {
    const { controls =false , navigator =defaultNavigator  } = options;
    const isSupported = useSupported(()=>navigator && "permissions" in navigator);
    let permissionStatus;
    const desc = typeof permissionDesc === "string" ? {
        name: permissionDesc
    } : permissionDesc;
    const state = (0, _vueDemi.ref)();
    const onChange = ()=>{
        if (permissionStatus) state.value = permissionStatus.state;
    };
    const query = (0, _shared.createSingletonPromise)(async ()=>{
        if (!isSupported.value) return;
        if (!permissionStatus) try {
            permissionStatus = await navigator.permissions.query(desc);
            useEventListener(permissionStatus, "change", onChange);
            onChange();
        } catch (e) {
            state.value = "prompt";
        }
        return permissionStatus;
    });
    query();
    if (controls) return {
        state,
        isSupported,
        query
    };
    else return state;
}
function useClipboard(options = {}) {
    const { navigator =defaultNavigator , read =false , source , copiedDuring =1500 , legacy =false  } = options;
    const isClipboardApiSupported = useSupported(()=>navigator && "clipboard" in navigator);
    const permissionRead = usePermission("clipboard-read");
    const permissionWrite = usePermission("clipboard-write");
    const isSupported = (0, _vueDemi.computed)(()=>isClipboardApiSupported.value || legacy);
    const text = (0, _vueDemi.ref)("");
    const copied = (0, _vueDemi.ref)(false);
    const timeout = (0, _shared.useTimeoutFn)(()=>copied.value = false, copiedDuring);
    function updateText() {
        if (isClipboardApiSupported.value && isAllowed(permissionRead.value)) navigator.clipboard.readText().then((value)=>{
            text.value = value;
        });
        else text.value = legacyRead();
    }
    if (isSupported.value && read) useEventListener([
        "copy",
        "cut"
    ], updateText);
    async function copy(value = (0, _shared.toValue)(source)) {
        if (isSupported.value && value != null) {
            if (isClipboardApiSupported.value && isAllowed(permissionWrite.value)) await navigator.clipboard.writeText(value);
            else legacyCopy(value);
            text.value = value;
            copied.value = true;
            timeout.start();
        }
    }
    function legacyCopy(value) {
        const ta = document.createElement("textarea");
        ta.value = value != null ? value : "";
        ta.style.position = "absolute";
        ta.style.opacity = "0";
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        ta.remove();
    }
    function legacyRead() {
        var _a, _b, _c;
        return (_c = (_b = (_a = document == null ? void 0 : document.getSelection) == null ? void 0 : _a.call(document)) == null ? void 0 : _b.toString()) != null ? _c : "";
    }
    function isAllowed(status) {
        return status === "granted" || status === "prompt";
    }
    return {
        isSupported,
        text,
        copied,
        copy
    };
}
function useClipboardItems(options = {}) {
    const { navigator =defaultNavigator , read =false , source , copiedDuring =1500  } = options;
    const isSupported = useSupported(()=>navigator && "clipboard" in navigator);
    const content = (0, _vueDemi.ref)([]);
    const copied = (0, _vueDemi.ref)(false);
    const timeout = (0, _shared.useTimeoutFn)(()=>copied.value = false, copiedDuring);
    function updateContent() {
        if (isSupported.value) navigator.clipboard.read().then((items)=>{
            content.value = items;
        });
    }
    if (isSupported.value && read) useEventListener([
        "copy",
        "cut"
    ], updateContent);
    async function copy(value = (0, _shared.toValue)(source)) {
        if (isSupported.value && value != null) {
            await navigator.clipboard.write(value);
            content.value = value;
            copied.value = true;
            timeout.start();
        }
    }
    return {
        isSupported,
        content,
        copied,
        copy
    };
}
function cloneFnJSON(source) {
    return JSON.parse(JSON.stringify(source));
}
function useCloned(source, options = {}) {
    const cloned = (0, _vueDemi.ref)({});
    const { manual , clone =cloneFnJSON , // watch options
    deep =true , immediate =true  } = options;
    function sync() {
        cloned.value = clone((0, _shared.toValue)(source));
    }
    if (!manual && ((0, _vueDemi.isRef)(source) || typeof source === "function")) (0, _vueDemi.watch)(source, sync, {
        ...options,
        deep,
        immediate
    });
    else sync();
    return {
        cloned,
        sync
    };
}
const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
const globalKey = "__vueuse_ssr_handlers__";
const handlers = /* @__PURE__ */ getHandlers();
function getHandlers() {
    if (!(globalKey in _global)) _global[globalKey] = _global[globalKey] || {};
    return _global[globalKey];
}
function getSSRHandler(key, fallback) {
    return handlers[key] || fallback;
}
function setSSRHandler(key, fn) {
    handlers[key] = fn;
}
function guessSerializerType(rawInit) {
    return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
}
const StorageSerializers = {
    boolean: {
        read: (v)=>v === "true",
        write: (v)=>String(v)
    },
    object: {
        read: (v)=>JSON.parse(v),
        write: (v)=>JSON.stringify(v)
    },
    number: {
        read: (v)=>Number.parseFloat(v),
        write: (v)=>String(v)
    },
    any: {
        read: (v)=>v,
        write: (v)=>String(v)
    },
    string: {
        read: (v)=>v,
        write: (v)=>String(v)
    },
    map: {
        read: (v)=>new Map(JSON.parse(v)),
        write: (v)=>JSON.stringify(Array.from(v.entries()))
    },
    set: {
        read: (v)=>new Set(JSON.parse(v)),
        write: (v)=>JSON.stringify(Array.from(v))
    },
    date: {
        read: (v)=>new Date(v),
        write: (v)=>v.toISOString()
    }
};
const customStorageEventName = "vueuse-storage";
function useStorage(key, defaults, storage, options = {}) {
    var _a;
    const { flush ="pre" , deep =true , listenToStorageChanges =true , writeDefaults =true , mergeDefaults =false , shallow , window: window1 = defaultWindow , eventFilter , onError =(e)=>{
        console.error(e);
    } , initOnMounted  } = options;
    const data = (shallow ? (0, _vueDemi.shallowRef) : (0, _vueDemi.ref))(typeof defaults === "function" ? defaults() : defaults);
    if (!storage) try {
        storage = getSSRHandler("getDefaultStorage", ()=>{
            var _a2;
            return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;
        })();
    } catch (e) {
        onError(e);
    }
    if (!storage) return data;
    const rawInit = (0, _shared.toValue)(defaults);
    const type = guessSerializerType(rawInit);
    const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];
    const { pause: pauseWatch , resume: resumeWatch  } = (0, _shared.pausableWatch)(data, ()=>write(data.value), {
        flush,
        deep,
        eventFilter
    });
    if (window1 && listenToStorageChanges) (0, _shared.tryOnMounted)(()=>{
        useEventListener(window1, "storage", update);
        useEventListener(window1, customStorageEventName, updateFromCustomEvent);
        if (initOnMounted) update();
    });
    if (!initOnMounted) update();
    function dispatchWriteEvent(oldValue, newValue) {
        if (window1) window1.dispatchEvent(new CustomEvent(customStorageEventName, {
            detail: {
                key,
                oldValue,
                newValue,
                storageArea: storage
            }
        }));
    }
    function write(v) {
        try {
            const oldValue = storage.getItem(key);
            if (v == null) {
                dispatchWriteEvent(oldValue, null);
                storage.removeItem(key);
            } else {
                const serialized = serializer.write(v);
                if (oldValue !== serialized) {
                    storage.setItem(key, serialized);
                    dispatchWriteEvent(oldValue, serialized);
                }
            }
        } catch (e) {
            onError(e);
        }
    }
    function read(event) {
        const rawValue = event ? event.newValue : storage.getItem(key);
        if (rawValue == null) {
            if (writeDefaults && rawInit != null) storage.setItem(key, serializer.write(rawInit));
            return rawInit;
        } else if (!event && mergeDefaults) {
            const value = serializer.read(rawValue);
            if (typeof mergeDefaults === "function") return mergeDefaults(value, rawInit);
            else if (type === "object" && !Array.isArray(value)) return {
                ...rawInit,
                ...value
            };
            return value;
        } else if (typeof rawValue !== "string") return rawValue;
        else return serializer.read(rawValue);
    }
    function update(event) {
        if (event && event.storageArea !== storage) return;
        if (event && event.key == null) {
            data.value = rawInit;
            return;
        }
        if (event && event.key !== key) return;
        pauseWatch();
        try {
            if ((event == null ? void 0 : event.newValue) !== serializer.write(data.value)) data.value = read(event);
        } catch (e) {
            onError(e);
        } finally{
            if (event) (0, _vueDemi.nextTick)(resumeWatch);
            else resumeWatch();
        }
    }
    function updateFromCustomEvent(event) {
        update(event.detail);
    }
    return data;
}
function usePreferredDark(options) {
    return useMediaQuery("(prefers-color-scheme: dark)", options);
}
function useColorMode(options = {}) {
    const { selector ="html" , attribute ="class" , initialValue ="auto" , window: window1 = defaultWindow , storage , storageKey ="vueuse-color-scheme" , listenToStorageChanges =true , storageRef , emitAuto , disableTransition =true  } = options;
    const modes = {
        auto: "",
        light: "light",
        dark: "dark",
        ...options.modes || {}
    };
    const preferredDark = usePreferredDark({
        window: window1
    });
    const system = (0, _vueDemi.computed)(()=>preferredDark.value ? "dark" : "light");
    const store = storageRef || (storageKey == null ? (0, _shared.toRef)(initialValue) : useStorage(storageKey, initialValue, storage, {
        window: window1,
        listenToStorageChanges
    }));
    const state = (0, _vueDemi.computed)(()=>store.value === "auto" ? system.value : store.value);
    const updateHTMLAttrs = getSSRHandler("updateHTMLAttrs", (selector2, attribute2, value)=>{
        const el = typeof selector2 === "string" ? window1 == null ? void 0 : window1.document.querySelector(selector2) : unrefElement(selector2);
        if (!el) return;
        let style;
        if (disableTransition) {
            style = window1.document.createElement("style");
            const styleString = "*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}";
            style.appendChild(document.createTextNode(styleString));
            window1.document.head.appendChild(style);
        }
        if (attribute2 === "class") {
            const current = value.split(/\s/g);
            Object.values(modes).flatMap((i)=>(i || "").split(/\s/g)).filter(Boolean).forEach((v)=>{
                if (current.includes(v)) el.classList.add(v);
                else el.classList.remove(v);
            });
        } else el.setAttribute(attribute2, value);
        if (disableTransition) {
            window1.getComputedStyle(style).opacity;
            document.head.removeChild(style);
        }
    });
    function defaultOnChanged(mode) {
        var _a;
        updateHTMLAttrs(selector, attribute, (_a = modes[mode]) != null ? _a : mode);
    }
    function onChanged(mode) {
        if (options.onChanged) options.onChanged(mode, defaultOnChanged);
        else defaultOnChanged(mode);
    }
    (0, _vueDemi.watch)(state, onChanged, {
        flush: "post",
        immediate: true
    });
    (0, _shared.tryOnMounted)(()=>onChanged(state.value));
    const auto = (0, _vueDemi.computed)({
        get () {
            return emitAuto ? store.value : state.value;
        },
        set (v) {
            store.value = v;
        }
    });
    try {
        return Object.assign(auto, {
            store,
            system,
            state
        });
    } catch (e) {
        return auto;
    }
}
function useConfirmDialog(revealed = (0, _vueDemi.ref)(false)) {
    const confirmHook = (0, _shared.createEventHook)();
    const cancelHook = (0, _shared.createEventHook)();
    const revealHook = (0, _shared.createEventHook)();
    let _resolve = (0, _shared.noop);
    const reveal = (data)=>{
        revealHook.trigger(data);
        revealed.value = true;
        return new Promise((resolve)=>{
            _resolve = resolve;
        });
    };
    const confirm = (data)=>{
        revealed.value = false;
        confirmHook.trigger(data);
        _resolve({
            data,
            isCanceled: false
        });
    };
    const cancel = (data)=>{
        revealed.value = false;
        cancelHook.trigger(data);
        _resolve({
            data,
            isCanceled: true
        });
    };
    return {
        isRevealed: (0, _vueDemi.computed)(()=>revealed.value),
        reveal,
        confirm,
        cancel,
        onReveal: revealHook.on,
        onConfirm: confirmHook.on,
        onCancel: cancelHook.on
    };
}
function useCssVar(prop, target, options = {}) {
    const { window: window1 = defaultWindow , initialValue ="" , observe =false  } = options;
    const variable = (0, _vueDemi.ref)(initialValue);
    const elRef = (0, _vueDemi.computed)(()=>{
        var _a;
        return unrefElement(target) || ((_a = window1 == null ? void 0 : window1.document) == null ? void 0 : _a.documentElement);
    });
    function updateCssVar() {
        var _a;
        const key = (0, _shared.toValue)(prop);
        const el = (0, _shared.toValue)(elRef);
        if (el && window1) {
            const value = (_a = window1.getComputedStyle(el).getPropertyValue(key)) == null ? void 0 : _a.trim();
            variable.value = value || initialValue;
        }
    }
    if (observe) useMutationObserver(elRef, updateCssVar, {
        attributeFilter: [
            "style",
            "class"
        ],
        window: window1
    });
    (0, _vueDemi.watch)([
        elRef,
        ()=>(0, _shared.toValue)(prop)
    ], updateCssVar, {
        immediate: true
    });
    (0, _vueDemi.watch)(variable, (val)=>{
        var _a;
        if ((_a = elRef.value) == null ? void 0 : _a.style) elRef.value.style.setProperty((0, _shared.toValue)(prop), val);
    });
    return variable;
}
function useCurrentElement(rootComponent) {
    const vm = (0, _vueDemi.getCurrentInstance)();
    const currentElement = (0, _shared.computedWithControl)(()=>null, ()=>rootComponent ? unrefElement(rootComponent) : vm.proxy.$el);
    (0, _vueDemi.onUpdated)(currentElement.trigger);
    (0, _vueDemi.onMounted)(currentElement.trigger);
    return currentElement;
}
function useCycleList(list, options) {
    const state = (0, _vueDemi.shallowRef)(getInitialValue());
    const listRef = (0, _shared.toRef)(list);
    const index = (0, _vueDemi.computed)({
        get () {
            var _a;
            const targetList = listRef.value;
            let index2 = (options == null ? void 0 : options.getIndexOf) ? options.getIndexOf(state.value, targetList) : targetList.indexOf(state.value);
            if (index2 < 0) index2 = (_a = options == null ? void 0 : options.fallbackIndex) != null ? _a : 0;
            return index2;
        },
        set (v) {
            set(v);
        }
    });
    function set(i) {
        const targetList = listRef.value;
        const length = targetList.length;
        const index2 = (i % length + length) % length;
        const value = targetList[index2];
        state.value = value;
        return value;
    }
    function shift(delta = 1) {
        return set(index.value + delta);
    }
    function next(n = 1) {
        return shift(n);
    }
    function prev(n = 1) {
        return shift(-n);
    }
    function getInitialValue() {
        var _a, _b;
        return (_b = (0, _shared.toValue)((_a = options == null ? void 0 : options.initialValue) != null ? _a : (0, _shared.toValue)(list)[0])) != null ? _b : void 0;
    }
    (0, _vueDemi.watch)(listRef, ()=>set(index.value));
    return {
        state,
        index,
        next,
        prev,
        go: set
    };
}
function useDark(options = {}) {
    const { valueDark ="dark" , valueLight ="" , window: window1 = defaultWindow  } = options;
    const mode = useColorMode({
        ...options,
        onChanged: (mode2, defaultHandler)=>{
            var _a;
            if (options.onChanged) (_a = options.onChanged) == null || _a.call(options, mode2 === "dark", defaultHandler, mode2);
            else defaultHandler(mode2);
        },
        modes: {
            dark: valueDark,
            light: valueLight
        }
    });
    const system = (0, _vueDemi.computed)(()=>{
        if (mode.system) return mode.system.value;
        else {
            const preferredDark = usePreferredDark({
                window: window1
            });
            return preferredDark.value ? "dark" : "light";
        }
    });
    const isDark = (0, _vueDemi.computed)({
        get () {
            return mode.value === "dark";
        },
        set (v) {
            const modeVal = v ? "dark" : "light";
            if (system.value === modeVal) mode.value = "auto";
            else mode.value = modeVal;
        }
    });
    return isDark;
}
function fnBypass(v) {
    return v;
}
function fnSetSource(source, value) {
    return source.value = value;
}
function defaultDump(clone) {
    return clone ? typeof clone === "function" ? clone : cloneFnJSON : fnBypass;
}
function defaultParse(clone) {
    return clone ? typeof clone === "function" ? clone : cloneFnJSON : fnBypass;
}
function useManualRefHistory(source, options = {}) {
    const { clone =false , dump =defaultDump(clone) , parse =defaultParse(clone) , setSource =fnSetSource  } = options;
    function _createHistoryRecord() {
        return (0, _vueDemi.markRaw)({
            snapshot: dump(source.value),
            timestamp: (0, _shared.timestamp)()
        });
    }
    const last = (0, _vueDemi.ref)(_createHistoryRecord());
    const undoStack = (0, _vueDemi.ref)([]);
    const redoStack = (0, _vueDemi.ref)([]);
    const _setSource = (record)=>{
        setSource(source, parse(record.snapshot));
        last.value = record;
    };
    const commit = ()=>{
        undoStack.value.unshift(last.value);
        last.value = _createHistoryRecord();
        if (options.capacity && undoStack.value.length > options.capacity) undoStack.value.splice(options.capacity, Number.POSITIVE_INFINITY);
        if (redoStack.value.length) redoStack.value.splice(0, redoStack.value.length);
    };
    const clear = ()=>{
        undoStack.value.splice(0, undoStack.value.length);
        redoStack.value.splice(0, redoStack.value.length);
    };
    const undo = ()=>{
        const state = undoStack.value.shift();
        if (state) {
            redoStack.value.unshift(last.value);
            _setSource(state);
        }
    };
    const redo = ()=>{
        const state = redoStack.value.shift();
        if (state) {
            undoStack.value.unshift(last.value);
            _setSource(state);
        }
    };
    const reset = ()=>{
        _setSource(last.value);
    };
    const history = (0, _vueDemi.computed)(()=>[
            last.value,
            ...undoStack.value
        ]);
    const canUndo = (0, _vueDemi.computed)(()=>undoStack.value.length > 0);
    const canRedo = (0, _vueDemi.computed)(()=>redoStack.value.length > 0);
    return {
        source,
        undoStack,
        redoStack,
        last,
        history,
        canUndo,
        canRedo,
        clear,
        commit,
        reset,
        undo,
        redo
    };
}
function useRefHistory(source, options = {}) {
    const { deep =false , flush ="pre" , eventFilter  } = options;
    const { eventFilter: composedFilter , pause , resume: resumeTracking , isActive: isTracking  } = (0, _shared.pausableFilter)(eventFilter);
    const { ignoreUpdates , ignorePrevAsyncUpdates , stop  } = (0, _shared.watchIgnorable)(source, commit, {
        deep,
        flush,
        eventFilter: composedFilter
    });
    function setSource(source2, value) {
        ignorePrevAsyncUpdates();
        ignoreUpdates(()=>{
            source2.value = value;
        });
    }
    const manualHistory = useManualRefHistory(source, {
        ...options,
        clone: options.clone || deep,
        setSource
    });
    const { clear , commit: manualCommit  } = manualHistory;
    function commit() {
        ignorePrevAsyncUpdates();
        manualCommit();
    }
    function resume(commitNow) {
        resumeTracking();
        if (commitNow) commit();
    }
    function batch(fn) {
        let canceled = false;
        const cancel = ()=>canceled = true;
        ignoreUpdates(()=>{
            fn(cancel);
        });
        if (!canceled) commit();
    }
    function dispose() {
        stop();
        clear();
    }
    return {
        ...manualHistory,
        isTracking,
        pause,
        resume,
        commit,
        batch,
        dispose
    };
}
function useDebouncedRefHistory(source, options = {}) {
    const filter = options.debounce ? (0, _shared.debounceFilter)(options.debounce) : void 0;
    const history = useRefHistory(source, {
        ...options,
        eventFilter: filter
    });
    return {
        ...history
    };
}
function useDeviceMotion(options = {}) {
    const { window: window1 = defaultWindow , eventFilter =(0, _shared.bypassFilter)  } = options;
    const acceleration = (0, _vueDemi.ref)({
        x: null,
        y: null,
        z: null
    });
    const rotationRate = (0, _vueDemi.ref)({
        alpha: null,
        beta: null,
        gamma: null
    });
    const interval = (0, _vueDemi.ref)(0);
    const accelerationIncludingGravity = (0, _vueDemi.ref)({
        x: null,
        y: null,
        z: null
    });
    if (window1) {
        const onDeviceMotion = (0, _shared.createFilterWrapper)(eventFilter, (event)=>{
            acceleration.value = event.acceleration;
            accelerationIncludingGravity.value = event.accelerationIncludingGravity;
            rotationRate.value = event.rotationRate;
            interval.value = event.interval;
        });
        useEventListener(window1, "devicemotion", onDeviceMotion);
    }
    return {
        acceleration,
        accelerationIncludingGravity,
        rotationRate,
        interval
    };
}
function useDeviceOrientation(options = {}) {
    const { window: window1 = defaultWindow  } = options;
    const isSupported = useSupported(()=>window1 && "DeviceOrientationEvent" in window1);
    const isAbsolute = (0, _vueDemi.ref)(false);
    const alpha = (0, _vueDemi.ref)(null);
    const beta = (0, _vueDemi.ref)(null);
    const gamma = (0, _vueDemi.ref)(null);
    if (window1 && isSupported.value) useEventListener(window1, "deviceorientation", (event)=>{
        isAbsolute.value = event.absolute;
        alpha.value = event.alpha;
        beta.value = event.beta;
        gamma.value = event.gamma;
    });
    return {
        isSupported,
        isAbsolute,
        alpha,
        beta,
        gamma
    };
}
function useDevicePixelRatio(options = {}) {
    const { window: window1 = defaultWindow  } = options;
    const pixelRatio = (0, _vueDemi.ref)(1);
    if (window1) {
        let observe2 = function() {
            pixelRatio.value = window1.devicePixelRatio;
            cleanup2();
            media = window1.matchMedia(`(resolution: ${pixelRatio.value}dppx)`);
            media.addEventListener("change", observe2, {
                once: true
            });
        }, cleanup2 = function() {
            media == null || media.removeEventListener("change", observe2);
        };
        let media;
        observe2();
        (0, _shared.tryOnScopeDispose)(cleanup2);
    }
    return {
        pixelRatio
    };
}
function useDevicesList(options = {}) {
    const { navigator =defaultNavigator , requestPermissions =false , constraints ={
        audio: true,
        video: true
    } , onUpdated  } = options;
    const devices = (0, _vueDemi.ref)([]);
    const videoInputs = (0, _vueDemi.computed)(()=>devices.value.filter((i)=>i.kind === "videoinput"));
    const audioInputs = (0, _vueDemi.computed)(()=>devices.value.filter((i)=>i.kind === "audioinput"));
    const audioOutputs = (0, _vueDemi.computed)(()=>devices.value.filter((i)=>i.kind === "audiooutput"));
    const isSupported = useSupported(()=>navigator && navigator.mediaDevices && navigator.mediaDevices.enumerateDevices);
    const permissionGranted = (0, _vueDemi.ref)(false);
    let stream;
    async function update() {
        if (!isSupported.value) return;
        devices.value = await navigator.mediaDevices.enumerateDevices();
        onUpdated == null || onUpdated(devices.value);
        if (stream) {
            stream.getTracks().forEach((t)=>t.stop());
            stream = null;
        }
    }
    async function ensurePermissions() {
        if (!isSupported.value) return false;
        if (permissionGranted.value) return true;
        const { state , query  } = usePermission("camera", {
            controls: true
        });
        await query();
        if (state.value !== "granted") {
            stream = await navigator.mediaDevices.getUserMedia(constraints);
            update();
            permissionGranted.value = true;
        } else permissionGranted.value = true;
        return permissionGranted.value;
    }
    if (isSupported.value) {
        if (requestPermissions) ensurePermissions();
        useEventListener(navigator.mediaDevices, "devicechange", update);
        update();
    }
    return {
        devices,
        ensurePermissions,
        permissionGranted,
        videoInputs,
        audioInputs,
        audioOutputs,
        isSupported
    };
}
function useDisplayMedia(options = {}) {
    var _a;
    const enabled = (0, _vueDemi.ref)((_a = options.enabled) != null ? _a : false);
    const video = options.video;
    const audio = options.audio;
    const { navigator =defaultNavigator  } = options;
    const isSupported = useSupported(()=>{
        var _a2;
        return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getDisplayMedia;
    });
    const constraint = {
        audio,
        video
    };
    const stream = (0, _vueDemi.shallowRef)();
    async function _start() {
        var _a2;
        if (!isSupported.value || stream.value) return;
        stream.value = await navigator.mediaDevices.getDisplayMedia(constraint);
        (_a2 = stream.value) == null || _a2.getTracks().forEach((t)=>t.addEventListener("ended", stop));
        return stream.value;
    }
    async function _stop() {
        var _a2;
        (_a2 = stream.value) == null || _a2.getTracks().forEach((t)=>t.stop());
        stream.value = void 0;
    }
    function stop() {
        _stop();
        enabled.value = false;
    }
    async function start() {
        await _start();
        if (stream.value) enabled.value = true;
        return stream.value;
    }
    (0, _vueDemi.watch)(enabled, (v)=>{
        if (v) _start();
        else _stop();
    }, {
        immediate: true
    });
    return {
        isSupported,
        stream,
        start,
        stop,
        enabled
    };
}
function useDocumentVisibility(options = {}) {
    const { document: document1 = defaultDocument  } = options;
    if (!document1) return (0, _vueDemi.ref)("visible");
    const visibility = (0, _vueDemi.ref)(document1.visibilityState);
    useEventListener(document1, "visibilitychange", ()=>{
        visibility.value = document1.visibilityState;
    });
    return visibility;
}
function useDraggable(target, options = {}) {
    var _a, _b;
    const { pointerTypes , preventDefault , stopPropagation , exact , onMove , onEnd , onStart , initialValue , axis ="both" , draggingElement =defaultWindow , containerElement , handle: draggingHandle = target  } = options;
    const position = (0, _vueDemi.ref)((_a = (0, _shared.toValue)(initialValue)) != null ? _a : {
        x: 0,
        y: 0
    });
    const pressedDelta = (0, _vueDemi.ref)();
    const filterEvent = (e)=>{
        if (pointerTypes) return pointerTypes.includes(e.pointerType);
        return true;
    };
    const handleEvent = (e)=>{
        if ((0, _shared.toValue)(preventDefault)) e.preventDefault();
        if ((0, _shared.toValue)(stopPropagation)) e.stopPropagation();
    };
    const start = (e)=>{
        var _a2;
        if (e.button !== 0) return;
        if ((0, _shared.toValue)(options.disabled) || !filterEvent(e)) return;
        if ((0, _shared.toValue)(exact) && e.target !== (0, _shared.toValue)(target)) return;
        const container = (0, _shared.toValue)(containerElement);
        const containerRect = (_a2 = container == null ? void 0 : container.getBoundingClientRect) == null ? void 0 : _a2.call(container);
        const targetRect = (0, _shared.toValue)(target).getBoundingClientRect();
        const pos = {
            x: e.clientX - (container ? targetRect.left - containerRect.left + container.scrollLeft : targetRect.left),
            y: e.clientY - (container ? targetRect.top - containerRect.top + container.scrollTop : targetRect.top)
        };
        if ((onStart == null ? void 0 : onStart(pos, e)) === false) return;
        pressedDelta.value = pos;
        handleEvent(e);
    };
    const move = (e)=>{
        if ((0, _shared.toValue)(options.disabled) || !filterEvent(e)) return;
        if (!pressedDelta.value) return;
        const container = (0, _shared.toValue)(containerElement);
        const targetRect = (0, _shared.toValue)(target).getBoundingClientRect();
        let { x , y  } = position.value;
        if (axis === "x" || axis === "both") {
            x = e.clientX - pressedDelta.value.x;
            if (container) x = Math.min(Math.max(0, x), container.scrollWidth - targetRect.width);
        }
        if (axis === "y" || axis === "both") {
            y = e.clientY - pressedDelta.value.y;
            if (container) y = Math.min(Math.max(0, y), container.scrollHeight - targetRect.height);
        }
        position.value = {
            x,
            y
        };
        onMove == null || onMove(position.value, e);
        handleEvent(e);
    };
    const end = (e)=>{
        if ((0, _shared.toValue)(options.disabled) || !filterEvent(e)) return;
        if (!pressedDelta.value) return;
        pressedDelta.value = void 0;
        onEnd == null || onEnd(position.value, e);
        handleEvent(e);
    };
    if (0, _shared.isClient) {
        const config = {
            capture: (_b = options.capture) != null ? _b : true
        };
        useEventListener(draggingHandle, "pointerdown", start, config);
        useEventListener(draggingElement, "pointermove", move, config);
        useEventListener(draggingElement, "pointerup", end, config);
    }
    return {
        ...(0, _shared.toRefs)(position),
        position,
        isDragging: (0, _vueDemi.computed)(()=>!!pressedDelta.value),
        style: (0, _vueDemi.computed)(()=>`left:${position.value.x}px;top:${position.value.y}px;`)
    };
}
function useDropZone(target, options = {}) {
    const isOverDropZone = (0, _vueDemi.ref)(false);
    const files = (0, _vueDemi.shallowRef)(null);
    let counter = 0;
    let isDataTypeIncluded = true;
    if (0, _shared.isClient) {
        const _options = typeof options === "function" ? {
            onDrop: options
        } : options;
        const getFiles = (event)=>{
            var _a, _b;
            const list = Array.from((_b = (_a = event.dataTransfer) == null ? void 0 : _a.files) != null ? _b : []);
            return files.value = list.length === 0 ? null : list;
        };
        useEventListener(target, "dragenter", (event)=>{
            var _a, _b;
            const types = Array.from(((_a = event == null ? void 0 : event.dataTransfer) == null ? void 0 : _a.items) || []).map((i)=>i.kind === "file" ? i.type : null).filter((0, _shared.notNullish));
            if (_options.dataTypes && event.dataTransfer) {
                const dataTypes = (0, _vueDemi.unref)(_options.dataTypes);
                isDataTypeIncluded = typeof dataTypes === "function" ? dataTypes(types) : dataTypes ? dataTypes.some((item)=>types.includes(item)) : true;
                if (!isDataTypeIncluded) return;
            }
            event.preventDefault();
            counter += 1;
            isOverDropZone.value = true;
            (_b = _options.onEnter) == null || _b.call(_options, getFiles(event), event);
        });
        useEventListener(target, "dragover", (event)=>{
            var _a;
            if (!isDataTypeIncluded) return;
            event.preventDefault();
            (_a = _options.onOver) == null || _a.call(_options, getFiles(event), event);
        });
        useEventListener(target, "dragleave", (event)=>{
            var _a;
            if (!isDataTypeIncluded) return;
            event.preventDefault();
            counter -= 1;
            if (counter === 0) isOverDropZone.value = false;
            (_a = _options.onLeave) == null || _a.call(_options, getFiles(event), event);
        });
        useEventListener(target, "drop", (event)=>{
            var _a;
            event.preventDefault();
            counter = 0;
            isOverDropZone.value = false;
            (_a = _options.onDrop) == null || _a.call(_options, getFiles(event), event);
        });
    }
    return {
        files,
        isOverDropZone
    };
}
function useResizeObserver(target, callback, options = {}) {
    const { window: window1 = defaultWindow , ...observerOptions } = options;
    let observer;
    const isSupported = useSupported(()=>window1 && "ResizeObserver" in window1);
    const cleanup = ()=>{
        if (observer) {
            observer.disconnect();
            observer = void 0;
        }
    };
    const targets = (0, _vueDemi.computed)(()=>Array.isArray(target) ? target.map((el)=>unrefElement(el)) : [
            unrefElement(target)
        ]);
    const stopWatch = (0, _vueDemi.watch)(targets, (els)=>{
        cleanup();
        if (isSupported.value && window1) {
            observer = new ResizeObserver(callback);
            for (const _el of els)_el && observer.observe(_el, observerOptions);
        }
    }, {
        immediate: true,
        flush: "post"
    });
    const stop = ()=>{
        cleanup();
        stopWatch();
    };
    (0, _shared.tryOnScopeDispose)(stop);
    return {
        isSupported,
        stop
    };
}
function useElementBounding(target, options = {}) {
    const { reset =true , windowResize =true , windowScroll =true , immediate =true  } = options;
    const height = (0, _vueDemi.ref)(0);
    const bottom = (0, _vueDemi.ref)(0);
    const left = (0, _vueDemi.ref)(0);
    const right = (0, _vueDemi.ref)(0);
    const top = (0, _vueDemi.ref)(0);
    const width = (0, _vueDemi.ref)(0);
    const x = (0, _vueDemi.ref)(0);
    const y = (0, _vueDemi.ref)(0);
    function update() {
        const el = unrefElement(target);
        if (!el) {
            if (reset) {
                height.value = 0;
                bottom.value = 0;
                left.value = 0;
                right.value = 0;
                top.value = 0;
                width.value = 0;
                x.value = 0;
                y.value = 0;
            }
            return;
        }
        const rect = el.getBoundingClientRect();
        height.value = rect.height;
        bottom.value = rect.bottom;
        left.value = rect.left;
        right.value = rect.right;
        top.value = rect.top;
        width.value = rect.width;
        x.value = rect.x;
        y.value = rect.y;
    }
    useResizeObserver(target, update);
    (0, _vueDemi.watch)(()=>unrefElement(target), (ele)=>!ele && update());
    useMutationObserver(target, update, {
        attributeFilter: [
            "style",
            "class"
        ]
    });
    if (windowScroll) useEventListener("scroll", update, {
        capture: true,
        passive: true
    });
    if (windowResize) useEventListener("resize", update, {
        passive: true
    });
    (0, _shared.tryOnMounted)(()=>{
        if (immediate) update();
    });
    return {
        height,
        bottom,
        left,
        right,
        top,
        width,
        x,
        y,
        update
    };
}
function useElementByPoint(options) {
    const { x , y , document: document1 = defaultDocument , multiple , interval ="requestAnimationFrame" , immediate =true  } = options;
    const isSupported = useSupported(()=>{
        if ((0, _shared.toValue)(multiple)) return document1 && "elementsFromPoint" in document1;
        return document1 && "elementFromPoint" in document1;
    });
    const element = (0, _vueDemi.ref)(null);
    const cb = ()=>{
        var _a, _b;
        element.value = (0, _shared.toValue)(multiple) ? (_a = document1 == null ? void 0 : document1.elementsFromPoint((0, _shared.toValue)(x), (0, _shared.toValue)(y))) != null ? _a : [] : (_b = document1 == null ? void 0 : document1.elementFromPoint((0, _shared.toValue)(x), (0, _shared.toValue)(y))) != null ? _b : null;
    };
    const controls = interval === "requestAnimationFrame" ? useRafFn(cb, {
        immediate
    }) : (0, _shared.useIntervalFn)(cb, interval, {
        immediate
    });
    return {
        isSupported,
        element,
        ...controls
    };
}
function useElementHover(el, options = {}) {
    const { delayEnter =0 , delayLeave =0 , window: window1 = defaultWindow  } = options;
    const isHovered = (0, _vueDemi.ref)(false);
    let timer;
    const toggle = (entering)=>{
        const delay = entering ? delayEnter : delayLeave;
        if (timer) {
            clearTimeout(timer);
            timer = void 0;
        }
        if (delay) timer = setTimeout(()=>isHovered.value = entering, delay);
        else isHovered.value = entering;
    };
    if (!window1) return isHovered;
    useEventListener(el, "mouseenter", ()=>toggle(true), {
        passive: true
    });
    useEventListener(el, "mouseleave", ()=>toggle(false), {
        passive: true
    });
    return isHovered;
}
function useElementSize(target, initialSize = {
    width: 0,
    height: 0
}, options = {}) {
    const { window: window1 = defaultWindow , box ="content-box"  } = options;
    const isSVG = (0, _vueDemi.computed)(()=>{
        var _a, _b;
        return (_b = (_a = unrefElement(target)) == null ? void 0 : _a.namespaceURI) == null ? void 0 : _b.includes("svg");
    });
    const width = (0, _vueDemi.ref)(initialSize.width);
    const height = (0, _vueDemi.ref)(initialSize.height);
    const { stop: stop1  } = useResizeObserver(target, ([entry])=>{
        const boxSize = box === "border-box" ? entry.borderBoxSize : box === "content-box" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;
        if (window1 && isSVG.value) {
            const $elem = unrefElement(target);
            if ($elem) {
                const rect = $elem.getBoundingClientRect();
                width.value = rect.width;
                height.value = rect.height;
            }
        } else if (boxSize) {
            const formatBoxSize = Array.isArray(boxSize) ? boxSize : [
                boxSize
            ];
            width.value = formatBoxSize.reduce((acc, { inlineSize  })=>acc + inlineSize, 0);
            height.value = formatBoxSize.reduce((acc, { blockSize  })=>acc + blockSize, 0);
        } else {
            width.value = entry.contentRect.width;
            height.value = entry.contentRect.height;
        }
    }, options);
    (0, _shared.tryOnMounted)(()=>{
        const ele = unrefElement(target);
        if (ele) {
            width.value = "offsetWidth" in ele ? ele.offsetWidth : initialSize.width;
            height.value = "offsetHeight" in ele ? ele.offsetHeight : initialSize.height;
        }
    });
    const stop2 = (0, _vueDemi.watch)(()=>unrefElement(target), (ele)=>{
        width.value = ele ? initialSize.width : 0;
        height.value = ele ? initialSize.height : 0;
    });
    function stop() {
        stop1();
        stop2();
    }
    return {
        width,
        height,
        stop
    };
}
function useIntersectionObserver(target, callback, options = {}) {
    const { root , rootMargin ="0px" , threshold =0.1 , window: window1 = defaultWindow , immediate =true  } = options;
    const isSupported = useSupported(()=>window1 && "IntersectionObserver" in window1);
    const targets = (0, _vueDemi.computed)(()=>{
        const _target = (0, _shared.toValue)(target);
        return (Array.isArray(_target) ? _target : [
            _target
        ]).map(unrefElement).filter((0, _shared.notNullish));
    });
    let cleanup = (0, _shared.noop);
    const isActive = (0, _vueDemi.ref)(immediate);
    const stopWatch = isSupported.value ? (0, _vueDemi.watch)(()=>[
            targets.value,
            unrefElement(root),
            isActive.value
        ], ([targets2, root2])=>{
        cleanup();
        if (!isActive.value) return;
        if (!targets2.length) return;
        const observer = new IntersectionObserver(callback, {
            root: unrefElement(root2),
            rootMargin,
            threshold
        });
        targets2.forEach((el)=>el && observer.observe(el));
        cleanup = ()=>{
            observer.disconnect();
            cleanup = (0, _shared.noop);
        };
    }, {
        immediate,
        flush: "post"
    }) : (0, _shared.noop);
    const stop = ()=>{
        cleanup();
        stopWatch();
        isActive.value = false;
    };
    (0, _shared.tryOnScopeDispose)(stop);
    return {
        isSupported,
        isActive,
        pause () {
            cleanup();
            isActive.value = false;
        },
        resume () {
            isActive.value = true;
        },
        stop
    };
}
function useElementVisibility(element, options = {}) {
    const { window: window1 = defaultWindow , scrollTarget , threshold =0  } = options;
    const elementIsVisible = (0, _vueDemi.ref)(false);
    useIntersectionObserver(element, (intersectionObserverEntries)=>{
        let isIntersecting = elementIsVisible.value;
        let latestTime = 0;
        for (const entry of intersectionObserverEntries)if (entry.time >= latestTime) {
            latestTime = entry.time;
            isIntersecting = entry.isIntersecting;
        }
        elementIsVisible.value = isIntersecting;
    }, {
        root: scrollTarget,
        window: window1,
        threshold
    });
    return elementIsVisible;
}
const events = /* @__PURE__ */ new Map();
function useEventBus(key) {
    const scope = (0, _vueDemi.getCurrentScope)();
    function on(listener) {
        var _a;
        const listeners = events.get(key) || /* @__PURE__ */ new Set();
        listeners.add(listener);
        events.set(key, listeners);
        const _off = ()=>off(listener);
        (_a = scope == null ? void 0 : scope.cleanups) == null || _a.push(_off);
        return _off;
    }
    function once(listener) {
        function _listener(...args) {
            off(_listener);
            listener(...args);
        }
        return on(_listener);
    }
    function off(listener) {
        const listeners = events.get(key);
        if (!listeners) return;
        listeners.delete(listener);
        if (!listeners.size) reset();
    }
    function reset() {
        events.delete(key);
    }
    function emit(event, payload) {
        var _a;
        (_a = events.get(key)) == null || _a.forEach((v)=>v(event, payload));
    }
    return {
        on,
        once,
        off,
        emit,
        reset
    };
}
function resolveNestedOptions$1(options) {
    if (options === true) return {};
    return options;
}
function useEventSource(url, events = [], options = {}) {
    const event = (0, _vueDemi.ref)(null);
    const data = (0, _vueDemi.ref)(null);
    const status = (0, _vueDemi.ref)("CONNECTING");
    const eventSource = (0, _vueDemi.ref)(null);
    const error = (0, _vueDemi.shallowRef)(null);
    const urlRef = (0, _shared.toRef)(url);
    const lastEventId = (0, _vueDemi.shallowRef)(null);
    let explicitlyClosed = false;
    let retried = 0;
    const { withCredentials =false , immediate =true  } = options;
    const close = ()=>{
        if ((0, _shared.isClient) && eventSource.value) {
            eventSource.value.close();
            eventSource.value = null;
            status.value = "CLOSED";
            explicitlyClosed = true;
        }
    };
    const _init = ()=>{
        if (explicitlyClosed || typeof urlRef.value === "undefined") return;
        const es = new EventSource(urlRef.value, {
            withCredentials
        });
        status.value = "CONNECTING";
        eventSource.value = es;
        es.onopen = ()=>{
            status.value = "OPEN";
            error.value = null;
        };
        es.onerror = (e)=>{
            status.value = "CLOSED";
            error.value = e;
            if (es.readyState === 2 && !explicitlyClosed && options.autoReconnect) {
                es.close();
                const { retries =-1 , delay =1e3 , onFailed  } = resolveNestedOptions$1(options.autoReconnect);
                retried += 1;
                if (typeof retries === "number" && (retries < 0 || retried < retries)) setTimeout(_init, delay);
                else if (typeof retries === "function" && retries()) setTimeout(_init, delay);
                else onFailed == null || onFailed();
            }
        };
        es.onmessage = (e)=>{
            event.value = null;
            data.value = e.data;
            lastEventId.value = e.lastEventId;
        };
        for (const event_name of events)useEventListener(es, event_name, (e)=>{
            event.value = event_name;
            data.value = e.data || null;
        });
    };
    const open = ()=>{
        if (!(0, _shared.isClient)) return;
        close();
        explicitlyClosed = false;
        retried = 0;
        _init();
    };
    if (immediate) (0, _vueDemi.watch)(urlRef, open, {
        immediate: true
    });
    (0, _shared.tryOnScopeDispose)(close);
    return {
        eventSource,
        event,
        data,
        status,
        error,
        open,
        close,
        lastEventId
    };
}
function useEyeDropper(options = {}) {
    const { initialValue =""  } = options;
    const isSupported = useSupported(()=>typeof window !== "undefined" && "EyeDropper" in window);
    const sRGBHex = (0, _vueDemi.ref)(initialValue);
    async function open(openOptions) {
        if (!isSupported.value) return;
        const eyeDropper = new window.EyeDropper();
        const result = await eyeDropper.open(openOptions);
        sRGBHex.value = result.sRGBHex;
        return result;
    }
    return {
        isSupported,
        sRGBHex,
        open
    };
}
function useFavicon(newIcon = null, options = {}) {
    const { baseUrl ="" , rel ="icon" , document: document1 = defaultDocument  } = options;
    const favicon = (0, _shared.toRef)(newIcon);
    const applyIcon = (icon)=>{
        const elements = document1 == null ? void 0 : document1.head.querySelectorAll(`link[rel*="${rel}"]`);
        if (!elements || elements.length === 0) {
            const link = document1 == null ? void 0 : document1.createElement("link");
            if (link) {
                link.rel = rel;
                link.href = `${baseUrl}${icon}`;
                link.type = `image/${icon.split(".").pop()}`;
                document1 == null || document1.head.append(link);
            }
            return;
        }
        elements == null || elements.forEach((el)=>el.href = `${baseUrl}${icon}`);
    };
    (0, _vueDemi.watch)(favicon, (i, o)=>{
        if (typeof i === "string" && i !== o) applyIcon(i);
    }, {
        immediate: true
    });
    return favicon;
}
const payloadMapping = {
    json: "application/json",
    text: "text/plain"
};
function isFetchOptions(obj) {
    return obj && (0, _shared.containsProp)(obj, "immediate", "refetch", "initialData", "timeout", "beforeFetch", "afterFetch", "onFetchError", "fetch", "updateDataOnError");
}
const reAbsolute = /^(?:[a-z][a-z\d+\-.]*:)?\/\//i;
function isAbsoluteURL(url) {
    return reAbsolute.test(url);
}
function headersToObject(headers) {
    if (typeof Headers !== "undefined" && headers instanceof Headers) return Object.fromEntries(headers.entries());
    return headers;
}
function combineCallbacks(combination, ...callbacks) {
    if (combination === "overwrite") return async (ctx)=>{
        const callback = callbacks[callbacks.length - 1];
        if (callback) return {
            ...ctx,
            ...await callback(ctx)
        };
        return ctx;
    };
    else return async (ctx)=>{
        for (const callback of callbacks)if (callback) ctx = {
            ...ctx,
            ...await callback(ctx)
        };
        return ctx;
    };
}
function createFetch(config = {}) {
    const _combination = config.combination || "chain";
    const _options = config.options || {};
    const _fetchOptions = config.fetchOptions || {};
    function useFactoryFetch(url, ...args) {
        const computedUrl = (0, _vueDemi.computed)(()=>{
            const baseUrl = (0, _shared.toValue)(config.baseUrl);
            const targetUrl = (0, _shared.toValue)(url);
            return baseUrl && !isAbsoluteURL(targetUrl) ? joinPaths(baseUrl, targetUrl) : targetUrl;
        });
        let options = _options;
        let fetchOptions = _fetchOptions;
        if (args.length > 0) {
            if (isFetchOptions(args[0])) options = {
                ...options,
                ...args[0],
                beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[0].beforeFetch),
                afterFetch: combineCallbacks(_combination, _options.afterFetch, args[0].afterFetch),
                onFetchError: combineCallbacks(_combination, _options.onFetchError, args[0].onFetchError)
            };
            else fetchOptions = {
                ...fetchOptions,
                ...args[0],
                headers: {
                    ...headersToObject(fetchOptions.headers) || {},
                    ...headersToObject(args[0].headers) || {}
                }
            };
        }
        if (args.length > 1 && isFetchOptions(args[1])) options = {
            ...options,
            ...args[1],
            beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[1].beforeFetch),
            afterFetch: combineCallbacks(_combination, _options.afterFetch, args[1].afterFetch),
            onFetchError: combineCallbacks(_combination, _options.onFetchError, args[1].onFetchError)
        };
        return useFetch(computedUrl, fetchOptions, options);
    }
    return useFactoryFetch;
}
function useFetch(url, ...args) {
    var _a;
    const supportsAbort = typeof AbortController === "function";
    let fetchOptions = {};
    let options = {
        immediate: true,
        refetch: false,
        timeout: 0,
        updateDataOnError: false
    };
    const config = {
        method: "GET",
        type: "text",
        payload: void 0
    };
    if (args.length > 0) {
        if (isFetchOptions(args[0])) options = {
            ...options,
            ...args[0]
        };
        else fetchOptions = args[0];
    }
    if (args.length > 1) {
        if (isFetchOptions(args[1])) options = {
            ...options,
            ...args[1]
        };
    }
    const { fetch =(_a = defaultWindow) == null ? void 0 : _a.fetch , initialData , timeout  } = options;
    const responseEvent = (0, _shared.createEventHook)();
    const errorEvent = (0, _shared.createEventHook)();
    const finallyEvent = (0, _shared.createEventHook)();
    const isFinished = (0, _vueDemi.ref)(false);
    const isFetching = (0, _vueDemi.ref)(false);
    const aborted = (0, _vueDemi.ref)(false);
    const statusCode = (0, _vueDemi.ref)(null);
    const response = (0, _vueDemi.shallowRef)(null);
    const error = (0, _vueDemi.shallowRef)(null);
    const data = (0, _vueDemi.shallowRef)(initialData || null);
    const canAbort = (0, _vueDemi.computed)(()=>supportsAbort && isFetching.value);
    let controller;
    let timer;
    const abort = ()=>{
        if (supportsAbort) {
            controller == null || controller.abort();
            controller = new AbortController();
            controller.signal.onabort = ()=>aborted.value = true;
            fetchOptions = {
                ...fetchOptions,
                signal: controller.signal
            };
        }
    };
    const loading = (isLoading)=>{
        isFetching.value = isLoading;
        isFinished.value = !isLoading;
    };
    if (timeout) timer = (0, _shared.useTimeoutFn)(abort, timeout, {
        immediate: false
    });
    let executeCounter = 0;
    const execute = async (throwOnFailed = false)=>{
        var _a2, _b;
        abort();
        loading(true);
        error.value = null;
        statusCode.value = null;
        aborted.value = false;
        executeCounter += 1;
        const currentExecuteCounter = executeCounter;
        const defaultFetchOptions = {
            method: config.method,
            headers: {}
        };
        if (config.payload) {
            const headers = headersToObject(defaultFetchOptions.headers);
            const payload = (0, _shared.toValue)(config.payload);
            if (!config.payloadType && payload && Object.getPrototypeOf(payload) === Object.prototype && !(payload instanceof FormData)) config.payloadType = "json";
            if (config.payloadType) headers["Content-Type"] = (_a2 = payloadMapping[config.payloadType]) != null ? _a2 : config.payloadType;
            defaultFetchOptions.body = config.payloadType === "json" ? JSON.stringify(payload) : payload;
        }
        let isCanceled = false;
        const context = {
            url: (0, _shared.toValue)(url),
            options: {
                ...defaultFetchOptions,
                ...fetchOptions
            },
            cancel: ()=>{
                isCanceled = true;
            }
        };
        if (options.beforeFetch) Object.assign(context, await options.beforeFetch(context));
        if (isCanceled || !fetch) {
            loading(false);
            return Promise.resolve(null);
        }
        let responseData = null;
        if (timer) timer.start();
        return fetch(context.url, {
            ...defaultFetchOptions,
            ...context.options,
            headers: {
                ...headersToObject(defaultFetchOptions.headers),
                ...headersToObject((_b = context.options) == null ? void 0 : _b.headers)
            }
        }).then(async (fetchResponse)=>{
            response.value = fetchResponse;
            statusCode.value = fetchResponse.status;
            responseData = await fetchResponse.clone()[config.type]();
            if (!fetchResponse.ok) {
                data.value = initialData || null;
                throw new Error(fetchResponse.statusText);
            }
            if (options.afterFetch) ({ data: responseData  } = await options.afterFetch({
                data: responseData,
                response: fetchResponse
            }));
            data.value = responseData;
            responseEvent.trigger(fetchResponse);
            return fetchResponse;
        }).catch(async (fetchError)=>{
            let errorData = fetchError.message || fetchError.name;
            if (options.onFetchError) ({ error: errorData , data: responseData  } = await options.onFetchError({
                data: responseData,
                error: fetchError,
                response: response.value
            }));
            error.value = errorData;
            if (options.updateDataOnError) data.value = responseData;
            errorEvent.trigger(fetchError);
            if (throwOnFailed) throw fetchError;
            return null;
        }).finally(()=>{
            if (currentExecuteCounter === executeCounter) loading(false);
            if (timer) timer.stop();
            finallyEvent.trigger(null);
        });
    };
    const refetch = (0, _shared.toRef)(options.refetch);
    (0, _vueDemi.watch)([
        refetch,
        (0, _shared.toRef)(url)
    ], ([refetch2])=>refetch2 && execute(), {
        deep: true
    });
    const shell = {
        isFinished: (0, _vueDemi.readonly)(isFinished),
        isFetching: (0, _vueDemi.readonly)(isFetching),
        statusCode,
        response,
        error,
        data,
        canAbort,
        aborted,
        abort,
        execute,
        onFetchResponse: responseEvent.on,
        onFetchError: errorEvent.on,
        onFetchFinally: finallyEvent.on,
        // method
        get: setMethod("GET"),
        put: setMethod("PUT"),
        post: setMethod("POST"),
        delete: setMethod("DELETE"),
        patch: setMethod("PATCH"),
        head: setMethod("HEAD"),
        options: setMethod("OPTIONS"),
        // type
        json: setType("json"),
        text: setType("text"),
        blob: setType("blob"),
        arrayBuffer: setType("arrayBuffer"),
        formData: setType("formData")
    };
    function setMethod(method) {
        return (payload, payloadType)=>{
            if (!isFetching.value) {
                config.method = method;
                config.payload = payload;
                config.payloadType = payloadType;
                if ((0, _vueDemi.isRef)(config.payload)) (0, _vueDemi.watch)([
                    refetch,
                    (0, _shared.toRef)(config.payload)
                ], ([refetch2])=>refetch2 && execute(), {
                    deep: true
                });
                return {
                    ...shell,
                    then (onFulfilled, onRejected) {
                        return waitUntilFinished().then(onFulfilled, onRejected);
                    }
                };
            }
            return void 0;
        };
    }
    function waitUntilFinished() {
        return new Promise((resolve, reject)=>{
            (0, _shared.until)(isFinished).toBe(true).then(()=>resolve(shell)).catch((error2)=>reject(error2));
        });
    }
    function setType(type) {
        return ()=>{
            if (!isFetching.value) {
                config.type = type;
                return {
                    ...shell,
                    then (onFulfilled, onRejected) {
                        return waitUntilFinished().then(onFulfilled, onRejected);
                    }
                };
            }
            return void 0;
        };
    }
    if (options.immediate) Promise.resolve().then(()=>execute());
    return {
        ...shell,
        then (onFulfilled, onRejected) {
            return waitUntilFinished().then(onFulfilled, onRejected);
        }
    };
}
function joinPaths(start, end) {
    if (!start.endsWith("/") && !end.startsWith("/")) return `${start}/${end}`;
    return `${start}${end}`;
}
const DEFAULT_OPTIONS = {
    multiple: true,
    accept: "*",
    reset: false,
    directory: false
};
function useFileDialog(options = {}) {
    const { document: document1 = defaultDocument  } = options;
    const files = (0, _vueDemi.ref)(null);
    const { on: onChange , trigger  } = (0, _shared.createEventHook)();
    let input;
    if (document1) {
        input = document1.createElement("input");
        input.type = "file";
        input.onchange = (event)=>{
            const result = event.target;
            files.value = result.files;
            trigger(files.value);
        };
    }
    const reset = ()=>{
        files.value = null;
        if (input && input.value) {
            input.value = "";
            trigger(null);
        }
    };
    const open = (localOptions)=>{
        if (!input) return;
        const _options = {
            ...DEFAULT_OPTIONS,
            ...options,
            ...localOptions
        };
        input.multiple = _options.multiple;
        input.accept = _options.accept;
        input.webkitdirectory = _options.directory;
        if ((0, _shared.hasOwn)(_options, "capture")) input.capture = _options.capture;
        if (_options.reset) reset();
        input.click();
    };
    return {
        files: (0, _vueDemi.readonly)(files),
        open,
        reset,
        onChange
    };
}
function useFileSystemAccess(options = {}) {
    const { window: _window = defaultWindow , dataType ="Text"  } = options;
    const window1 = _window;
    const isSupported = useSupported(()=>window1 && "showSaveFilePicker" in window1 && "showOpenFilePicker" in window1);
    const fileHandle = (0, _vueDemi.ref)();
    const data = (0, _vueDemi.ref)();
    const file = (0, _vueDemi.ref)();
    const fileName = (0, _vueDemi.computed)(()=>{
        var _a, _b;
        return (_b = (_a = file.value) == null ? void 0 : _a.name) != null ? _b : "";
    });
    const fileMIME = (0, _vueDemi.computed)(()=>{
        var _a, _b;
        return (_b = (_a = file.value) == null ? void 0 : _a.type) != null ? _b : "";
    });
    const fileSize = (0, _vueDemi.computed)(()=>{
        var _a, _b;
        return (_b = (_a = file.value) == null ? void 0 : _a.size) != null ? _b : 0;
    });
    const fileLastModified = (0, _vueDemi.computed)(()=>{
        var _a, _b;
        return (_b = (_a = file.value) == null ? void 0 : _a.lastModified) != null ? _b : 0;
    });
    async function open(_options = {}) {
        if (!isSupported.value) return;
        const [handle] = await window1.showOpenFilePicker({
            ...(0, _shared.toValue)(options),
            ..._options
        });
        fileHandle.value = handle;
        await updateData();
    }
    async function create(_options = {}) {
        if (!isSupported.value) return;
        fileHandle.value = await window1.showSaveFilePicker({
            ...options,
            ..._options
        });
        data.value = void 0;
        await updateData();
    }
    async function save(_options = {}) {
        if (!isSupported.value) return;
        if (!fileHandle.value) return saveAs(_options);
        if (data.value) {
            const writableStream = await fileHandle.value.createWritable();
            await writableStream.write(data.value);
            await writableStream.close();
        }
        await updateFile();
    }
    async function saveAs(_options = {}) {
        if (!isSupported.value) return;
        fileHandle.value = await window1.showSaveFilePicker({
            ...options,
            ..._options
        });
        if (data.value) {
            const writableStream = await fileHandle.value.createWritable();
            await writableStream.write(data.value);
            await writableStream.close();
        }
        await updateFile();
    }
    async function updateFile() {
        var _a;
        file.value = await ((_a = fileHandle.value) == null ? void 0 : _a.getFile());
    }
    async function updateData() {
        var _a, _b;
        await updateFile();
        const type = (0, _shared.toValue)(dataType);
        if (type === "Text") data.value = await ((_a = file.value) == null ? void 0 : _a.text());
        else if (type === "ArrayBuffer") data.value = await ((_b = file.value) == null ? void 0 : _b.arrayBuffer());
        else if (type === "Blob") data.value = file.value;
    }
    (0, _vueDemi.watch)(()=>(0, _shared.toValue)(dataType), updateData);
    return {
        isSupported,
        data,
        file,
        fileName,
        fileMIME,
        fileSize,
        fileLastModified,
        open,
        create,
        save,
        saveAs,
        updateData
    };
}
function useFocus(target, options = {}) {
    const { initialValue =false , focusVisible =false , preventScroll =false  } = options;
    const innerFocused = (0, _vueDemi.ref)(false);
    const targetElement = (0, _vueDemi.computed)(()=>unrefElement(target));
    useEventListener(targetElement, "focus", (event)=>{
        var _a, _b;
        if (!focusVisible || ((_b = (_a = event.target).matches) == null ? void 0 : _b.call(_a, ":focus-visible"))) innerFocused.value = true;
    });
    useEventListener(targetElement, "blur", ()=>innerFocused.value = false);
    const focused = (0, _vueDemi.computed)({
        get: ()=>innerFocused.value,
        set (value) {
            var _a, _b;
            if (!value && innerFocused.value) (_a = targetElement.value) == null || _a.blur();
            else if (value && !innerFocused.value) (_b = targetElement.value) == null || _b.focus({
                preventScroll
            });
        }
    });
    (0, _vueDemi.watch)(targetElement, ()=>{
        focused.value = initialValue;
    }, {
        immediate: true,
        flush: "post"
    });
    return {
        focused
    };
}
function useFocusWithin(target, options = {}) {
    const activeElement = useActiveElement(options);
    const targetElement = (0, _vueDemi.computed)(()=>unrefElement(target));
    const focused = (0, _vueDemi.computed)(()=>targetElement.value && activeElement.value ? targetElement.value.contains(activeElement.value) : false);
    return {
        focused
    };
}
function useFps(options) {
    var _a;
    const fps = (0, _vueDemi.ref)(0);
    if (typeof performance === "undefined") return fps;
    const every = (_a = options == null ? void 0 : options.every) != null ? _a : 10;
    let last = performance.now();
    let ticks = 0;
    useRafFn(()=>{
        ticks += 1;
        if (ticks >= every) {
            const now = performance.now();
            const diff = now - last;
            fps.value = Math.round(1e3 / (diff / ticks));
            last = now;
            ticks = 0;
        }
    });
    return fps;
}
const eventHandlers = [
    "fullscreenchange",
    "webkitfullscreenchange",
    "webkitendfullscreen",
    "mozfullscreenchange",
    "MSFullscreenChange"
];
function useFullscreen(target, options = {}) {
    const { document: document1 = defaultDocument , autoExit =false  } = options;
    const targetRef = (0, _vueDemi.computed)(()=>{
        var _a;
        return (_a = unrefElement(target)) != null ? _a : document1 == null ? void 0 : document1.querySelector("html");
    });
    const isFullscreen = (0, _vueDemi.ref)(false);
    const requestMethod = (0, _vueDemi.computed)(()=>{
        return [
            "requestFullscreen",
            "webkitRequestFullscreen",
            "webkitEnterFullscreen",
            "webkitEnterFullScreen",
            "webkitRequestFullScreen",
            "mozRequestFullScreen",
            "msRequestFullscreen"
        ].find((m)=>document1 && m in document1 || targetRef.value && m in targetRef.value);
    });
    const exitMethod = (0, _vueDemi.computed)(()=>{
        return [
            "exitFullscreen",
            "webkitExitFullscreen",
            "webkitExitFullScreen",
            "webkitCancelFullScreen",
            "mozCancelFullScreen",
            "msExitFullscreen"
        ].find((m)=>document1 && m in document1 || targetRef.value && m in targetRef.value);
    });
    const fullscreenEnabled = (0, _vueDemi.computed)(()=>{
        return [
            "fullScreen",
            "webkitIsFullScreen",
            "webkitDisplayingFullscreen",
            "mozFullScreen",
            "msFullscreenElement"
        ].find((m)=>document1 && m in document1 || targetRef.value && m in targetRef.value);
    });
    const fullscreenElementMethod = [
        "fullscreenElement",
        "webkitFullscreenElement",
        "mozFullScreenElement",
        "msFullscreenElement"
    ].find((m)=>document1 && m in document1);
    const isSupported = useSupported(()=>targetRef.value && document1 && requestMethod.value !== void 0 && exitMethod.value !== void 0 && fullscreenEnabled.value !== void 0);
    const isCurrentElementFullScreen = ()=>{
        if (fullscreenElementMethod) return (document1 == null ? void 0 : document1[fullscreenElementMethod]) === targetRef.value;
        return false;
    };
    const isElementFullScreen = ()=>{
        if (fullscreenEnabled.value) {
            if (document1 && document1[fullscreenEnabled.value] != null) return document1[fullscreenEnabled.value];
            else {
                const target2 = targetRef.value;
                if ((target2 == null ? void 0 : target2[fullscreenEnabled.value]) != null) return Boolean(target2[fullscreenEnabled.value]);
            }
        }
        return false;
    };
    async function exit() {
        if (!isSupported.value || !isFullscreen.value) return;
        if (exitMethod.value) {
            if ((document1 == null ? void 0 : document1[exitMethod.value]) != null) await document1[exitMethod.value]();
            else {
                const target2 = targetRef.value;
                if ((target2 == null ? void 0 : target2[exitMethod.value]) != null) await target2[exitMethod.value]();
            }
        }
        isFullscreen.value = false;
    }
    async function enter() {
        if (!isSupported.value || isFullscreen.value) return;
        if (isElementFullScreen()) await exit();
        const target2 = targetRef.value;
        if (requestMethod.value && (target2 == null ? void 0 : target2[requestMethod.value]) != null) {
            await target2[requestMethod.value]();
            isFullscreen.value = true;
        }
    }
    async function toggle() {
        await (isFullscreen.value ? exit() : enter());
    }
    const handlerCallback = ()=>{
        const isElementFullScreenValue = isElementFullScreen();
        if (!isElementFullScreenValue || isElementFullScreenValue && isCurrentElementFullScreen()) isFullscreen.value = isElementFullScreenValue;
    };
    useEventListener(document1, eventHandlers, handlerCallback, false);
    useEventListener(()=>unrefElement(targetRef), eventHandlers, handlerCallback, false);
    if (autoExit) (0, _shared.tryOnScopeDispose)(exit);
    return {
        isSupported,
        isFullscreen,
        enter,
        exit,
        toggle
    };
}
function mapGamepadToXbox360Controller(gamepad) {
    return (0, _vueDemi.computed)(()=>{
        if (gamepad.value) return {
            buttons: {
                a: gamepad.value.buttons[0],
                b: gamepad.value.buttons[1],
                x: gamepad.value.buttons[2],
                y: gamepad.value.buttons[3]
            },
            bumper: {
                left: gamepad.value.buttons[4],
                right: gamepad.value.buttons[5]
            },
            triggers: {
                left: gamepad.value.buttons[6],
                right: gamepad.value.buttons[7]
            },
            stick: {
                left: {
                    horizontal: gamepad.value.axes[0],
                    vertical: gamepad.value.axes[1],
                    button: gamepad.value.buttons[10]
                },
                right: {
                    horizontal: gamepad.value.axes[2],
                    vertical: gamepad.value.axes[3],
                    button: gamepad.value.buttons[11]
                }
            },
            dpad: {
                up: gamepad.value.buttons[12],
                down: gamepad.value.buttons[13],
                left: gamepad.value.buttons[14],
                right: gamepad.value.buttons[15]
            },
            back: gamepad.value.buttons[8],
            start: gamepad.value.buttons[9]
        };
        return null;
    });
}
function useGamepad(options = {}) {
    const { navigator =defaultNavigator  } = options;
    const isSupported = useSupported(()=>navigator && "getGamepads" in navigator);
    const gamepads = (0, _vueDemi.ref)([]);
    const onConnectedHook = (0, _shared.createEventHook)();
    const onDisconnectedHook = (0, _shared.createEventHook)();
    const stateFromGamepad = (gamepad)=>{
        const hapticActuators = [];
        const vibrationActuator = "vibrationActuator" in gamepad ? gamepad.vibrationActuator : null;
        if (vibrationActuator) hapticActuators.push(vibrationActuator);
        if (gamepad.hapticActuators) hapticActuators.push(...gamepad.hapticActuators);
        return {
            id: gamepad.id,
            index: gamepad.index,
            connected: gamepad.connected,
            mapping: gamepad.mapping,
            timestamp: gamepad.timestamp,
            vibrationActuator: gamepad.vibrationActuator,
            hapticActuators,
            axes: gamepad.axes.map((axes)=>axes),
            buttons: gamepad.buttons.map((button)=>({
                    pressed: button.pressed,
                    touched: button.touched,
                    value: button.value
                }))
        };
    };
    const updateGamepadState = ()=>{
        const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];
        for (const gamepad of _gamepads)if (gamepad && gamepads.value[gamepad.index]) gamepads.value[gamepad.index] = stateFromGamepad(gamepad);
    };
    const { isActive , pause , resume  } = useRafFn(updateGamepadState);
    const onGamepadConnected = (gamepad)=>{
        if (!gamepads.value.some(({ index  })=>index === gamepad.index)) {
            gamepads.value.push(stateFromGamepad(gamepad));
            onConnectedHook.trigger(gamepad.index);
        }
        resume();
    };
    const onGamepadDisconnected = (gamepad)=>{
        gamepads.value = gamepads.value.filter((x)=>x.index !== gamepad.index);
        onDisconnectedHook.trigger(gamepad.index);
    };
    useEventListener("gamepadconnected", (e)=>onGamepadConnected(e.gamepad));
    useEventListener("gamepaddisconnected", (e)=>onGamepadDisconnected(e.gamepad));
    (0, _shared.tryOnMounted)(()=>{
        const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];
        for (const gamepad of _gamepads)if (gamepad && gamepads.value[gamepad.index]) onGamepadConnected(gamepad);
    });
    pause();
    return {
        isSupported,
        onConnected: onConnectedHook.on,
        onDisconnected: onDisconnectedHook.on,
        gamepads,
        pause,
        resume,
        isActive
    };
}
function useGeolocation(options = {}) {
    const { enableHighAccuracy =true , maximumAge =3e4 , timeout =27e3 , navigator =defaultNavigator , immediate =true  } = options;
    const isSupported = useSupported(()=>navigator && "geolocation" in navigator);
    const locatedAt = (0, _vueDemi.ref)(null);
    const error = (0, _vueDemi.shallowRef)(null);
    const coords = (0, _vueDemi.ref)({
        accuracy: 0,
        latitude: Number.POSITIVE_INFINITY,
        longitude: Number.POSITIVE_INFINITY,
        altitude: null,
        altitudeAccuracy: null,
        heading: null,
        speed: null
    });
    function updatePosition(position) {
        locatedAt.value = position.timestamp;
        coords.value = position.coords;
        error.value = null;
    }
    let watcher;
    function resume() {
        if (isSupported.value) watcher = navigator.geolocation.watchPosition(updatePosition, (err)=>error.value = err, {
            enableHighAccuracy,
            maximumAge,
            timeout
        });
    }
    if (immediate) resume();
    function pause() {
        if (watcher && navigator) navigator.geolocation.clearWatch(watcher);
    }
    (0, _shared.tryOnScopeDispose)(()=>{
        pause();
    });
    return {
        isSupported,
        coords,
        locatedAt,
        error,
        resume,
        pause
    };
}
const defaultEvents$1 = [
    "mousemove",
    "mousedown",
    "resize",
    "keydown",
    "touchstart",
    "wheel"
];
const oneMinute = 6e4;
function useIdle(timeout = oneMinute, options = {}) {
    const { initialState =false , listenForVisibilityChange =true , events =defaultEvents$1 , window: window1 = defaultWindow , eventFilter =(0, _shared.throttleFilter)(50)  } = options;
    const idle = (0, _vueDemi.ref)(initialState);
    const lastActive = (0, _vueDemi.ref)((0, _shared.timestamp)());
    let timer;
    const reset = ()=>{
        idle.value = false;
        clearTimeout(timer);
        timer = setTimeout(()=>idle.value = true, timeout);
    };
    const onEvent = (0, _shared.createFilterWrapper)(eventFilter, ()=>{
        lastActive.value = (0, _shared.timestamp)();
        reset();
    });
    if (window1) {
        const document1 = window1.document;
        for (const event of events)useEventListener(window1, event, onEvent, {
            passive: true
        });
        if (listenForVisibilityChange) useEventListener(document1, "visibilitychange", ()=>{
            if (!document1.hidden) onEvent();
        });
        reset();
    }
    return {
        idle,
        lastActive,
        reset
    };
}
async function loadImage(options) {
    return new Promise((resolve, reject)=>{
        const img = new Image();
        const { src , srcset , sizes , class: clazz , loading , crossorigin , referrerPolicy  } = options;
        img.src = src;
        if (srcset) img.srcset = srcset;
        if (sizes) img.sizes = sizes;
        if (clazz) img.className = clazz;
        if (loading) img.loading = loading;
        if (crossorigin) img.crossOrigin = crossorigin;
        if (referrerPolicy) img.referrerPolicy = referrerPolicy;
        img.onload = ()=>resolve(img);
        img.onerror = reject;
    });
}
function useImage(options, asyncStateOptions = {}) {
    const state = useAsyncState(()=>loadImage((0, _shared.toValue)(options)), void 0, {
        resetOnExecute: true,
        ...asyncStateOptions
    });
    (0, _vueDemi.watch)(()=>(0, _shared.toValue)(options), ()=>state.execute(asyncStateOptions.delay), {
        deep: true
    });
    return state;
}
const ARRIVED_STATE_THRESHOLD_PIXELS = 1;
function useScroll(element, options = {}) {
    const { throttle =0 , idle =200 , onStop =(0, _shared.noop) , onScroll =(0, _shared.noop) , offset ={
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
    } , eventListenerOptions ={
        capture: false,
        passive: true
    } , behavior ="auto" , window: window1 = defaultWindow , onError =(e)=>{
        console.error(e);
    }  } = options;
    const internalX = (0, _vueDemi.ref)(0);
    const internalY = (0, _vueDemi.ref)(0);
    const x = (0, _vueDemi.computed)({
        get () {
            return internalX.value;
        },
        set (x2) {
            scrollTo1(x2, void 0);
        }
    });
    const y = (0, _vueDemi.computed)({
        get () {
            return internalY.value;
        },
        set (y2) {
            scrollTo1(void 0, y2);
        }
    });
    function scrollTo1(_x, _y) {
        var _a, _b, _c, _d;
        if (!window1) return;
        const _element = (0, _shared.toValue)(element);
        if (!_element) return;
        (_c = _element instanceof Document ? window1.document.body : _element) == null || _c.scrollTo({
            top: (_a = (0, _shared.toValue)(_y)) != null ? _a : y.value,
            left: (_b = (0, _shared.toValue)(_x)) != null ? _b : x.value,
            behavior: (0, _shared.toValue)(behavior)
        });
        const scrollContainer = ((_d = _element == null ? void 0 : _element.document) == null ? void 0 : _d.documentElement) || (_element == null ? void 0 : _element.documentElement) || _element;
        if (x != null) internalX.value = scrollContainer.scrollLeft;
        if (y != null) internalY.value = scrollContainer.scrollTop;
    }
    const isScrolling = (0, _vueDemi.ref)(false);
    const arrivedState = (0, _vueDemi.reactive)({
        left: true,
        right: false,
        top: true,
        bottom: false
    });
    const directions = (0, _vueDemi.reactive)({
        left: false,
        right: false,
        top: false,
        bottom: false
    });
    const onScrollEnd = (e)=>{
        if (!isScrolling.value) return;
        isScrolling.value = false;
        directions.left = false;
        directions.right = false;
        directions.top = false;
        directions.bottom = false;
        onStop(e);
    };
    const onScrollEndDebounced = (0, _shared.useDebounceFn)(onScrollEnd, throttle + idle);
    const setArrivedState = (target)=>{
        var _a;
        if (!window1) return;
        const el = ((_a = target == null ? void 0 : target.document) == null ? void 0 : _a.documentElement) || (target == null ? void 0 : target.documentElement) || unrefElement(target);
        const { display , flexDirection  } = getComputedStyle(el);
        const scrollLeft = el.scrollLeft;
        directions.left = scrollLeft < internalX.value;
        directions.right = scrollLeft > internalX.value;
        const left = Math.abs(scrollLeft) <= (offset.left || 0);
        const right = Math.abs(scrollLeft) + el.clientWidth >= el.scrollWidth - (offset.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;
        if (display === "flex" && flexDirection === "row-reverse") {
            arrivedState.left = right;
            arrivedState.right = left;
        } else {
            arrivedState.left = left;
            arrivedState.right = right;
        }
        internalX.value = scrollLeft;
        let scrollTop = el.scrollTop;
        if (target === window1.document && !scrollTop) scrollTop = window1.document.body.scrollTop;
        directions.top = scrollTop < internalY.value;
        directions.bottom = scrollTop > internalY.value;
        const top = Math.abs(scrollTop) <= (offset.top || 0);
        const bottom = Math.abs(scrollTop) + el.clientHeight >= el.scrollHeight - (offset.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;
        if (display === "flex" && flexDirection === "column-reverse") {
            arrivedState.top = bottom;
            arrivedState.bottom = top;
        } else {
            arrivedState.top = top;
            arrivedState.bottom = bottom;
        }
        internalY.value = scrollTop;
    };
    const onScrollHandler = (e)=>{
        var _a;
        if (!window1) return;
        const eventTarget = (_a = e.target.documentElement) != null ? _a : e.target;
        setArrivedState(eventTarget);
        isScrolling.value = true;
        onScrollEndDebounced(e);
        onScroll(e);
    };
    useEventListener(element, "scroll", throttle ? (0, _shared.useThrottleFn)(onScrollHandler, throttle, true, false) : onScrollHandler, eventListenerOptions);
    (0, _shared.tryOnMounted)(()=>{
        try {
            const _element = (0, _shared.toValue)(element);
            if (!_element) return;
            setArrivedState(_element);
        } catch (e) {
            onError(e);
        }
    });
    useEventListener(element, "scrollend", onScrollEnd, eventListenerOptions);
    return {
        x,
        y,
        isScrolling,
        arrivedState,
        directions,
        measure () {
            const _element = (0, _shared.toValue)(element);
            if (window1 && _element) setArrivedState(_element);
        }
    };
}
function resolveElement(el) {
    if (typeof Window !== "undefined" && el instanceof Window) return el.document.documentElement;
    if (typeof Document !== "undefined" && el instanceof Document) return el.documentElement;
    return el;
}
function useInfiniteScroll(element, onLoadMore, options = {}) {
    var _a;
    const { direction ="bottom" , interval =100 , canLoadMore =()=>true  } = options;
    const state = (0, _vueDemi.reactive)(useScroll(element, {
        ...options,
        offset: {
            [direction]: (_a = options.distance) != null ? _a : 0,
            ...options.offset
        }
    }));
    const promise = (0, _vueDemi.ref)();
    const isLoading = (0, _vueDemi.computed)(()=>!!promise.value);
    const observedElement = (0, _vueDemi.computed)(()=>{
        return resolveElement((0, _shared.toValue)(element));
    });
    const isElementVisible = useElementVisibility(observedElement);
    function checkAndLoad() {
        state.measure();
        if (!observedElement.value || !isElementVisible.value || !canLoadMore(observedElement.value)) return;
        const { scrollHeight , clientHeight , scrollWidth , clientWidth  } = observedElement.value;
        const isNarrower = direction === "bottom" || direction === "top" ? scrollHeight <= clientHeight : scrollWidth <= clientWidth;
        if (state.arrivedState[direction] || isNarrower) {
            if (!promise.value) promise.value = Promise.all([
                onLoadMore(state),
                new Promise((resolve)=>setTimeout(resolve, interval))
            ]).finally(()=>{
                promise.value = null;
                (0, _vueDemi.nextTick)(()=>checkAndLoad());
            });
        }
    }
    (0, _vueDemi.watch)(()=>[
            state.arrivedState[direction],
            isElementVisible.value
        ], checkAndLoad, {
        immediate: true
    });
    return {
        isLoading
    };
}
const defaultEvents = [
    "mousedown",
    "mouseup",
    "keydown",
    "keyup"
];
function useKeyModifier(modifier, options = {}) {
    const { events =defaultEvents , document: document1 = defaultDocument , initial =null  } = options;
    const state = (0, _vueDemi.ref)(initial);
    if (document1) events.forEach((listenerEvent)=>{
        useEventListener(document1, listenerEvent, (evt)=>{
            if (typeof evt.getModifierState === "function") state.value = evt.getModifierState(modifier);
        });
    });
    return state;
}
function useLocalStorage(key, initialValue, options = {}) {
    const { window: window1 = defaultWindow  } = options;
    return useStorage(key, initialValue, window1 == null ? void 0 : window1.localStorage, options);
}
const DefaultMagicKeysAliasMap = {
    ctrl: "control",
    command: "meta",
    cmd: "meta",
    option: "alt",
    up: "arrowup",
    down: "arrowdown",
    left: "arrowleft",
    right: "arrowright"
};
function useMagicKeys(options = {}) {
    const { reactive: useReactive = false , target =defaultWindow , aliasMap =DefaultMagicKeysAliasMap , passive =true , onEventFired =(0, _shared.noop)  } = options;
    const current = (0, _vueDemi.reactive)(/* @__PURE__ */ new Set());
    const obj = {
        toJSON () {
            return {};
        },
        current
    };
    const refs = useReactive ? (0, _vueDemi.reactive)(obj) : obj;
    const metaDeps = /* @__PURE__ */ new Set();
    const usedKeys = /* @__PURE__ */ new Set();
    function setRefs(key, value) {
        if (key in refs) {
            if (useReactive) refs[key] = value;
            else refs[key].value = value;
        }
    }
    function reset() {
        current.clear();
        for (const key of usedKeys)setRefs(key, false);
    }
    function updateRefs(e, value) {
        var _a, _b;
        const key = (_a = e.key) == null ? void 0 : _a.toLowerCase();
        const code = (_b = e.code) == null ? void 0 : _b.toLowerCase();
        const values = [
            code,
            key
        ].filter(Boolean);
        if (key) {
            if (value) current.add(key);
            else current.delete(key);
        }
        for (const key2 of values){
            usedKeys.add(key2);
            setRefs(key2, value);
        }
        if (key === "meta" && !value) {
            metaDeps.forEach((key2)=>{
                current.delete(key2);
                setRefs(key2, false);
            });
            metaDeps.clear();
        } else if (typeof e.getModifierState === "function" && e.getModifierState("Meta") && value) [
            ...current,
            ...values
        ].forEach((key2)=>metaDeps.add(key2));
    }
    useEventListener(target, "keydown", (e)=>{
        updateRefs(e, true);
        return onEventFired(e);
    }, {
        passive
    });
    useEventListener(target, "keyup", (e)=>{
        updateRefs(e, false);
        return onEventFired(e);
    }, {
        passive
    });
    useEventListener("blur", reset, {
        passive: true
    });
    useEventListener("focus", reset, {
        passive: true
    });
    const proxy = new Proxy(refs, {
        get (target2, prop, rec) {
            if (typeof prop !== "string") return Reflect.get(target2, prop, rec);
            prop = prop.toLowerCase();
            if (prop in aliasMap) prop = aliasMap[prop];
            if (!(prop in refs)) {
                if (/[+_-]/.test(prop)) {
                    const keys = prop.split(/[+_-]/g).map((i)=>i.trim());
                    refs[prop] = (0, _vueDemi.computed)(()=>keys.every((key)=>(0, _shared.toValue)(proxy[key])));
                } else refs[prop] = (0, _vueDemi.ref)(false);
            }
            const r = Reflect.get(target2, prop, rec);
            return useReactive ? (0, _shared.toValue)(r) : r;
        }
    });
    return proxy;
}
function usingElRef(source, cb) {
    if ((0, _shared.toValue)(source)) cb((0, _shared.toValue)(source));
}
function timeRangeToArray(timeRanges) {
    let ranges = [];
    for(let i = 0; i < timeRanges.length; ++i)ranges = [
        ...ranges,
        [
            timeRanges.start(i),
            timeRanges.end(i)
        ]
    ];
    return ranges;
}
function tracksToArray(tracks) {
    return Array.from(tracks).map(({ label , kind , language , mode , activeCues , cues , inBandMetadataTrackDispatchType  }, id)=>({
            id,
            label,
            kind,
            language,
            mode,
            activeCues,
            cues,
            inBandMetadataTrackDispatchType
        }));
}
const defaultOptions = {
    src: "",
    tracks: []
};
function useMediaControls(target, options = {}) {
    target = (0, _shared.toRef)(target);
    options = {
        ...defaultOptions,
        ...options
    };
    const { document: document1 = defaultDocument  } = options;
    const currentTime = (0, _vueDemi.ref)(0);
    const duration = (0, _vueDemi.ref)(0);
    const seeking = (0, _vueDemi.ref)(false);
    const volume = (0, _vueDemi.ref)(1);
    const waiting = (0, _vueDemi.ref)(false);
    const ended = (0, _vueDemi.ref)(false);
    const playing = (0, _vueDemi.ref)(false);
    const rate = (0, _vueDemi.ref)(1);
    const stalled = (0, _vueDemi.ref)(false);
    const buffered = (0, _vueDemi.ref)([]);
    const tracks = (0, _vueDemi.ref)([]);
    const selectedTrack = (0, _vueDemi.ref)(-1);
    const isPictureInPicture = (0, _vueDemi.ref)(false);
    const muted = (0, _vueDemi.ref)(false);
    const supportsPictureInPicture = document1 && "pictureInPictureEnabled" in document1;
    const sourceErrorEvent = (0, _shared.createEventHook)();
    const disableTrack = (track)=>{
        usingElRef(target, (el)=>{
            if (track) {
                const id = typeof track === "number" ? track : track.id;
                el.textTracks[id].mode = "disabled";
            } else for(let i = 0; i < el.textTracks.length; ++i)el.textTracks[i].mode = "disabled";
            selectedTrack.value = -1;
        });
    };
    const enableTrack = (track, disableTracks = true)=>{
        usingElRef(target, (el)=>{
            const id = typeof track === "number" ? track : track.id;
            if (disableTracks) disableTrack();
            el.textTracks[id].mode = "showing";
            selectedTrack.value = id;
        });
    };
    const togglePictureInPicture = ()=>{
        return new Promise((resolve, reject)=>{
            usingElRef(target, async (el)=>{
                if (supportsPictureInPicture) {
                    if (!isPictureInPicture.value) el.requestPictureInPicture().then(resolve).catch(reject);
                    else document1.exitPictureInPicture().then(resolve).catch(reject);
                }
            });
        });
    };
    (0, _vueDemi.watchEffect)(()=>{
        if (!document1) return;
        const el = (0, _shared.toValue)(target);
        if (!el) return;
        const src = (0, _shared.toValue)(options.src);
        let sources = [];
        if (!src) return;
        if (typeof src === "string") sources = [
            {
                src
            }
        ];
        else if (Array.isArray(src)) sources = src;
        else if ((0, _shared.isObject)(src)) sources = [
            src
        ];
        el.querySelectorAll("source").forEach((e)=>{
            e.removeEventListener("error", sourceErrorEvent.trigger);
            e.remove();
        });
        sources.forEach(({ src: src2 , type  })=>{
            const source = document1.createElement("source");
            source.setAttribute("src", src2);
            source.setAttribute("type", type || "");
            source.addEventListener("error", sourceErrorEvent.trigger);
            el.appendChild(source);
        });
        el.load();
    });
    (0, _shared.tryOnScopeDispose)(()=>{
        const el = (0, _shared.toValue)(target);
        if (!el) return;
        el.querySelectorAll("source").forEach((e)=>e.removeEventListener("error", sourceErrorEvent.trigger));
    });
    (0, _vueDemi.watch)([
        target,
        volume
    ], ()=>{
        const el = (0, _shared.toValue)(target);
        if (!el) return;
        el.volume = volume.value;
    });
    (0, _vueDemi.watch)([
        target,
        muted
    ], ()=>{
        const el = (0, _shared.toValue)(target);
        if (!el) return;
        el.muted = muted.value;
    });
    (0, _vueDemi.watch)([
        target,
        rate
    ], ()=>{
        const el = (0, _shared.toValue)(target);
        if (!el) return;
        el.playbackRate = rate.value;
    });
    (0, _vueDemi.watchEffect)(()=>{
        if (!document1) return;
        const textTracks = (0, _shared.toValue)(options.tracks);
        const el = (0, _shared.toValue)(target);
        if (!textTracks || !textTracks.length || !el) return;
        el.querySelectorAll("track").forEach((e)=>e.remove());
        textTracks.forEach(({ default: isDefault , kind , label , src , srcLang  }, i)=>{
            const track = document1.createElement("track");
            track.default = isDefault || false;
            track.kind = kind;
            track.label = label;
            track.src = src;
            track.srclang = srcLang;
            if (track.default) selectedTrack.value = i;
            el.appendChild(track);
        });
    });
    const { ignoreUpdates: ignoreCurrentTimeUpdates  } = (0, _shared.watchIgnorable)(currentTime, (time)=>{
        const el = (0, _shared.toValue)(target);
        if (!el) return;
        el.currentTime = time;
    });
    const { ignoreUpdates: ignorePlayingUpdates  } = (0, _shared.watchIgnorable)(playing, (isPlaying)=>{
        const el = (0, _shared.toValue)(target);
        if (!el) return;
        isPlaying ? el.play() : el.pause();
    });
    useEventListener(target, "timeupdate", ()=>ignoreCurrentTimeUpdates(()=>currentTime.value = (0, _shared.toValue)(target).currentTime));
    useEventListener(target, "durationchange", ()=>duration.value = (0, _shared.toValue)(target).duration);
    useEventListener(target, "progress", ()=>buffered.value = timeRangeToArray((0, _shared.toValue)(target).buffered));
    useEventListener(target, "seeking", ()=>seeking.value = true);
    useEventListener(target, "seeked", ()=>seeking.value = false);
    useEventListener(target, [
        "waiting",
        "loadstart"
    ], ()=>{
        waiting.value = true;
        ignorePlayingUpdates(()=>playing.value = false);
    });
    useEventListener(target, "loadeddata", ()=>waiting.value = false);
    useEventListener(target, "playing", ()=>{
        waiting.value = false;
        ended.value = false;
        ignorePlayingUpdates(()=>playing.value = true);
    });
    useEventListener(target, "ratechange", ()=>rate.value = (0, _shared.toValue)(target).playbackRate);
    useEventListener(target, "stalled", ()=>stalled.value = true);
    useEventListener(target, "ended", ()=>ended.value = true);
    useEventListener(target, "pause", ()=>ignorePlayingUpdates(()=>playing.value = false));
    useEventListener(target, "play", ()=>ignorePlayingUpdates(()=>playing.value = true));
    useEventListener(target, "enterpictureinpicture", ()=>isPictureInPicture.value = true);
    useEventListener(target, "leavepictureinpicture", ()=>isPictureInPicture.value = false);
    useEventListener(target, "volumechange", ()=>{
        const el = (0, _shared.toValue)(target);
        if (!el) return;
        volume.value = el.volume;
        muted.value = el.muted;
    });
    const listeners = [];
    const stop = (0, _vueDemi.watch)([
        target
    ], ()=>{
        const el = (0, _shared.toValue)(target);
        if (!el) return;
        stop();
        listeners[0] = useEventListener(el.textTracks, "addtrack", ()=>tracks.value = tracksToArray(el.textTracks));
        listeners[1] = useEventListener(el.textTracks, "removetrack", ()=>tracks.value = tracksToArray(el.textTracks));
        listeners[2] = useEventListener(el.textTracks, "change", ()=>tracks.value = tracksToArray(el.textTracks));
    });
    (0, _shared.tryOnScopeDispose)(()=>listeners.forEach((listener)=>listener()));
    return {
        currentTime,
        duration,
        waiting,
        seeking,
        ended,
        stalled,
        buffered,
        playing,
        rate,
        // Volume
        volume,
        muted,
        // Tracks
        tracks,
        selectedTrack,
        enableTrack,
        disableTrack,
        // Picture in Picture
        supportsPictureInPicture,
        togglePictureInPicture,
        isPictureInPicture,
        // Events
        onSourceError: sourceErrorEvent.on
    };
}
function getMapVue2Compat() {
    const data = (0, _vueDemi.shallowReactive)({});
    return {
        get: (key)=>data[key],
        set: (key, value)=>(0, _vueDemi.set)(data, key, value),
        has: (key)=>(0, _shared.hasOwn)(data, key),
        delete: (key)=>(0, _vueDemi.del)(data, key),
        clear: ()=>{
            Object.keys(data).forEach((key)=>{
                (0, _vueDemi.del)(data, key);
            });
        }
    };
}
function useMemoize(resolver, options) {
    const initCache = ()=>{
        if (options == null ? void 0 : options.cache) return (0, _vueDemi.shallowReactive)(options.cache);
        if (0, _vueDemi.isVue2) return getMapVue2Compat();
        return (0, _vueDemi.shallowReactive)(/* @__PURE__ */ new Map());
    };
    const cache = initCache();
    const generateKey = (...args)=>(options == null ? void 0 : options.getKey) ? options.getKey(...args) : JSON.stringify(args);
    const _loadData = (key, ...args)=>{
        cache.set(key, resolver(...args));
        return cache.get(key);
    };
    const loadData = (...args)=>_loadData(generateKey(...args), ...args);
    const deleteData = (...args)=>{
        cache.delete(generateKey(...args));
    };
    const clearData = ()=>{
        cache.clear();
    };
    const memoized = (...args)=>{
        const key = generateKey(...args);
        if (cache.has(key)) return cache.get(key);
        return _loadData(key, ...args);
    };
    memoized.load = loadData;
    memoized.delete = deleteData;
    memoized.clear = clearData;
    memoized.generateKey = generateKey;
    memoized.cache = cache;
    return memoized;
}
function useMemory(options = {}) {
    const memory = (0, _vueDemi.ref)();
    const isSupported = useSupported(()=>typeof performance !== "undefined" && "memory" in performance);
    if (isSupported.value) {
        const { interval =1e3  } = options;
        (0, _shared.useIntervalFn)(()=>{
            memory.value = performance.memory;
        }, interval, {
            immediate: options.immediate,
            immediateCallback: options.immediateCallback
        });
    }
    return {
        isSupported,
        memory
    };
}
const UseMouseBuiltinExtractors = {
    page: (event)=>[
            event.pageX,
            event.pageY
        ],
    client: (event)=>[
            event.clientX,
            event.clientY
        ],
    screen: (event)=>[
            event.screenX,
            event.screenY
        ],
    movement: (event)=>event instanceof Touch ? null : [
            event.movementX,
            event.movementY
        ]
};
function useMouse(options = {}) {
    const { type ="page" , touch =true , resetOnTouchEnds =false , initialValue ={
        x: 0,
        y: 0
    } , window: window1 = defaultWindow , target =window1 , scroll =true , eventFilter  } = options;
    let _prevMouseEvent = null;
    const x = (0, _vueDemi.ref)(initialValue.x);
    const y = (0, _vueDemi.ref)(initialValue.y);
    const sourceType = (0, _vueDemi.ref)(null);
    const extractor = typeof type === "function" ? type : UseMouseBuiltinExtractors[type];
    const mouseHandler = (event)=>{
        const result = extractor(event);
        _prevMouseEvent = event;
        if (result) {
            [x.value, y.value] = result;
            sourceType.value = "mouse";
        }
    };
    const touchHandler = (event)=>{
        if (event.touches.length > 0) {
            const result = extractor(event.touches[0]);
            if (result) {
                [x.value, y.value] = result;
                sourceType.value = "touch";
            }
        }
    };
    const scrollHandler = ()=>{
        if (!_prevMouseEvent || !window1) return;
        const pos = extractor(_prevMouseEvent);
        if (_prevMouseEvent instanceof MouseEvent && pos) {
            x.value = pos[0] + window1.scrollX;
            y.value = pos[1] + window1.scrollY;
        }
    };
    const reset = ()=>{
        x.value = initialValue.x;
        y.value = initialValue.y;
    };
    const mouseHandlerWrapper = eventFilter ? (event)=>eventFilter(()=>mouseHandler(event), {}) : (event)=>mouseHandler(event);
    const touchHandlerWrapper = eventFilter ? (event)=>eventFilter(()=>touchHandler(event), {}) : (event)=>touchHandler(event);
    const scrollHandlerWrapper = eventFilter ? ()=>eventFilter(()=>scrollHandler(), {}) : ()=>scrollHandler();
    if (target) {
        const listenerOptions = {
            passive: true
        };
        useEventListener(target, [
            "mousemove",
            "dragover"
        ], mouseHandlerWrapper, listenerOptions);
        if (touch && type !== "movement") {
            useEventListener(target, [
                "touchstart",
                "touchmove"
            ], touchHandlerWrapper, listenerOptions);
            if (resetOnTouchEnds) useEventListener(target, "touchend", reset, listenerOptions);
        }
        if (scroll && type === "page") useEventListener(window1, "scroll", scrollHandlerWrapper, {
            passive: true
        });
    }
    return {
        x,
        y,
        sourceType
    };
}
function useMouseInElement(target, options = {}) {
    const { handleOutside =true , window: window1 = defaultWindow  } = options;
    const type = options.type || "page";
    const { x , y , sourceType  } = useMouse(options);
    const targetRef = (0, _vueDemi.ref)(target != null ? target : window1 == null ? void 0 : window1.document.body);
    const elementX = (0, _vueDemi.ref)(0);
    const elementY = (0, _vueDemi.ref)(0);
    const elementPositionX = (0, _vueDemi.ref)(0);
    const elementPositionY = (0, _vueDemi.ref)(0);
    const elementHeight = (0, _vueDemi.ref)(0);
    const elementWidth = (0, _vueDemi.ref)(0);
    const isOutside = (0, _vueDemi.ref)(true);
    let stop = ()=>{};
    if (window1) {
        stop = (0, _vueDemi.watch)([
            targetRef,
            x,
            y
        ], ()=>{
            const el = unrefElement(targetRef);
            if (!el) return;
            const { left , top , width , height  } = el.getBoundingClientRect();
            elementPositionX.value = left + (type === "page" ? window1.pageXOffset : 0);
            elementPositionY.value = top + (type === "page" ? window1.pageYOffset : 0);
            elementHeight.value = height;
            elementWidth.value = width;
            const elX = x.value - elementPositionX.value;
            const elY = y.value - elementPositionY.value;
            isOutside.value = width === 0 || height === 0 || elX < 0 || elY < 0 || elX > width || elY > height;
            if (handleOutside || !isOutside.value) {
                elementX.value = elX;
                elementY.value = elY;
            }
        }, {
            immediate: true
        });
        useEventListener(document, "mouseleave", ()=>{
            isOutside.value = true;
        });
    }
    return {
        x,
        y,
        sourceType,
        elementX,
        elementY,
        elementPositionX,
        elementPositionY,
        elementHeight,
        elementWidth,
        isOutside,
        stop
    };
}
function useMousePressed(options = {}) {
    const { touch =true , drag =true , capture =false , initialValue =false , window: window1 = defaultWindow  } = options;
    const pressed = (0, _vueDemi.ref)(initialValue);
    const sourceType = (0, _vueDemi.ref)(null);
    if (!window1) return {
        pressed,
        sourceType
    };
    const onPressed = (srcType)=>()=>{
            pressed.value = true;
            sourceType.value = srcType;
        };
    const onReleased = ()=>{
        pressed.value = false;
        sourceType.value = null;
    };
    const target = (0, _vueDemi.computed)(()=>unrefElement(options.target) || window1);
    useEventListener(target, "mousedown", onPressed("mouse"), {
        passive: true,
        capture
    });
    useEventListener(window1, "mouseleave", onReleased, {
        passive: true,
        capture
    });
    useEventListener(window1, "mouseup", onReleased, {
        passive: true,
        capture
    });
    if (drag) {
        useEventListener(target, "dragstart", onPressed("mouse"), {
            passive: true,
            capture
        });
        useEventListener(window1, "drop", onReleased, {
            passive: true,
            capture
        });
        useEventListener(window1, "dragend", onReleased, {
            passive: true,
            capture
        });
    }
    if (touch) {
        useEventListener(target, "touchstart", onPressed("touch"), {
            passive: true,
            capture
        });
        useEventListener(window1, "touchend", onReleased, {
            passive: true,
            capture
        });
        useEventListener(window1, "touchcancel", onReleased, {
            passive: true,
            capture
        });
    }
    return {
        pressed,
        sourceType
    };
}
function useNavigatorLanguage(options = {}) {
    const { window: window1 = defaultWindow  } = options;
    const navigator = window1 == null ? void 0 : window1.navigator;
    const isSupported = useSupported(()=>navigator && "language" in navigator);
    const language = (0, _vueDemi.ref)(navigator == null ? void 0 : navigator.language);
    useEventListener(window1, "languagechange", ()=>{
        if (navigator) language.value = navigator.language;
    });
    return {
        isSupported,
        language
    };
}
function useNetwork(options = {}) {
    const { window: window1 = defaultWindow  } = options;
    const navigator = window1 == null ? void 0 : window1.navigator;
    const isSupported = useSupported(()=>navigator && "connection" in navigator);
    const isOnline = (0, _vueDemi.ref)(true);
    const saveData = (0, _vueDemi.ref)(false);
    const offlineAt = (0, _vueDemi.ref)(void 0);
    const onlineAt = (0, _vueDemi.ref)(void 0);
    const downlink = (0, _vueDemi.ref)(void 0);
    const downlinkMax = (0, _vueDemi.ref)(void 0);
    const rtt = (0, _vueDemi.ref)(void 0);
    const effectiveType = (0, _vueDemi.ref)(void 0);
    const type = (0, _vueDemi.ref)("unknown");
    const connection = isSupported.value && navigator.connection;
    function updateNetworkInformation() {
        if (!navigator) return;
        isOnline.value = navigator.onLine;
        offlineAt.value = isOnline.value ? void 0 : Date.now();
        onlineAt.value = isOnline.value ? Date.now() : void 0;
        if (connection) {
            downlink.value = connection.downlink;
            downlinkMax.value = connection.downlinkMax;
            effectiveType.value = connection.effectiveType;
            rtt.value = connection.rtt;
            saveData.value = connection.saveData;
            type.value = connection.type;
        }
    }
    if (window1) {
        useEventListener(window1, "offline", ()=>{
            isOnline.value = false;
            offlineAt.value = Date.now();
        });
        useEventListener(window1, "online", ()=>{
            isOnline.value = true;
            onlineAt.value = Date.now();
        });
    }
    if (connection) useEventListener(connection, "change", updateNetworkInformation, false);
    updateNetworkInformation();
    return {
        isSupported,
        isOnline,
        saveData,
        offlineAt,
        onlineAt,
        downlink,
        downlinkMax,
        effectiveType,
        rtt,
        type
    };
}
function useNow(options = {}) {
    const { controls: exposeControls = false , interval ="requestAnimationFrame"  } = options;
    const now = (0, _vueDemi.ref)(/* @__PURE__ */ new Date());
    const update = ()=>now.value = /* @__PURE__ */ new Date();
    const controls = interval === "requestAnimationFrame" ? useRafFn(update, {
        immediate: true
    }) : (0, _shared.useIntervalFn)(update, interval, {
        immediate: true
    });
    if (exposeControls) return {
        now,
        ...controls
    };
    else return now;
}
function useObjectUrl(object) {
    const url = (0, _vueDemi.ref)();
    const release = ()=>{
        if (url.value) URL.revokeObjectURL(url.value);
        url.value = void 0;
    };
    (0, _vueDemi.watch)(()=>(0, _shared.toValue)(object), (newObject)=>{
        release();
        if (newObject) url.value = URL.createObjectURL(newObject);
    }, {
        immediate: true
    });
    (0, _shared.tryOnScopeDispose)(release);
    return (0, _vueDemi.readonly)(url);
}
function useClamp(value, min, max) {
    if (typeof value === "function" || (0, _vueDemi.isReadonly)(value)) return (0, _vueDemi.computed)(()=>(0, _shared.clamp)((0, _shared.toValue)(value), (0, _shared.toValue)(min), (0, _shared.toValue)(max)));
    const _value = (0, _vueDemi.ref)(value);
    return (0, _vueDemi.computed)({
        get () {
            return _value.value = (0, _shared.clamp)(_value.value, (0, _shared.toValue)(min), (0, _shared.toValue)(max));
        },
        set (value2) {
            _value.value = (0, _shared.clamp)(value2, (0, _shared.toValue)(min), (0, _shared.toValue)(max));
        }
    });
}
function useOffsetPagination(options) {
    const { total =Number.POSITIVE_INFINITY , pageSize =10 , page =1 , onPageChange =(0, _shared.noop) , onPageSizeChange =(0, _shared.noop) , onPageCountChange =(0, _shared.noop)  } = options;
    const currentPageSize = useClamp(pageSize, 1, Number.POSITIVE_INFINITY);
    const pageCount = (0, _vueDemi.computed)(()=>Math.max(1, Math.ceil((0, _shared.toValue)(total) / (0, _shared.toValue)(currentPageSize))));
    const currentPage = useClamp(page, 1, pageCount);
    const isFirstPage = (0, _vueDemi.computed)(()=>currentPage.value === 1);
    const isLastPage = (0, _vueDemi.computed)(()=>currentPage.value === pageCount.value);
    if ((0, _vueDemi.isRef)(page)) (0, _shared.syncRef)(page, currentPage, {
        direction: (0, _vueDemi.isReadonly)(page) ? "ltr" : "both"
    });
    if ((0, _vueDemi.isRef)(pageSize)) (0, _shared.syncRef)(pageSize, currentPageSize, {
        direction: (0, _vueDemi.isReadonly)(pageSize) ? "ltr" : "both"
    });
    function prev() {
        currentPage.value--;
    }
    function next() {
        currentPage.value++;
    }
    const returnValue = {
        currentPage,
        currentPageSize,
        pageCount,
        isFirstPage,
        isLastPage,
        prev,
        next
    };
    (0, _vueDemi.watch)(currentPage, ()=>{
        onPageChange((0, _vueDemi.reactive)(returnValue));
    });
    (0, _vueDemi.watch)(currentPageSize, ()=>{
        onPageSizeChange((0, _vueDemi.reactive)(returnValue));
    });
    (0, _vueDemi.watch)(pageCount, ()=>{
        onPageCountChange((0, _vueDemi.reactive)(returnValue));
    });
    return returnValue;
}
function useOnline(options = {}) {
    const { isOnline  } = useNetwork(options);
    return isOnline;
}
function usePageLeave(options = {}) {
    const { window: window1 = defaultWindow  } = options;
    const isLeft = (0, _vueDemi.ref)(false);
    const handler = (event)=>{
        if (!window1) return;
        event = event || window1.event;
        const from = event.relatedTarget || event.toElement;
        isLeft.value = !from;
    };
    if (window1) {
        useEventListener(window1, "mouseout", handler, {
            passive: true
        });
        useEventListener(window1.document, "mouseleave", handler, {
            passive: true
        });
        useEventListener(window1.document, "mouseenter", handler, {
            passive: true
        });
    }
    return isLeft;
}
function useScreenOrientation(options = {}) {
    const { window: window1 = defaultWindow  } = options;
    const isSupported = useSupported(()=>window1 && "screen" in window1 && "orientation" in window1.screen);
    const screenOrientation = isSupported.value ? window1.screen.orientation : {};
    const orientation = (0, _vueDemi.ref)(screenOrientation.type);
    const angle = (0, _vueDemi.ref)(screenOrientation.angle || 0);
    if (isSupported.value) useEventListener(window1, "orientationchange", ()=>{
        orientation.value = screenOrientation.type;
        angle.value = screenOrientation.angle;
    });
    const lockOrientation = (type)=>{
        if (isSupported.value && typeof screenOrientation.lock === "function") return screenOrientation.lock(type);
        return Promise.reject(new Error("Not supported"));
    };
    const unlockOrientation = ()=>{
        if (isSupported.value && typeof screenOrientation.unlock === "function") screenOrientation.unlock();
    };
    return {
        isSupported,
        orientation,
        angle,
        lockOrientation,
        unlockOrientation
    };
}
function useParallax(target, options = {}) {
    const { deviceOrientationTiltAdjust =(i)=>i , deviceOrientationRollAdjust =(i)=>i , mouseTiltAdjust =(i)=>i , mouseRollAdjust =(i)=>i , window: window1 = defaultWindow  } = options;
    const orientation = (0, _vueDemi.reactive)(useDeviceOrientation({
        window: window1
    }));
    const screenOrientation = (0, _vueDemi.reactive)(useScreenOrientation({
        window: window1
    }));
    const { elementX: x , elementY: y , elementWidth: width , elementHeight: height  } = useMouseInElement(target, {
        handleOutside: false,
        window: window1
    });
    const source = (0, _vueDemi.computed)(()=>{
        if (orientation.isSupported && (orientation.alpha != null && orientation.alpha !== 0 || orientation.gamma != null && orientation.gamma !== 0)) return "deviceOrientation";
        return "mouse";
    });
    const roll = (0, _vueDemi.computed)(()=>{
        if (source.value === "deviceOrientation") {
            let value;
            switch(screenOrientation.orientation){
                case "landscape-primary":
                    value = orientation.gamma / 90;
                    break;
                case "landscape-secondary":
                    value = -orientation.gamma / 90;
                    break;
                case "portrait-primary":
                    value = -orientation.beta / 90;
                    break;
                case "portrait-secondary":
                    value = orientation.beta / 90;
                    break;
                default:
                    value = -orientation.beta / 90;
            }
            return deviceOrientationRollAdjust(value);
        } else {
            const value = -(y.value - height.value / 2) / height.value;
            return mouseRollAdjust(value);
        }
    });
    const tilt = (0, _vueDemi.computed)(()=>{
        if (source.value === "deviceOrientation") {
            let value;
            switch(screenOrientation.orientation){
                case "landscape-primary":
                    value = orientation.beta / 90;
                    break;
                case "landscape-secondary":
                    value = -orientation.beta / 90;
                    break;
                case "portrait-primary":
                    value = orientation.gamma / 90;
                    break;
                case "portrait-secondary":
                    value = -orientation.gamma / 90;
                    break;
                default:
                    value = orientation.gamma / 90;
            }
            return deviceOrientationTiltAdjust(value);
        } else {
            const value = (x.value - width.value / 2) / width.value;
            return mouseTiltAdjust(value);
        }
    });
    return {
        roll,
        tilt,
        source
    };
}
function useParentElement(element = useCurrentElement()) {
    const parentElement = (0, _vueDemi.shallowRef)();
    const update = ()=>{
        const el = unrefElement(element);
        if (el) parentElement.value = el.parentElement;
    };
    (0, _shared.tryOnMounted)(update);
    (0, _vueDemi.watch)(()=>(0, _shared.toValue)(element), update);
    return parentElement;
}
function usePerformanceObserver(options, callback) {
    const { window: window1 = defaultWindow , immediate =true , ...performanceOptions } = options;
    const isSupported = useSupported(()=>window1 && "PerformanceObserver" in window1);
    let observer;
    const stop = ()=>{
        observer == null || observer.disconnect();
    };
    const start = ()=>{
        if (isSupported.value) {
            stop();
            observer = new PerformanceObserver(callback);
            observer.observe(performanceOptions);
        }
    };
    (0, _shared.tryOnScopeDispose)(stop);
    if (immediate) start();
    return {
        isSupported,
        start,
        stop
    };
}
const defaultState = {
    x: 0,
    y: 0,
    pointerId: 0,
    pressure: 0,
    tiltX: 0,
    tiltY: 0,
    width: 0,
    height: 0,
    twist: 0,
    pointerType: null
};
const keys = /* @__PURE__ */ Object.keys(defaultState);
function usePointer(options = {}) {
    const { target =defaultWindow  } = options;
    const isInside = (0, _vueDemi.ref)(false);
    const state = (0, _vueDemi.ref)(options.initialValue || {});
    Object.assign(state.value, defaultState, state.value);
    const handler = (event)=>{
        isInside.value = true;
        if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType)) return;
        state.value = (0, _shared.objectPick)(event, keys, false);
    };
    if (target) {
        const listenerOptions = {
            passive: true
        };
        useEventListener(target, [
            "pointerdown",
            "pointermove",
            "pointerup"
        ], handler, listenerOptions);
        useEventListener(target, "pointerleave", ()=>isInside.value = false, listenerOptions);
    }
    return {
        ...(0, _shared.toRefs)(state),
        isInside
    };
}
function usePointerLock(target, options = {}) {
    const { document: document1 = defaultDocument  } = options;
    const isSupported = useSupported(()=>document1 && "pointerLockElement" in document1);
    const element = (0, _vueDemi.ref)();
    const triggerElement = (0, _vueDemi.ref)();
    let targetElement;
    if (isSupported.value) {
        useEventListener(document1, "pointerlockchange", ()=>{
            var _a;
            const currentElement = (_a = document1.pointerLockElement) != null ? _a : element.value;
            if (targetElement && currentElement === targetElement) {
                element.value = document1.pointerLockElement;
                if (!element.value) targetElement = triggerElement.value = null;
            }
        });
        useEventListener(document1, "pointerlockerror", ()=>{
            var _a;
            const currentElement = (_a = document1.pointerLockElement) != null ? _a : element.value;
            if (targetElement && currentElement === targetElement) {
                const action = document1.pointerLockElement ? "release" : "acquire";
                throw new Error(`Failed to ${action} pointer lock.`);
            }
        });
    }
    async function lock(e) {
        var _a;
        if (!isSupported.value) throw new Error("Pointer Lock API is not supported by your browser.");
        triggerElement.value = e instanceof Event ? e.currentTarget : null;
        targetElement = e instanceof Event ? (_a = unrefElement(target)) != null ? _a : triggerElement.value : unrefElement(e);
        if (!targetElement) throw new Error("Target element undefined.");
        targetElement.requestPointerLock();
        return await (0, _shared.until)(element).toBe(targetElement);
    }
    async function unlock() {
        if (!element.value) return false;
        document1.exitPointerLock();
        await (0, _shared.until)(element).toBeNull();
        return true;
    }
    return {
        isSupported,
        element,
        triggerElement,
        lock,
        unlock
    };
}
function usePointerSwipe(target, options = {}) {
    const targetRef = (0, _shared.toRef)(target);
    const { threshold =50 , onSwipe , onSwipeEnd , onSwipeStart , disableTextSelect =false  } = options;
    const posStart = (0, _vueDemi.reactive)({
        x: 0,
        y: 0
    });
    const updatePosStart = (x, y)=>{
        posStart.x = x;
        posStart.y = y;
    };
    const posEnd = (0, _vueDemi.reactive)({
        x: 0,
        y: 0
    });
    const updatePosEnd = (x, y)=>{
        posEnd.x = x;
        posEnd.y = y;
    };
    const distanceX = (0, _vueDemi.computed)(()=>posStart.x - posEnd.x);
    const distanceY = (0, _vueDemi.computed)(()=>posStart.y - posEnd.y);
    const { max , abs  } = Math;
    const isThresholdExceeded = (0, _vueDemi.computed)(()=>max(abs(distanceX.value), abs(distanceY.value)) >= threshold);
    const isSwiping = (0, _vueDemi.ref)(false);
    const isPointerDown = (0, _vueDemi.ref)(false);
    const direction = (0, _vueDemi.computed)(()=>{
        if (!isThresholdExceeded.value) return "none";
        if (abs(distanceX.value) > abs(distanceY.value)) return distanceX.value > 0 ? "left" : "right";
        else return distanceY.value > 0 ? "up" : "down";
    });
    const eventIsAllowed = (e)=>{
        var _a, _b, _c;
        const isReleasingButton = e.buttons === 0;
        const isPrimaryButton = e.buttons === 1;
        return (_c = (_b = (_a = options.pointerTypes) == null ? void 0 : _a.includes(e.pointerType)) != null ? _b : isReleasingButton || isPrimaryButton) != null ? _c : true;
    };
    const stops = [
        useEventListener(target, "pointerdown", (e)=>{
            if (!eventIsAllowed(e)) return;
            isPointerDown.value = true;
            const eventTarget = e.target;
            eventTarget == null || eventTarget.setPointerCapture(e.pointerId);
            const { clientX: x , clientY: y  } = e;
            updatePosStart(x, y);
            updatePosEnd(x, y);
            onSwipeStart == null || onSwipeStart(e);
        }),
        useEventListener(target, "pointermove", (e)=>{
            if (!eventIsAllowed(e)) return;
            if (!isPointerDown.value) return;
            const { clientX: x , clientY: y  } = e;
            updatePosEnd(x, y);
            if (!isSwiping.value && isThresholdExceeded.value) isSwiping.value = true;
            if (isSwiping.value) onSwipe == null || onSwipe(e);
        }),
        useEventListener(target, "pointerup", (e)=>{
            if (!eventIsAllowed(e)) return;
            if (isSwiping.value) onSwipeEnd == null || onSwipeEnd(e, direction.value);
            isPointerDown.value = false;
            isSwiping.value = false;
        })
    ];
    (0, _shared.tryOnMounted)(()=>{
        var _a, _b, _c, _d, _e, _f, _g, _h;
        (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null || _b.setProperty("touch-action", "none");
        if (disableTextSelect) {
            (_d = (_c = targetRef.value) == null ? void 0 : _c.style) == null || _d.setProperty("-webkit-user-select", "none");
            (_f = (_e = targetRef.value) == null ? void 0 : _e.style) == null || _f.setProperty("-ms-user-select", "none");
            (_h = (_g = targetRef.value) == null ? void 0 : _g.style) == null || _h.setProperty("user-select", "none");
        }
    });
    const stop = ()=>stops.forEach((s)=>s());
    return {
        isSwiping: (0, _vueDemi.readonly)(isSwiping),
        direction: (0, _vueDemi.readonly)(direction),
        posStart: (0, _vueDemi.readonly)(posStart),
        posEnd: (0, _vueDemi.readonly)(posEnd),
        distanceX,
        distanceY,
        stop
    };
}
function usePreferredColorScheme(options) {
    const isLight = useMediaQuery("(prefers-color-scheme: light)", options);
    const isDark = useMediaQuery("(prefers-color-scheme: dark)", options);
    return (0, _vueDemi.computed)(()=>{
        if (isDark.value) return "dark";
        if (isLight.value) return "light";
        return "no-preference";
    });
}
function usePreferredContrast(options) {
    const isMore = useMediaQuery("(prefers-contrast: more)", options);
    const isLess = useMediaQuery("(prefers-contrast: less)", options);
    const isCustom = useMediaQuery("(prefers-contrast: custom)", options);
    return (0, _vueDemi.computed)(()=>{
        if (isMore.value) return "more";
        if (isLess.value) return "less";
        if (isCustom.value) return "custom";
        return "no-preference";
    });
}
function usePreferredLanguages(options = {}) {
    const { window: window1 = defaultWindow  } = options;
    if (!window1) return (0, _vueDemi.ref)([
        "en"
    ]);
    const navigator = window1.navigator;
    const value = (0, _vueDemi.ref)(navigator.languages);
    useEventListener(window1, "languagechange", ()=>{
        value.value = navigator.languages;
    });
    return value;
}
function usePreferredReducedMotion(options) {
    const isReduced = useMediaQuery("(prefers-reduced-motion: reduce)", options);
    return (0, _vueDemi.computed)(()=>{
        if (isReduced.value) return "reduce";
        return "no-preference";
    });
}
function usePrevious(value, initialValue) {
    const previous = (0, _vueDemi.shallowRef)(initialValue);
    (0, _vueDemi.watch)((0, _shared.toRef)(value), (_, oldValue)=>{
        previous.value = oldValue;
    }, {
        flush: "sync"
    });
    return (0, _vueDemi.readonly)(previous);
}
const topVarName = "--vueuse-safe-area-top";
const rightVarName = "--vueuse-safe-area-right";
const bottomVarName = "--vueuse-safe-area-bottom";
const leftVarName = "--vueuse-safe-area-left";
function useScreenSafeArea() {
    const top = (0, _vueDemi.ref)("");
    const right = (0, _vueDemi.ref)("");
    const bottom = (0, _vueDemi.ref)("");
    const left = (0, _vueDemi.ref)("");
    if (0, _shared.isClient) {
        const topCssVar = useCssVar(topVarName);
        const rightCssVar = useCssVar(rightVarName);
        const bottomCssVar = useCssVar(bottomVarName);
        const leftCssVar = useCssVar(leftVarName);
        topCssVar.value = "env(safe-area-inset-top, 0px)";
        rightCssVar.value = "env(safe-area-inset-right, 0px)";
        bottomCssVar.value = "env(safe-area-inset-bottom, 0px)";
        leftCssVar.value = "env(safe-area-inset-left, 0px)";
        update();
        useEventListener("resize", (0, _shared.useDebounceFn)(update));
    }
    function update() {
        top.value = getValue(topVarName);
        right.value = getValue(rightVarName);
        bottom.value = getValue(bottomVarName);
        left.value = getValue(leftVarName);
    }
    return {
        top,
        right,
        bottom,
        left,
        update
    };
}
function getValue(position) {
    return getComputedStyle(document.documentElement).getPropertyValue(position);
}
function useScriptTag(src, onLoaded = (0, _shared.noop), options = {}) {
    const { immediate =true , manual =false , type ="text/javascript" , async =true , crossOrigin , referrerPolicy , noModule , defer , document: document1 = defaultDocument , attrs ={}  } = options;
    const scriptTag = (0, _vueDemi.ref)(null);
    let _promise = null;
    const loadScript = (waitForScriptLoad)=>new Promise((resolve, reject)=>{
            const resolveWithElement = (el2)=>{
                scriptTag.value = el2;
                resolve(el2);
                return el2;
            };
            if (!document1) {
                resolve(false);
                return;
            }
            let shouldAppend = false;
            let el = document1.querySelector(`script[src="${(0, _shared.toValue)(src)}"]`);
            if (!el) {
                el = document1.createElement("script");
                el.type = type;
                el.async = async;
                el.src = (0, _shared.toValue)(src);
                if (defer) el.defer = defer;
                if (crossOrigin) el.crossOrigin = crossOrigin;
                if (noModule) el.noModule = noModule;
                if (referrerPolicy) el.referrerPolicy = referrerPolicy;
                Object.entries(attrs).forEach(([name, value])=>el == null ? void 0 : el.setAttribute(name, value));
                shouldAppend = true;
            } else if (el.hasAttribute("data-loaded")) resolveWithElement(el);
            el.addEventListener("error", (event)=>reject(event));
            el.addEventListener("abort", (event)=>reject(event));
            el.addEventListener("load", ()=>{
                el.setAttribute("data-loaded", "true");
                onLoaded(el);
                resolveWithElement(el);
            });
            if (shouldAppend) el = document1.head.appendChild(el);
            if (!waitForScriptLoad) resolveWithElement(el);
        });
    const load = (waitForScriptLoad = true)=>{
        if (!_promise) _promise = loadScript(waitForScriptLoad);
        return _promise;
    };
    const unload = ()=>{
        if (!document1) return;
        _promise = null;
        if (scriptTag.value) scriptTag.value = null;
        const el = document1.querySelector(`script[src="${(0, _shared.toValue)(src)}"]`);
        if (el) document1.head.removeChild(el);
    };
    if (immediate && !manual) (0, _shared.tryOnMounted)(load);
    if (!manual) (0, _shared.tryOnUnmounted)(unload);
    return {
        scriptTag,
        load,
        unload
    };
}
function checkOverflowScroll(ele) {
    const style = window.getComputedStyle(ele);
    if (style.overflowX === "scroll" || style.overflowY === "scroll" || style.overflowX === "auto" && ele.clientWidth < ele.scrollWidth || style.overflowY === "auto" && ele.clientHeight < ele.scrollHeight) return true;
    else {
        const parent = ele.parentNode;
        if (!parent || parent.tagName === "BODY") return false;
        return checkOverflowScroll(parent);
    }
}
function preventDefault(rawEvent) {
    const e = rawEvent || window.event;
    const _target = e.target;
    if (checkOverflowScroll(_target)) return false;
    if (e.touches.length > 1) return true;
    if (e.preventDefault) e.preventDefault();
    return false;
}
const elInitialOverflow = /* @__PURE__ */ new WeakMap();
function useScrollLock(element, initialState = false) {
    const isLocked = (0, _vueDemi.ref)(initialState);
    let stopTouchMoveListener = null;
    let initialOverflow = "";
    (0, _vueDemi.watch)((0, _shared.toRef)(element), (el)=>{
        const target = resolveElement((0, _shared.toValue)(el));
        if (target) {
            const ele = target;
            if (!elInitialOverflow.get(ele)) elInitialOverflow.set(ele, ele.style.overflow);
            if (ele.style.overflow !== "hidden") initialOverflow = ele.style.overflow;
            if (ele.style.overflow === "hidden") return isLocked.value = true;
            if (isLocked.value) return ele.style.overflow = "hidden";
        }
    }, {
        immediate: true
    });
    const lock = ()=>{
        const el = resolveElement((0, _shared.toValue)(element));
        if (!el || isLocked.value) return;
        if (0, _shared.isIOS) stopTouchMoveListener = useEventListener(el, "touchmove", (e)=>{
            preventDefault(e);
        }, {
            passive: false
        });
        el.style.overflow = "hidden";
        isLocked.value = true;
    };
    const unlock = ()=>{
        const el = resolveElement((0, _shared.toValue)(element));
        if (!el || !isLocked.value) return;
        (0, _shared.isIOS) && (stopTouchMoveListener == null || stopTouchMoveListener());
        el.style.overflow = initialOverflow;
        elInitialOverflow.delete(el);
        isLocked.value = false;
    };
    (0, _shared.tryOnScopeDispose)(unlock);
    return (0, _vueDemi.computed)({
        get () {
            return isLocked.value;
        },
        set (v) {
            if (v) lock();
            else unlock();
        }
    });
}
function useSessionStorage(key, initialValue, options = {}) {
    const { window: window1 = defaultWindow  } = options;
    return useStorage(key, initialValue, window1 == null ? void 0 : window1.sessionStorage, options);
}
function useShare(shareOptions = {}, options = {}) {
    const { navigator =defaultNavigator  } = options;
    const _navigator = navigator;
    const isSupported = useSupported(()=>_navigator && "canShare" in _navigator);
    const share = async (overrideOptions = {})=>{
        if (isSupported.value) {
            const data = {
                ...(0, _shared.toValue)(shareOptions),
                ...(0, _shared.toValue)(overrideOptions)
            };
            let granted = true;
            if (data.files && _navigator.canShare) granted = _navigator.canShare({
                files: data.files
            });
            if (granted) return _navigator.share(data);
        }
    };
    return {
        isSupported,
        share
    };
}
const defaultSortFn = (source, compareFn)=>source.sort(compareFn);
const defaultCompare = (a, b)=>a - b;
function useSorted(...args) {
    var _a, _b, _c, _d;
    const [source] = args;
    let compareFn = defaultCompare;
    let options = {};
    if (args.length === 2) {
        if (typeof args[1] === "object") {
            options = args[1];
            compareFn = (_a = options.compareFn) != null ? _a : defaultCompare;
        } else compareFn = (_b = args[1]) != null ? _b : defaultCompare;
    } else if (args.length > 2) {
        compareFn = (_c = args[1]) != null ? _c : defaultCompare;
        options = (_d = args[2]) != null ? _d : {};
    }
    const { dirty =false , sortFn =defaultSortFn  } = options;
    if (!dirty) return (0, _vueDemi.computed)(()=>sortFn([
            ...(0, _shared.toValue)(source)
        ], compareFn));
    (0, _vueDemi.watchEffect)(()=>{
        const result = sortFn((0, _shared.toValue)(source), compareFn);
        if ((0, _vueDemi.isRef)(source)) source.value = result;
        else source.splice(0, source.length, ...result);
    });
    return source;
}
function useSpeechRecognition(options = {}) {
    const { interimResults =true , continuous =true , window: window1 = defaultWindow  } = options;
    const lang = (0, _shared.toRef)(options.lang || "en-US");
    const isListening = (0, _vueDemi.ref)(false);
    const isFinal = (0, _vueDemi.ref)(false);
    const result = (0, _vueDemi.ref)("");
    const error = (0, _vueDemi.shallowRef)(void 0);
    const toggle = (value = !isListening.value)=>{
        isListening.value = value;
    };
    const start = ()=>{
        isListening.value = true;
    };
    const stop = ()=>{
        isListening.value = false;
    };
    const SpeechRecognition = window1 && (window1.SpeechRecognition || window1.webkitSpeechRecognition);
    const isSupported = useSupported(()=>SpeechRecognition);
    let recognition;
    if (isSupported.value) {
        recognition = new SpeechRecognition();
        recognition.continuous = continuous;
        recognition.interimResults = interimResults;
        recognition.lang = (0, _shared.toValue)(lang);
        recognition.onstart = ()=>{
            isFinal.value = false;
        };
        (0, _vueDemi.watch)(lang, (lang2)=>{
            if (recognition && !isListening.value) recognition.lang = lang2;
        });
        recognition.onresult = (event)=>{
            const currentResult = event.results[event.resultIndex];
            const { transcript  } = currentResult[0];
            isFinal.value = currentResult.isFinal;
            result.value = transcript;
            error.value = void 0;
        };
        recognition.onerror = (event)=>{
            error.value = event;
        };
        recognition.onend = ()=>{
            isListening.value = false;
            recognition.lang = (0, _shared.toValue)(lang);
        };
        (0, _vueDemi.watch)(isListening, ()=>{
            if (isListening.value) recognition.start();
            else recognition.stop();
        });
    }
    (0, _shared.tryOnScopeDispose)(()=>{
        isListening.value = false;
    });
    return {
        isSupported,
        isListening,
        isFinal,
        recognition,
        result,
        error,
        toggle,
        start,
        stop
    };
}
function useSpeechSynthesis(text, options = {}) {
    const { pitch =1 , rate =1 , volume =1 , window: window1 = defaultWindow  } = options;
    const synth = window1 && window1.speechSynthesis;
    const isSupported = useSupported(()=>synth);
    const isPlaying = (0, _vueDemi.ref)(false);
    const status = (0, _vueDemi.ref)("init");
    const spokenText = (0, _shared.toRef)(text || "");
    const lang = (0, _shared.toRef)(options.lang || "en-US");
    const error = (0, _vueDemi.shallowRef)(void 0);
    const toggle = (value = !isPlaying.value)=>{
        isPlaying.value = value;
    };
    const bindEventsForUtterance = (utterance2)=>{
        utterance2.lang = (0, _shared.toValue)(lang);
        utterance2.voice = (0, _shared.toValue)(options.voice) || null;
        utterance2.pitch = (0, _shared.toValue)(pitch);
        utterance2.rate = (0, _shared.toValue)(rate);
        utterance2.volume = volume;
        utterance2.onstart = ()=>{
            isPlaying.value = true;
            status.value = "play";
        };
        utterance2.onpause = ()=>{
            isPlaying.value = false;
            status.value = "pause";
        };
        utterance2.onresume = ()=>{
            isPlaying.value = true;
            status.value = "play";
        };
        utterance2.onend = ()=>{
            isPlaying.value = false;
            status.value = "end";
        };
        utterance2.onerror = (event)=>{
            error.value = event;
        };
    };
    const utterance = (0, _vueDemi.computed)(()=>{
        isPlaying.value = false;
        status.value = "init";
        const newUtterance = new SpeechSynthesisUtterance(spokenText.value);
        bindEventsForUtterance(newUtterance);
        return newUtterance;
    });
    const speak = ()=>{
        synth.cancel();
        utterance && synth.speak(utterance.value);
    };
    const stop = ()=>{
        synth.cancel();
        isPlaying.value = false;
    };
    if (isSupported.value) {
        bindEventsForUtterance(utterance.value);
        (0, _vueDemi.watch)(lang, (lang2)=>{
            if (utterance.value && !isPlaying.value) utterance.value.lang = lang2;
        });
        if (options.voice) (0, _vueDemi.watch)(options.voice, ()=>{
            synth.cancel();
        });
        (0, _vueDemi.watch)(isPlaying, ()=>{
            if (isPlaying.value) synth.resume();
            else synth.pause();
        });
    }
    (0, _shared.tryOnScopeDispose)(()=>{
        isPlaying.value = false;
    });
    return {
        isSupported,
        isPlaying,
        status,
        utterance,
        error,
        stop,
        toggle,
        speak
    };
}
function useStepper(steps, initialStep) {
    const stepsRef = (0, _vueDemi.ref)(steps);
    const stepNames = (0, _vueDemi.computed)(()=>Array.isArray(stepsRef.value) ? stepsRef.value : Object.keys(stepsRef.value));
    const index = (0, _vueDemi.ref)(stepNames.value.indexOf(initialStep != null ? initialStep : stepNames.value[0]));
    const current = (0, _vueDemi.computed)(()=>at(index.value));
    const isFirst = (0, _vueDemi.computed)(()=>index.value === 0);
    const isLast = (0, _vueDemi.computed)(()=>index.value === stepNames.value.length - 1);
    const next = (0, _vueDemi.computed)(()=>stepNames.value[index.value + 1]);
    const previous = (0, _vueDemi.computed)(()=>stepNames.value[index.value - 1]);
    function at(index2) {
        if (Array.isArray(stepsRef.value)) return stepsRef.value[index2];
        return stepsRef.value[stepNames.value[index2]];
    }
    function get(step) {
        if (!stepNames.value.includes(step)) return;
        return at(stepNames.value.indexOf(step));
    }
    function goTo(step) {
        if (stepNames.value.includes(step)) index.value = stepNames.value.indexOf(step);
    }
    function goToNext() {
        if (isLast.value) return;
        index.value++;
    }
    function goToPrevious() {
        if (isFirst.value) return;
        index.value--;
    }
    function goBackTo(step) {
        if (isAfter(step)) goTo(step);
    }
    function isNext(step) {
        return stepNames.value.indexOf(step) === index.value + 1;
    }
    function isPrevious(step) {
        return stepNames.value.indexOf(step) === index.value - 1;
    }
    function isCurrent(step) {
        return stepNames.value.indexOf(step) === index.value;
    }
    function isBefore(step) {
        return index.value < stepNames.value.indexOf(step);
    }
    function isAfter(step) {
        return index.value > stepNames.value.indexOf(step);
    }
    return {
        steps: stepsRef,
        stepNames,
        index,
        current,
        next,
        previous,
        isFirst,
        isLast,
        at,
        get,
        goTo,
        goToNext,
        goToPrevious,
        goBackTo,
        isNext,
        isPrevious,
        isCurrent,
        isBefore,
        isAfter
    };
}
function useStorageAsync(key, initialValue, storage, options = {}) {
    var _a;
    const { flush ="pre" , deep =true , listenToStorageChanges =true , writeDefaults =true , mergeDefaults =false , shallow , window: window1 = defaultWindow , eventFilter , onError =(e)=>{
        console.error(e);
    }  } = options;
    const rawInit = (0, _shared.toValue)(initialValue);
    const type = guessSerializerType(rawInit);
    const data = (shallow ? (0, _vueDemi.shallowRef) : (0, _vueDemi.ref))(initialValue);
    const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];
    if (!storage) try {
        storage = getSSRHandler("getDefaultStorageAsync", ()=>{
            var _a2;
            return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;
        })();
    } catch (e) {
        onError(e);
    }
    async function read(event) {
        if (!storage || event && event.key !== key) return;
        try {
            const rawValue = event ? event.newValue : await storage.getItem(key);
            if (rawValue == null) {
                data.value = rawInit;
                if (writeDefaults && rawInit !== null) await storage.setItem(key, await serializer.write(rawInit));
            } else if (mergeDefaults) {
                const value = await serializer.read(rawValue);
                if (typeof mergeDefaults === "function") data.value = mergeDefaults(value, rawInit);
                else if (type === "object" && !Array.isArray(value)) data.value = {
                    ...rawInit,
                    ...value
                };
                else data.value = value;
            } else data.value = await serializer.read(rawValue);
        } catch (e) {
            onError(e);
        }
    }
    read();
    if (window1 && listenToStorageChanges) useEventListener(window1, "storage", (e)=>Promise.resolve().then(()=>read(e)));
    if (storage) (0, _shared.watchWithFilter)(data, async ()=>{
        try {
            if (data.value == null) await storage.removeItem(key);
            else await storage.setItem(key, await serializer.write(data.value));
        } catch (e) {
            onError(e);
        }
    }, {
        flush,
        deep,
        eventFilter
    });
    return data;
}
let _id = 0;
function useStyleTag(css, options = {}) {
    const isLoaded = (0, _vueDemi.ref)(false);
    const { document: document1 = defaultDocument , immediate =true , manual =false , id =`vueuse_styletag_${++_id}`  } = options;
    const cssRef = (0, _vueDemi.ref)(css);
    let stop = ()=>{};
    const load = ()=>{
        if (!document1) return;
        const el = document1.getElementById(id) || document1.createElement("style");
        if (!el.isConnected) {
            el.id = id;
            if (options.media) el.media = options.media;
            document1.head.appendChild(el);
        }
        if (isLoaded.value) return;
        stop = (0, _vueDemi.watch)(cssRef, (value)=>{
            el.textContent = value;
        }, {
            immediate: true
        });
        isLoaded.value = true;
    };
    const unload = ()=>{
        if (!document1 || !isLoaded.value) return;
        stop();
        document1.head.removeChild(document1.getElementById(id));
        isLoaded.value = false;
    };
    if (immediate && !manual) (0, _shared.tryOnMounted)(load);
    if (!manual) (0, _shared.tryOnScopeDispose)(unload);
    return {
        id,
        css: cssRef,
        unload,
        load,
        isLoaded: (0, _vueDemi.readonly)(isLoaded)
    };
}
function useSwipe(target, options = {}) {
    const { threshold =50 , onSwipe , onSwipeEnd , onSwipeStart , passive =true , window: window1 = defaultWindow  } = options;
    const coordsStart = (0, _vueDemi.reactive)({
        x: 0,
        y: 0
    });
    const coordsEnd = (0, _vueDemi.reactive)({
        x: 0,
        y: 0
    });
    const diffX = (0, _vueDemi.computed)(()=>coordsStart.x - coordsEnd.x);
    const diffY = (0, _vueDemi.computed)(()=>coordsStart.y - coordsEnd.y);
    const { max , abs  } = Math;
    const isThresholdExceeded = (0, _vueDemi.computed)(()=>max(abs(diffX.value), abs(diffY.value)) >= threshold);
    const isSwiping = (0, _vueDemi.ref)(false);
    const direction = (0, _vueDemi.computed)(()=>{
        if (!isThresholdExceeded.value) return "none";
        if (abs(diffX.value) > abs(diffY.value)) return diffX.value > 0 ? "left" : "right";
        else return diffY.value > 0 ? "up" : "down";
    });
    const getTouchEventCoords = (e)=>[
            e.touches[0].clientX,
            e.touches[0].clientY
        ];
    const updateCoordsStart = (x, y)=>{
        coordsStart.x = x;
        coordsStart.y = y;
    };
    const updateCoordsEnd = (x, y)=>{
        coordsEnd.x = x;
        coordsEnd.y = y;
    };
    let listenerOptions;
    const isPassiveEventSupported = checkPassiveEventSupport(window1 == null ? void 0 : window1.document);
    if (!passive) listenerOptions = isPassiveEventSupported ? {
        passive: false,
        capture: true
    } : {
        capture: true
    };
    else listenerOptions = isPassiveEventSupported ? {
        passive: true
    } : {
        capture: false
    };
    const onTouchEnd = (e)=>{
        if (isSwiping.value) onSwipeEnd == null || onSwipeEnd(e, direction.value);
        isSwiping.value = false;
    };
    const stops = [
        useEventListener(target, "touchstart", (e)=>{
            if (e.touches.length !== 1) return;
            if (listenerOptions.capture && !listenerOptions.passive) e.preventDefault();
            const [x, y] = getTouchEventCoords(e);
            updateCoordsStart(x, y);
            updateCoordsEnd(x, y);
            onSwipeStart == null || onSwipeStart(e);
        }, listenerOptions),
        useEventListener(target, "touchmove", (e)=>{
            if (e.touches.length !== 1) return;
            const [x, y] = getTouchEventCoords(e);
            updateCoordsEnd(x, y);
            if (!isSwiping.value && isThresholdExceeded.value) isSwiping.value = true;
            if (isSwiping.value) onSwipe == null || onSwipe(e);
        }, listenerOptions),
        useEventListener(target, [
            "touchend",
            "touchcancel"
        ], onTouchEnd, listenerOptions)
    ];
    const stop = ()=>stops.forEach((s)=>s());
    return {
        isPassiveEventSupported,
        isSwiping,
        direction,
        coordsStart,
        coordsEnd,
        lengthX: diffX,
        lengthY: diffY,
        stop
    };
}
function checkPassiveEventSupport(document1) {
    if (!document1) return false;
    let supportsPassive = false;
    const optionsBlock = {
        get passive () {
            supportsPassive = true;
            return false;
        }
    };
    document1.addEventListener("x", (0, _shared.noop), optionsBlock);
    document1.removeEventListener("x", (0, _shared.noop));
    return supportsPassive;
}
function useTemplateRefsList() {
    const refs = (0, _vueDemi.ref)([]);
    refs.value.set = (el)=>{
        if (el) refs.value.push(el);
    };
    (0, _vueDemi.onBeforeUpdate)(()=>{
        refs.value.length = 0;
    });
    return refs;
}
function useTextDirection(options = {}) {
    const { document: document1 = defaultDocument , selector ="html" , observe =false , initialValue ="ltr"  } = options;
    function getValue() {
        var _a, _b;
        return (_b = (_a = document1 == null ? void 0 : document1.querySelector(selector)) == null ? void 0 : _a.getAttribute("dir")) != null ? _b : initialValue;
    }
    const dir = (0, _vueDemi.ref)(getValue());
    (0, _shared.tryOnMounted)(()=>dir.value = getValue());
    if (observe && document1) useMutationObserver(document1.querySelector(selector), ()=>dir.value = getValue(), {
        attributes: true
    });
    return (0, _vueDemi.computed)({
        get () {
            return dir.value;
        },
        set (v) {
            var _a, _b;
            dir.value = v;
            if (!document1) return;
            if (dir.value) (_a = document1.querySelector(selector)) == null || _a.setAttribute("dir", dir.value);
            else (_b = document1.querySelector(selector)) == null || _b.removeAttribute("dir");
        }
    });
}
function getRangesFromSelection(selection) {
    var _a;
    const rangeCount = (_a = selection.rangeCount) != null ? _a : 0;
    return Array.from({
        length: rangeCount
    }, (_, i)=>selection.getRangeAt(i));
}
function useTextSelection(options = {}) {
    const { window: window1 = defaultWindow  } = options;
    const selection = (0, _vueDemi.ref)(null);
    const text = (0, _vueDemi.computed)(()=>{
        var _a, _b;
        return (_b = (_a = selection.value) == null ? void 0 : _a.toString()) != null ? _b : "";
    });
    const ranges = (0, _vueDemi.computed)(()=>selection.value ? getRangesFromSelection(selection.value) : []);
    const rects = (0, _vueDemi.computed)(()=>ranges.value.map((range)=>range.getBoundingClientRect()));
    function onSelectionChange() {
        selection.value = null;
        if (window1) selection.value = window1.getSelection();
    }
    if (window1) useEventListener(window1.document, "selectionchange", onSelectionChange);
    return {
        text,
        rects,
        ranges,
        selection
    };
}
function useTextareaAutosize(options) {
    var _a;
    const textarea = (0, _vueDemi.ref)(options == null ? void 0 : options.element);
    const input = (0, _vueDemi.ref)(options == null ? void 0 : options.input);
    const styleProp = (_a = options == null ? void 0 : options.styleProp) != null ? _a : "height";
    const textareaScrollHeight = (0, _vueDemi.ref)(1);
    function triggerResize() {
        var _a2;
        if (!textarea.value) return;
        let height = "";
        textarea.value.style[styleProp] = "1px";
        textareaScrollHeight.value = (_a2 = textarea.value) == null ? void 0 : _a2.scrollHeight;
        if (options == null ? void 0 : options.styleTarget) (0, _shared.toValue)(options.styleTarget).style[styleProp] = `${textareaScrollHeight.value}px`;
        else height = `${textareaScrollHeight.value}px`;
        textarea.value.style[styleProp] = height;
    }
    (0, _vueDemi.watch)([
        input,
        textarea
    ], ()=>(0, _vueDemi.nextTick)(triggerResize), {
        immediate: true
    });
    (0, _vueDemi.watch)(textareaScrollHeight, ()=>{
        var _a2;
        return (_a2 = options == null ? void 0 : options.onResize) == null ? void 0 : _a2.call(options);
    });
    useResizeObserver(textarea, ()=>triggerResize());
    if (options == null ? void 0 : options.watch) (0, _vueDemi.watch)(options.watch, triggerResize, {
        immediate: true,
        deep: true
    });
    return {
        textarea,
        input,
        triggerResize
    };
}
function useThrottledRefHistory(source, options = {}) {
    const { throttle =200 , trailing =true  } = options;
    const filter = (0, _shared.throttleFilter)(throttle, trailing);
    const history = useRefHistory(source, {
        ...options,
        eventFilter: filter
    });
    return {
        ...history
    };
}
const DEFAULT_UNITS = [
    {
        max: 6e4,
        value: 1e3,
        name: "second"
    },
    {
        max: 276e4,
        value: 6e4,
        name: "minute"
    },
    {
        max: 72e6,
        value: 36e5,
        name: "hour"
    },
    {
        max: 5184e5,
        value: 864e5,
        name: "day"
    },
    {
        max: 24192e5,
        value: 6048e5,
        name: "week"
    },
    {
        max: 28512e6,
        value: 2592e6,
        name: "month"
    },
    {
        max: Number.POSITIVE_INFINITY,
        value: 31536e6,
        name: "year"
    }
];
const DEFAULT_MESSAGES = {
    justNow: "just now",
    past: (n)=>n.match(/\d/) ? `${n} ago` : n,
    future: (n)=>n.match(/\d/) ? `in ${n}` : n,
    month: (n, past)=>n === 1 ? past ? "last month" : "next month" : `${n} month${n > 1 ? "s" : ""}`,
    year: (n, past)=>n === 1 ? past ? "last year" : "next year" : `${n} year${n > 1 ? "s" : ""}`,
    day: (n, past)=>n === 1 ? past ? "yesterday" : "tomorrow" : `${n} day${n > 1 ? "s" : ""}`,
    week: (n, past)=>n === 1 ? past ? "last week" : "next week" : `${n} week${n > 1 ? "s" : ""}`,
    hour: (n)=>`${n} hour${n > 1 ? "s" : ""}`,
    minute: (n)=>`${n} minute${n > 1 ? "s" : ""}`,
    second: (n)=>`${n} second${n > 1 ? "s" : ""}`,
    invalid: ""
};
function DEFAULT_FORMATTER(date) {
    return date.toISOString().slice(0, 10);
}
function useTimeAgo(time, options = {}) {
    const { controls: exposeControls = false , updateInterval =3e4  } = options;
    const { now , ...controls } = useNow({
        interval: updateInterval,
        controls: true
    });
    const timeAgo = (0, _vueDemi.computed)(()=>formatTimeAgo(new Date((0, _shared.toValue)(time)), options, (0, _shared.toValue)(now)));
    if (exposeControls) return {
        timeAgo,
        ...controls
    };
    else return timeAgo;
}
function formatTimeAgo(from, options = {}, now = Date.now()) {
    var _a;
    const { max , messages =DEFAULT_MESSAGES , fullDateFormatter =DEFAULT_FORMATTER , units =DEFAULT_UNITS , showSecond =false , rounding ="round"  } = options;
    const roundFn = typeof rounding === "number" ? (n)=>+n.toFixed(rounding) : Math[rounding];
    const diff = +now - +from;
    const absDiff = Math.abs(diff);
    function getValue(diff2, unit) {
        return roundFn(Math.abs(diff2) / unit.value);
    }
    function format(diff2, unit) {
        const val = getValue(diff2, unit);
        const past = diff2 > 0;
        const str = applyFormat(unit.name, val, past);
        return applyFormat(past ? "past" : "future", str, past);
    }
    function applyFormat(name, val, isPast) {
        const formatter = messages[name];
        if (typeof formatter === "function") return formatter(val, isPast);
        return formatter.replace("{0}", val.toString());
    }
    if (absDiff < 6e4 && !showSecond) return messages.justNow;
    if (typeof max === "number" && absDiff > max) return fullDateFormatter(new Date(from));
    if (typeof max === "string") {
        const unitMax = (_a = units.find((i)=>i.name === max)) == null ? void 0 : _a.max;
        if (unitMax && absDiff > unitMax) return fullDateFormatter(new Date(from));
    }
    for (const [idx, unit] of units.entries()){
        const val = getValue(diff, unit);
        if (val <= 0 && units[idx - 1]) return format(diff, units[idx - 1]);
        if (absDiff < unit.max) return format(diff, unit);
    }
    return messages.invalid;
}
function useTimeoutPoll(fn, interval, timeoutPollOptions) {
    const { start  } = (0, _shared.useTimeoutFn)(loop, interval, {
        immediate: false
    });
    const isActive = (0, _vueDemi.ref)(false);
    async function loop() {
        if (!isActive.value) return;
        await fn();
        start();
    }
    function resume() {
        if (!isActive.value) {
            isActive.value = true;
            loop();
        }
    }
    function pause() {
        isActive.value = false;
    }
    if (timeoutPollOptions == null ? void 0 : timeoutPollOptions.immediate) resume();
    (0, _shared.tryOnScopeDispose)(pause);
    return {
        isActive,
        pause,
        resume
    };
}
function useTimestamp(options = {}) {
    const { controls: exposeControls = false , offset =0 , immediate =true , interval ="requestAnimationFrame" , callback  } = options;
    const ts = (0, _vueDemi.ref)((0, _shared.timestamp)() + offset);
    const update = ()=>ts.value = (0, _shared.timestamp)() + offset;
    const cb = callback ? ()=>{
        update();
        callback(ts.value);
    } : update;
    const controls = interval === "requestAnimationFrame" ? useRafFn(cb, {
        immediate
    }) : (0, _shared.useIntervalFn)(cb, interval, {
        immediate
    });
    if (exposeControls) return {
        timestamp: ts,
        ...controls
    };
    else return ts;
}
function useTitle(newTitle = null, options = {}) {
    var _a, _b, _c;
    const { document: document1 = defaultDocument , restoreOnUnmount =(t)=>t  } = options;
    const originalTitle = (_a = document1 == null ? void 0 : document1.title) != null ? _a : "";
    const title = (0, _shared.toRef)((_b = newTitle != null ? newTitle : document1 == null ? void 0 : document1.title) != null ? _b : null);
    const isReadonly = newTitle && typeof newTitle === "function";
    function format(t) {
        if (!("titleTemplate" in options)) return t;
        const template = options.titleTemplate || "%s";
        return typeof template === "function" ? template(t) : (0, _shared.toValue)(template).replace(/%s/g, t);
    }
    (0, _vueDemi.watch)(title, (t, o)=>{
        if (t !== o && document1) document1.title = format(typeof t === "string" ? t : "");
    }, {
        immediate: true
    });
    if (options.observe && !options.titleTemplate && document1 && !isReadonly) useMutationObserver((_c = document1.head) == null ? void 0 : _c.querySelector("title"), ()=>{
        if (document1 && document1.title !== title.value) title.value = format(document1.title);
    }, {
        childList: true
    });
    (0, _shared.tryOnBeforeUnmount)(()=>{
        if (restoreOnUnmount) {
            const restoredTitle = restoreOnUnmount(originalTitle, title.value || "");
            if (restoredTitle != null && document1) document1.title = restoredTitle;
        }
    });
    return title;
}
const _TransitionPresets = {
    easeInSine: [
        0.12,
        0,
        0.39,
        0
    ],
    easeOutSine: [
        0.61,
        1,
        0.88,
        1
    ],
    easeInOutSine: [
        0.37,
        0,
        0.63,
        1
    ],
    easeInQuad: [
        0.11,
        0,
        0.5,
        0
    ],
    easeOutQuad: [
        0.5,
        1,
        0.89,
        1
    ],
    easeInOutQuad: [
        0.45,
        0,
        0.55,
        1
    ],
    easeInCubic: [
        0.32,
        0,
        0.67,
        0
    ],
    easeOutCubic: [
        0.33,
        1,
        0.68,
        1
    ],
    easeInOutCubic: [
        0.65,
        0,
        0.35,
        1
    ],
    easeInQuart: [
        0.5,
        0,
        0.75,
        0
    ],
    easeOutQuart: [
        0.25,
        1,
        0.5,
        1
    ],
    easeInOutQuart: [
        0.76,
        0,
        0.24,
        1
    ],
    easeInQuint: [
        0.64,
        0,
        0.78,
        0
    ],
    easeOutQuint: [
        0.22,
        1,
        0.36,
        1
    ],
    easeInOutQuint: [
        0.83,
        0,
        0.17,
        1
    ],
    easeInExpo: [
        0.7,
        0,
        0.84,
        0
    ],
    easeOutExpo: [
        0.16,
        1,
        0.3,
        1
    ],
    easeInOutExpo: [
        0.87,
        0,
        0.13,
        1
    ],
    easeInCirc: [
        0.55,
        0,
        1,
        0.45
    ],
    easeOutCirc: [
        0,
        0.55,
        0.45,
        1
    ],
    easeInOutCirc: [
        0.85,
        0,
        0.15,
        1
    ],
    easeInBack: [
        0.36,
        0,
        0.66,
        -0.56
    ],
    easeOutBack: [
        0.34,
        1.56,
        0.64,
        1
    ],
    easeInOutBack: [
        0.68,
        -0.6,
        0.32,
        1.6
    ]
};
const TransitionPresets = /* @__PURE__ */ Object.assign({}, {
    linear: (0, _shared.identity)
}, _TransitionPresets);
function createEasingFunction([p0, p1, p2, p3]) {
    const a = (a1, a2)=>1 - 3 * a2 + 3 * a1;
    const b = (a1, a2)=>3 * a2 - 6 * a1;
    const c = (a1)=>3 * a1;
    const calcBezier = (t, a1, a2)=>((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;
    const getSlope = (t, a1, a2)=>3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1);
    const getTforX = (x)=>{
        let aGuessT = x;
        for(let i = 0; i < 4; ++i){
            const currentSlope = getSlope(aGuessT, p0, p2);
            if (currentSlope === 0) return aGuessT;
            const currentX = calcBezier(aGuessT, p0, p2) - x;
            aGuessT -= currentX / currentSlope;
        }
        return aGuessT;
    };
    return (x)=>p0 === p1 && p2 === p3 ? x : calcBezier(getTforX(x), p1, p3);
}
function lerp(a, b, alpha) {
    return a + alpha * (b - a);
}
function toVec(t) {
    return (typeof t === "number" ? [
        t
    ] : t) || [];
}
function executeTransition(source, from, to, options = {}) {
    var _a, _b;
    const fromVal = (0, _shared.toValue)(from);
    const toVal = (0, _shared.toValue)(to);
    const v1 = toVec(fromVal);
    const v2 = toVec(toVal);
    const duration = (_a = (0, _shared.toValue)(options.duration)) != null ? _a : 1e3;
    const startedAt = Date.now();
    const endAt = Date.now() + duration;
    const trans = typeof options.transition === "function" ? options.transition : (_b = (0, _shared.toValue)(options.transition)) != null ? _b : (0, _shared.identity);
    const ease = typeof trans === "function" ? trans : createEasingFunction(trans);
    return new Promise((resolve)=>{
        source.value = fromVal;
        const tick = ()=>{
            var _a2;
            if ((_a2 = options.abort) == null ? void 0 : _a2.call(options)) {
                resolve();
                return;
            }
            const now = Date.now();
            const alpha = ease((now - startedAt) / duration);
            const arr = toVec(source.value).map((n, i)=>lerp(v1[i], v2[i], alpha));
            if (Array.isArray(source.value)) source.value = arr.map((n, i)=>{
                var _a3, _b2;
                return lerp((_a3 = v1[i]) != null ? _a3 : 0, (_b2 = v2[i]) != null ? _b2 : 0, alpha);
            });
            else if (typeof source.value === "number") source.value = arr[0];
            if (now < endAt) requestAnimationFrame(tick);
            else {
                source.value = toVal;
                resolve();
            }
        };
        tick();
    });
}
function useTransition(source, options = {}) {
    let currentId = 0;
    const sourceVal = ()=>{
        const v = (0, _shared.toValue)(source);
        return typeof v === "number" ? v : v.map((0, _shared.toValue));
    };
    const outputRef = (0, _vueDemi.ref)(sourceVal());
    (0, _vueDemi.watch)(sourceVal, async (to)=>{
        var _a, _b;
        if ((0, _shared.toValue)(options.disabled)) return;
        const id = ++currentId;
        if (options.delay) await (0, _shared.promiseTimeout)((0, _shared.toValue)(options.delay));
        if (id !== currentId) return;
        const toVal = Array.isArray(to) ? to.map((0, _shared.toValue)) : (0, _shared.toValue)(to);
        (_a = options.onStarted) == null || _a.call(options);
        await executeTransition(outputRef, outputRef.value, toVal, {
            ...options,
            abort: ()=>{
                var _a2;
                return id !== currentId || ((_a2 = options.abort) == null ? void 0 : _a2.call(options));
            }
        });
        (_b = options.onFinished) == null || _b.call(options);
    }, {
        deep: true
    });
    (0, _vueDemi.watch)(()=>(0, _shared.toValue)(options.disabled), (disabled)=>{
        if (disabled) {
            currentId++;
            outputRef.value = sourceVal();
        }
    });
    (0, _shared.tryOnScopeDispose)(()=>{
        currentId++;
    });
    return (0, _vueDemi.computed)(()=>(0, _shared.toValue)(options.disabled) ? sourceVal() : outputRef.value);
}
function useUrlSearchParams(mode = "history", options = {}) {
    const { initialValue ={} , removeNullishValues =true , removeFalsyValues =false , write: enableWrite = true , window: window1 = defaultWindow  } = options;
    if (!window1) return (0, _vueDemi.reactive)(initialValue);
    const state = (0, _vueDemi.reactive)({});
    function getRawParams() {
        if (mode === "history") return window1.location.search || "";
        else if (mode === "hash") {
            const hash = window1.location.hash || "";
            const index = hash.indexOf("?");
            return index > 0 ? hash.slice(index) : "";
        } else return (window1.location.hash || "").replace(/^#/, "");
    }
    function constructQuery(params) {
        const stringified = params.toString();
        if (mode === "history") return `${stringified ? `?${stringified}` : ""}${window1.location.hash || ""}`;
        if (mode === "hash-params") return `${window1.location.search || ""}${stringified ? `#${stringified}` : ""}`;
        const hash = window1.location.hash || "#";
        const index = hash.indexOf("?");
        if (index > 0) return `${hash.slice(0, index)}${stringified ? `?${stringified}` : ""}`;
        return `${hash}${stringified ? `?${stringified}` : ""}`;
    }
    function read() {
        return new URLSearchParams(getRawParams());
    }
    function updateState(params) {
        const unusedKeys = new Set(Object.keys(state));
        for (const key of params.keys()){
            const paramsForKey = params.getAll(key);
            state[key] = paramsForKey.length > 1 ? paramsForKey : params.get(key) || "";
            unusedKeys.delete(key);
        }
        Array.from(unusedKeys).forEach((key)=>delete state[key]);
    }
    const { pause , resume  } = (0, _shared.pausableWatch)(state, ()=>{
        const params = new URLSearchParams("");
        Object.keys(state).forEach((key)=>{
            const mapEntry = state[key];
            if (Array.isArray(mapEntry)) mapEntry.forEach((value)=>params.append(key, value));
            else if (removeNullishValues && mapEntry == null) params.delete(key);
            else if (removeFalsyValues && !mapEntry) params.delete(key);
            else params.set(key, mapEntry);
        });
        write(params);
    }, {
        deep: true
    });
    function write(params, shouldUpdate) {
        pause();
        if (shouldUpdate) updateState(params);
        window1.history.replaceState(window1.history.state, window1.document.title, window1.location.pathname + constructQuery(params));
        resume();
    }
    function onChanged() {
        if (!enableWrite) return;
        write(read(), true);
    }
    useEventListener(window1, "popstate", onChanged, false);
    if (mode !== "history") useEventListener(window1, "hashchange", onChanged, false);
    const initial = read();
    if (initial.keys().next().value) updateState(initial);
    else Object.assign(state, initialValue);
    return state;
}
function useUserMedia(options = {}) {
    var _a, _b;
    const enabled = (0, _vueDemi.ref)((_a = options.enabled) != null ? _a : false);
    const autoSwitch = (0, _vueDemi.ref)((_b = options.autoSwitch) != null ? _b : true);
    const constraints = (0, _vueDemi.ref)(options.constraints);
    const { navigator =defaultNavigator  } = options;
    const isSupported = useSupported(()=>{
        var _a2;
        return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getUserMedia;
    });
    const stream = (0, _vueDemi.shallowRef)();
    function getDeviceOptions(type) {
        switch(type){
            case "video":
                if (constraints.value) return constraints.value.video || false;
                break;
            case "audio":
                if (constraints.value) return constraints.value.audio || false;
                break;
        }
    }
    async function _start() {
        if (!isSupported.value || stream.value) return;
        stream.value = await navigator.mediaDevices.getUserMedia({
            video: getDeviceOptions("video"),
            audio: getDeviceOptions("audio")
        });
        return stream.value;
    }
    function _stop() {
        var _a2;
        (_a2 = stream.value) == null || _a2.getTracks().forEach((t)=>t.stop());
        stream.value = void 0;
    }
    function stop() {
        _stop();
        enabled.value = false;
    }
    async function start() {
        await _start();
        if (stream.value) enabled.value = true;
        return stream.value;
    }
    async function restart() {
        _stop();
        return await start();
    }
    (0, _vueDemi.watch)(enabled, (v)=>{
        if (v) _start();
        else _stop();
    }, {
        immediate: true
    });
    (0, _vueDemi.watch)(constraints, ()=>{
        if (autoSwitch.value && stream.value) restart();
    }, {
        immediate: true
    });
    (0, _shared.tryOnScopeDispose)(()=>{
        stop();
    });
    return {
        isSupported,
        stream,
        start,
        stop,
        restart,
        constraints,
        enabled,
        autoSwitch
    };
}
function useVModel(props, key, emit, options = {}) {
    var _a, _b, _c, _d, _e;
    const { clone =false , passive =false , eventName , deep =false , defaultValue , shouldEmit  } = options;
    const vm = (0, _vueDemi.getCurrentInstance)();
    const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));
    let event = eventName;
    if (!key) {
        if (0, _vueDemi.isVue2) {
            const modelOptions = (_e = (_d = vm == null ? void 0 : vm.proxy) == null ? void 0 : _d.$options) == null ? void 0 : _e.model;
            key = (modelOptions == null ? void 0 : modelOptions.value) || "value";
            if (!eventName) event = (modelOptions == null ? void 0 : modelOptions.event) || "input";
        } else key = "modelValue";
    }
    event = event || `update:${key.toString()}`;
    const cloneFn = (val)=>!clone ? val : typeof clone === "function" ? clone(val) : cloneFnJSON(val);
    const getValue = ()=>(0, _shared.isDef)(props[key]) ? cloneFn(props[key]) : defaultValue;
    const triggerEmit = (value)=>{
        if (shouldEmit) {
            if (shouldEmit(value)) _emit(event, value);
        } else _emit(event, value);
    };
    if (passive) {
        const initialValue = getValue();
        const proxy = (0, _vueDemi.ref)(initialValue);
        let isUpdating = false;
        (0, _vueDemi.watch)(()=>props[key], (v)=>{
            if (!isUpdating) {
                isUpdating = true;
                proxy.value = cloneFn(v);
                (0, _vueDemi.nextTick)(()=>isUpdating = false);
            }
        });
        (0, _vueDemi.watch)(proxy, (v)=>{
            if (!isUpdating && (v !== props[key] || deep)) triggerEmit(v);
        }, {
            deep
        });
        return proxy;
    } else return (0, _vueDemi.computed)({
        get () {
            return getValue();
        },
        set (value) {
            triggerEmit(value);
        }
    });
}
function useVModels(props, emit, options = {}) {
    const ret = {};
    for(const key in props)ret[key] = useVModel(props, key, emit, options);
    return ret;
}
function useVibrate(options) {
    const { pattern =[] , interval =0 , navigator =defaultNavigator  } = options || {};
    const isSupported = useSupported(()=>typeof navigator !== "undefined" && "vibrate" in navigator);
    const patternRef = (0, _shared.toRef)(pattern);
    let intervalControls;
    const vibrate = (pattern2 = patternRef.value)=>{
        if (isSupported.value) navigator.vibrate(pattern2);
    };
    const stop = ()=>{
        if (isSupported.value) navigator.vibrate(0);
        intervalControls == null || intervalControls.pause();
    };
    if (interval > 0) intervalControls = (0, _shared.useIntervalFn)(vibrate, interval, {
        immediate: false,
        immediateCallback: false
    });
    return {
        isSupported,
        pattern,
        intervalControls,
        vibrate,
        stop
    };
}
function useVirtualList(list, options) {
    const { containerStyle , wrapperProps , scrollTo: scrollTo1 , calculateRange , currentList , containerRef  } = "itemHeight" in options ? useVerticalVirtualList(options, list) : useHorizontalVirtualList(options, list);
    return {
        list: currentList,
        scrollTo: scrollTo1,
        containerProps: {
            ref: containerRef,
            onScroll: ()=>{
                calculateRange();
            },
            style: containerStyle
        },
        wrapperProps
    };
}
function useVirtualListResources(list) {
    const containerRef = (0, _vueDemi.ref)(null);
    const size = useElementSize(containerRef);
    const currentList = (0, _vueDemi.ref)([]);
    const source = (0, _vueDemi.shallowRef)(list);
    const state = (0, _vueDemi.ref)({
        start: 0,
        end: 10
    });
    return {
        state,
        source,
        currentList,
        size,
        containerRef
    };
}
function createGetViewCapacity(state, source, itemSize) {
    return (containerSize)=>{
        if (typeof itemSize === "number") return Math.ceil(containerSize / itemSize);
        const { start =0  } = state.value;
        let sum = 0;
        let capacity = 0;
        for(let i = start; i < source.value.length; i++){
            const size = itemSize(i);
            sum += size;
            capacity = i;
            if (sum > containerSize) break;
        }
        return capacity - start;
    };
}
function createGetOffset(source, itemSize) {
    return (scrollDirection)=>{
        if (typeof itemSize === "number") return Math.floor(scrollDirection / itemSize) + 1;
        let sum = 0;
        let offset = 0;
        for(let i = 0; i < source.value.length; i++){
            const size = itemSize(i);
            sum += size;
            if (sum >= scrollDirection) {
                offset = i;
                break;
            }
        }
        return offset + 1;
    };
}
function createCalculateRange(type, overscan, getOffset, getViewCapacity, { containerRef , state , currentList , source  }) {
    return ()=>{
        const element = containerRef.value;
        if (element) {
            const offset = getOffset(type === "vertical" ? element.scrollTop : element.scrollLeft);
            const viewCapacity = getViewCapacity(type === "vertical" ? element.clientHeight : element.clientWidth);
            const from = offset - overscan;
            const to = offset + viewCapacity + overscan;
            state.value = {
                start: from < 0 ? 0 : from,
                end: to > source.value.length ? source.value.length : to
            };
            currentList.value = source.value.slice(state.value.start, state.value.end).map((ele, index)=>({
                    data: ele,
                    index: index + state.value.start
                }));
        }
    };
}
function createGetDistance(itemSize, source) {
    return (index)=>{
        if (typeof itemSize === "number") {
            const size2 = index * itemSize;
            return size2;
        }
        const size = source.value.slice(0, index).reduce((sum, _, i)=>sum + itemSize(i), 0);
        return size;
    };
}
function useWatchForSizes(size, list, containerRef, calculateRange) {
    (0, _vueDemi.watch)([
        size.width,
        size.height,
        list,
        containerRef
    ], ()=>{
        calculateRange();
    });
}
function createComputedTotalSize(itemSize, source) {
    return (0, _vueDemi.computed)(()=>{
        if (typeof itemSize === "number") return source.value.length * itemSize;
        return source.value.reduce((sum, _, index)=>sum + itemSize(index), 0);
    });
}
const scrollToDictionaryForElementScrollKey = {
    horizontal: "scrollLeft",
    vertical: "scrollTop"
};
function createScrollTo(type, calculateRange, getDistance, containerRef) {
    return (index)=>{
        if (containerRef.value) {
            containerRef.value[scrollToDictionaryForElementScrollKey[type]] = getDistance(index);
            calculateRange();
        }
    };
}
function useHorizontalVirtualList(options, list) {
    const resources = useVirtualListResources(list);
    const { state , source , currentList , size , containerRef  } = resources;
    const containerStyle = {
        overflowX: "auto"
    };
    const { itemWidth , overscan =5  } = options;
    const getViewCapacity = createGetViewCapacity(state, source, itemWidth);
    const getOffset = createGetOffset(source, itemWidth);
    const calculateRange = createCalculateRange("horizontal", overscan, getOffset, getViewCapacity, resources);
    const getDistanceLeft = createGetDistance(itemWidth, source);
    const offsetLeft = (0, _vueDemi.computed)(()=>getDistanceLeft(state.value.start));
    const totalWidth = createComputedTotalSize(itemWidth, source);
    useWatchForSizes(size, list, containerRef, calculateRange);
    const scrollTo1 = createScrollTo("horizontal", calculateRange, getDistanceLeft, containerRef);
    const wrapperProps = (0, _vueDemi.computed)(()=>{
        return {
            style: {
                height: "100%",
                width: `${totalWidth.value - offsetLeft.value}px`,
                marginLeft: `${offsetLeft.value}px`,
                display: "flex"
            }
        };
    });
    return {
        scrollTo: scrollTo1,
        calculateRange,
        wrapperProps,
        containerStyle,
        currentList,
        containerRef
    };
}
function useVerticalVirtualList(options, list) {
    const resources = useVirtualListResources(list);
    const { state , source , currentList , size , containerRef  } = resources;
    const containerStyle = {
        overflowY: "auto"
    };
    const { itemHeight , overscan =5  } = options;
    const getViewCapacity = createGetViewCapacity(state, source, itemHeight);
    const getOffset = createGetOffset(source, itemHeight);
    const calculateRange = createCalculateRange("vertical", overscan, getOffset, getViewCapacity, resources);
    const getDistanceTop = createGetDistance(itemHeight, source);
    const offsetTop = (0, _vueDemi.computed)(()=>getDistanceTop(state.value.start));
    const totalHeight = createComputedTotalSize(itemHeight, source);
    useWatchForSizes(size, list, containerRef, calculateRange);
    const scrollTo1 = createScrollTo("vertical", calculateRange, getDistanceTop, containerRef);
    const wrapperProps = (0, _vueDemi.computed)(()=>{
        return {
            style: {
                width: "100%",
                height: `${totalHeight.value - offsetTop.value}px`,
                marginTop: `${offsetTop.value}px`
            }
        };
    });
    return {
        calculateRange,
        scrollTo: scrollTo1,
        containerStyle,
        wrapperProps,
        currentList,
        containerRef
    };
}
function useWakeLock(options = {}) {
    const { navigator =defaultNavigator , document: document1 = defaultDocument  } = options;
    let wakeLock;
    const isSupported = useSupported(()=>navigator && "wakeLock" in navigator);
    const isActive = (0, _vueDemi.ref)(false);
    async function onVisibilityChange() {
        if (!isSupported.value || !wakeLock) return;
        if (document1 && document1.visibilityState === "visible") wakeLock = await navigator.wakeLock.request("screen");
        isActive.value = !wakeLock.released;
    }
    if (document1) useEventListener(document1, "visibilitychange", onVisibilityChange, {
        passive: true
    });
    async function request(type) {
        if (!isSupported.value) return;
        wakeLock = await navigator.wakeLock.request(type);
        isActive.value = !wakeLock.released;
    }
    async function release() {
        if (!isSupported.value || !wakeLock) return;
        await wakeLock.release();
        isActive.value = !wakeLock.released;
        wakeLock = null;
    }
    return {
        isSupported,
        isActive,
        request,
        release
    };
}
function useWebNotification(options = {}) {
    const { window: window1 = defaultWindow , requestPermissions: _requestForPermissions = true  } = options;
    const defaultWebNotificationOptions = options;
    const isSupported = useSupported(()=>{
        if (!window1 || !("Notification" in window1)) return false;
        try {
            new Notification("");
        } catch (e) {
            return false;
        }
        return true;
    });
    const permissionGranted = (0, _vueDemi.ref)(isSupported.value && "permission" in Notification && Notification.permission === "granted");
    const notification = (0, _vueDemi.ref)(null);
    const ensurePermissions = async ()=>{
        if (!isSupported.value) return;
        if (!permissionGranted.value && Notification.permission !== "denied") {
            const result = await Notification.requestPermission();
            if (result === "granted") permissionGranted.value = true;
        }
        return permissionGranted.value;
    };
    const { on: onClick , trigger: clickTrigger  } = (0, _shared.createEventHook)();
    const { on: onShow , trigger: showTrigger  } = (0, _shared.createEventHook)();
    const { on: onError , trigger: errorTrigger  } = (0, _shared.createEventHook)();
    const { on: onClose , trigger: closeTrigger  } = (0, _shared.createEventHook)();
    const show = async (overrides)=>{
        if (!isSupported.value || !permissionGranted.value) return;
        const options2 = Object.assign({}, defaultWebNotificationOptions, overrides);
        notification.value = new Notification(options2.title || "", options2);
        notification.value.onclick = clickTrigger;
        notification.value.onshow = showTrigger;
        notification.value.onerror = errorTrigger;
        notification.value.onclose = closeTrigger;
        return notification.value;
    };
    const close = ()=>{
        if (notification.value) notification.value.close();
        notification.value = null;
    };
    if (_requestForPermissions) (0, _shared.tryOnMounted)(ensurePermissions);
    (0, _shared.tryOnScopeDispose)(close);
    if (isSupported.value && window1) {
        const document1 = window1.document;
        useEventListener(document1, "visibilitychange", (e)=>{
            e.preventDefault();
            if (document1.visibilityState === "visible") close();
        });
    }
    return {
        isSupported,
        notification,
        ensurePermissions,
        permissionGranted,
        show,
        close,
        onClick,
        onShow,
        onError,
        onClose
    };
}
const DEFAULT_PING_MESSAGE = "ping";
function resolveNestedOptions(options) {
    if (options === true) return {};
    return options;
}
function useWebSocket(url, options = {}) {
    const { onConnected , onDisconnected , onError , onMessage , immediate =true , autoClose =true , protocols =[]  } = options;
    const data = (0, _vueDemi.ref)(null);
    const status = (0, _vueDemi.ref)("CLOSED");
    const wsRef = (0, _vueDemi.ref)();
    const urlRef = (0, _shared.toRef)(url);
    let heartbeatPause;
    let heartbeatResume;
    let explicitlyClosed = false;
    let retried = 0;
    let bufferedData = [];
    let pongTimeoutWait;
    const _sendBuffer = ()=>{
        if (bufferedData.length && wsRef.value && status.value === "OPEN") {
            for (const buffer of bufferedData)wsRef.value.send(buffer);
            bufferedData = [];
        }
    };
    const resetHeartbeat = ()=>{
        clearTimeout(pongTimeoutWait);
        pongTimeoutWait = void 0;
    };
    const close = (code = 1e3, reason)=>{
        if (!(0, _shared.isClient) || !wsRef.value) return;
        explicitlyClosed = true;
        resetHeartbeat();
        heartbeatPause == null || heartbeatPause();
        wsRef.value.close(code, reason);
        wsRef.value = void 0;
    };
    const send = (data2, useBuffer = true)=>{
        if (!wsRef.value || status.value !== "OPEN") {
            if (useBuffer) bufferedData.push(data2);
            return false;
        }
        _sendBuffer();
        wsRef.value.send(data2);
        return true;
    };
    const _init = ()=>{
        if (explicitlyClosed || typeof urlRef.value === "undefined") return;
        const ws = new WebSocket(urlRef.value, protocols);
        wsRef.value = ws;
        status.value = "CONNECTING";
        ws.onopen = ()=>{
            status.value = "OPEN";
            onConnected == null || onConnected(ws);
            heartbeatResume == null || heartbeatResume();
            _sendBuffer();
        };
        ws.onclose = (ev)=>{
            status.value = "CLOSED";
            onDisconnected == null || onDisconnected(ws, ev);
            if (!explicitlyClosed && options.autoReconnect) {
                const { retries =-1 , delay =1e3 , onFailed  } = resolveNestedOptions(options.autoReconnect);
                retried += 1;
                if (typeof retries === "number" && (retries < 0 || retried < retries)) setTimeout(_init, delay);
                else if (typeof retries === "function" && retries()) setTimeout(_init, delay);
                else onFailed == null || onFailed();
            }
        };
        ws.onerror = (e)=>{
            onError == null || onError(ws, e);
        };
        ws.onmessage = (e)=>{
            if (options.heartbeat) {
                resetHeartbeat();
                const { message =DEFAULT_PING_MESSAGE  } = resolveNestedOptions(options.heartbeat);
                if (e.data === message) return;
            }
            data.value = e.data;
            onMessage == null || onMessage(ws, e);
        };
    };
    if (options.heartbeat) {
        const { message =DEFAULT_PING_MESSAGE , interval =1e3 , pongTimeout =1e3  } = resolveNestedOptions(options.heartbeat);
        const { pause , resume  } = (0, _shared.useIntervalFn)(()=>{
            send(message, false);
            if (pongTimeoutWait != null) return;
            pongTimeoutWait = setTimeout(()=>{
                close();
                explicitlyClosed = false;
            }, pongTimeout);
        }, interval, {
            immediate: false
        });
        heartbeatPause = pause;
        heartbeatResume = resume;
    }
    if (autoClose) {
        if (0, _shared.isClient) useEventListener("beforeunload", ()=>close());
        (0, _shared.tryOnScopeDispose)(close);
    }
    const open = ()=>{
        if (!(0, _shared.isClient) && !(0, _shared.isWorker)) return;
        close();
        explicitlyClosed = false;
        retried = 0;
        _init();
    };
    if (immediate) open();
    (0, _vueDemi.watch)(urlRef, open);
    return {
        data,
        status,
        close,
        send,
        open,
        ws: wsRef
    };
}
function useWebWorker(arg0, workerOptions, options) {
    const { window: window1 = defaultWindow  } = options != null ? options : {};
    const data = (0, _vueDemi.ref)(null);
    const worker = (0, _vueDemi.shallowRef)();
    const post = (...args)=>{
        if (!worker.value) return;
        worker.value.postMessage(...args);
    };
    const terminate = function terminate2() {
        if (!worker.value) return;
        worker.value.terminate();
    };
    if (window1) {
        if (typeof arg0 === "string") worker.value = new Worker(arg0, workerOptions);
        else if (typeof arg0 === "function") worker.value = arg0();
        else worker.value = arg0;
        worker.value.onmessage = (e)=>{
            data.value = e.data;
        };
        (0, _shared.tryOnScopeDispose)(()=>{
            if (worker.value) worker.value.terminate();
        });
    }
    return {
        data,
        post,
        terminate,
        worker
    };
}
function jobRunner(userFunc) {
    return (e)=>{
        const userFuncArgs = e.data[0];
        return Promise.resolve(userFunc.apply(void 0, userFuncArgs)).then((result)=>{
            postMessage([
                "SUCCESS",
                result
            ]);
        }).catch((error)=>{
            postMessage([
                "ERROR",
                error
            ]);
        });
    };
}
function depsParser(deps, localDeps) {
    if (deps.length === 0 && localDeps.length === 0) return "";
    const depsString = deps.map((dep)=>`'${dep}'`).toString();
    const depsFunctionString = localDeps.filter((dep)=>typeof dep === "function").map((fn)=>{
        const str = fn.toString();
        if (str.trim().startsWith("function")) return str;
        else {
            const name = fn.name;
            return `const ${name} = ${str}`;
        }
    }).join(";");
    const importString = `importScripts(${depsString});`;
    return `${depsString.trim() === "" ? "" : importString} ${depsFunctionString}`;
}
function createWorkerBlobUrl(fn, deps, localDeps) {
    const blobCode = `${depsParser(deps, localDeps)}; onmessage=(${jobRunner})(${fn})`;
    const blob = new Blob([
        blobCode
    ], {
        type: "text/javascript"
    });
    const url = URL.createObjectURL(blob);
    return url;
}
function useWebWorkerFn(fn, options = {}) {
    const { dependencies =[] , localDependencies =[] , timeout , window: window1 = defaultWindow  } = options;
    const worker = (0, _vueDemi.ref)();
    const workerStatus = (0, _vueDemi.ref)("PENDING");
    const promise = (0, _vueDemi.ref)({});
    const timeoutId = (0, _vueDemi.ref)();
    const workerTerminate = (status = "PENDING")=>{
        if (worker.value && worker.value._url && window1) {
            worker.value.terminate();
            URL.revokeObjectURL(worker.value._url);
            promise.value = {};
            worker.value = void 0;
            window1.clearTimeout(timeoutId.value);
            workerStatus.value = status;
        }
    };
    workerTerminate();
    (0, _shared.tryOnScopeDispose)(workerTerminate);
    const generateWorker = ()=>{
        const blobUrl = createWorkerBlobUrl(fn, dependencies, localDependencies);
        const newWorker = new Worker(blobUrl);
        newWorker._url = blobUrl;
        newWorker.onmessage = (e)=>{
            const { resolve =()=>{} , reject =()=>{}  } = promise.value;
            const [status, result] = e.data;
            switch(status){
                case "SUCCESS":
                    resolve(result);
                    workerTerminate(status);
                    break;
                default:
                    reject(result);
                    workerTerminate("ERROR");
                    break;
            }
        };
        newWorker.onerror = (e)=>{
            const { reject =()=>{}  } = promise.value;
            e.preventDefault();
            reject(e);
            workerTerminate("ERROR");
        };
        if (timeout) timeoutId.value = setTimeout(()=>workerTerminate("TIMEOUT_EXPIRED"), timeout);
        return newWorker;
    };
    const callWorker = (...fnArgs)=>new Promise((resolve, reject)=>{
            promise.value = {
                resolve,
                reject
            };
            worker.value && worker.value.postMessage([
                [
                    ...fnArgs
                ]
            ]);
            workerStatus.value = "RUNNING";
        });
    const workerFn = (...fnArgs)=>{
        if (workerStatus.value === "RUNNING") {
            console.error("[useWebWorkerFn] You can only run one instance of the worker at a time.");
            return Promise.reject();
        }
        worker.value = generateWorker();
        return callWorker(...fnArgs);
    };
    return {
        workerFn,
        workerStatus,
        workerTerminate
    };
}
function useWindowFocus(options = {}) {
    const { window: window1 = defaultWindow  } = options;
    if (!window1) return (0, _vueDemi.ref)(false);
    const focused = (0, _vueDemi.ref)(window1.document.hasFocus());
    useEventListener(window1, "blur", ()=>{
        focused.value = false;
    });
    useEventListener(window1, "focus", ()=>{
        focused.value = true;
    });
    return focused;
}
function useWindowScroll(options = {}) {
    const { window: window1 = defaultWindow , behavior ="auto"  } = options;
    if (!window1) return {
        x: (0, _vueDemi.ref)(0),
        y: (0, _vueDemi.ref)(0)
    };
    const internalX = (0, _vueDemi.ref)(window1.scrollX);
    const internalY = (0, _vueDemi.ref)(window1.scrollY);
    const x = (0, _vueDemi.computed)({
        get () {
            return internalX.value;
        },
        set (x2) {
            scrollTo({
                left: x2,
                behavior
            });
        }
    });
    const y = (0, _vueDemi.computed)({
        get () {
            return internalY.value;
        },
        set (y2) {
            scrollTo({
                top: y2,
                behavior
            });
        }
    });
    useEventListener(window1, "scroll", ()=>{
        internalX.value = window1.scrollX;
        internalY.value = window1.scrollY;
    }, {
        capture: false,
        passive: true
    });
    return {
        x,
        y
    };
}
function useWindowSize(options = {}) {
    const { window: window1 = defaultWindow , initialWidth =Number.POSITIVE_INFINITY , initialHeight =Number.POSITIVE_INFINITY , listenOrientation =true , includeScrollbar =true  } = options;
    const width = (0, _vueDemi.ref)(initialWidth);
    const height = (0, _vueDemi.ref)(initialHeight);
    const update = ()=>{
        if (window1) {
            if (includeScrollbar) {
                width.value = window1.innerWidth;
                height.value = window1.innerHeight;
            } else {
                width.value = window1.document.documentElement.clientWidth;
                height.value = window1.document.documentElement.clientHeight;
            }
        }
    };
    update();
    (0, _shared.tryOnMounted)(update);
    useEventListener("resize", update, {
        passive: true
    });
    if (listenOrientation) {
        const matches = useMediaQuery("(orientation: portrait)");
        (0, _vueDemi.watch)(matches, ()=>update());
    }
    return {
        width,
        height
    };
}

},{"@vueuse/shared":"8BCR2","vue-demi":"1O62H","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"8BCR2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "assert", ()=>assert);
parcelHelpers.export(exports, "autoResetRef", ()=>refAutoReset);
parcelHelpers.export(exports, "bypassFilter", ()=>bypassFilter);
parcelHelpers.export(exports, "camelize", ()=>camelize);
parcelHelpers.export(exports, "clamp", ()=>clamp);
parcelHelpers.export(exports, "computedEager", ()=>computedEager);
parcelHelpers.export(exports, "computedWithControl", ()=>computedWithControl);
parcelHelpers.export(exports, "containsProp", ()=>containsProp);
parcelHelpers.export(exports, "controlledComputed", ()=>computedWithControl);
parcelHelpers.export(exports, "controlledRef", ()=>controlledRef);
parcelHelpers.export(exports, "createEventHook", ()=>createEventHook);
parcelHelpers.export(exports, "createFilterWrapper", ()=>createFilterWrapper);
parcelHelpers.export(exports, "createGlobalState", ()=>createGlobalState);
parcelHelpers.export(exports, "createInjectionState", ()=>createInjectionState);
parcelHelpers.export(exports, "createReactiveFn", ()=>reactify);
parcelHelpers.export(exports, "createSharedComposable", ()=>createSharedComposable);
parcelHelpers.export(exports, "createSingletonPromise", ()=>createSingletonPromise);
parcelHelpers.export(exports, "debounceFilter", ()=>debounceFilter);
parcelHelpers.export(exports, "debouncedRef", ()=>refDebounced);
parcelHelpers.export(exports, "debouncedWatch", ()=>watchDebounced);
parcelHelpers.export(exports, "directiveHooks", ()=>directiveHooks);
parcelHelpers.export(exports, "eagerComputed", ()=>computedEager);
parcelHelpers.export(exports, "extendRef", ()=>extendRef);
parcelHelpers.export(exports, "formatDate", ()=>formatDate);
parcelHelpers.export(exports, "get", ()=>get);
parcelHelpers.export(exports, "getLifeCycleTarget", ()=>getLifeCycleTarget);
parcelHelpers.export(exports, "hasOwn", ()=>hasOwn);
parcelHelpers.export(exports, "hyphenate", ()=>hyphenate);
parcelHelpers.export(exports, "identity", ()=>identity);
parcelHelpers.export(exports, "ignorableWatch", ()=>watchIgnorable);
parcelHelpers.export(exports, "increaseWithUnit", ()=>increaseWithUnit);
parcelHelpers.export(exports, "injectLocal", ()=>injectLocal);
parcelHelpers.export(exports, "invoke", ()=>invoke);
parcelHelpers.export(exports, "isClient", ()=>isClient);
parcelHelpers.export(exports, "isDef", ()=>isDef);
parcelHelpers.export(exports, "isDefined", ()=>isDefined);
parcelHelpers.export(exports, "isIOS", ()=>isIOS);
parcelHelpers.export(exports, "isObject", ()=>isObject);
parcelHelpers.export(exports, "isWorker", ()=>isWorker);
parcelHelpers.export(exports, "makeDestructurable", ()=>makeDestructurable);
parcelHelpers.export(exports, "noop", ()=>noop);
parcelHelpers.export(exports, "normalizeDate", ()=>normalizeDate);
parcelHelpers.export(exports, "notNullish", ()=>notNullish);
parcelHelpers.export(exports, "now", ()=>now);
parcelHelpers.export(exports, "objectEntries", ()=>objectEntries);
parcelHelpers.export(exports, "objectOmit", ()=>objectOmit);
parcelHelpers.export(exports, "objectPick", ()=>objectPick);
parcelHelpers.export(exports, "pausableFilter", ()=>pausableFilter);
parcelHelpers.export(exports, "pausableWatch", ()=>watchPausable);
parcelHelpers.export(exports, "promiseTimeout", ()=>promiseTimeout);
parcelHelpers.export(exports, "provideLocal", ()=>provideLocal);
parcelHelpers.export(exports, "rand", ()=>rand);
parcelHelpers.export(exports, "reactify", ()=>reactify);
parcelHelpers.export(exports, "reactifyObject", ()=>reactifyObject);
parcelHelpers.export(exports, "reactiveComputed", ()=>reactiveComputed);
parcelHelpers.export(exports, "reactiveOmit", ()=>reactiveOmit);
parcelHelpers.export(exports, "reactivePick", ()=>reactivePick);
parcelHelpers.export(exports, "refAutoReset", ()=>refAutoReset);
parcelHelpers.export(exports, "refDebounced", ()=>refDebounced);
parcelHelpers.export(exports, "refDefault", ()=>refDefault);
parcelHelpers.export(exports, "refThrottled", ()=>refThrottled);
parcelHelpers.export(exports, "refWithControl", ()=>refWithControl);
parcelHelpers.export(exports, "resolveRef", ()=>resolveRef);
parcelHelpers.export(exports, "resolveUnref", ()=>resolveUnref);
parcelHelpers.export(exports, "set", ()=>set);
parcelHelpers.export(exports, "syncRef", ()=>syncRef);
parcelHelpers.export(exports, "syncRefs", ()=>syncRefs);
parcelHelpers.export(exports, "throttleFilter", ()=>throttleFilter);
parcelHelpers.export(exports, "throttledRef", ()=>refThrottled);
parcelHelpers.export(exports, "throttledWatch", ()=>watchThrottled);
parcelHelpers.export(exports, "timestamp", ()=>timestamp);
parcelHelpers.export(exports, "toReactive", ()=>toReactive);
parcelHelpers.export(exports, "toRef", ()=>toRef);
parcelHelpers.export(exports, "toRefs", ()=>toRefs);
parcelHelpers.export(exports, "toValue", ()=>toValue);
parcelHelpers.export(exports, "tryOnBeforeMount", ()=>tryOnBeforeMount);
parcelHelpers.export(exports, "tryOnBeforeUnmount", ()=>tryOnBeforeUnmount);
parcelHelpers.export(exports, "tryOnMounted", ()=>tryOnMounted);
parcelHelpers.export(exports, "tryOnScopeDispose", ()=>tryOnScopeDispose);
parcelHelpers.export(exports, "tryOnUnmounted", ()=>tryOnUnmounted);
parcelHelpers.export(exports, "until", ()=>until);
parcelHelpers.export(exports, "useArrayDifference", ()=>useArrayDifference);
parcelHelpers.export(exports, "useArrayEvery", ()=>useArrayEvery);
parcelHelpers.export(exports, "useArrayFilter", ()=>useArrayFilter);
parcelHelpers.export(exports, "useArrayFind", ()=>useArrayFind);
parcelHelpers.export(exports, "useArrayFindIndex", ()=>useArrayFindIndex);
parcelHelpers.export(exports, "useArrayFindLast", ()=>useArrayFindLast);
parcelHelpers.export(exports, "useArrayIncludes", ()=>useArrayIncludes);
parcelHelpers.export(exports, "useArrayJoin", ()=>useArrayJoin);
parcelHelpers.export(exports, "useArrayMap", ()=>useArrayMap);
parcelHelpers.export(exports, "useArrayReduce", ()=>useArrayReduce);
parcelHelpers.export(exports, "useArraySome", ()=>useArraySome);
parcelHelpers.export(exports, "useArrayUnique", ()=>useArrayUnique);
parcelHelpers.export(exports, "useCounter", ()=>useCounter);
parcelHelpers.export(exports, "useDateFormat", ()=>useDateFormat);
parcelHelpers.export(exports, "useDebounce", ()=>refDebounced);
parcelHelpers.export(exports, "useDebounceFn", ()=>useDebounceFn);
parcelHelpers.export(exports, "useInterval", ()=>useInterval);
parcelHelpers.export(exports, "useIntervalFn", ()=>useIntervalFn);
parcelHelpers.export(exports, "useLastChanged", ()=>useLastChanged);
parcelHelpers.export(exports, "useThrottle", ()=>refThrottled);
parcelHelpers.export(exports, "useThrottleFn", ()=>useThrottleFn);
parcelHelpers.export(exports, "useTimeout", ()=>useTimeout);
parcelHelpers.export(exports, "useTimeoutFn", ()=>useTimeoutFn);
parcelHelpers.export(exports, "useToNumber", ()=>useToNumber);
parcelHelpers.export(exports, "useToString", ()=>useToString);
parcelHelpers.export(exports, "useToggle", ()=>useToggle);
parcelHelpers.export(exports, "watchArray", ()=>watchArray);
parcelHelpers.export(exports, "watchAtMost", ()=>watchAtMost);
parcelHelpers.export(exports, "watchDebounced", ()=>watchDebounced);
parcelHelpers.export(exports, "watchDeep", ()=>watchDeep);
parcelHelpers.export(exports, "watchIgnorable", ()=>watchIgnorable);
parcelHelpers.export(exports, "watchImmediate", ()=>watchImmediate);
parcelHelpers.export(exports, "watchOnce", ()=>watchOnce);
parcelHelpers.export(exports, "watchPausable", ()=>watchPausable);
parcelHelpers.export(exports, "watchThrottled", ()=>watchThrottled);
parcelHelpers.export(exports, "watchTriggerable", ()=>watchTriggerable);
parcelHelpers.export(exports, "watchWithFilter", ()=>watchWithFilter);
parcelHelpers.export(exports, "whenever", ()=>whenever);
var _vueDemi = require("vue-demi");
function computedEager(fn, options) {
    var _a;
    const result = (0, _vueDemi.shallowRef)();
    (0, _vueDemi.watchEffect)(()=>{
        result.value = fn();
    }, {
        ...options,
        flush: (_a = options == null ? void 0 : options.flush) != null ? _a : "sync"
    });
    return (0, _vueDemi.readonly)(result);
}
function computedWithControl(source, fn) {
    let v = void 0;
    let track;
    let trigger;
    const dirty = (0, _vueDemi.ref)(true);
    const update = ()=>{
        dirty.value = true;
        trigger();
    };
    (0, _vueDemi.watch)(source, update, {
        flush: "sync"
    });
    const get = typeof fn === "function" ? fn : fn.get;
    const set = typeof fn === "function" ? void 0 : fn.set;
    const result = (0, _vueDemi.customRef)((_track, _trigger)=>{
        track = _track;
        trigger = _trigger;
        return {
            get () {
                if (dirty.value) {
                    v = get();
                    dirty.value = false;
                }
                track();
                return v;
            },
            set (v2) {
                set == null || set(v2);
            }
        };
    });
    if (Object.isExtensible(result)) result.trigger = update;
    return result;
}
function tryOnScopeDispose(fn) {
    if ((0, _vueDemi.getCurrentScope)()) {
        (0, _vueDemi.onScopeDispose)(fn);
        return true;
    }
    return false;
}
function createEventHook() {
    const fns = /* @__PURE__ */ new Set();
    const off = (fn)=>{
        fns.delete(fn);
    };
    const on = (fn)=>{
        fns.add(fn);
        const offFn = ()=>off(fn);
        tryOnScopeDispose(offFn);
        return {
            off: offFn
        };
    };
    const trigger = (...args)=>{
        return Promise.all(Array.from(fns).map((fn)=>fn(...args)));
    };
    return {
        on,
        off,
        trigger
    };
}
function createGlobalState(stateFactory) {
    let initialized = false;
    let state;
    const scope = (0, _vueDemi.effectScope)(true);
    return (...args)=>{
        if (!initialized) {
            state = scope.run(()=>stateFactory(...args));
            initialized = true;
        }
        return state;
    };
}
const localProvidedStateMap = /* @__PURE__ */ new WeakMap();
const provideLocal = (key, value)=>{
    var _a;
    const instance = (_a = (0, _vueDemi.getCurrentInstance)()) == null ? void 0 : _a.proxy;
    if (instance == null) throw new Error("provideLocal must be called in setup");
    if (!localProvidedStateMap.has(instance)) localProvidedStateMap.set(instance, /* @__PURE__ */ Object.create(null));
    const localProvidedState = localProvidedStateMap.get(instance);
    localProvidedState[key] = value;
    (0, _vueDemi.provide)(key, value);
};
const injectLocal = (...args)=>{
    var _a;
    const key = args[0];
    const instance = (_a = (0, _vueDemi.getCurrentInstance)()) == null ? void 0 : _a.proxy;
    if (instance == null) throw new Error("injectLocal must be called in setup");
    if (localProvidedStateMap.has(instance) && key in localProvidedStateMap.get(instance)) return localProvidedStateMap.get(instance)[key];
    return (0, _vueDemi.inject)(...args);
};
function createInjectionState(composable, options) {
    const key = (options == null ? void 0 : options.injectionKey) || Symbol(composable.name || "InjectionState");
    const defaultValue = options == null ? void 0 : options.defaultValue;
    const useProvidingState = (...args)=>{
        const state = composable(...args);
        provideLocal(key, state);
        return state;
    };
    const useInjectedState = ()=>injectLocal(key, defaultValue);
    return [
        useProvidingState,
        useInjectedState
    ];
}
function createSharedComposable(composable) {
    let subscribers = 0;
    let state;
    let scope;
    const dispose = ()=>{
        subscribers -= 1;
        if (scope && subscribers <= 0) {
            scope.stop();
            state = void 0;
            scope = void 0;
        }
    };
    return (...args)=>{
        subscribers += 1;
        if (!state) {
            scope = (0, _vueDemi.effectScope)(true);
            state = scope.run(()=>composable(...args));
        }
        tryOnScopeDispose(dispose);
        return state;
    };
}
function extendRef(ref, extend, { enumerable =false , unwrap =true  } = {}) {
    if (!(0, _vueDemi.isVue3) && !(0, _vueDemi.version).startsWith("2.7.")) throw new Error("[VueUse] extendRef only works in Vue 2.7 or above.");
    for (const [key, value] of Object.entries(extend)){
        if (key === "value") continue;
        if ((0, _vueDemi.isRef)(value) && unwrap) Object.defineProperty(ref, key, {
            get () {
                return value.value;
            },
            set (v) {
                value.value = v;
            },
            enumerable
        });
        else Object.defineProperty(ref, key, {
            value,
            enumerable
        });
    }
    return ref;
}
function get(obj, key) {
    if (key == null) return (0, _vueDemi.unref)(obj);
    return (0, _vueDemi.unref)(obj)[key];
}
function isDefined(v) {
    return (0, _vueDemi.unref)(v) != null;
}
function makeDestructurable(obj, arr) {
    if (typeof Symbol !== "undefined") {
        const clone = {
            ...obj
        };
        Object.defineProperty(clone, Symbol.iterator, {
            enumerable: false,
            value () {
                let index = 0;
                return {
                    next: ()=>({
                            value: arr[index++],
                            done: index > arr.length
                        })
                };
            }
        });
        return clone;
    } else return Object.assign([
        ...arr
    ], obj);
}
function toValue(r) {
    return typeof r === "function" ? r() : (0, _vueDemi.unref)(r);
}
const resolveUnref = toValue;
function reactify(fn, options) {
    const unrefFn = (options == null ? void 0 : options.computedGetter) === false ? (0, _vueDemi.unref) : toValue;
    return function(...args) {
        return (0, _vueDemi.computed)(()=>fn.apply(this, args.map((i)=>unrefFn(i))));
    };
}
function reactifyObject(obj, optionsOrKeys = {}) {
    let keys = [];
    let options;
    if (Array.isArray(optionsOrKeys)) keys = optionsOrKeys;
    else {
        options = optionsOrKeys;
        const { includeOwnProperties =true  } = optionsOrKeys;
        keys.push(...Object.keys(obj));
        if (includeOwnProperties) keys.push(...Object.getOwnPropertyNames(obj));
    }
    return Object.fromEntries(keys.map((key)=>{
        const value = obj[key];
        return [
            key,
            typeof value === "function" ? reactify(value.bind(obj), options) : value
        ];
    }));
}
function toReactive(objectRef) {
    if (!(0, _vueDemi.isRef)(objectRef)) return (0, _vueDemi.reactive)(objectRef);
    const proxy = new Proxy({}, {
        get (_, p, receiver) {
            return (0, _vueDemi.unref)(Reflect.get(objectRef.value, p, receiver));
        },
        set (_, p, value) {
            if ((0, _vueDemi.isRef)(objectRef.value[p]) && !(0, _vueDemi.isRef)(value)) objectRef.value[p].value = value;
            else objectRef.value[p] = value;
            return true;
        },
        deleteProperty (_, p) {
            return Reflect.deleteProperty(objectRef.value, p);
        },
        has (_, p) {
            return Reflect.has(objectRef.value, p);
        },
        ownKeys () {
            return Object.keys(objectRef.value);
        },
        getOwnPropertyDescriptor () {
            return {
                enumerable: true,
                configurable: true
            };
        }
    });
    return (0, _vueDemi.reactive)(proxy);
}
function reactiveComputed(fn) {
    return toReactive((0, _vueDemi.computed)(fn));
}
function reactiveOmit(obj, ...keys) {
    const flatKeys = keys.flat();
    const predicate = flatKeys[0];
    return reactiveComputed(()=>typeof predicate === "function" ? Object.fromEntries(Object.entries((0, _vueDemi.toRefs)(obj)).filter(([k, v])=>!predicate(toValue(v), k))) : Object.fromEntries(Object.entries((0, _vueDemi.toRefs)(obj)).filter((e)=>!flatKeys.includes(e[0]))));
}
const isClient = typeof window !== "undefined" && typeof document !== "undefined";
const isWorker = typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
const isDef = (val)=>typeof val !== "undefined";
const notNullish = (val)=>val != null;
const assert = (condition, ...infos)=>{
    if (!condition) console.warn(...infos);
};
const toString = Object.prototype.toString;
const isObject = (val)=>toString.call(val) === "[object Object]";
const now = ()=>Date.now();
const timestamp = ()=>+Date.now();
const clamp = (n, min, max)=>Math.min(max, Math.max(min, n));
const noop = ()=>{};
const rand = (min, max)=>{
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
};
const hasOwn = (val, key)=>Object.prototype.hasOwnProperty.call(val, key);
const isIOS = /* @__PURE__ */ getIsIOS();
function getIsIOS() {
    var _a, _b;
    return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function createFilterWrapper(filter, fn) {
    function wrapper(...args) {
        return new Promise((resolve, reject)=>{
            Promise.resolve(filter(()=>fn.apply(this, args), {
                fn,
                thisArg: this,
                args
            })).then(resolve).catch(reject);
        });
    }
    return wrapper;
}
const bypassFilter = (invoke)=>{
    return invoke();
};
function debounceFilter(ms, options = {}) {
    let timer;
    let maxTimer;
    let lastRejector = noop;
    const _clearTimeout = (timer2)=>{
        clearTimeout(timer2);
        lastRejector();
        lastRejector = noop;
    };
    const filter = (invoke)=>{
        const duration = toValue(ms);
        const maxDuration = toValue(options.maxWait);
        if (timer) _clearTimeout(timer);
        if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
            if (maxTimer) {
                _clearTimeout(maxTimer);
                maxTimer = null;
            }
            return Promise.resolve(invoke());
        }
        return new Promise((resolve, reject)=>{
            lastRejector = options.rejectOnCancel ? reject : resolve;
            if (maxDuration && !maxTimer) maxTimer = setTimeout(()=>{
                if (timer) _clearTimeout(timer);
                maxTimer = null;
                resolve(invoke());
            }, maxDuration);
            timer = setTimeout(()=>{
                if (maxTimer) _clearTimeout(maxTimer);
                maxTimer = null;
                resolve(invoke());
            }, duration);
        });
    };
    return filter;
}
function throttleFilter(...args) {
    let lastExec = 0;
    let timer;
    let isLeading = true;
    let lastRejector = noop;
    let lastValue;
    let ms;
    let trailing;
    let leading;
    let rejectOnCancel;
    if (!(0, _vueDemi.isRef)(args[0]) && typeof args[0] === "object") ({ delay: ms , trailing =true , leading =true , rejectOnCancel =false  } = args[0]);
    else [ms, trailing = true, leading = true, rejectOnCancel = false] = args;
    const clear = ()=>{
        if (timer) {
            clearTimeout(timer);
            timer = void 0;
            lastRejector();
            lastRejector = noop;
        }
    };
    const filter = (_invoke)=>{
        const duration = toValue(ms);
        const elapsed = Date.now() - lastExec;
        const invoke = ()=>{
            return lastValue = _invoke();
        };
        clear();
        if (duration <= 0) {
            lastExec = Date.now();
            return invoke();
        }
        if (elapsed > duration && (leading || !isLeading)) {
            lastExec = Date.now();
            invoke();
        } else if (trailing) lastValue = new Promise((resolve, reject)=>{
            lastRejector = rejectOnCancel ? reject : resolve;
            timer = setTimeout(()=>{
                lastExec = Date.now();
                isLeading = true;
                resolve(invoke());
                clear();
            }, Math.max(0, duration - elapsed));
        });
        if (!leading && !timer) timer = setTimeout(()=>isLeading = true, duration);
        isLeading = false;
        return lastValue;
    };
    return filter;
}
function pausableFilter(extendFilter = bypassFilter) {
    const isActive = (0, _vueDemi.ref)(true);
    function pause() {
        isActive.value = false;
    }
    function resume() {
        isActive.value = true;
    }
    const eventFilter = (...args)=>{
        if (isActive.value) extendFilter(...args);
    };
    return {
        isActive: (0, _vueDemi.readonly)(isActive),
        pause,
        resume,
        eventFilter
    };
}
const directiveHooks = {
    mounted: (0, _vueDemi.isVue3) ? "mounted" : "inserted",
    updated: (0, _vueDemi.isVue3) ? "updated" : "componentUpdated",
    unmounted: (0, _vueDemi.isVue3) ? "unmounted" : "unbind"
};
function cacheStringFunction(fn) {
    const cache = /* @__PURE__ */ Object.create(null);
    return (str)=>{
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    };
}
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str)=>str.replace(hyphenateRE, "-$1").toLowerCase());
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str)=>{
    return str.replace(camelizeRE, (_, c)=>c ? c.toUpperCase() : "");
});
function promiseTimeout(ms, throwOnTimeout = false, reason = "Timeout") {
    return new Promise((resolve, reject)=>{
        if (throwOnTimeout) setTimeout(()=>reject(reason), ms);
        else setTimeout(resolve, ms);
    });
}
function identity(arg) {
    return arg;
}
function createSingletonPromise(fn) {
    let _promise;
    function wrapper() {
        if (!_promise) _promise = fn();
        return _promise;
    }
    wrapper.reset = async ()=>{
        const _prev = _promise;
        _promise = void 0;
        if (_prev) await _prev;
    };
    return wrapper;
}
function invoke(fn) {
    return fn();
}
function containsProp(obj, ...props) {
    return props.some((k)=>k in obj);
}
function increaseWithUnit(target, delta) {
    var _a;
    if (typeof target === "number") return target + delta;
    const value = ((_a = target.match(/^-?\d+\.?\d*/)) == null ? void 0 : _a[0]) || "";
    const unit = target.slice(value.length);
    const result = Number.parseFloat(value) + delta;
    if (Number.isNaN(result)) return target;
    return result + unit;
}
function objectPick(obj, keys, omitUndefined = false) {
    return keys.reduce((n, k)=>{
        if (k in obj) {
            if (!omitUndefined || obj[k] !== void 0) n[k] = obj[k];
        }
        return n;
    }, {});
}
function objectOmit(obj, keys, omitUndefined = false) {
    return Object.fromEntries(Object.entries(obj).filter(([key, value])=>{
        return (!omitUndefined || value !== void 0) && !keys.includes(key);
    }));
}
function objectEntries(obj) {
    return Object.entries(obj);
}
function getLifeCycleTarget(target) {
    return target || (0, _vueDemi.getCurrentInstance)();
}
function toRef(...args) {
    if (args.length !== 1) return (0, _vueDemi.toRef)(...args);
    const r = args[0];
    return typeof r === "function" ? (0, _vueDemi.readonly)((0, _vueDemi.customRef)(()=>({
            get: r,
            set: noop
        }))) : (0, _vueDemi.ref)(r);
}
const resolveRef = toRef;
function reactivePick(obj, ...keys) {
    const flatKeys = keys.flat();
    const predicate = flatKeys[0];
    return reactiveComputed(()=>typeof predicate === "function" ? Object.fromEntries(Object.entries((0, _vueDemi.toRefs)(obj)).filter(([k, v])=>predicate(toValue(v), k))) : Object.fromEntries(flatKeys.map((k)=>[
                k,
                toRef(obj, k)
            ])));
}
function refAutoReset(defaultValue, afterMs = 1e4) {
    return (0, _vueDemi.customRef)((track, trigger)=>{
        let value = toValue(defaultValue);
        let timer;
        const resetAfter = ()=>setTimeout(()=>{
                value = toValue(defaultValue);
                trigger();
            }, toValue(afterMs));
        tryOnScopeDispose(()=>{
            clearTimeout(timer);
        });
        return {
            get () {
                track();
                return value;
            },
            set (newValue) {
                value = newValue;
                trigger();
                clearTimeout(timer);
                timer = resetAfter();
            }
        };
    });
}
function useDebounceFn(fn, ms = 200, options = {}) {
    return createFilterWrapper(debounceFilter(ms, options), fn);
}
function refDebounced(value, ms = 200, options = {}) {
    const debounced = (0, _vueDemi.ref)(value.value);
    const updater = useDebounceFn(()=>{
        debounced.value = value.value;
    }, ms, options);
    (0, _vueDemi.watch)(value, ()=>updater());
    return debounced;
}
function refDefault(source, defaultValue) {
    return (0, _vueDemi.computed)({
        get () {
            var _a;
            return (_a = source.value) != null ? _a : defaultValue;
        },
        set (value) {
            source.value = value;
        }
    });
}
function useThrottleFn(fn, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {
    return createFilterWrapper(throttleFilter(ms, trailing, leading, rejectOnCancel), fn);
}
function refThrottled(value, delay = 200, trailing = true, leading = true) {
    if (delay <= 0) return value;
    const throttled = (0, _vueDemi.ref)(value.value);
    const updater = useThrottleFn(()=>{
        throttled.value = value.value;
    }, delay, trailing, leading);
    (0, _vueDemi.watch)(value, ()=>updater());
    return throttled;
}
function refWithControl(initial, options = {}) {
    let source = initial;
    let track;
    let trigger;
    const ref = (0, _vueDemi.customRef)((_track, _trigger)=>{
        track = _track;
        trigger = _trigger;
        return {
            get () {
                return get();
            },
            set (v) {
                set(v);
            }
        };
    });
    function get(tracking = true) {
        if (tracking) track();
        return source;
    }
    function set(value, triggering = true) {
        var _a, _b;
        if (value === source) return;
        const old = source;
        if (((_a = options.onBeforeChange) == null ? void 0 : _a.call(options, value, old)) === false) return;
        source = value;
        (_b = options.onChanged) == null || _b.call(options, value, old);
        if (triggering) trigger();
    }
    const untrackedGet = ()=>get(false);
    const silentSet = (v)=>set(v, false);
    const peek = ()=>get(false);
    const lay = (v)=>set(v, false);
    return extendRef(ref, {
        get,
        set,
        untrackedGet,
        silentSet,
        peek,
        lay
    }, {
        enumerable: true
    });
}
const controlledRef = refWithControl;
function set(...args) {
    if (args.length === 2) {
        const [ref, value] = args;
        ref.value = value;
    }
    if (args.length === 3) {
        if (0, _vueDemi.isVue2) (0, _vueDemi.set)(...args);
        else {
            const [target, key, value] = args;
            target[key] = value;
        }
    }
}
function watchWithFilter(source, cb, options = {}) {
    const { eventFilter =bypassFilter , ...watchOptions } = options;
    return (0, _vueDemi.watch)(source, createFilterWrapper(eventFilter, cb), watchOptions);
}
function watchPausable(source, cb, options = {}) {
    const { eventFilter: filter , ...watchOptions } = options;
    const { eventFilter , pause , resume , isActive  } = pausableFilter(filter);
    const stop = watchWithFilter(source, cb, {
        ...watchOptions,
        eventFilter
    });
    return {
        stop,
        pause,
        resume,
        isActive
    };
}
function syncRef(left, right, ...[options]) {
    const { flush ="sync" , deep =false , immediate =true , direction ="both" , transform ={}  } = options || {};
    const watchers = [];
    const transformLTR = "ltr" in transform && transform.ltr || ((v)=>v);
    const transformRTL = "rtl" in transform && transform.rtl || ((v)=>v);
    if (direction === "both" || direction === "ltr") watchers.push(watchPausable(left, (newValue)=>{
        watchers.forEach((w)=>w.pause());
        right.value = transformLTR(newValue);
        watchers.forEach((w)=>w.resume());
    }, {
        flush,
        deep,
        immediate
    }));
    if (direction === "both" || direction === "rtl") watchers.push(watchPausable(right, (newValue)=>{
        watchers.forEach((w)=>w.pause());
        left.value = transformRTL(newValue);
        watchers.forEach((w)=>w.resume());
    }, {
        flush,
        deep,
        immediate
    }));
    const stop = ()=>{
        watchers.forEach((w)=>w.stop());
    };
    return stop;
}
function syncRefs(source, targets, options = {}) {
    const { flush ="sync" , deep =false , immediate =true  } = options;
    if (!Array.isArray(targets)) targets = [
        targets
    ];
    return (0, _vueDemi.watch)(source, (newValue)=>targets.forEach((target)=>target.value = newValue), {
        flush,
        deep,
        immediate
    });
}
function toRefs(objectRef, options = {}) {
    if (!(0, _vueDemi.isRef)(objectRef)) return (0, _vueDemi.toRefs)(objectRef);
    const result = Array.isArray(objectRef.value) ? Array.from({
        length: objectRef.value.length
    }) : {};
    for(const key in objectRef.value)result[key] = (0, _vueDemi.customRef)(()=>({
            get () {
                return objectRef.value[key];
            },
            set (v) {
                var _a;
                const replaceRef = (_a = toValue(options.replaceRef)) != null ? _a : true;
                if (replaceRef) {
                    if (Array.isArray(objectRef.value)) {
                        const copy = [
                            ...objectRef.value
                        ];
                        copy[key] = v;
                        objectRef.value = copy;
                    } else {
                        const newObject = {
                            ...objectRef.value,
                            [key]: v
                        };
                        Object.setPrototypeOf(newObject, Object.getPrototypeOf(objectRef.value));
                        objectRef.value = newObject;
                    }
                } else objectRef.value[key] = v;
            }
        }));
    return result;
}
function tryOnBeforeMount(fn, sync = true, target) {
    const instance = getLifeCycleTarget(target);
    if (instance) (0, _vueDemi.onBeforeMount)(fn, target);
    else if (sync) fn();
    else (0, _vueDemi.nextTick)(fn);
}
function tryOnBeforeUnmount(fn, target) {
    const instance = getLifeCycleTarget(target);
    if (instance) (0, _vueDemi.onBeforeUnmount)(fn, target);
}
function tryOnMounted(fn, sync = true, target) {
    const instance = getLifeCycleTarget();
    if (instance) (0, _vueDemi.onMounted)(fn, target);
    else if (sync) fn();
    else (0, _vueDemi.nextTick)(fn);
}
function tryOnUnmounted(fn, target) {
    const instance = getLifeCycleTarget(target);
    if (instance) (0, _vueDemi.onUnmounted)(fn, target);
}
function createUntil(r, isNot = false) {
    function toMatch(condition, { flush ="sync" , deep =false , timeout , throwOnTimeout  } = {}) {
        let stop = null;
        const watcher = new Promise((resolve)=>{
            stop = (0, _vueDemi.watch)(r, (v)=>{
                if (condition(v) !== isNot) {
                    stop == null || stop();
                    resolve(v);
                }
            }, {
                flush,
                deep,
                immediate: true
            });
        });
        const promises = [
            watcher
        ];
        if (timeout != null) promises.push(promiseTimeout(timeout, throwOnTimeout).then(()=>toValue(r)).finally(()=>stop == null ? void 0 : stop()));
        return Promise.race(promises);
    }
    function toBe(value, options) {
        if (!(0, _vueDemi.isRef)(value)) return toMatch((v)=>v === value, options);
        const { flush ="sync" , deep =false , timeout , throwOnTimeout  } = options != null ? options : {};
        let stop = null;
        const watcher = new Promise((resolve)=>{
            stop = (0, _vueDemi.watch)([
                r,
                value
            ], ([v1, v2])=>{
                if (isNot !== (v1 === v2)) {
                    stop == null || stop();
                    resolve(v1);
                }
            }, {
                flush,
                deep,
                immediate: true
            });
        });
        const promises = [
            watcher
        ];
        if (timeout != null) promises.push(promiseTimeout(timeout, throwOnTimeout).then(()=>toValue(r)).finally(()=>{
            stop == null || stop();
            return toValue(r);
        }));
        return Promise.race(promises);
    }
    function toBeTruthy(options) {
        return toMatch((v)=>Boolean(v), options);
    }
    function toBeNull(options) {
        return toBe(null, options);
    }
    function toBeUndefined(options) {
        return toBe(void 0, options);
    }
    function toBeNaN(options) {
        return toMatch(Number.isNaN, options);
    }
    function toContains(value, options) {
        return toMatch((v)=>{
            const array = Array.from(v);
            return array.includes(value) || array.includes(toValue(value));
        }, options);
    }
    function changed(options) {
        return changedTimes(1, options);
    }
    function changedTimes(n = 1, options) {
        let count = -1;
        return toMatch(()=>{
            count += 1;
            return count >= n;
        }, options);
    }
    if (Array.isArray(toValue(r))) {
        const instance = {
            toMatch,
            toContains,
            changed,
            changedTimes,
            get not () {
                return createUntil(r, !isNot);
            }
        };
        return instance;
    } else {
        const instance = {
            toMatch,
            toBe,
            toBeTruthy,
            toBeNull,
            toBeNaN,
            toBeUndefined,
            changed,
            changedTimes,
            get not () {
                return createUntil(r, !isNot);
            }
        };
        return instance;
    }
}
function until(r) {
    return createUntil(r);
}
function defaultComparator(value, othVal) {
    return value === othVal;
}
function useArrayDifference(...args) {
    var _a;
    const list = args[0];
    const values = args[1];
    let compareFn = (_a = args[2]) != null ? _a : defaultComparator;
    if (typeof compareFn === "string") {
        const key = compareFn;
        compareFn = (value, othVal)=>value[key] === othVal[key];
    }
    return (0, _vueDemi.computed)(()=>toValue(list).filter((x)=>toValue(values).findIndex((y)=>compareFn(x, y)) === -1));
}
function useArrayEvery(list, fn) {
    return (0, _vueDemi.computed)(()=>toValue(list).every((element, index, array)=>fn(toValue(element), index, array)));
}
function useArrayFilter(list, fn) {
    return (0, _vueDemi.computed)(()=>toValue(list).map((i)=>toValue(i)).filter(fn));
}
function useArrayFind(list, fn) {
    return (0, _vueDemi.computed)(()=>toValue(toValue(list).find((element, index, array)=>fn(toValue(element), index, array))));
}
function useArrayFindIndex(list, fn) {
    return (0, _vueDemi.computed)(()=>toValue(list).findIndex((element, index, array)=>fn(toValue(element), index, array)));
}
function findLast(arr, cb) {
    let index = arr.length;
    while(index-- > 0){
        if (cb(arr[index], index, arr)) return arr[index];
    }
    return void 0;
}
function useArrayFindLast(list, fn) {
    return (0, _vueDemi.computed)(()=>toValue(!Array.prototype.findLast ? findLast(toValue(list), (element, index, array)=>fn(toValue(element), index, array)) : toValue(list).findLast((element, index, array)=>fn(toValue(element), index, array))));
}
function isArrayIncludesOptions(obj) {
    return isObject(obj) && containsProp(obj, "formIndex", "comparator");
}
function useArrayIncludes(...args) {
    var _a;
    const list = args[0];
    const value = args[1];
    let comparator = args[2];
    let formIndex = 0;
    if (isArrayIncludesOptions(comparator)) {
        formIndex = (_a = comparator.fromIndex) != null ? _a : 0;
        comparator = comparator.comparator;
    }
    if (typeof comparator === "string") {
        const key = comparator;
        comparator = (element, value2)=>element[key] === toValue(value2);
    }
    comparator = comparator != null ? comparator : (element, value2)=>element === toValue(value2);
    return (0, _vueDemi.computed)(()=>toValue(list).slice(formIndex).some((element, index, array)=>comparator(toValue(element), toValue(value), index, toValue(array))));
}
function useArrayJoin(list, separator) {
    return (0, _vueDemi.computed)(()=>toValue(list).map((i)=>toValue(i)).join(toValue(separator)));
}
function useArrayMap(list, fn) {
    return (0, _vueDemi.computed)(()=>toValue(list).map((i)=>toValue(i)).map(fn));
}
function useArrayReduce(list, reducer, ...args) {
    const reduceCallback = (sum, value, index)=>reducer(toValue(sum), toValue(value), index);
    return (0, _vueDemi.computed)(()=>{
        const resolved = toValue(list);
        return args.length ? resolved.reduce(reduceCallback, toValue(args[0])) : resolved.reduce(reduceCallback);
    });
}
function useArraySome(list, fn) {
    return (0, _vueDemi.computed)(()=>toValue(list).some((element, index, array)=>fn(toValue(element), index, array)));
}
function uniq(array) {
    return Array.from(new Set(array));
}
function uniqueElementsBy(array, fn) {
    return array.reduce((acc, v)=>{
        if (!acc.some((x)=>fn(v, x, array))) acc.push(v);
        return acc;
    }, []);
}
function useArrayUnique(list, compareFn) {
    return (0, _vueDemi.computed)(()=>{
        const resolvedList = toValue(list).map((element)=>toValue(element));
        return compareFn ? uniqueElementsBy(resolvedList, compareFn) : uniq(resolvedList);
    });
}
function useCounter(initialValue = 0, options = {}) {
    let _initialValue = (0, _vueDemi.unref)(initialValue);
    const count = (0, _vueDemi.ref)(initialValue);
    const { max =Number.POSITIVE_INFINITY , min =Number.NEGATIVE_INFINITY  } = options;
    const inc = (delta = 1)=>count.value = Math.max(Math.min(max, count.value + delta), min);
    const dec = (delta = 1)=>count.value = Math.min(Math.max(min, count.value - delta), max);
    const get = ()=>count.value;
    const set = (val)=>count.value = Math.max(min, Math.min(max, val));
    const reset = (val = _initialValue)=>{
        _initialValue = val;
        return set(val);
    };
    return {
        count,
        inc,
        dec,
        get,
        set,
        reset
    };
}
const REGEX_PARSE = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[T\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/i;
const REGEX_FORMAT = /[YMDHhms]o|\[([^\]]+)\]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g;
function defaultMeridiem(hours, minutes, isLowercase, hasPeriod) {
    let m = hours < 12 ? "AM" : "PM";
    if (hasPeriod) m = m.split("").reduce((acc, curr)=>acc += `${curr}.`, "");
    return isLowercase ? m.toLowerCase() : m;
}
function formatOrdinal(num) {
    const suffixes = [
        "th",
        "st",
        "nd",
        "rd"
    ];
    const v = num % 100;
    return num + (suffixes[(v - 20) % 10] || suffixes[v] || suffixes[0]);
}
function formatDate(date, formatStr, options = {}) {
    var _a;
    const years = date.getFullYear();
    const month = date.getMonth();
    const days = date.getDate();
    const hours = date.getHours();
    const minutes = date.getMinutes();
    const seconds = date.getSeconds();
    const milliseconds = date.getMilliseconds();
    const day = date.getDay();
    const meridiem = (_a = options.customMeridiem) != null ? _a : defaultMeridiem;
    const matches = {
        Yo: ()=>formatOrdinal(years),
        YY: ()=>String(years).slice(-2),
        YYYY: ()=>years,
        M: ()=>month + 1,
        Mo: ()=>formatOrdinal(month + 1),
        MM: ()=>`${month + 1}`.padStart(2, "0"),
        MMM: ()=>date.toLocaleDateString(options.locales, {
                month: "short"
            }),
        MMMM: ()=>date.toLocaleDateString(options.locales, {
                month: "long"
            }),
        D: ()=>String(days),
        Do: ()=>formatOrdinal(days),
        DD: ()=>`${days}`.padStart(2, "0"),
        H: ()=>String(hours),
        Ho: ()=>formatOrdinal(hours),
        HH: ()=>`${hours}`.padStart(2, "0"),
        h: ()=>`${hours % 12 || 12}`.padStart(1, "0"),
        ho: ()=>formatOrdinal(hours % 12 || 12),
        hh: ()=>`${hours % 12 || 12}`.padStart(2, "0"),
        m: ()=>String(minutes),
        mo: ()=>formatOrdinal(minutes),
        mm: ()=>`${minutes}`.padStart(2, "0"),
        s: ()=>String(seconds),
        so: ()=>formatOrdinal(seconds),
        ss: ()=>`${seconds}`.padStart(2, "0"),
        SSS: ()=>`${milliseconds}`.padStart(3, "0"),
        d: ()=>day,
        dd: ()=>date.toLocaleDateString(options.locales, {
                weekday: "narrow"
            }),
        ddd: ()=>date.toLocaleDateString(options.locales, {
                weekday: "short"
            }),
        dddd: ()=>date.toLocaleDateString(options.locales, {
                weekday: "long"
            }),
        A: ()=>meridiem(hours, minutes),
        AA: ()=>meridiem(hours, minutes, false, true),
        a: ()=>meridiem(hours, minutes, true),
        aa: ()=>meridiem(hours, minutes, true, true)
    };
    return formatStr.replace(REGEX_FORMAT, (match, $1)=>{
        var _a2, _b;
        return (_b = $1 != null ? $1 : (_a2 = matches[match]) == null ? void 0 : _a2.call(matches)) != null ? _b : match;
    });
}
function normalizeDate(date) {
    if (date === null) return new Date(Number.NaN);
    if (date === void 0) return /* @__PURE__ */ new Date();
    if (date instanceof Date) return new Date(date);
    if (typeof date === "string" && !/Z$/i.test(date)) {
        const d = date.match(REGEX_PARSE);
        if (d) {
            const m = d[2] - 1 || 0;
            const ms = (d[7] || "0").substring(0, 3);
            return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);
        }
    }
    return new Date(date);
}
function useDateFormat(date, formatStr = "HH:mm:ss", options = {}) {
    return (0, _vueDemi.computed)(()=>formatDate(normalizeDate(toValue(date)), toValue(formatStr), options));
}
function useIntervalFn(cb, interval = 1e3, options = {}) {
    const { immediate =true , immediateCallback =false  } = options;
    let timer = null;
    const isActive = (0, _vueDemi.ref)(false);
    function clean() {
        if (timer) {
            clearInterval(timer);
            timer = null;
        }
    }
    function pause() {
        isActive.value = false;
        clean();
    }
    function resume() {
        const intervalValue = toValue(interval);
        if (intervalValue <= 0) return;
        isActive.value = true;
        if (immediateCallback) cb();
        clean();
        timer = setInterval(cb, intervalValue);
    }
    if (immediate && isClient) resume();
    if ((0, _vueDemi.isRef)(interval) || typeof interval === "function") {
        const stopWatch = (0, _vueDemi.watch)(interval, ()=>{
            if (isActive.value && isClient) resume();
        });
        tryOnScopeDispose(stopWatch);
    }
    tryOnScopeDispose(pause);
    return {
        isActive,
        pause,
        resume
    };
}
function useInterval(interval = 1e3, options = {}) {
    const { controls: exposeControls = false , immediate =true , callback  } = options;
    const counter = (0, _vueDemi.ref)(0);
    const update = ()=>counter.value += 1;
    const reset = ()=>{
        counter.value = 0;
    };
    const controls = useIntervalFn(callback ? ()=>{
        update();
        callback(counter.value);
    } : update, interval, {
        immediate
    });
    if (exposeControls) return {
        counter,
        reset,
        ...controls
    };
    else return counter;
}
function useLastChanged(source, options = {}) {
    var _a;
    const ms = (0, _vueDemi.ref)((_a = options.initialValue) != null ? _a : null);
    (0, _vueDemi.watch)(source, ()=>ms.value = timestamp(), options);
    return ms;
}
function useTimeoutFn(cb, interval, options = {}) {
    const { immediate =true  } = options;
    const isPending = (0, _vueDemi.ref)(false);
    let timer = null;
    function clear() {
        if (timer) {
            clearTimeout(timer);
            timer = null;
        }
    }
    function stop() {
        isPending.value = false;
        clear();
    }
    function start(...args) {
        clear();
        isPending.value = true;
        timer = setTimeout(()=>{
            isPending.value = false;
            timer = null;
            cb(...args);
        }, toValue(interval));
    }
    if (immediate) {
        isPending.value = true;
        if (isClient) start();
    }
    tryOnScopeDispose(stop);
    return {
        isPending: (0, _vueDemi.readonly)(isPending),
        start,
        stop
    };
}
function useTimeout(interval = 1e3, options = {}) {
    const { controls: exposeControls = false , callback  } = options;
    const controls = useTimeoutFn(callback != null ? callback : noop, interval, options);
    const ready = (0, _vueDemi.computed)(()=>!controls.isPending.value);
    if (exposeControls) return {
        ready,
        ...controls
    };
    else return ready;
}
function useToNumber(value, options = {}) {
    const { method ="parseFloat" , radix , nanToZero  } = options;
    return (0, _vueDemi.computed)(()=>{
        let resolved = toValue(value);
        if (typeof resolved === "string") resolved = Number[method](resolved, radix);
        if (nanToZero && Number.isNaN(resolved)) resolved = 0;
        return resolved;
    });
}
function useToString(value) {
    return (0, _vueDemi.computed)(()=>`${toValue(value)}`);
}
function useToggle(initialValue = false, options = {}) {
    const { truthyValue =true , falsyValue =false  } = options;
    const valueIsRef = (0, _vueDemi.isRef)(initialValue);
    const _value = (0, _vueDemi.ref)(initialValue);
    function toggle(value) {
        if (arguments.length) {
            _value.value = value;
            return _value.value;
        } else {
            const truthy = toValue(truthyValue);
            _value.value = _value.value === truthy ? toValue(falsyValue) : truthy;
            return _value.value;
        }
    }
    if (valueIsRef) return toggle;
    else return [
        _value,
        toggle
    ];
}
function watchArray(source, cb, options) {
    let oldList = (options == null ? void 0 : options.immediate) ? [] : [
        ...source instanceof Function ? source() : Array.isArray(source) ? source : toValue(source)
    ];
    return (0, _vueDemi.watch)(source, (newList, _, onCleanup)=>{
        const oldListRemains = Array.from({
            length: oldList.length
        });
        const added = [];
        for (const obj of newList){
            let found = false;
            for(let i = 0; i < oldList.length; i++)if (!oldListRemains[i] && obj === oldList[i]) {
                oldListRemains[i] = true;
                found = true;
                break;
            }
            if (!found) added.push(obj);
        }
        const removed = oldList.filter((_2, i)=>!oldListRemains[i]);
        cb(newList, oldList, added, removed, onCleanup);
        oldList = [
            ...newList
        ];
    }, options);
}
function watchAtMost(source, cb, options) {
    const { count , ...watchOptions } = options;
    const current = (0, _vueDemi.ref)(0);
    const stop = watchWithFilter(source, (...args)=>{
        current.value += 1;
        if (current.value >= toValue(count)) (0, _vueDemi.nextTick)(()=>stop());
        cb(...args);
    }, watchOptions);
    return {
        count: current,
        stop
    };
}
function watchDebounced(source, cb, options = {}) {
    const { debounce =0 , maxWait , ...watchOptions } = options;
    return watchWithFilter(source, cb, {
        ...watchOptions,
        eventFilter: debounceFilter(debounce, {
            maxWait
        })
    });
}
function watchDeep(source, cb, options) {
    return (0, _vueDemi.watch)(source, cb, {
        ...options,
        deep: true
    });
}
function watchIgnorable(source, cb, options = {}) {
    const { eventFilter =bypassFilter , ...watchOptions } = options;
    const filteredCb = createFilterWrapper(eventFilter, cb);
    let ignoreUpdates;
    let ignorePrevAsyncUpdates;
    let stop;
    if (watchOptions.flush === "sync") {
        const ignore = (0, _vueDemi.ref)(false);
        ignorePrevAsyncUpdates = ()=>{};
        ignoreUpdates = (updater)=>{
            ignore.value = true;
            updater();
            ignore.value = false;
        };
        stop = (0, _vueDemi.watch)(source, (...args)=>{
            if (!ignore.value) filteredCb(...args);
        }, watchOptions);
    } else {
        const disposables = [];
        const ignoreCounter = (0, _vueDemi.ref)(0);
        const syncCounter = (0, _vueDemi.ref)(0);
        ignorePrevAsyncUpdates = ()=>{
            ignoreCounter.value = syncCounter.value;
        };
        disposables.push((0, _vueDemi.watch)(source, ()=>{
            syncCounter.value++;
        }, {
            ...watchOptions,
            flush: "sync"
        }));
        ignoreUpdates = (updater)=>{
            const syncCounterPrev = syncCounter.value;
            updater();
            ignoreCounter.value += syncCounter.value - syncCounterPrev;
        };
        disposables.push((0, _vueDemi.watch)(source, (...args)=>{
            const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;
            ignoreCounter.value = 0;
            syncCounter.value = 0;
            if (ignore) return;
            filteredCb(...args);
        }, watchOptions));
        stop = ()=>{
            disposables.forEach((fn)=>fn());
        };
    }
    return {
        stop,
        ignoreUpdates,
        ignorePrevAsyncUpdates
    };
}
function watchImmediate(source, cb, options) {
    return (0, _vueDemi.watch)(source, cb, {
        ...options,
        immediate: true
    });
}
function watchOnce(source, cb, options) {
    const stop = (0, _vueDemi.watch)(source, (...args)=>{
        (0, _vueDemi.nextTick)(()=>stop());
        return cb(...args);
    }, options);
    return stop;
}
function watchThrottled(source, cb, options = {}) {
    const { throttle =0 , trailing =true , leading =true , ...watchOptions } = options;
    return watchWithFilter(source, cb, {
        ...watchOptions,
        eventFilter: throttleFilter(throttle, trailing, leading)
    });
}
function watchTriggerable(source, cb, options = {}) {
    let cleanupFn;
    function onEffect() {
        if (!cleanupFn) return;
        const fn = cleanupFn;
        cleanupFn = void 0;
        fn();
    }
    function onCleanup(callback) {
        cleanupFn = callback;
    }
    const _cb = (value, oldValue)=>{
        onEffect();
        return cb(value, oldValue, onCleanup);
    };
    const res = watchIgnorable(source, _cb, options);
    const { ignoreUpdates  } = res;
    const trigger = ()=>{
        let res2;
        ignoreUpdates(()=>{
            res2 = _cb(getWatchSources(source), getOldValue(source));
        });
        return res2;
    };
    return {
        ...res,
        trigger
    };
}
function getWatchSources(sources) {
    if ((0, _vueDemi.isReactive)(sources)) return sources;
    if (Array.isArray(sources)) return sources.map((item)=>toValue(item));
    return toValue(sources);
}
function getOldValue(source) {
    return Array.isArray(source) ? source.map(()=>void 0) : void 0;
}
function whenever(source, cb, options) {
    const stop = (0, _vueDemi.watch)(source, (v, ov, onInvalidate)=>{
        if (v) {
            if (options == null ? void 0 : options.once) (0, _vueDemi.nextTick)(()=>stop());
            cb(v, ov, onInvalidate);
        }
    }, {
        ...options,
        once: false
    });
    return stop;
}

},{"vue-demi":"1O62H","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"bpEe2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
function render(_ctx, _cache, $props, $setup, $data, $options) {
    return $props.type ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("section", {
        key: 0,
        ref: "node",
        class: (0, _vue.normalizeClass)([
            _ctx.$style.ico,
            {
                [_ctx.$style["ico--empty"]]: !$props.label
            },
            _ctx.$style[$setup.iconClassName]
        ]),
        style: (0, _vue.normalizeStyle)({
            fontSize: `${$props.size}px`
        })
    }, [
        $props.label ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("article", {
            key: 0,
            class: (0, _vue.normalizeClass)([
                _ctx.$style.txt,
                _ctx.$style[`txt-${$props.type}`],
                _ctx.$style[`txt-${$props.type}--${$setup.state}`]
            ])
        }, (0, _vue.toDisplayString)($props.label), 3 /* TEXT, CLASS */ )) : (0, _vue.createCommentVNode)("v-if", true)
    ], 6 /* CLASS, STYLE */ )) : (0, _vue.createCommentVNode)("v-if", true);
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("c36ef3-hmr", render);
});

},{"vue":"dmrjI","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"9L6d4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _interactiveIconVue = require("template:./InteractiveIcon.vue");
let cssModules = {
    "$style": {
        "ico": "_ico_gr4tf_1",
        "ico--empty": "_ico--empty_gr4tf_10",
        "txt": "_txt_gr4tf_14",
        "txt-save": "_txt-save_gr4tf_25",
        "txt-save--click": "_txt-save--click_gr4tf_29",
        "txt-delete": "_txt-delete_gr4tf_33",
        "txt-delete--click": "_txt-delete--click_gr4tf_37",
        "img-close--click": "_img-close--click_gr4tf_51",
        "img-close--default": "_img-close--default_gr4tf_55",
        "img-close--disable": "_img-close--disable_gr4tf_59",
        "img-close--hover": "_img-close--hover_gr4tf_63",
        "img-collect--click": "_img-collect--click_gr4tf_67",
        "img-collect--default": "_img-collect--default_gr4tf_71",
        "img-collect--disable": "_img-collect--disable_gr4tf_75",
        "img-collect--hover": "_img-collect--hover_gr4tf_79",
        "img-copy--click": "_img-copy--click_gr4tf_83",
        "img-copy--default": "_img-copy--default_gr4tf_87",
        "img-copy--disable": "_img-copy--disable_gr4tf_91",
        "img-copy--hover": "_img-copy--hover_gr4tf_95",
        "img-delete--click": "_img-delete--click_gr4tf_99",
        "img-delete--default": "_img-delete--default_gr4tf_103",
        "img-delete--hover": "_img-delete--hover_gr4tf_107",
        "img-previous--click": "_img-previous--click_gr4tf_111",
        "img-previous--default": "_img-previous--default_gr4tf_115",
        "img-previous--disable": "_img-previous--disable_gr4tf_119",
        "img-previous--hover": "_img-previous--hover_gr4tf_123",
        "img-setting--click": "_img-setting--click_gr4tf_127",
        "img-setting--default": "_img-setting--default_gr4tf_131",
        "img-setting--disable": "_img-setting--disable_gr4tf_135",
        "img-setting--hover": "_img-setting--hover_gr4tf_139",
        "img-keep--click": "_img-keep--click_gr4tf_143",
        "img-keep--default": "_img-keep--default_gr4tf_147",
        "img-keep--hover": "_img-keep--hover_gr4tf_151",
        "img-save--click": "_img-save--click_gr4tf_155",
        "img-save--default": "_img-save--default_gr4tf_159",
        "img-save--hover": "_img-save--hover_gr4tf_163",
        "img-pencil--click": "_img-pencil--click_gr4tf_167",
        "img-pencil--default": "_img-pencil--default_gr4tf_171",
        "img-pencil--hover": "_img-pencil--hover_gr4tf_175",
        "img-send--default": "_img-send--default_gr4tf_179",
        "img-send--hover": "_img-send--hover_gr4tf_183",
        "img-send--click": "_img-send--click_gr4tf_187"
    }
};
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("c36ef3-hmr", (0, _interactiveIconVue.render));
});
exports.default = cssModules;

},{"template:./InteractiveIcon.vue":"bpEe2","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"2BL3b":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"6qnSn":[function(require,module,exports) {
module.exports = require("aa5607882416dbab").getBundleURL("ceSdd") + "icon.520a0ac5.png" + "?" + Date.now();

},{"aa5607882416dbab":"eCfaW"}],"eCfaW":[function(require,module,exports) {
"use strict";
var bundleURL = {};
function getBundleURLCached(id) {
    var value = bundleURL[id];
    if (!value) {
        value = getBundleURL();
        bundleURL[id] = value;
    }
    return value;
}
function getBundleURL() {
    try {
        throw new Error();
    } catch (err) {
        var matches = ("" + err.stack).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/[^)\n]+/g);
        if (matches) // The first two stack frames will be this function and getBundleURLCached.
        // Use the 3rd one, which will be a runtime in the original bundle.
        return getBaseURL(matches[2]);
    }
    return "/";
}
function getBaseURL(url) {
    return ("" + url).replace(/^((?:https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/.+)\/[^/]+$/, "$1") + "/";
}
// TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.
function getOrigin(url) {
    var matches = ("" + url).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/[^/]+/);
    if (!matches) throw new Error("Origin not found");
    return matches[0];
}
exports.getBundleURL = getBundleURLCached;
exports.getBaseURL = getBaseURL;
exports.getOrigin = getOrigin;

},{}],"9NGvj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
const _hoisted_1 = [
    "src"
];
function render(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("section", {
        class: (0, _vue.normalizeClass)(_ctx.$style.headerPanel)
    }, [
        (0, _vue.createElementVNode)("section", {
            class: (0, _vue.normalizeClass)(_ctx.$style.headerLogos)
        }, [
            (0, _vue.createElementVNode)("img", {
                class: (0, _vue.normalizeClass)(_ctx.$style.logo),
                src: $setup.SamsungLogo
            }, null, 10 /* CLASS, PROPS */ , _hoisted_1),
            (0, _vue.createElementVNode)("span", {
                class: (0, _vue.normalizeClass)(_ctx.$style.headerText)
            }, "Samsung", 2 /* CLASS */ )
        ], 2 /* CLASS */ ),
        (0, _vue.createElementVNode)("section", {
            class: (0, _vue.normalizeClass)(_ctx.$style.headerIcons)
        }, [
            (0, _vue.withDirectives)((0, _vue.createVNode)($setup["Popper"], {
                class: (0, _vue.normalizeClass)(_ctx.$style.popover),
                hover: "",
                "offset-distance": "8",
                placement: "top"
            }, {
                content: (0, _vue.withCtx)(()=>[
                        (0, _vue.createElementVNode)("span", {
                            class: (0, _vue.normalizeClass)(_ctx.$style.popoverText)
                        }, "Settings", 2 /* CLASS */ )
                    ]),
                default: (0, _vue.withCtx)(()=>[
                        (0, _vue.createVNode)($setup["InteractiveIcon"], {
                            class: (0, _vue.normalizeClass)(_ctx.$style.icon),
                            type: "setting",
                            onClick: $setup.openSettingPage
                        }, null, 8 /* PROPS */ , [
                            "class"
                        ])
                    ]),
                _: 1 /* STABLE */ 
            }, 8 /* PROPS */ , [
                "class"
            ]), [
                [
                    (0, _vue.vShow),
                    false
                ]
            ]),
            (0, _vue.createVNode)($setup["Popper"], {
                class: (0, _vue.normalizeClass)(_ctx.$style.popover),
                hover: "",
                "offset-distance": "8",
                placement: "top"
            }, {
                content: (0, _vue.withCtx)(()=>[
                        (0, _vue.createElementVNode)("span", {
                            class: (0, _vue.normalizeClass)(_ctx.$style.popoverText)
                        }, "Close", 2 /* CLASS */ )
                    ]),
                default: (0, _vue.withCtx)(()=>[
                        (0, _vue.createVNode)($setup["InteractiveIcon"], {
                            class: (0, _vue.normalizeClass)(_ctx.$style.icon),
                            type: "close",
                            onClick: $setup.closePopup
                        }, null, 8 /* PROPS */ , [
                            "class"
                        ])
                    ]),
                _: 1 /* STABLE */ 
            }, 8 /* PROPS */ , [
                "class"
            ])
        ], 2 /* CLASS */ )
    ], 2 /* CLASS */ );
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("f6fb50-hmr", render);
});

},{"vue":"dmrjI","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"3IQCi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _headerPanelVue = require("template:./HeaderPanel.vue");
let cssModules = {
    "$style": {
        "headerPanel": "_headerPanel_1r4be_1",
        "headerLogos": "_headerLogos_1r4be_8",
        "headerIcons": "_headerIcons_1r4be_15",
        "headerText": "_headerText_1r4be_22",
        "logo": "_logo_1r4be_30",
        "icon": "_icon_1r4be_37",
        "popoverText": "_popoverText_1r4be_50",
        "popover": "_popover_1r4be_50"
    }
};
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("f6fb50-hmr", (0, _headerPanelVue.render));
});
exports.default = cssModules;

},{"template:./HeaderPanel.vue":"9NGvj","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"2hYoE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"iGRiO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require("154f556e1e81b8d8");
    if (script.__esModule) script = script.default;
    script.render = require("bfb7bd6eb126dbdd").render;
    script.__cssModules = require("ce3b4def33759402").default;
    require("9f05fb1fa74984a8").default(script);
    script.__scopeId = "data-v-afc26c";
    script.__file = "/Users/mahbubislammahim/Desktop/Development/Webpilot/src/components/WebpilotAlert.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "afc26c-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("afc26c-hmr", script)) __VUE_HMR_RUNTIME__.reload("afc26c-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"154f556e1e81b8d8":"lsOrj","bfb7bd6eb126dbdd":"2ftiI","ce3b4def33759402":"bxn67","9f05fb1fa74984a8":"5aQ16","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"lsOrj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _vue = require("vue");
var _core = require("@vueuse/core");
var _iconAlertInfoVue = require("./icon/IconAlertInfo.vue");
var _iconAlertInfoVueDefault = parcelHelpers.interopDefault(_iconAlertInfoVue);
var _iconAlertErrorVue = require("./icon/IconAlertError.vue");
var _iconAlertErrorVueDefault = parcelHelpers.interopDefault(_iconAlertErrorVue);
var _iconAlertSuccessVue = require("./icon/IconAlertSuccess.vue");
var _iconAlertSuccessVueDefault = parcelHelpers.interopDefault(_iconAlertSuccessVue);
exports.default = {
    __name: "WebpilotAlert",
    props: {
        type: {
            type: String,
            required: true,
            default: ""
        },
        tips: {
            type: String,
            required: true
        },
        color: {
            type: String,
            default: "#585b58"
        },
        autoHide: {
            type: Boolean,
            default: false
        }
    },
    emits: [
        "onHide"
    ],
    setup (__props, { expose: __expose , emit: emits  }) {
        __expose();
        const props = __props;
        const refAlert = (0, _vue.ref)(null);
        (0, _core.onClickOutside)(refAlert, ()=>{
            if (props.autoHide) emits("onHide");
        });
        const ALERT_TYPE = {
            INFO: "info",
            ERROR: "error",
            SUCCESS: "success"
        };
        const __returned__ = {
            props,
            emits,
            refAlert,
            ALERT_TYPE,
            ref: (0, _vue.ref),
            get onClickOutside () {
                return 0, _core.onClickOutside;
            },
            IconAlertInfo: (0, _iconAlertInfoVueDefault.default),
            IconError: (0, _iconAlertErrorVueDefault.default),
            IconSuccess: (0, _iconAlertSuccessVueDefault.default)
        };
        Object.defineProperty(__returned__, "__isScriptSetup", {
            enumerable: false,
            value: true
        });
        return __returned__;
    }
};

},{"vue":"dmrjI","@vueuse/core":"fa5y9","./icon/IconAlertInfo.vue":"jvDno","./icon/IconAlertError.vue":"3DwtW","./icon/IconAlertSuccess.vue":"jrWgh","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"jvDno":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = {};
    script.render = require("36a3b3982fc730e8").render;
    require("4f85252bccbb3dd7").default(script);
    script.__scopeId = "data-v-656d53";
    script.__file = "/Users/mahbubislammahim/Desktop/Development/Webpilot/src/components/icon/IconAlertInfo.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "656d53-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("656d53-hmr", script)) __VUE_HMR_RUNTIME__.reload("656d53-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"36a3b3982fc730e8":"5UcO2","4f85252bccbb3dd7":"2D9OA","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"5UcO2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
const _hoisted_1 = {
    fill: "none",
    height: "16",
    viewBox: "0 0 16 16",
    width: "16",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /*#__PURE__*/ (0, _vue.createElementVNode)("path", {
    "clip-rule": "evenodd",
    d: "M8 0C12.4183 0 16 3.58172 16 8C16 12.4183 12.4183 16 8 16C3.58172 16 0 12.4183 0 8C0 3.58172 3.58172 0 8 0Z",
    fill: "#4F5AFF",
    "fill-rule": "evenodd"
}, null, -1 /* HOISTED */ );
const _hoisted_3 = /*#__PURE__*/ (0, _vue.createElementVNode)("path", {
    "clip-rule": "evenodd",
    d: "M8.00009 6.18182C8.60258 6.18182 9.091 5.6934 9.091 5.09091C9.091 4.48842 8.60258 4 8.00009 4C7.3976 4 6.90918 4.48842 6.90918 5.09091C6.90918 5.6934 7.3976 6.18182 8.00009 6.18182ZM8.90918 8C8.90918 7.49792 8.50217 7.09091 8.00009 7.09091C7.75898 7.09091 7.52775 7.18669 7.35726 7.35718C7.18678 7.52766 7.091 7.75889 7.091 8V10.9091C7.091 11.4112 7.49801 11.8182 8.00009 11.8182C8.50217 11.8182 8.90918 11.4112 8.90918 10.9091V8Z",
    fill: "white",
    "fill-rule": "evenodd"
}, null, -1 /* HOISTED */ );
const _hoisted_4 = [
    _hoisted_2,
    _hoisted_3
];
function render(_ctx, _cache) {
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("svg", _hoisted_1, _hoisted_4);
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("656d53-hmr", render);
});

},{"vue":"dmrjI","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"2D9OA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"3DwtW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = {};
    script.render = require("ce42b52c76e51a5b").render;
    require("7c1e460111f9fb8").default(script);
    script.__scopeId = "data-v-1e8649";
    script.__file = "/Users/mahbubislammahim/Desktop/Development/Webpilot/src/components/icon/IconAlertError.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "1e8649-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("1e8649-hmr", script)) __VUE_HMR_RUNTIME__.reload("1e8649-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"ce42b52c76e51a5b":"lfZ5V","7c1e460111f9fb8":"kpqP5","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"lfZ5V":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
const _hoisted_1 = {
    fill: "none",
    height: "16",
    viewBox: "0 0 16 16",
    width: "16",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /*#__PURE__*/ (0, _vue.createStaticVNode)('<g clip-path="url(#clip0_1747_3165)"><path clip-rule="evenodd" d="M16 8.00058C15.9992 8.19137 15.9235 8.3742 15.7891 8.50967L8.51636 15.7824C8.38031 15.9212 8.19436 15.9998 8 16.0006C7.80921 15.9998 7.62637 15.924 7.49091 15.7897L0.218182 8.51694C0.0793777 8.38089 0.000806854 8.19494 0 8.00058C0.000806854 7.80622 0.0793777 7.62027 0.218182 7.48421L7.49091 0.211486C7.77457 -0.0704952 8.2327 -0.0704952 8.51636 0.211486L15.7891 7.48421C15.9252 7.62146 16.0011 7.80727 16 8.00058Z" fill="#CC0000" fill-rule="evenodd"></path><path clip-rule="evenodd" d="M7.27246 8.00062C7.27246 8.40228 7.59807 8.72789 7.99973 8.72789C8.4014 8.72789 8.72701 8.40228 8.72701 8.00062V5.09153C8.72701 4.68987 8.4014 4.36426 7.99973 4.36426C7.59807 4.36426 7.27246 4.68987 7.27246 5.09153V8.00062ZM7.99973 10.9097C8.4014 10.9097 8.72701 10.5841 8.72701 10.1824C8.72701 9.78078 8.4014 9.45517 7.99973 9.45517C7.59807 9.45517 7.27246 9.78078 7.27246 10.1824C7.27246 10.5841 7.59807 10.9097 7.99973 10.9097Z" fill="white" fill-rule="evenodd"></path></g><defs><clipPath id="clip0_1747_3165"><rect fill="white" height="16" width="16"></rect></clipPath></defs>', 2);
const _hoisted_4 = [
    _hoisted_2
];
function render(_ctx, _cache) {
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("svg", _hoisted_1, _hoisted_4);
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("1e8649-hmr", render);
});

},{"vue":"dmrjI","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"kpqP5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"jrWgh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = {};
    script.render = require("ec153fee9e044e86").render;
    require("14ac6f994fbcb482").default(script);
    script.__scopeId = "data-v-f5b589";
    script.__file = "/Users/mahbubislammahim/Desktop/Development/Webpilot/src/components/icon/IconAlertSuccess.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "f5b589-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("f5b589-hmr", script)) __VUE_HMR_RUNTIME__.reload("f5b589-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"ec153fee9e044e86":"69EQh","14ac6f994fbcb482":"hxp9Q","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"69EQh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
const _hoisted_1 = {
    fill: "none",
    height: "16",
    viewBox: "0 0 16 16",
    width: "16",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /*#__PURE__*/ (0, _vue.createElementVNode)("path", {
    "clip-rule": "evenodd",
    d: "M8 0C12.4183 0 16 3.58172 16 8C16 12.4183 12.4183 16 8 16C3.58172 16 0 12.4183 0 8C0 3.58172 3.58172 0 8 0Z",
    fill: "#318619",
    "fill-rule": "evenodd"
}, null, -1 /* HOISTED */ );
const _hoisted_3 = /*#__PURE__*/ (0, _vue.createElementVNode)("path", {
    "clip-rule": "evenodd",
    d: "M7.27243 11.2729C7.08017 11.274 6.87958 11.1479 6.74307 11.0128L4.57309 8.84795C4.38961 8.6649 4.31796 8.39811 4.38512 8.14806C4.45227 7.89801 4.64804 7.7027 4.89868 7.6357C5.14931 7.56871 5.41674 7.64019 5.60022 7.82324L7.1626 9.41803L10.2874 5.08828C10.4267 4.85358 10.6868 4.71731 10.9595 4.73609C11.2323 4.75488 11.4712 4.9255 11.5768 5.17707C11.6825 5.42864 11.637 5.71817 11.4592 5.92536L7.84253 10.9767C7.71983 11.1504 7.52665 11.2613 7.3145 11.2798L7.27243 11.2729Z",
    fill: "white",
    "fill-rule": "evenodd"
}, null, -1 /* HOISTED */ );
const _hoisted_4 = [
    _hoisted_2,
    _hoisted_3
];
function render(_ctx, _cache) {
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("svg", _hoisted_1, _hoisted_4);
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("f5b589-hmr", render);
});

},{"vue":"dmrjI","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"hxp9Q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"2ftiI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
function render(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("section", {
        ref: "refAlert",
        class: (0, _vue.normalizeClass)({
            [_ctx.$style.tips]: true,
            [_ctx.$style.tipsError]: $props.type === $setup.ALERT_TYPE.ERROR,
            [_ctx.$style.tipsSuccess]: $props.type === $setup.ALERT_TYPE.SUCCESS
        })
    }, [
        (0, _vue.renderSlot)(_ctx.$slots, "icon", {}, ()=>[
                (0, _vue.createElementVNode)("article", {
                    class: (0, _vue.normalizeClass)(_ctx.$style.icon)
                }, [
                    $props.type === $setup.ALERT_TYPE.INFO ? ((0, _vue.openBlock)(), (0, _vue.createBlock)($setup["IconAlertInfo"], {
                        key: 0
                    })) : (0, _vue.createCommentVNode)("v-if", true),
                    $props.type === $setup.ALERT_TYPE.SUCCESS ? ((0, _vue.openBlock)(), (0, _vue.createBlock)($setup["IconSuccess"], {
                        key: 1
                    })) : (0, _vue.createCommentVNode)("v-if", true),
                    $props.type === $setup.ALERT_TYPE.ERROR ? ((0, _vue.openBlock)(), (0, _vue.createBlock)($setup["IconError"], {
                        key: 2
                    })) : (0, _vue.createCommentVNode)("v-if", true)
                ], 2 /* CLASS */ )
            ]),
        (0, _vue.createTextVNode)(" " + (0, _vue.toDisplayString)($props.tips), 1 /* TEXT */ )
    ], 2 /* CLASS */ );
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("afc26c-hmr", render);
});

},{"vue":"dmrjI","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"bxn67":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _webpilotAlertVue = require("template:./WebpilotAlert.vue");
let cssModules = {
    "$style": {
        "tips": "_tips_knbqx_1",
        "icon": "_icon_knbqx_16",
        "tipsSuccess": "_tipsSuccess_knbqx_20",
        "tipsError": "_tipsError_knbqx_24"
    }
};
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("afc26c-hmr", (0, _webpilotAlertVue.render));
});
exports.default = cssModules;

},{"template:./WebpilotAlert.vue":"2ftiI","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"5aQ16":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"7dyjF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require("cbd9a6bbd77e0ff0");
    if (script.__esModule) script = script.default;
    script.render = require("b35836ee4f670c62").render;
    script.__cssModules = require("99ff2015f1e77751").default;
    require("f6d7ca54b3a86d40").default(script);
    script.__scopeId = "data-v-e7c2fc";
    script.__file = "/Users/mahbubislammahim/Desktop/Development/Webpilot/src/components/TipsShortcut.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "e7c2fc-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("e7c2fc-hmr", script)) __VUE_HMR_RUNTIME__.reload("e7c2fc-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"cbd9a6bbd77e0ff0":"3Ka8O","b35836ee4f670c62":"30XXS","99ff2015f1e77751":"eiMpS","f6d7ca54b3a86d40":"lQTpB","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"3Ka8O":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _vue = require("vue");
var _store = require("@/stores/store");
var _storeDefault = parcelHelpers.interopDefault(_store);
var _utils = require("@/utils");
exports.default = {
    __name: "TipsShortcut",
    setup (__props, { expose: __expose  }) {
        __expose();
        const store = (0, _storeDefault.default)();
        const shortcut = (0, _vue.computed)(()=>{
            return (0, _utils.formatShortcut)(store.config.customShortcut);
        });
        const __returned__ = {
            store,
            shortcut,
            computed: (0, _vue.computed),
            get useStore () {
                return 0, _storeDefault.default;
            },
            get formatShortcut () {
                return 0, _utils.formatShortcut;
            }
        };
        Object.defineProperty(__returned__, "__isScriptSetup", {
            enumerable: false,
            value: true
        });
        return __returned__;
    }
};

},{"vue":"dmrjI","@/stores/store":"6gHZ2","@/utils":"bP42X","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"bP42X":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getOS", ()=>getOS);
parcelHelpers.export(exports, "formatShortcut", ()=>formatShortcut);
parcelHelpers.export(exports, "getRectFromInputAndTextarea", ()=>getRectFromInputAndTextarea);
parcelHelpers.export(exports, "getAllScrollableParents", ()=>getAllScrollableParents);
var global = arguments[3];
function getOS() {
    const { userAgent , platform  } = global.navigator;
    const macosPlatforms = [
        "Macintosh",
        "MacIntel",
        "MacPPC",
        "Mac68K"
    ];
    const windowsPlatforms = [
        "Win32",
        "Win64",
        "Windows",
        "WinCE"
    ];
    const iosPlatforms = [
        "iPhone",
        "iPad",
        "iPod"
    ];
    let os = null;
    if (macosPlatforms.indexOf(platform) !== -1) os = "Mac OS";
    else if (iosPlatforms.indexOf(platform) !== -1) os = "iOS";
    else if (windowsPlatforms.indexOf(platform) !== -1) os = "Windows";
    else if (/Android/.test(userAgent)) os = "Android";
    else if (!os && /Linux/.test(platform)) os = "Linux";
    return os;
}
function formatShortcut(keys) {
    let keyList = keys;
    keyList = keyList.map((item)=>{
        if (item === "Control") return "Ctrl";
        if (item === "Meta") return "Cmd";
        if (item === " " && (item.charCodeAt() === 160 || item.charCodeAt() === 32)) return "Space";
        // if (item === 'Meta') return '\u2318'
        return item.length === 1 ? item.toUpperCase() : item;
    });
    return keyList.join(" + ");
}
function getRectFromInputAndTextarea(target) {
    const { selectionEnd , selectionStart  } = target;
    const cloneElement = document.createElement("span");
    const { top , left  } = target.getBoundingClientRect();
    const style = window.getComputedStyle(target);
    cloneElement.textContent = target.value;
    cloneElement.style.whiteSpace = "pre-wrap";
    cloneElement.style.visibility = "hidden";
    cloneElement.style.position = "fixed";
    cloneElement.style.top = `${top}px`;
    cloneElement.style.left = `${left}px`;
    cloneElement.style.width = style.width;
    cloneElement.style.height = style.height;
    cloneElement.style.margin = style.margin;
    cloneElement.style.padding = style.padding;
    cloneElement.style.fontFamily = style.fontFamily;
    cloneElement.style.fontSize = style.fontSize;
    cloneElement.style.lineHeight = style.lineHeight;
    cloneElement.style.fontWeight = style.fontWeight;
    cloneElement.style.borderTop = style.borderTop;
    cloneElement.style.borderLeft = style.borderLeft;
    cloneElement.style.borderRight = style.borderRight;
    cloneElement.style.borderBottom = style.borderBottom;
    cloneElement.style.backgroundColor = "white";
    // add to document
    document.body.appendChild(cloneElement);
    // set selection content on cloneelement
    const range = new Range();
    range.setStart(cloneElement.firstChild, selectionStart);
    range.setEnd(cloneElement.firstChild, selectionEnd);
    const selection = window.getSelection();
    selection.removeAllRanges();
    selection.addRange(range);
    // get rect
    const rect = selection.getRangeAt(0).getBoundingClientRect();
    // remove clone elemnt
    document.body.removeChild(cloneElement);
    // recovery textarear or input selection
    target.setSelectionRange(selectionStart, selectionEnd);
    return rect;
}
function getAllScrollableParents(element) {
    const scrollableElemetns = [];
    let tempElement = element;
    while(tempElement){
        const { scrollHeight , clientHeight  } = tempElement;
        const { overflowY  } = window.getComputedStyle(tempElement);
        if (scrollHeight > clientHeight && overflowY !== "hidden") // scroll event not works on HTML tag, replace it with window
        scrollableElemetns.push(tempElement.tagName === "HTML" ? window : tempElement);
        tempElement = tempElement?.parentElement;
    }
    return scrollableElemetns;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"30XXS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
function render(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("section", {
        class: (0, _vue.normalizeClass)(_ctx.$style.shortcutWrap)
    }, [
        (0, _vue.createElementVNode)("span", {
            class: (0, _vue.normalizeClass)(_ctx.$style.shortcutText)
        }, "Shortcut:", 2 /* CLASS */ ),
        (0, _vue.createElementVNode)("section", {
            class: (0, _vue.normalizeClass)(_ctx.$style.shortcutKeys)
        }, (0, _vue.toDisplayString)($setup.shortcut), 3 /* TEXT, CLASS */ )
    ], 2 /* CLASS */ );
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("e7c2fc-hmr", render);
});

},{"vue":"dmrjI","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"eiMpS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tipsShortcutVue = require("template:./TipsShortcut.vue");
let cssModules = {
    "$style": {
        "shortcutWrap": "_shortcutWrap_dq9o7_1",
        "shortcutText": "_shortcutText_dq9o7_7",
        "shortcutKeys": "_shortcutKeys_dq9o7_14"
    }
};
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("e7c2fc-hmr", (0, _tipsShortcutVue.render));
});
exports.default = cssModules;

},{"template:./TipsShortcut.vue":"30XXS","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"lQTpB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"eujuA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
const _hoisted_1 = {
    role: "list"
};
function render(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("section", {
        class: (0, _vue.normalizeClass)(_ctx.$style.notSupportPaeg)
    }, [
        (0, _vue.createVNode)($setup["HeaderPanel"], {
            onOnClose: $setup.closeWindow
        }),
        (0, _vue.createElementVNode)("section", {
            class: (0, _vue.normalizeClass)(_ctx.$style.tipsWrap)
        }, [
            (0, _vue.createVNode)($setup["WebpilotAlert"], {
                tips: $setup.$gettext("Current Webpage Not Supported"),
                type: "error"
            }, null, 8 /* PROPS */ , [
                "tips"
            ])
        ], 2 /* CLASS */ ),
        (0, _vue.createElementVNode)("section", {
            class: (0, _vue.normalizeClass)(_ctx.$style.explain)
        }, [
            (0, _vue.createTextVNode)((0, _vue.toDisplayString)($setup.$gettext("Due to Chrome's constraints, Webpilot cannot be activated on the following webpages:")) + " ", 1 /* TEXT */ ),
            (0, _vue.createElementVNode)("ul", _hoisted_1, [
                (0, _vue.createElementVNode)("li", null, (0, _vue.toDisplayString)($setup.$gettext("Chrome's Settings, History, and Web Store pages")), 1 /* TEXT */ ),
                (0, _vue.createElementVNode)("li", null, (0, _vue.toDisplayString)($setup.$gettext("New tab and blank pages")), 1 /* TEXT */ )
            ])
        ], 2 /* CLASS */ ),
        (0, _vue.createVNode)($setup["TipsShortcut"], {
            class: (0, _vue.normalizeClass)(_ctx.$style.shortcut)
        }, null, 8 /* PROPS */ , [
            "class"
        ])
    ], 2 /* CLASS */ );
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("65f623-hmr", render);
});

},{"vue":"dmrjI","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"fV5z7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _webpilotPopupVue = require("template:./WebpilotPopup.vue");
let cssModules = {
    "$style": {
        "notSupportPaeg": "_notSupportPaeg_9a04i_1",
        "tipsWrap": "_tipsWrap_9a04i_9",
        "explain": "_explain_9a04i_13",
        "shortcut": "_shortcut_9a04i_28"
    }
};
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("65f623-hmr", (0, _webpilotPopupVue.render));
});
exports.default = cssModules;

},{"template:./WebpilotPopup.vue":"eujuA","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"a48Dg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"hJnhS":[function() {},{}],"3xB5O":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
function render(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div");
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("fa6ae5-hmr", render);
});

},{"vue":"dmrjI","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"jRlsO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}]},["cQRzy","4z694"], "4z694", "parcelRequire3cd7")

//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUMsRUFBRSxFQUFDLEFBQUMsQ0FBQSxNQUFJLEtBQUcsTUFBTSxRQUFRLE1BQUksQ0FBQyxDQUFDLEVBQUUsU0FBTyxFQUFFLEtBQUcsQ0FBQSxLQUFJLEVBQUUsS0FBSztRQUFDO1FBQUU7S0FBRTtJQUFFLE9BQU8sRUFBRSxVQUFTLENBQUEsSUFBRSxFQUFFLE9BQU8sRUFBRSxFQUFFLFFBQU8sR0FBRSxHQUFHO0FBQUM7QUFBQyxTQUFTLEVBQUUsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO0lBQUUsSUFBRyxFQUFFLEdBQUUsR0FBRSxJQUFHLE9BQU0sQ0FBQztJQUFFLElBQUksSUFBRSxFQUFFLE9BQU8sT0FBTyxNQUFLLElBQUcsSUFBRSxDQUFDO0lBQUUsTUFBSyxFQUFFLFNBQU8sR0FBRztRQUFDLElBQUcsQ0FBQyxHQUFFLEVBQUUsR0FBQyxFQUFFO1FBQVEsSUFBRyxFQUFFLEdBQUUsR0FBRSxPQUFNLElBQUUsQ0FBQzthQUFNO1lBQUMsSUFBSSxJQUFFLEVBQUUsT0FBTyxPQUFPLE1BQUs7WUFBRyxJQUFHLEVBQUUsV0FBUyxHQUFFO2dCQUFDLElBQUUsQ0FBQztnQkFBRTtZQUFLO1lBQUMsRUFBRSxRQUFRO1FBQUU7SUFBQztJQUFDLE9BQU87QUFBQztBQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7SUFBRSxJQUFHLEVBQUMsU0FBUSxFQUFDLEVBQUMsR0FBQztJQUFFLElBQUcsQ0FBQyxHQUFFLE9BQU0sQ0FBQztJQUFFLElBQUcsS0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLGNBQWMsRUFBQyxPQUFPLEVBQUUsU0FBTyxFQUFFLEVBQUUsUUFBTyxHQUFFLEtBQUcsQ0FBQztJQUFFLElBQUcsRUFBRSxhQUFhLENBQUMsRUFBRSxFQUFDLE9BQU0sQ0FBQztJQUFFLEVBQUUsYUFBYSxDQUFDLEVBQUUsR0FBQyxDQUFDO0lBQUUsSUFBSSxJQUFFLEVBQUUsS0FBSyxDQUFDLEVBQUU7SUFBQyxPQUFPLEVBQUUsZ0JBQWdCLEtBQUs7UUFBQztRQUFFO0tBQUUsR0FB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WUFBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsUUFBUSxHQUFFLElBQUcsTUFBSSxNQUFJO1FBQUM7UUFBQyxPQUFPO0lBQUMsRUFBRTtJQUFBLFNBQU8sT0FBTSxJQUFHLEFBQUMsQ0FBQSxNQUFNLElBQUksQ0FBQyxXQUFXO1lBQUM7U0FBRSxDQUFBLENBQUUsQ0FBQyxFQUFFLENBQUM7SUFBQSxhQUFXLE9BQU0sSUFBRyxJQUFJLENBQUMsa0JBQWdCLE1BQU0sSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBRyxFQUFFLE9BQU8sSUFBSSxDQUFDLFVBQVUsT0FBTyxDQUFDLEdBQUUsSUFBSyxDQUFBLENBQUMsQ0FBQyxFQUFFLEdBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLFFBQVEsSUFBRyxDQUFBLEdBQUcsQ0FBQyxHQUFHO0lBQUEsU0FBTyxPQUFNLEdBQUUsSUFBSSxNQUFNLElBQUksQ0FBQyxXQUFXO1lBQUMsQ0FBQyxFQUFFLEVBQUM7UUFBQyxHQUFHO0lBQUEsYUFBVyxPQUFNLElBQUksQ0FBQSxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUUsT0FBTyxRQUFRLEdBQUcsT0FBTyxDQUFDLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxTQUFTLElBQUksUUFBUSxDQUFDLENBQUMsR0FBRSxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsR0FBRSxLQUFJLElBQUksQ0FBQyxtQkFBaUIsTUFBTSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFHLElBQUcsRUFBRztJQUFBLFFBQU0sT0FBTSxJQUFFLENBQUMsQ0FBQztRQUFJLEtBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLFNBQVEsTUFBTSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFBTyxFQUFFO0lBQUEsWUFBVSxPQUFNO1FBQUksTUFBTSxJQUFJLENBQUMsY0FBYztZQUFDO1NBQUU7SUFBQyxFQUFFO0lBQUEsZ0JBQWMsT0FBTTtRQUFJLElBQUksQ0FBQyxDQUFDLENBQUMs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Q0FBQTtBQUNBLEtBQUE7a0I7SSxRO0ksTyxPLEUsRSxRLFMsRTtRO1FBRUEsTUFBTSxjQUFjO1lBQ2xCLE9BQU87UUFDVDtRLE0sZTtZO1ksSSxZO2dCLE8sRztZO3lCLEMsRyw4QjsyQixDLEcsZ0M7MEIsQyxHLCtCO1E7USxPLGUsYyxtQjtZLFk7WSxPO1E7USxPO0k7QTs7Ozs7QUNqRkMsSUFBSTtBQUNKLElBQUksYUFBYTtJQUNmLFNBQVMsUUFBUTtJQUNqQixJQUFJLE9BQU8sWUFBWSxTQUFTLE9BQU87SUFDdkMsT0FBTyxTQUFTLFFBQVEsb0JBQThCO0lBQ3RELE9BQU8sZUFBZSxRQUFRLG9CQUEyQjtJQUN6RCxRQUFRLG9CQUE0QixRQUFRO0lBQzVDLE9BQU8sWUFBWTtJQUNuQixPQUFPLFNBQVM7QUFDbEI7QUFDQTtBQUNBLElBQUksT0FBTyxLQUFLO0lBQ2QsT0FBTyxVQUFVO0lBQ2pCLE9BQU8sSUFBSSxPQUFPO1FBQ2hCLFdBQVc7WUFDVDtZQUNBLElBQUksQ0FBQyxvQkFBb0IsYUFBYSxjQUFjLFNBQ2xELG9CQUFvQixPQUFPLGNBQWM7UUFFN0MsR0FBRztJQUNMO0FBQ0Y7a0JBQ2U7Ozs7O0FBQ2hCO0FBQ0E7O0FBRUE7O0FBRUE7O2tCO0ksUTtJLE87UTtLO0ksTyxPLEUsRSxRLFMsRSxNLE0sRTtRO1FBSUEsTUFBTSxrQkFBa0I7WUFDdEIsQ0FBQSxHQUFBLDJCQUFlLEVBQUU7Z0JBQUMsTUFBTTtZQUFhO1FBQ3ZDO1FBRUEsTUFBTSxhQUFhO1lBQ2pCLE1BQU07UUFDUjtRLE0sZTtZO1k7WTtZLEksb0I7Z0IsTyxHO1k7WSxJLFU7Z0IsTyxHO1k7WSxJLGU7Z0IsTyxHO1k7NkIsQyxHLGtDO1E7USxPLGUsYyxtQjtZLFk7WSxPO1E7USxPO0k7QTs7Ozs7QUN2Q214QywyQ0FBTztBQUFQLGtEQUFrQjtBQUFsQiwrREFBb0M7QUFBcEMsc0RBQW1FO0FBQW5FLDhEQUF5RjtBQUF6Rix5REFBdUg7QUFBdkgsa0RBQWdKO0FBQW42QztBQUFnQyxJQUFJLElBQUUsV0FBVyxTQUFTLFdB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O1FBQTBCLFlBQVc7UUFBb0IsV0FBVTtRQUFvQixZQUFXO0lBQW9CO0FBQUM7QUFDcEssSUFBSSxPQUFPLEtBQ1QsT0FBTyxJQUFJLE9BQU87SUFDaEIsb0JBQW9CLFNBQVMsY0FBYyxDQUFBLEdBQUEsd0JBQUs7QUFDbEQ7a0JBRWE7Ozs7O0FBUGYsSUFBSSxPQUFPLEtBQU87a0JBRUgsQ0FBQSxVQUVmOzs7OztBLDRDO0E7QSxTLE8sSSxFLE0sRSxNLEUsTSxFLEssRSxRO0l0QkpDLE9BQUEsQ0FBQSxHQUFBLGNBQUEsS0FBQSxDQUFBLEdBQUEsdUJBQUEsRUFBVztBO0EsSSxPLEssTyxJLE87SSxvQixTLGM7QTs7Ozs7QUFBWixJQUFJLE9BQU8sS0FBTztrQkFFSCxDQUFBLFVBRWYiLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9AcGxhc21vaHEvcGFyY2VsLXJ1bnRpbWUvZGlzdC9ydW50aW1lLWE2OWRhOTY3NzkzODVkNWUuanMiLCJub2RlX21vZHVsZXMvQHBsYXNtb2hxL3BhcmNlbC1yZXNvbHZlci9kaXN0L3BvbHlmaWxscy9yZWFjdC1yZWZyZXNoL3J1bnRpbWUuanMiLCIucGxhc21vL3N0YXRpYy9wb3B1cC50cyIsInNyYy9wb3B1cC9pbmRleC52dWUiLCJzcmMvZmVhdHVyZUZsYWdzQ29uZmlnLnRzIiwibm9kZV9tb2R1bGVzL3Z1ZS9kaXN0L3Z1ZS5ydW50aW1lLmVzbS1idW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL0B2dWUvcnVudGltZS1kb20vZGlzdC9ydW50aW1lLWRvbS5lc20tYnVuZGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtY29yZS9kaXN0L3J1bnRpbWUtY29yZS5lc20tYnVuZGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AdnVlL3JlYWN0aXZpdHkvZGlzdC9yZWFjdGl2aXR5LmVzbS1idW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL0B2dWUvcmVhY3Rpdml0eS9ub2RlX21vZHVsZXMvQHZ1ZS9zaGFyZWQvZGlzdC9zaGFyZWQuZXNtLWJ1bmRsZXIuanMiLCJub2RlX21vZHVsZXMvQHBhcmNlbC90cmFuc2Zvcm1lci1qcy9zcmMvZXNtb2R1bGUtaGVscGVycy5qcyIsIm5vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtY29yZS9ub2RlX21vZHVsZXMvQHZ1ZS9zaGFyZWQvZGlzdC9zaGFyZWQuZXNtLWJ1bmRsZXIuanMiLCJub2RlX21vZHVsZXMvQHZ1ZS9ydW50aW1lLWRvbS9ub2RlX21vZHVsZXMvQHZ1ZS9zaGFyZWQvZGlzdC9zaGFyZWQuZXNtLWJ1bmRsZXIuanMiLCJub2RlX21vZHVsZXMvcGluaWEvZGlzdC9waW5pYS5tanMiLCJub2RlX21vZHVsZXMvdnVlLWRlbWkvbGliL2luZGV4Lm1qcyIsIm5vZGVfbW9kdWxlcy9AdnVlL2RldnRvb2xzLWFwaS9saWIvZXNtL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B2dWUvZGV2dG9vbHMtYXBpL2xpYi9lc20vZW52LmpzIiwibm9kZV9tb2R1bGVzL0B2dWUvZGV2dG9vbHMtYXBpL2xpYi9lc20vY29uc3QuanMiLCJub2RlX21vZHVsZXMvQHZ1ZS9kZXZ0b29scy1hcGkvbGliL2VzbS9wcm94eS5qcyIsIm5vZGVfbW9kdWxlcy9AdnVlL2RldnRvb2xzLWFwaS9saWIvZXNtL3RpbWUuanMiLCJzcmMvdXRpbHMvaTE4bi5qcyIsInNyYy9zdG9yZXMvc3RvcmUudHMiLCJub2RlX21vZHVsZXMvQHBsYXNtb2hxL3N0b3JhZ2UvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9waWZ5L2luZGV4LmpzIiwic3JjL2NvbmZpZy50cyIsInNyYy9wb3B1cC9jb21wb25ldG5zL1dlYnBpbG90UG9wdXAudnVlIiwic3JjL2NvbXBvbmVudHMvSGVhZGVyUGFuZWwudnVlIiwibm9kZV9tb2R1bGVzL0BwbGFzbW9ocS9tZXNzYWdpbmcvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9uYW5vaWQvaW5kZXguYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy92dWUzLXBvcHBlci9kaXN0L3BvcHBlci5lc20uanMiLCJzcmMvY29tcG9uZW50cy9JbnRlcmFjdGl2ZUljb24vSW50ZXJhY3RpdmVJY29uLnZ1ZSIsIm5vZGVfbW9kdWxlcy9AdnVldXNlL2NvcmUvaW5kZXgubWpzIiwibm9kZV9tb2R1bGVzL0B2dWV1c2Uvc2hhcmVkL2luZGV4Lm1qcyIsIm5vZGVfbW9kdWxlcy9AcGFyY2VsL3J1bnRpbWUtanMvbGliL3J1bnRpbWUtZWNjMzhlMGMyMjAzZDFlZi5qcyIsIm5vZGVfbW9kdWxlcy9AcGFyY2VsL3J1bnRpbWUtanMvbGliL2hlbHBlcnMvYnVuZGxlLXVybC5qcyIsInNyYy9jb21wb25lbnRzL1dlYnBpbG90QWxlcnQudnVlIiwic3JjL2NvbXBvbmVudHMvaWNvbi9JY29uQWxlcnRJbmZvLnZ1ZSIsInNyYy9jb21wb25lbnRzL2ljb24vSWNvbkFsZXJ0RXJyb3IudnVlIiwic3JjL2NvbXBvbmVudHMvaWNvbi9JY29uQWxlcnRTdWNjZXNzLnZ1ZSIsInNyYy9jb21wb25lbnRzL1RpcHNTaG9ydGN1dC52dWUiLCJzcmMvdXRpbHMvaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFc9T2JqZWN0LmNyZWF0ZTt2YXIgaz1PYmplY3QuZGVmaW5lUHJvcGVydHk7dmFyIFY9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjt2YXIgRz1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lczt2YXIgWD1PYmplY3QuZ2V0UHJvdG90eXBlT2YsSj1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O3ZhciBxPShlLHQsbyxyKT0+e2lmKHQmJnR5cGVvZiB0PT1cIm9iamVjdFwifHx0eXBlb2YgdD09XCJmdW5jdGlvblwiKWZvcihsZXQgcyBvZiBHKHQpKSFKLmNhbGwoZSxzKSYmcyE9PW8mJmsoZSxzLHtnZXQ6KCk9PnRbc10sZW51bWVyYWJsZTohKHI9Vih0LHMpKXx8ci5lbnVtZXJhYmxlfSk7cmV0dXJuIGV9O3ZhciB6PShlLHQsbyk9PihvPWUhPW51bGw/VyhYKGUpKTp7fSxxKHR8fCFlfHwhZS5fX2VzTW9kdWxlP2sobyxcImRlZmF1bHRcIix7dmFsdWU6ZSxlbnVtZXJhYmxlOiEwfSk6byxlKSk7dmFyIF89dHlwZW9mIGdsb2JhbFRoaXMucHJvY2VzczxcInVcIj9nbG9iYWxUaGlzLnByb2Nlc3MuYXJndjpbXTt2YXIgRD0oKT0+dHlwZW9mIGdsb2JhbFRoaXMucHJvY2VzczxcInVcIj9nbG9iYWxUaGlzLnByb2Nlc3MuZW52Ont9O3ZhciBLPW5ldyBTZXQoXyksVD1lPT5LLmhhcyhlKSx1ZT1fLmZpbHRlcihlPT5lLnN0YXJ0c1dpdGgoXCItLVwiKSYmZS5pbmNsdWRlcyhcIj1cIikpLm1hcChlPT5lLnNwbGl0KFwiPVwiKSkucmVkdWNlKChlLFt0LG9dKT0+KGVbdF09byxlKSx7fSk7dmFyIGRlPVQoXCItLWRyeS1ydW5cIiksQT0oKT0+VChcIi0tdmVyYm9zZVwiKXx8RCgpLlZFUkJPU0U9PT1cInRydWVcIixmZT1BKCk7dmFyIEU9KGU9XCJcIiwuLi50KT0+Y29uc29sZS5sb2coZS5wYWRFbmQoOSksXCJ8XCIsLi4udCk7dmFyIHc9KC4uLmUpPT5jb25zb2xlLmVycm9yKFwiXFx1ezFGNTM0fSBFUlJPUlwiLnBhZEVuZCg5KSxcInxcIiwuLi5lKSxMPSguLi5lKT0+RShcIlxcdXsxRjUzNX0gSU5GT1wiLC4uLmUpLHg9KC4uLmUpPT5FKFwiXFx1ezFGN0UwfSBXQVJOXCIsLi4uZSksUT0wLHA9KC4uLmUpPT5BKCkmJkUoYFxcdXsxRjdFMX0gJHtRKyt9YCwuLi5lKTt2YXIgYz17XCJpc0NvbnRlbnRTY3JpcHRcIjpmYWxzZSxcImlzQmFja2dyb3VuZFwiOmZhbHNlLFwiaXNSZWFjdFwiOmZhbHNlLFwicnVudGltZXNcIjpbXCJwYWdlLXJ1bnRpbWVcIl0sXCJob3N0XCI6XCJsb2NhbGhvc3RcIixcInBvcnRcIjo2MDQ5MixcImVudHJ5RmlsZVBhdGhcIjpcIi9Vc2Vycy9tYWhidWJpc2xhbW1haGltL0Rlc2t0b3AvRGV2ZWxvcG1lbnQvV2VicGlsb3QvLnBsYXNtby9zdGF0aWMvcG9wdXAudHNcIixcImJ1bmRsZUlkXCI6XCI4ZTkwZDgzOTdlMzk0YzhiXCIsXCJlbnZIYXNoXCI6XCJlNzkyZmJiZGFhNzhlZTg0XCIsXCJ2ZXJib3NlXCI6XCJmYWxzZVwiLFwic2VjdXJlXCI6ZmFsc2UsXCJzZXJ2ZXJQb3J0XCI6NjA0OTF9O21vZHVsZS5idW5kbGUuSE1SX0JVTkRMRV9JRD1jLmJ1bmRsZUlkO2dsb2JhbFRoaXMucHJvY2Vzcz17YXJndjpbXSxlbnY6e1ZFUkJPU0U6Yy52ZXJib3NlfX07dmFyIFk9bW9kdWxlLmJ1bmRsZS5Nb2R1bGU7ZnVuY3Rpb24gWihlKXtZLmNhbGwodGhpcyxlKSx0aGlzLmhvdD17ZGF0YTptb2R1bGUuYnVuZGxlLmhvdERhdGFbZV0sX2FjY2VwdENhbGxiYWNrczpbXSxfZGlzcG9zZUNhbGxiYWNrczpbXSxhY2NlcHQ6ZnVuY3Rpb24odCl7dGhpcy5fYWNjZXB0Q2FsbGJhY2tzLnB1c2godHx8ZnVuY3Rpb24oKXt9KX0sZGlzcG9zZTpmdW5jdGlvbih0KXt0aGlzLl9kaXNwb3NlQ2FsbGJhY2tzLnB1c2godCl9fSxtb2R1bGUuYnVuZGxlLmhvdERhdGFbZV09dm9pZCAwfW1vZHVsZS5idW5kbGUuTW9kdWxlPVo7bW9kdWxlLmJ1bmRsZS5ob3REYXRhPXt9O3ZhciBkPWdsb2JhbFRoaXMuYnJvd3Nlcnx8Z2xvYmFsVGhpcy5jaHJvbWV8fG51bGw7YXN5bmMgZnVuY3Rpb24gbShlPSExKXtlPyhwKFwiVHJpZ2dlcmluZyBmdWxsIHJlbG9hZFwiKSxkLnJ1bnRpbWUuc2VuZE1lc3NhZ2Uoe19fcGxhc21vX2Z1bGxfcmVsb2FkX186ITB9KSk6Z2xvYmFsVGhpcy5sb2NhdGlvbj8ucmVsb2FkPy4oKX1mdW5jdGlvbiBoKCl7cmV0dXJuIWMuaG9zdHx8Yy5ob3N0PT09XCIwLjAuMC4wXCI/bG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZihcImh0dHBcIik9PT0wP2xvY2F0aW9uLmhvc3RuYW1lOlwibG9jYWxob3N0XCI6Yy5ob3N0fWZ1bmN0aW9uIGYoKXtyZXR1cm4gYy5wb3J0fHxsb2NhdGlvbi5wb3J0fXZhciBTPVwiX19wbGFzbW9fcnVudGltZV9wYWdlX1wiO3ZhciBpPXtjaGVja2VkQXNzZXRzOnt9LGFzc2V0c1RvRGlzcG9zZTpbXSxhc3NldHNUb0FjY2VwdDpbXX0sQz0oKT0+e2kuY2hlY2tlZEFzc2V0cz17fSxpLmFzc2V0c1RvRGlzcG9zZT1bXSxpLmFzc2V0c1RvQWNjZXB0PVtdfTtmdW5jdGlvbiB1KGUsdCl7bGV0e21vZHVsZXM6b309ZTtpZighbylyZXR1cm5bXTtsZXQgcj1bXSxzLG4sYTtmb3IocyBpbiBvKWZvcihuIGluIG9bc11bMV0pYT1vW3NdWzFdW25dLChhPT09dHx8QXJyYXkuaXNBcnJheShhKSYmYVthLmxlbmd0aC0xXT09PXQpJiZyLnB1c2goW2Usc10pO3JldHVybiBlLnBhcmVudCYmKHI9ci5jb25jYXQodShlLnBhcmVudCx0KSkpLHJ9ZnVuY3Rpb24gUihlLHQsbyl7aWYoQihlLHQsbykpcmV0dXJuITA7bGV0IHI9dShtb2R1bGUuYnVuZGxlLnJvb3QsdCkscz0hMTtmb3IoO3IubGVuZ3RoPjA7KXtsZXRbbixhXT1yLnNoaWZ0KCk7aWYoQihuLGEsbnVsbCkpcz0hMDtlbHNle2xldCB5PXUobW9kdWxlLmJ1bmRsZS5yb290LGEpO2lmKHkubGVuZ3RoPT09MCl7cz0hMTticmVha31yLnB1c2goLi4ueSl9fXJldHVybiBzfWZ1bmN0aW9uIEIoZSx0LG8pe2xldHttb2R1bGVzOnJ9PWU7aWYoIXIpcmV0dXJuITE7aWYobyYmIW9bZS5ITVJfQlVORExFX0lEXSlyZXR1cm4gZS5wYXJlbnQ/UihlLnBhcmVudCx0LG8pOiEwO2lmKGkuY2hlY2tlZEFzc2V0c1t0XSlyZXR1cm4hMDtpLmNoZWNrZWRBc3NldHNbdF09ITA7bGV0IHM9ZS5jYWNoZVt0XTtyZXR1cm4gaS5hc3NldHNUb0Rpc3Bvc2UucHVzaChbZSx0XSksIXN8fHMuaG90JiZzLmhvdC5fYWNjZXB0Q2FsbGJhY2tzLmxlbmd0aD8oaS5hc3NldHNUb0FjY2VwdC5wdXNoKFtlLHRdKSwhMCk6ITF9ZnVuY3Rpb24gTShlLHQpe2xldHttb2R1bGVzOm99PWU7cmV0dXJuIG8/ISFvW3RdOiExfWZ1bmN0aW9uIGVlKGUpe2lmKGUudHlwZT09PVwianNcIiYmdHlwZW9mIGRvY3VtZW50PFwidVwiKXJldHVybiBuZXcgUHJvbWlzZSgodCxvKT0+e2xldCByPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7ci5zcmM9YCR7ZS51cmx9P3Q9JHtEYXRlLm5vdygpfWAsZS5vdXRwdXRGb3JtYXQ9PT1cImVzbW9kdWxlXCImJihyLnR5cGU9XCJtb2R1bGVcIiksci5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCgpPT50KHIpKSxyLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCgpPT5vKG5ldyBFcnJvcihgRmFpbGVkIHRvIGRvd25sb2FkIGFzc2V0OiAke2UuaWR9YCkpKSxkb2N1bWVudC5oZWFkPy5hcHBlbmRDaGlsZChyKX0pfXZhciBQPSExO3RyeXsoMCxldmFsKSgndGhyb3cgbmV3IEVycm9yKFwidGVzdFwiKTsgLy8jIHNvdXJjZVVSTD10ZXN0LmpzJyl9Y2F0Y2goZSl7UD1lLnN0YWNrLmluY2x1ZGVzKFwidGVzdC5qc1wiKX1hc3luYyBmdW5jdGlvbiBPKGUpe2dsb2JhbC5wYXJjZWxIb3RVcGRhdGU9T2JqZWN0LmNyZWF0ZShudWxsKSxlLmZvckVhY2gobz0+e28udXJsPWQucnVudGltZS5nZXRVUkwoXCIvX19wbGFzbW9faG1yX3Byb3h5X18/dXJsPVwiK2VuY29kZVVSSUNvbXBvbmVudChgJHtvLnVybH0/dD0ke0RhdGUubm93KCl9YCkpfSk7bGV0IHQ9YXdhaXQgUHJvbWlzZS5hbGwoUD9bXTplLm1hcChlZSkpO3RyeXtlLmZvckVhY2goZnVuY3Rpb24obyl7JChtb2R1bGUuYnVuZGxlLnJvb3Qsbyl9KX1maW5hbGx5e2RlbGV0ZSBnbG9iYWwucGFyY2VsSG90VXBkYXRlLHQmJnQuZm9yRWFjaChvPT57byYmZG9jdW1lbnQuaGVhZD8ucmVtb3ZlQ2hpbGQobyl9KX19ZnVuY3Rpb24gdGUoZSl7bGV0IHQ9ZS5jbG9uZU5vZGUoKTt0Lm9ubG9hZD1mdW5jdGlvbigpe2UucGFyZW50Tm9kZSE9PW51bGwmJmUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKX0sdC5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsZS5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLnNwbGl0KFwiP1wiKVswXStcIj9cIitEYXRlLm5vdygpKSxlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHQsZS5uZXh0U2libGluZyl9dmFyIGI9bnVsbDtmdW5jdGlvbiBvZSgpe2J8fChiPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtsZXQgZT1kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdsaW5rW3JlbD1cInN0eWxlc2hlZXRcIl0nKTtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoO3QrKyl7bGV0IG89ZVt0XS5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLHI9aCgpLHM9cj09PVwibG9jYWxob3N0XCI/bmV3IFJlZ0V4cChcIl4oaHR0cHM/OlxcXFwvXFxcXC8oMC4wLjAuMHwxMjcuMC4wLjEpfGxvY2FsaG9zdCk6XCIrZigpKS50ZXN0KG8pOm8uaW5kZXhPZihyK1wiOlwiK2YoKSk7L15odHRwcz86XFwvXFwvL2kudGVzdChvKSYmby5pbmRleE9mKGxvY2F0aW9uLm9yaWdpbikhPT0wJiYhc3x8dGUoZVt0XSl9Yj1udWxsfSw0NykpfWZ1bmN0aW9uICQoZSx0KXtsZXR7bW9kdWxlczpvfT1lO2lmKG8pe2lmKHQudHlwZT09PVwiY3NzXCIpb2UoKTtlbHNlIGlmKHQudHlwZT09PVwianNcIil7bGV0IHI9dC5kZXBzQnlCdW5kbGVbZS5ITVJfQlVORExFX0lEXTtpZihyKXtpZihvW3QuaWRdKXtsZXQgbj1vW3QuaWRdWzFdO2ZvcihsZXQgYSBpbiBuKWlmKCFyW2FdfHxyW2FdIT09blthXSl7bGV0IGw9blthXTt1KG1vZHVsZS5idW5kbGUucm9vdCxsKS5sZW5ndGg9PT0xJiZ2KG1vZHVsZS5idW5kbGUucm9vdCxsKX19UCYmKDAsZXZhbCkodC5vdXRwdXQpO2xldCBzPWdsb2JhbC5wYXJjZWxIb3RVcGRhdGVbdC5pZF07b1t0LmlkXT1bcyxyXX1lbHNlIGUucGFyZW50JiYkKGUucGFyZW50LHQpfX19ZnVuY3Rpb24gdihlLHQpe2xldCBvPWUubW9kdWxlcztpZihvKWlmKG9bdF0pe2xldCByPW9bdF1bMV0scz1bXTtmb3IobGV0IG4gaW4gcil1KG1vZHVsZS5idW5kbGUucm9vdCxyW25dKS5sZW5ndGg9PT0xJiZzLnB1c2gocltuXSk7ZGVsZXRlIG9bdF0sZGVsZXRlIGUuY2FjaGVbdF0scy5mb3JFYWNoKG49Pnt2KG1vZHVsZS5idW5kbGUucm9vdCxuKX0pfWVsc2UgZS5wYXJlbnQmJnYoZS5wYXJlbnQsdCl9ZnVuY3Rpb24gSChlLHQpe2xldCBvPWUuY2FjaGVbdF07ZS5ob3REYXRhW3RdPXt9LG8mJm8uaG90JiYoby5ob3QuZGF0YT1lLmhvdERhdGFbdF0pLG8mJm8uaG90JiZvLmhvdC5fZGlzcG9zZUNhbGxiYWNrcy5sZW5ndGgmJm8uaG90Ll9kaXNwb3NlQ2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24ocil7cihlLmhvdERhdGFbdF0pfSksZGVsZXRlIGUuY2FjaGVbdF19ZnVuY3Rpb24gaihlLHQpe2UodCk7bGV0IG89ZS5jYWNoZVt0XTtpZihvJiZvLmhvdCYmby5ob3QuX2FjY2VwdENhbGxiYWNrcy5sZW5ndGgpe2xldCByPXUobW9kdWxlLmJ1bmRsZS5yb290LHQpO28uaG90Ll9hY2NlcHRDYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbihzKXtsZXQgbj1zKCgpPT5yKTtuJiZuLmxlbmd0aCYmKG4uZm9yRWFjaCgoW2EsbF0pPT57SChhLGwpfSksaS5hc3NldHNUb0FjY2VwdC5wdXNoLmFwcGx5KGkuYXNzZXRzVG9BY2NlcHQsbikpfSl9fWZ1bmN0aW9uIHJlKGU9ZigpKXtsZXQgdD1oKCk7cmV0dXJuYCR7Yy5zZWN1cmV8fGxvY2F0aW9uLnByb3RvY29sPT09XCJodHRwczpcIiYmIS9sb2NhbGhvc3R8MTI3LjAuMC4xfDAuMC4wLjAvLnRlc3QodCk/XCJ3c3NcIjpcIndzXCJ9Oi8vJHt0fToke2V9L2B9ZnVuY3Rpb24gc2UoZSl7dHlwZW9mIGUubWVzc2FnZT09XCJzdHJpbmdcIiYmdyhcIltwbGFzbW8vcGFyY2VsLXJ1bnRpbWVdOiBcIitlLm1lc3NhZ2UpfWZ1bmN0aW9uIEkoZSl7aWYodHlwZW9mIGdsb2JhbFRoaXMuV2ViU29ja2V0PlwidVwiKXJldHVybjtsZXQgdD1uZXcgV2ViU29ja2V0KHJlKCkpO3JldHVybiB0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsYXN5bmMgZnVuY3Rpb24obyl7bGV0IHI9SlNPTi5wYXJzZShvLmRhdGEpO2lmKHIudHlwZT09PVwidXBkYXRlXCImJmF3YWl0IGUoci5hc3NldHMpLHIudHlwZT09PVwiZXJyb3JcIilmb3IobGV0IHMgb2Ygci5kaWFnbm9zdGljcy5hbnNpKXtsZXQgbj1zLmNvZGVmcmFtZXx8cy5zdGFjazt4KFwiW3BsYXNtby9wYXJjZWwtcnVudGltZV06IFwiK3MubWVzc2FnZStgXG5gK24rYFxuXG5gK3MuaGludHMuam9pbihgXG5gKSl9fSksdC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIixzZSksdC5hZGRFdmVudExpc3RlbmVyKFwib3BlblwiLCgpPT57TChgW3BsYXNtby9wYXJjZWwtcnVudGltZV06IENvbm5lY3RlZCB0byBITVIgc2VydmVyIGZvciAke2MuZW50cnlGaWxlUGF0aH1gKX0pLHQuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsKCk9Pnt4KGBbcGxhc21vL3BhcmNlbC1ydW50aW1lXTogQ29ubmVjdGlvbiB0byB0aGUgSE1SIHNlcnZlciBpcyBjbG9zZWQgZm9yICR7Yy5lbnRyeUZpbGVQYXRofWApfSksdH12YXIgTj16KHJlcXVpcmUoXCJyZWFjdC1yZWZyZXNoL3J1bnRpbWVcIikpO2FzeW5jIGZ1bmN0aW9uIFUoKXtOLmRlZmF1bHQuaW5qZWN0SW50b0dsb2JhbEhvb2sod2luZG93KSx3aW5kb3cuJFJlZnJlc2hSZWckPWZ1bmN0aW9uKCl7fSx3aW5kb3cuJFJlZnJlc2hTaWckPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiBlfX19dmFyIG5lPWAke1N9JHttb2R1bGUuaWR9X19gLGcsRj1tb2R1bGUuYnVuZGxlLnBhcmVudDtpZighRnx8IUYuaXNQYXJjZWxSZXF1aXJlKXt0cnl7Zz1kPy5ydW50aW1lLmNvbm5lY3Qoe25hbWU6bmV9KSxnLm9uRGlzY29ubmVjdC5hZGRMaXN0ZW5lcigoKT0+e20oKX0pLGMuaXNSZWFjdHx8Zy5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIoKCk9PnttKCl9KX1jYXRjaChlKXtwKGUpfUkoYXN5bmMgZT0+e2lmKHAoXCJQYWdlIHJ1bnRpbWUgLSBPbiBITVIgVXBkYXRlXCIpLGMuaXNSZWFjdCl7QygpO2xldCB0PWUuZmlsdGVyKHI9PnIuZW52SGFzaD09PWMuZW52SGFzaCk7aWYodC5zb21lKHI9PnIudHlwZT09PVwiY3NzXCJ8fHIudHlwZT09PVwianNcIiYmUihtb2R1bGUuYnVuZGxlLnJvb3Qsci5pZCxyLmRlcHNCeUJ1bmRsZSkpKXRyeXthd2FpdCBPKHQpO2xldCByPXt9O2ZvcihsZXRbbixhXW9mIGkuYXNzZXRzVG9EaXNwb3NlKXJbYV18fChIKG4sYSksclthXT0hMCk7bGV0IHM9e307Zm9yKGxldCBuPTA7bjxpLmFzc2V0c1RvQWNjZXB0Lmxlbmd0aDtuKyspe2xldFthLGxdPWkuYXNzZXRzVG9BY2NlcHRbbl07c1tsXXx8KGooYSxsKSxzW2xdPSEwKX19Y2F0Y2gocil7Yy52ZXJib3NlPT09XCJ0cnVlXCImJihjb25zb2xlLnRyYWNlKHIpLGFsZXJ0KEpTT04uc3RyaW5naWZ5KHIpKSksYXdhaXQgbSghMCl9fWVsc2V7bGV0IHQ9ZS5maWx0ZXIobz0+by5lbnZIYXNoPT09Yy5lbnZIYXNoKS5zb21lKG89Pk0obW9kdWxlLmJ1bmRsZSxvLmlkKSk7cChcIlBhZ2UgcnVudGltZSAtXCIse3NvdXJjZUNoYW5nZWQ6dH0pLHQmJmcucG9zdE1lc3NhZ2Uoe19fcGxhc21vX3BhZ2VfY2hhbmdlZF9fOiEwfSl9fSl9Yy5pc1JlYWN0JiYocChcIkluamVjdGluZyByZWFjdCByZWZyZXNoXCIpLFUoKSk7XG4iLCJ2YXIgb2U9T2JqZWN0LmNyZWF0ZTt2YXIgSD1PYmplY3QuZGVmaW5lUHJvcGVydHk7dmFyIGFlPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7dmFyIHVlPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO3ZhciBzZT1PYmplY3QuZ2V0UHJvdG90eXBlT2YsbGU9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTt2YXIgej0obyxmKT0+KCk9PihmfHxvKChmPXtleHBvcnRzOnt9fSkuZXhwb3J0cyxmKSxmLmV4cG9ydHMpLGNlPShvLGYpPT57Zm9yKHZhciBzIGluIGYpSChvLHMse2dldDpmW3NdLGVudW1lcmFibGU6ITB9KX0sRD0obyxmLHMseSk9PntpZihmJiZ0eXBlb2YgZj09XCJvYmplY3RcInx8dHlwZW9mIGY9PVwiZnVuY3Rpb25cIilmb3IobGV0IG0gb2YgdWUoZikpIWxlLmNhbGwobyxtKSYmbSE9PXMmJkgobyxtLHtnZXQ6KCk9PmZbbV0sZW51bWVyYWJsZTohKHk9YWUoZixtKSl8fHkuZW51bWVyYWJsZX0pO3JldHVybiBvfSxTPShvLGYscyk9PihEKG8sZixcImRlZmF1bHRcIikscyYmRChzLGYsXCJkZWZhdWx0XCIpKSxHPShvLGYscyk9PihzPW8hPW51bGw/b2Uoc2UobykpOnt9LEQoZnx8IW98fCFvLl9fZXNNb2R1bGU/SChzLFwiZGVmYXVsdFwiLHt2YWx1ZTpvLGVudW1lcmFibGU6ITB9KTpzLG8pKSxkZT1vPT5EKEgoe30sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbyk7dmFyIE49eihoPT57XCJ1c2Ugc3RyaWN0XCI7KGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG89U3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLGY9U3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIikscz10eXBlb2YgV2Vha01hcD09XCJmdW5jdGlvblwiP1dlYWtNYXA6TWFwLHk9bmV3IE1hcCxtPW5ldyBzLGI9bmV3IHMsaj1uZXcgcyxFPVtdLEM9bmV3IE1hcCxPPW5ldyBNYXAscD1uZXcgU2V0LF89bmV3IFNldCxGPXR5cGVvZiBXZWFrTWFwPT1cImZ1bmN0aW9uXCI/bmV3IFdlYWtNYXA6bnVsbCxUPSExO2Z1bmN0aW9uIEIoZSl7aWYoZS5mdWxsS2V5IT09bnVsbClyZXR1cm4gZS5mdWxsS2V5O3ZhciByPWUub3duS2V5LG47dHJ5e249ZS5nZXRDdXN0b21Ib29rcygpfWNhdGNoKGkpe3JldHVybiBlLmZvcmNlUmVzZXQ9ITAsZS5mdWxsS2V5PXIscn1mb3IodmFyIHQ9MDt0PG4ubGVuZ3RoO3QrKyl7dmFyIGw9blt0XTtpZih0eXBlb2YgbCE9XCJmdW5jdGlvblwiKXJldHVybiBlLmZvcmNlUmVzZXQ9ITAsZS5mdWxsS2V5PXIscjt2YXIgZD1iLmdldChsKTtpZihkIT09dm9pZCAwKXt2YXIgYT1CKGQpO2QuZm9yY2VSZXNldCYmKGUuZm9yY2VSZXNldD0hMCkscis9YFxuLS0tXG5gK2F9fXJldHVybiBlLmZ1bGxLZXk9cixyfWZ1bmN0aW9uIHEoZSxyKXt2YXIgbj1iLmdldChlKSx0PWIuZ2V0KHIpO3JldHVybiBuPT09dm9pZCAwJiZ0PT09dm9pZCAwPyEwOiEobj09PXZvaWQgMHx8dD09PXZvaWQgMHx8QihuKSE9PUIodCl8fHQuZm9yY2VSZXNldCl9ZnVuY3Rpb24gJChlKXtyZXR1cm4gZS5wcm90b3R5cGUmJmUucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnR9ZnVuY3Rpb24gayhlLHIpe3JldHVybiAkKGUpfHwkKHIpPyExOiEhcShlLHIpfWZ1bmN0aW9uIFkoZSl7cmV0dXJuIGouZ2V0KGUpfWZ1bmN0aW9uIFooZSl7dmFyIHI9bmV3IE1hcDtyZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKG4sdCl7ci5zZXQodCxuKX0pLHJ9ZnVuY3Rpb24gVyhlKXt2YXIgcj1uZXcgU2V0O3JldHVybiBlLmZvckVhY2goZnVuY3Rpb24obil7ci5hZGQobil9KSxyfWZ1bmN0aW9uIE0oZSxyKXt0cnl7cmV0dXJuIGVbcl19Y2F0Y2gobil7cmV0dXJufX1mdW5jdGlvbiBKKCl7aWYoRS5sZW5ndGg9PT0wfHxUKXJldHVybiBudWxsO1Q9ITA7dHJ5e3ZhciBlPW5ldyBTZXQscj1uZXcgU2V0LG49RTtFPVtdLG4uZm9yRWFjaChmdW5jdGlvbih1KXt2YXIgYz11WzBdLHY9dVsxXSxSPWMuY3VycmVudDtqLnNldChSLGMpLGouc2V0KHYsYyksYy5jdXJyZW50PXYsayhSLHYpP3IuYWRkKGMpOmUuYWRkKGMpfSk7dmFyIHQ9e3VwZGF0ZWRGYW1pbGllczpyLHN0YWxlRmFtaWxpZXM6ZX07Qy5mb3JFYWNoKGZ1bmN0aW9uKHUpe3Uuc2V0UmVmcmVzaEhhbmRsZXIoWSl9KTt2YXIgbD0hMSxkPW51bGwsYT1XKF8pLGk9VyhwKSxnPVooTyk7aWYoYS5mb3JFYWNoKGZ1bmN0aW9uKHUpe3ZhciBjPWcuZ2V0KHUpO2lmKGM9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgaGVscGVycyBmb3IgYSByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0IFJlZnJlc2guXCIpO2lmKF8uaGFzKHUpLEYhPT1udWxsJiZGLmhhcyh1KSl7dmFyIHY9Ri5nZXQodSk7dHJ5e2Muc2NoZWR1bGVSb290KHUsdil9Y2F0Y2goUil7bHx8KGw9ITAsZD1SKX19fSksaS5mb3JFYWNoKGZ1bmN0aW9uKHUpe3ZhciBjPWcuZ2V0KHUpO2lmKGM9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgaGVscGVycyBmb3IgYSByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0IFJlZnJlc2guXCIpO3AuaGFzKHUpO3RyeXtjLnNjaGVkdWxlUmVmcmVzaCh1LHQpfWNhdGNoKHYpe2x8fChsPSEwLGQ9dil9fSksbCl0aHJvdyBkO3JldHVybiB0fWZpbmFsbHl7VD0hMX19ZnVuY3Rpb24gUChlLHIpe3tpZihlPT09bnVsbHx8dHlwZW9mIGUhPVwiZnVuY3Rpb25cIiYmdHlwZW9mIGUhPVwib2JqZWN0XCJ8fG0uaGFzKGUpKXJldHVybjt2YXIgbj15LmdldChyKTtpZihuPT09dm9pZCAwPyhuPXtjdXJyZW50OmV9LHkuc2V0KHIsbikpOkUucHVzaChbbixlXSksbS5zZXQoZSxuKSx0eXBlb2YgZT09XCJvYmplY3RcIiYmZSE9PW51bGwpc3dpdGNoKE0oZSxcIiQkdHlwZW9mXCIpKXtjYXNlIG86UChlLnJlbmRlcixyK1wiJHJlbmRlclwiKTticmVhaztjYXNlIGY6UChlLnR5cGUscitcIiR0eXBlXCIpO2JyZWFrfX19ZnVuY3Rpb24gSyhlLHIpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dm9pZCAwP2FyZ3VtZW50c1syXTohMSx0PWFyZ3VtZW50cy5sZW5ndGg+Mz9hcmd1bWVudHNbM106dm9pZCAwO2lmKGIuaGFzKGUpfHxiLnNldChlLHtmb3JjZVJlc2V0Om4sb3duS2V5OnIsZnVsbEtleTpudWxsLGdldEN1c3RvbUhvb2tzOnR8fGZ1bmN0aW9uKCl7cmV0dXJuW119fSksdHlwZW9mIGU9PVwib2JqZWN0XCImJmUhPT1udWxsKXN3aXRjaChNKGUsXCIkJHR5cGVvZlwiKSl7Y2FzZSBvOksoZS5yZW5kZXIscixuLHQpO2JyZWFrO2Nhc2UgZjpLKGUudHlwZSxyLG4sdCk7YnJlYWt9fWZ1bmN0aW9uIHgoZSl7e3ZhciByPWIuZ2V0KGUpO3IhPT12b2lkIDAmJkIocil9fWZ1bmN0aW9uIFEoZSl7cmV0dXJuIHkuZ2V0KGUpfWZ1bmN0aW9uIFgoZSl7cmV0dXJuIG0uZ2V0KGUpfWZ1bmN0aW9uIGVlKGUpe3t2YXIgcj1uZXcgU2V0O3JldHVybiBwLmZvckVhY2goZnVuY3Rpb24obil7dmFyIHQ9Ty5nZXQobik7aWYodD09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBoZWxwZXJzIGZvciBhIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QgUmVmcmVzaC5cIik7dmFyIGw9dC5maW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2gobixlKTtsLmZvckVhY2goZnVuY3Rpb24oZCl7ci5hZGQoZCl9KX0pLHJ9fWZ1bmN0aW9uIHJlKGUpe3t2YXIgcj1lLl9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztpZihyPT09dm9pZCAwKXt2YXIgbj0wO2UuX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fPXI9e3JlbmRlcmVyczpuZXcgTWFwLHN1cHBvcnRzRmliZXI6ITAsaW5qZWN0OmZ1bmN0aW9uKGEpe3JldHVybiBuKyt9LG9uU2NoZWR1bGVGaWJlclJvb3Q6ZnVuY3Rpb24oYSxpLGcpe30sb25Db21taXRGaWJlclJvb3Q6ZnVuY3Rpb24oYSxpLGcsdSl7fSxvbkNvbW1pdEZpYmVyVW5tb3VudDpmdW5jdGlvbigpe319fWlmKHIuaXNEaXNhYmxlZCl7Y29uc29sZS53YXJuKFwiU29tZXRoaW5nIGhhcyBzaGltbWVkIHRoZSBSZWFjdCBEZXZUb29scyBnbG9iYWwgaG9vayAoX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fKS4gRmFzdCBSZWZyZXNoIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhpcyBzaGltIGFuZCB3aWxsIGJlIGRpc2FibGVkLlwiKTtyZXR1cm59dmFyIHQ9ci5pbmplY3Q7ci5pbmplY3Q9ZnVuY3Rpb24oYSl7dmFyIGk9dC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIHR5cGVvZiBhLnNjaGVkdWxlUmVmcmVzaD09XCJmdW5jdGlvblwiJiZ0eXBlb2YgYS5zZXRSZWZyZXNoSGFuZGxlcj09XCJmdW5jdGlvblwiJiZDLnNldChpLGEpLGl9LHIucmVuZGVyZXJzLmZvckVhY2goZnVuY3Rpb24oYSxpKXt0eXBlb2YgYS5zY2hlZHVsZVJlZnJlc2g9PVwiZnVuY3Rpb25cIiYmdHlwZW9mIGEuc2V0UmVmcmVzaEhhbmRsZXI9PVwiZnVuY3Rpb25cIiYmQy5zZXQoaSxhKX0pO3ZhciBsPXIub25Db21taXRGaWJlclJvb3QsZD1yLm9uU2NoZWR1bGVGaWJlclJvb3R8fGZ1bmN0aW9uKCl7fTtyLm9uU2NoZWR1bGVGaWJlclJvb3Q9ZnVuY3Rpb24oYSxpLGcpe3JldHVybiBUfHwoXy5kZWxldGUoaSksRiE9PW51bGwmJkYuc2V0KGksZykpLGQuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxyLm9uQ29tbWl0RmliZXJSb290PWZ1bmN0aW9uKGEsaSxnLHUpe3ZhciBjPUMuZ2V0KGEpO2lmKGMhPT12b2lkIDApe08uc2V0KGksYyk7dmFyIHY9aS5jdXJyZW50LFI9di5hbHRlcm5hdGU7aWYoUiE9PW51bGwpe3ZhciBMPVIubWVtb2l6ZWRTdGF0ZSE9bnVsbCYmUi5tZW1vaXplZFN0YXRlLmVsZW1lbnQhPW51bGwmJnAuaGFzKGkpLEE9di5tZW1vaXplZFN0YXRlIT1udWxsJiZ2Lm1lbW9pemVkU3RhdGUuZWxlbWVudCE9bnVsbDshTCYmQT8ocC5hZGQoaSksXy5kZWxldGUoaSkpOkwmJkF8fChMJiYhQT8ocC5kZWxldGUoaSksdT9fLmFkZChpKTpPLmRlbGV0ZShpKSk6IUwmJiFBJiZ1JiZfLmFkZChpKSl9ZWxzZSBwLmFkZChpKX1yZXR1cm4gbC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fX1mdW5jdGlvbiBuZSgpe3JldHVybiExfWZ1bmN0aW9uIHRlKCl7cmV0dXJuIHAuc2l6ZX1mdW5jdGlvbiBmZSgpe3t2YXIgZSxyLG49ITE7cmV0dXJuIGZ1bmN0aW9uKHQsbCxkLGEpe2lmKHR5cGVvZiBsPT1cInN0cmluZ1wiKXJldHVybiBlfHwoZT10LHI9dHlwZW9mIGE9PVwiZnVuY3Rpb25cIiksdCE9bnVsbCYmKHR5cGVvZiB0PT1cImZ1bmN0aW9uXCJ8fHR5cGVvZiB0PT1cIm9iamVjdFwiKSYmSyh0LGwsZCxhKSx0OyFuJiZyJiYobj0hMCx4KGUpKX19fWZ1bmN0aW9uIGllKGUpe3N3aXRjaCh0eXBlb2YgZSl7Y2FzZVwiZnVuY3Rpb25cIjp7aWYoZS5wcm90b3R5cGUhPW51bGwpe2lmKGUucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpcmV0dXJuITA7dmFyIHI9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZS5wcm90b3R5cGUpO2lmKHIubGVuZ3RoPjF8fHJbMF0hPT1cImNvbnN0cnVjdG9yXCJ8fGUucHJvdG90eXBlLl9fcHJvdG9fXyE9PU9iamVjdC5wcm90b3R5cGUpcmV0dXJuITF9dmFyIG49ZS5uYW1lfHxlLmRpc3BsYXlOYW1lO3JldHVybiB0eXBlb2Ygbj09XCJzdHJpbmdcIiYmL15bQS1aXS8udGVzdChuKX1jYXNlXCJvYmplY3RcIjp7aWYoZSE9bnVsbClzd2l0Y2goTShlLFwiJCR0eXBlb2ZcIikpe2Nhc2UgbzpjYXNlIGY6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX1yZXR1cm4hMX1kZWZhdWx0OnJldHVybiExfX1oLl9nZXRNb3VudGVkUm9vdENvdW50PXRlLGguY29sbGVjdEN1c3RvbUhvb2tzRm9yU2lnbmF0dXJlPXgsaC5jcmVhdGVTaWduYXR1cmVGdW5jdGlvbkZvclRyYW5zZm9ybT1mZSxoLmZpbmRBZmZlY3RlZEhvc3RJbnN0YW5jZXM9ZWUsaC5nZXRGYW1pbHlCeUlEPVEsaC5nZXRGYW1pbHlCeVR5cGU9WCxoLmhhc1VucmVjb3ZlcmFibGVFcnJvcnM9bmUsaC5pbmplY3RJbnRvR2xvYmFsSG9vaz1yZSxoLmlzTGlrZWx5Q29tcG9uZW50VHlwZT1pZSxoLnBlcmZvcm1SZWFjdFJlZnJlc2g9SixoLnJlZ2lzdGVyPVAsaC5zZXRTaWduYXR1cmU9S30pKCl9KTt2YXIgST16KChwZSxWKT0+e1widXNlIHN0cmljdFwiO1YuZXhwb3J0cz1OKCl9KTt2YXIgdz17fTtjZSh3LHtkZWZhdWx0OigpPT5oZX0pO21vZHVsZS5leHBvcnRzPWRlKHcpO3ZhciBVPUcoSSgpKTtTKHcsRyhJKCkpLG1vZHVsZS5leHBvcnRzKTt2YXIgaGU9VS5kZWZhdWx0O1xuLyohIEJ1bmRsZWQgbGljZW5zZSBpbmZvcm1hdGlvbjpcblxucmVhY3QtcmVmcmVzaC9janMvcmVhY3QtcmVmcmVzaC1ydW50aW1lLmRldmVsb3BtZW50LmpzOlxuICAoKipcbiAgICogQGxpY2Vuc2UgUmVhY3RcbiAgICogcmVhY3QtcmVmcmVzaC1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gICAqXG4gICAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICAgKlxuICAgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAgICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICAgKilcbiovXG4iLCIvLyBAdHMtbm9jaGVja1xuaW1wb3J0ICogYXMgQ29tcG9uZW50IGZyb20gXCIuLi8uLi9zcmMvcG9wdXAvaW5kZXgudnVlXCJcbmltcG9ydCB7IGNyZWF0ZUFwcCB9IGZyb20gXCJ2dWVcIlxuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCAoKSA9PiB7XG4gIGNvbnN0IGFwcCA9IGNyZWF0ZUFwcChDb21wb25lbnQuZGVmYXVsdClcbiAgQ29tcG9uZW50LmRlZmF1bHQucHJlcGFyZT8uKGFwcClcbiAgYXBwLm1vdW50KFwiI19fcGxhc21vXCIpXG59KVxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2PjwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdCBzZXR1cD5cbmltcG9ydCAnQC9mZWF0dXJlRmxhZ3NDb25maWcnXG5cbmltcG9ydCB7Y3JlYXRlQXBwfSBmcm9tICd2dWUnXG5cbmltcG9ydCB7Y3JlYXRlUGluaWF9IGZyb20gJ3BpbmlhJ1xuXG5pbXBvcnQge2kxOG5QbHVnaW59IGZyb20gJ0AvdXRpbHMvaTE4bidcbmltcG9ydCB1c2VTdG9yZSBmcm9tICdAL3N0b3Jlcy9zdG9yZSdcblxuaW1wb3J0IFdlYnBpbG90UG9wdXAgZnJvbSAnLi9jb21wb25ldG5zL1dlYnBpbG90UG9wdXAudnVlJ1xuaW1wb3J0ICd2dWUtdG9hc3Qtbm90aWZpY2F0aW9uL2Rpc3QvdGhlbWUtYm9vdHN0cmFwLmNzcydcblxuY29uc3QgYXBwID0gY3JlYXRlQXBwKFdlYnBpbG90UG9wdXApXG5jb25zdCBwaW5pYSA9IGNyZWF0ZVBpbmlhKClcbmFwcC51c2UocGluaWEpXG5hcHAudXNlKGkxOG5QbHVnaW4pXG5cbmNvbnN0IHNvdGVyQ29uZmlnID0gdXNlU3RvcmUoKVxuc290ZXJDb25maWcuaW5pdENvbmZpZygpLnRoZW4oKCkgPT4ge1xuICBhcHAubW91bnQoJyN3ZWJwaWxvdC1wb3B1cC1wYWdlJylcbn0pXG48L3NjcmlwdD5cbiIsIi8vIEhhcmRjb2RlIHRvIGRpc2FibGUgdGhlIGV4dGlzaW9ucyB3YXJuaW5nXG5cbmdsb2JhbFRoaXMuX19WVUVfT1BUSU9OU19BUElfXyA9IGZhbHNlXG5nbG9iYWxUaGlzLl9fVlVFX1BST0RfREVWVE9PTFNfXyA9IGZhbHNlXG4iLCIvKipcbiogdnVlIHYzLjUuMTZcbiogKGMpIDIwMTgtcHJlc2VudCBZdXhpIChFdmFuKSBZb3UgYW5kIFZ1ZSBjb250cmlidXRvcnNcbiogQGxpY2Vuc2UgTUlUXG4qKi9cbmltcG9ydCB7IGluaXRDdXN0b21Gb3JtYXR0ZXIsIHdhcm4gfSBmcm9tICdAdnVlL3J1bnRpbWUtZG9tJztcbmV4cG9ydCAqIGZyb20gJ0B2dWUvcnVudGltZS1kb20nO1xuXG5mdW5jdGlvbiBpbml0RGV2KCkge1xuICB7XG4gICAgaW5pdEN1c3RvbUZvcm1hdHRlcigpO1xuICB9XG59XG5cbmlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gIGluaXREZXYoKTtcbn1cbmNvbnN0IGNvbXBpbGUgPSAoKSA9PiB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FybihcbiAgICAgIGBSdW50aW1lIGNvbXBpbGF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBWdWUuYCArIChgIENvbmZpZ3VyZSB5b3VyIGJ1bmRsZXIgdG8gYWxpYXMgXCJ2dWVcIiB0byBcInZ1ZS9kaXN0L3Z1ZS5lc20tYnVuZGxlci5qc1wiLmAgKVxuICAgICk7XG4gIH1cbn07XG5cbmV4cG9ydCB7IGNvbXBpbGUgfTtcbiIsIi8qKlxuKiBAdnVlL3J1bnRpbWUtZG9tIHYzLjUuMTZcbiogKGMpIDIwMTgtcHJlc2VudCBZdXhpIChFdmFuKSBZb3UgYW5kIFZ1ZSBjb250cmlidXRvcnNcbiogQGxpY2Vuc2UgTUlUXG4qKi9cbmltcG9ydCB7IHdhcm4sIEJhc2VUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLCBoLCBCYXNlVHJhbnNpdGlvbiwgYXNzZXJ0TnVtYmVyLCBnZXRDdXJyZW50SW5zdGFuY2UsIG9uQmVmb3JlVXBkYXRlLCBxdWV1ZVBvc3RGbHVzaENiLCBvbk1vdW50ZWQsIHdhdGNoLCBvblVubW91bnRlZCwgRnJhZ21lbnQsIFN0YXRpYywgY2FtZWxpemUsIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nLCBkZWZpbmVDb21wb25lbnQsIG5leHRUaWNrLCB1bnJlZiwgY3JlYXRlVk5vZGUsIHVzZVRyYW5zaXRpb25TdGF0ZSwgb25VcGRhdGVkLCB0b1JhdywgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuLCBzZXRUcmFuc2l0aW9uSG9va3MsIHJlc29sdmVUcmFuc2l0aW9uSG9va3MsIFRleHQsIGNyZWF0ZVJlbmRlcmVyLCBjcmVhdGVIeWRyYXRpb25SZW5kZXJlciwgaXNSdW50aW1lT25seSB9IGZyb20gJ0B2dWUvcnVudGltZS1jb3JlJztcbmV4cG9ydCAqIGZyb20gJ0B2dWUvcnVudGltZS1jb3JlJztcbmltcG9ydCB7IGV4dGVuZCwgaXNPYmplY3QsIHRvTnVtYmVyLCBpc0FycmF5LCBOT09QLCBpc1N0cmluZywgaHlwaGVuYXRlLCBjYXBpdGFsaXplLCBpc1NwZWNpYWxCb29sZWFuQXR0ciwgaW5jbHVkZUJvb2xlYW5BdHRyLCBpc1N5bWJvbCwgaXNGdW5jdGlvbiwgaXNPbiwgaXNNb2RlbExpc3RlbmVyLCBjYW1lbGl6ZSBhcyBjYW1lbGl6ZSQxLCBpc1BsYWluT2JqZWN0LCBoYXNPd24sIEVNUFRZX09CSiwgbG9vc2VUb051bWJlciwgbG9vc2VJbmRleE9mLCBpc1NldCwgbG9vc2VFcXVhbCwgaW52b2tlQXJyYXlGbnMsIGlzSFRNTFRhZywgaXNTVkdUYWcsIGlzTWF0aE1MVGFnIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5sZXQgcG9saWN5ID0gdm9pZCAwO1xuY29uc3QgdHQgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy50cnVzdGVkVHlwZXM7XG5pZiAodHQpIHtcbiAgdHJ5IHtcbiAgICBwb2xpY3kgPSAvKiBAX19QVVJFX18gKi8gdHQuY3JlYXRlUG9saWN5KFwidnVlXCIsIHtcbiAgICAgIGNyZWF0ZUhUTUw6ICh2YWwpID0+IHZhbFxuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGBFcnJvciBjcmVhdGluZyB0cnVzdGVkIHR5cGVzIHBvbGljeTogJHtlfWApO1xuICB9XG59XG5jb25zdCB1bnNhZmVUb1RydXN0ZWRIVE1MID0gcG9saWN5ID8gKHZhbCkgPT4gcG9saWN5LmNyZWF0ZUhUTUwodmFsKSA6ICh2YWwpID0+IHZhbDtcbmNvbnN0IHN2Z05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuY29uc3QgbWF0aG1sTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIjtcbmNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogbnVsbDtcbmNvbnN0IHRlbXBsYXRlQ29udGFpbmVyID0gZG9jICYmIC8qIEBfX1BVUkVfXyAqLyBkb2MuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuY29uc3Qgbm9kZU9wcyA9IHtcbiAgaW5zZXJ0OiAoY2hpbGQsIHBhcmVudCwgYW5jaG9yKSA9PiB7XG4gICAgcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgYW5jaG9yIHx8IG51bGwpO1xuICB9LFxuICByZW1vdmU6IChjaGlsZCkgPT4ge1xuICAgIGNvbnN0IHBhcmVudCA9IGNoaWxkLnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9XG4gIH0sXG4gIGNyZWF0ZUVsZW1lbnQ6ICh0YWcsIG5hbWVzcGFjZSwgaXMsIHByb3BzKSA9PiB7XG4gICAgY29uc3QgZWwgPSBuYW1lc3BhY2UgPT09IFwic3ZnXCIgPyBkb2MuY3JlYXRlRWxlbWVudE5TKHN2Z05TLCB0YWcpIDogbmFtZXNwYWNlID09PSBcIm1hdGhtbFwiID8gZG9jLmNyZWF0ZUVsZW1lbnROUyhtYXRobWxOUywgdGFnKSA6IGlzID8gZG9jLmNyZWF0ZUVsZW1lbnQodGFnLCB7IGlzIH0pIDogZG9jLmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICBpZiAodGFnID09PSBcInNlbGVjdFwiICYmIHByb3BzICYmIHByb3BzLm11bHRpcGxlICE9IG51bGwpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShcIm11bHRpcGxlXCIsIHByb3BzLm11bHRpcGxlKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsO1xuICB9LFxuICBjcmVhdGVUZXh0OiAodGV4dCkgPT4gZG9jLmNyZWF0ZVRleHROb2RlKHRleHQpLFxuICBjcmVhdGVDb21tZW50OiAodGV4dCkgPT4gZG9jLmNyZWF0ZUNvbW1lbnQodGV4dCksXG4gIHNldFRleHQ6IChub2RlLCB0ZXh0KSA9PiB7XG4gICAgbm9kZS5ub2RlVmFsdWUgPSB0ZXh0O1xuICB9LFxuICBzZXRFbGVtZW50VGV4dDogKGVsLCB0ZXh0KSA9PiB7XG4gICAgZWwudGV4dENvbnRlbnQgPSB0ZXh0O1xuICB9LFxuICBwYXJlbnROb2RlOiAobm9kZSkgPT4gbm9kZS5wYXJlbnROb2RlLFxuICBuZXh0U2libGluZzogKG5vZGUpID0+IG5vZGUubmV4dFNpYmxpbmcsXG4gIHF1ZXJ5U2VsZWN0b3I6IChzZWxlY3RvcikgPT4gZG9jLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpLFxuICBzZXRTY29wZUlkKGVsLCBpZCkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShpZCwgXCJcIik7XG4gIH0sXG4gIC8vIF9fVU5TQUZFX19cbiAgLy8gUmVhc29uOiBpbm5lckhUTUwuXG4gIC8vIFN0YXRpYyBjb250ZW50IGhlcmUgY2FuIG9ubHkgY29tZSBmcm9tIGNvbXBpbGVkIHRlbXBsYXRlcy5cbiAgLy8gQXMgbG9uZyBhcyB0aGUgdXNlciBvbmx5IHVzZXMgdHJ1c3RlZCB0ZW1wbGF0ZXMsIHRoaXMgaXMgc2FmZS5cbiAgaW5zZXJ0U3RhdGljQ29udGVudChjb250ZW50LCBwYXJlbnQsIGFuY2hvciwgbmFtZXNwYWNlLCBzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgYmVmb3JlID0gYW5jaG9yID8gYW5jaG9yLnByZXZpb3VzU2libGluZyA6IHBhcmVudC5sYXN0Q2hpbGQ7XG4gICAgaWYgKHN0YXJ0ICYmIChzdGFydCA9PT0gZW5kIHx8IHN0YXJ0Lm5leHRTaWJsaW5nKSkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShzdGFydC5jbG9uZU5vZGUodHJ1ZSksIGFuY2hvcik7XG4gICAgICAgIGlmIChzdGFydCA9PT0gZW5kIHx8ICEoc3RhcnQgPSBzdGFydC5uZXh0U2libGluZykpIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0ZW1wbGF0ZUNvbnRhaW5lci5pbm5lckhUTUwgPSB1bnNhZmVUb1RydXN0ZWRIVE1MKFxuICAgICAgICBuYW1lc3BhY2UgPT09IFwic3ZnXCIgPyBgPHN2Zz4ke2NvbnRlbnR9PC9zdmc+YCA6IG5hbWVzcGFjZSA9PT0gXCJtYXRobWxcIiA/IGA8bWF0aD4ke2NvbnRlbnR9PC9tYXRoPmAgOiBjb250ZW50XG4gICAgICApO1xuICAgICAgY29uc3QgdGVtcGxhdGUgPSB0ZW1wbGF0ZUNvbnRhaW5lci5jb250ZW50O1xuICAgICAgaWYgKG5hbWVzcGFjZSA9PT0gXCJzdmdcIiB8fCBuYW1lc3BhY2UgPT09IFwibWF0aG1sXCIpIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IHRlbXBsYXRlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHdoaWxlICh3cmFwcGVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICB0ZW1wbGF0ZS5hcHBlbmRDaGlsZCh3cmFwcGVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBsYXRlLnJlbW92ZUNoaWxkKHdyYXBwZXIpO1xuICAgICAgfVxuICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh0ZW1wbGF0ZSwgYW5jaG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIC8vIGZpcnN0XG4gICAgICBiZWZvcmUgPyBiZWZvcmUubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZCxcbiAgICAgIC8vIGxhc3RcbiAgICAgIGFuY2hvciA/IGFuY2hvci5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnQubGFzdENoaWxkXG4gICAgXTtcbiAgfVxufTtcblxuY29uc3QgVFJBTlNJVElPTiA9IFwidHJhbnNpdGlvblwiO1xuY29uc3QgQU5JTUFUSU9OID0gXCJhbmltYXRpb25cIjtcbmNvbnN0IHZ0Y0tleSA9IFN5bWJvbChcIl92dGNcIik7XG5jb25zdCBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIHR5cGU6IFN0cmluZyxcbiAgY3NzOiB7XG4gICAgdHlwZTogQm9vbGVhbixcbiAgICBkZWZhdWx0OiB0cnVlXG4gIH0sXG4gIGR1cmF0aW9uOiBbU3RyaW5nLCBOdW1iZXIsIE9iamVjdF0sXG4gIGVudGVyRnJvbUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckZyb21DbGFzczogU3RyaW5nLFxuICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlRnJvbUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVUb0NsYXNzOiBTdHJpbmdcbn07XG5jb25zdCBUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzID0gLyogQF9fUFVSRV9fICovIGV4dGVuZChcbiAge30sXG4gIEJhc2VUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLFxuICBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzXG4pO1xuY29uc3QgZGVjb3JhdGUkMSA9ICh0KSA9PiB7XG4gIHQuZGlzcGxheU5hbWUgPSBcIlRyYW5zaXRpb25cIjtcbiAgdC5wcm9wcyA9IFRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnM7XG4gIHJldHVybiB0O1xufTtcbmNvbnN0IFRyYW5zaXRpb24gPSAvKiBAX19QVVJFX18gKi8gZGVjb3JhdGUkMShcbiAgKHByb3BzLCB7IHNsb3RzIH0pID0+IGgoQmFzZVRyYW5zaXRpb24sIHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocHJvcHMpLCBzbG90cylcbik7XG5jb25zdCBjYWxsSG9vayA9IChob29rLCBhcmdzID0gW10pID0+IHtcbiAgaWYgKGlzQXJyYXkoaG9vaykpIHtcbiAgICBob29rLmZvckVhY2goKGgyKSA9PiBoMiguLi5hcmdzKSk7XG4gIH0gZWxzZSBpZiAoaG9vaykge1xuICAgIGhvb2soLi4uYXJncyk7XG4gIH1cbn07XG5jb25zdCBoYXNFeHBsaWNpdENhbGxiYWNrID0gKGhvb2spID0+IHtcbiAgcmV0dXJuIGhvb2sgPyBpc0FycmF5KGhvb2spID8gaG9vay5zb21lKChoMikgPT4gaDIubGVuZ3RoID4gMSkgOiBob29rLmxlbmd0aCA+IDEgOiBmYWxzZTtcbn07XG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvblByb3BzKHJhd1Byb3BzKSB7XG4gIGNvbnN0IGJhc2VQcm9wcyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiByYXdQcm9wcykge1xuICAgIGlmICghKGtleSBpbiBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzKSkge1xuICAgICAgYmFzZVByb3BzW2tleV0gPSByYXdQcm9wc1trZXldO1xuICAgIH1cbiAgfVxuICBpZiAocmF3UHJvcHMuY3NzID09PSBmYWxzZSkge1xuICAgIHJldHVybiBiYXNlUHJvcHM7XG4gIH1cbiAgY29uc3Qge1xuICAgIG5hbWUgPSBcInZcIixcbiAgICB0eXBlLFxuICAgIGR1cmF0aW9uLFxuICAgIGVudGVyRnJvbUNsYXNzID0gYCR7bmFtZX0tZW50ZXItZnJvbWAsXG4gICAgZW50ZXJBY3RpdmVDbGFzcyA9IGAke25hbWV9LWVudGVyLWFjdGl2ZWAsXG4gICAgZW50ZXJUb0NsYXNzID0gYCR7bmFtZX0tZW50ZXItdG9gLFxuICAgIGFwcGVhckZyb21DbGFzcyA9IGVudGVyRnJvbUNsYXNzLFxuICAgIGFwcGVhckFjdGl2ZUNsYXNzID0gZW50ZXJBY3RpdmVDbGFzcyxcbiAgICBhcHBlYXJUb0NsYXNzID0gZW50ZXJUb0NsYXNzLFxuICAgIGxlYXZlRnJvbUNsYXNzID0gYCR7bmFtZX0tbGVhdmUtZnJvbWAsXG4gICAgbGVhdmVBY3RpdmVDbGFzcyA9IGAke25hbWV9LWxlYXZlLWFjdGl2ZWAsXG4gICAgbGVhdmVUb0NsYXNzID0gYCR7bmFtZX0tbGVhdmUtdG9gXG4gIH0gPSByYXdQcm9wcztcbiAgY29uc3QgZHVyYXRpb25zID0gbm9ybWFsaXplRHVyYXRpb24oZHVyYXRpb24pO1xuICBjb25zdCBlbnRlckR1cmF0aW9uID0gZHVyYXRpb25zICYmIGR1cmF0aW9uc1swXTtcbiAgY29uc3QgbGVhdmVEdXJhdGlvbiA9IGR1cmF0aW9ucyAmJiBkdXJhdGlvbnNbMV07XG4gIGNvbnN0IHtcbiAgICBvbkJlZm9yZUVudGVyLFxuICAgIG9uRW50ZXIsXG4gICAgb25FbnRlckNhbmNlbGxlZCxcbiAgICBvbkxlYXZlLFxuICAgIG9uTGVhdmVDYW5jZWxsZWQsXG4gICAgb25CZWZvcmVBcHBlYXIgPSBvbkJlZm9yZUVudGVyLFxuICAgIG9uQXBwZWFyID0gb25FbnRlcixcbiAgICBvbkFwcGVhckNhbmNlbGxlZCA9IG9uRW50ZXJDYW5jZWxsZWRcbiAgfSA9IGJhc2VQcm9wcztcbiAgY29uc3QgZmluaXNoRW50ZXIgPSAoZWwsIGlzQXBwZWFyLCBkb25lLCBpc0NhbmNlbGxlZCkgPT4ge1xuICAgIGVsLl9lbnRlckNhbmNlbGxlZCA9IGlzQ2FuY2VsbGVkO1xuICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJUb0NsYXNzIDogZW50ZXJUb0NsYXNzKTtcbiAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyQWN0aXZlQ2xhc3MgOiBlbnRlckFjdGl2ZUNsYXNzKTtcbiAgICBkb25lICYmIGRvbmUoKTtcbiAgfTtcbiAgY29uc3QgZmluaXNoTGVhdmUgPSAoZWwsIGRvbmUpID0+IHtcbiAgICBlbC5faXNMZWF2aW5nID0gZmFsc2U7XG4gICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XG4gICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgZG9uZSAmJiBkb25lKCk7XG4gIH07XG4gIGNvbnN0IG1ha2VFbnRlckhvb2sgPSAoaXNBcHBlYXIpID0+IHtcbiAgICByZXR1cm4gKGVsLCBkb25lKSA9PiB7XG4gICAgICBjb25zdCBob29rID0gaXNBcHBlYXIgPyBvbkFwcGVhciA6IG9uRW50ZXI7XG4gICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoRW50ZXIoZWwsIGlzQXBwZWFyLCBkb25lKTtcbiAgICAgIGNhbGxIb29rKGhvb2ssIFtlbCwgcmVzb2x2ZV0pO1xuICAgICAgbmV4dEZyYW1lKCgpID0+IHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhckZyb21DbGFzcyA6IGVudGVyRnJvbUNsYXNzKTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3MpO1xuICAgICAgICBpZiAoIWhhc0V4cGxpY2l0Q2FsbGJhY2soaG9vaykpIHtcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGVudGVyRHVyYXRpb24sIHJlc29sdmUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuICByZXR1cm4gZXh0ZW5kKGJhc2VQcm9wcywge1xuICAgIG9uQmVmb3JlRW50ZXIoZWwpIHtcbiAgICAgIGNhbGxIb29rKG9uQmVmb3JlRW50ZXIsIFtlbF0pO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBlbnRlckZyb21DbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGVudGVyQWN0aXZlQ2xhc3MpO1xuICAgIH0sXG4gICAgb25CZWZvcmVBcHBlYXIoZWwpIHtcbiAgICAgIGNhbGxIb29rKG9uQmVmb3JlQXBwZWFyLCBbZWxdKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYXBwZWFyRnJvbUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYXBwZWFyQWN0aXZlQ2xhc3MpO1xuICAgIH0sXG4gICAgb25FbnRlcjogbWFrZUVudGVySG9vayhmYWxzZSksXG4gICAgb25BcHBlYXI6IG1ha2VFbnRlckhvb2sodHJ1ZSksXG4gICAgb25MZWF2ZShlbCwgZG9uZSkge1xuICAgICAgZWwuX2lzTGVhdmluZyA9IHRydWU7XG4gICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoTGVhdmUoZWwsIGRvbmUpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XG4gICAgICBpZiAoIWVsLl9lbnRlckNhbmNlbGxlZCkge1xuICAgICAgICBmb3JjZVJlZmxvdygpO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgICAgZm9yY2VSZWZsb3coKTtcbiAgICAgIH1cbiAgICAgIG5leHRGcmFtZSgoKSA9PiB7XG4gICAgICAgIGlmICghZWwuX2lzTGVhdmluZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlRnJvbUNsYXNzKTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICBpZiAoIWhhc0V4cGxpY2l0Q2FsbGJhY2sob25MZWF2ZSkpIHtcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGxlYXZlRHVyYXRpb24sIHJlc29sdmUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNhbGxIb29rKG9uTGVhdmUsIFtlbCwgcmVzb2x2ZV0pO1xuICAgIH0sXG4gICAgb25FbnRlckNhbmNlbGxlZChlbCkge1xuICAgICAgZmluaXNoRW50ZXIoZWwsIGZhbHNlLCB2b2lkIDAsIHRydWUpO1xuICAgICAgY2FsbEhvb2sob25FbnRlckNhbmNlbGxlZCwgW2VsXSk7XG4gICAgfSxcbiAgICBvbkFwcGVhckNhbmNlbGxlZChlbCkge1xuICAgICAgZmluaXNoRW50ZXIoZWwsIHRydWUsIHZvaWQgMCwgdHJ1ZSk7XG4gICAgICBjYWxsSG9vayhvbkFwcGVhckNhbmNlbGxlZCwgW2VsXSk7XG4gICAgfSxcbiAgICBvbkxlYXZlQ2FuY2VsbGVkKGVsKSB7XG4gICAgICBmaW5pc2hMZWF2ZShlbCk7XG4gICAgICBjYWxsSG9vayhvbkxlYXZlQ2FuY2VsbGVkLCBbZWxdKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplRHVyYXRpb24oZHVyYXRpb24pIHtcbiAgaWYgKGR1cmF0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmIChpc09iamVjdChkdXJhdGlvbikpIHtcbiAgICByZXR1cm4gW051bWJlck9mKGR1cmF0aW9uLmVudGVyKSwgTnVtYmVyT2YoZHVyYXRpb24ubGVhdmUpXTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBuID0gTnVtYmVyT2YoZHVyYXRpb24pO1xuICAgIHJldHVybiBbbiwgbl07XG4gIH1cbn1cbmZ1bmN0aW9uIE51bWJlck9mKHZhbCkge1xuICBjb25zdCByZXMgPSB0b051bWJlcih2YWwpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGFzc2VydE51bWJlcihyZXMsIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IGR1cmF0aW9uXCIpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGNscykge1xuICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKChjKSA9PiBjICYmIGVsLmNsYXNzTGlzdC5hZGQoYykpO1xuICAoZWxbdnRjS2V5XSB8fCAoZWxbdnRjS2V5XSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpKS5hZGQoY2xzKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgY2xzKSB7XG4gIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goKGMpID0+IGMgJiYgZWwuY2xhc3NMaXN0LnJlbW92ZShjKSk7XG4gIGNvbnN0IF92dGMgPSBlbFt2dGNLZXldO1xuICBpZiAoX3Z0Yykge1xuICAgIF92dGMuZGVsZXRlKGNscyk7XG4gICAgaWYgKCFfdnRjLnNpemUpIHtcbiAgICAgIGVsW3Z0Y0tleV0gPSB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBuZXh0RnJhbWUoY2IpIHtcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpO1xuICB9KTtcbn1cbmxldCBlbmRJZCA9IDA7XG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIGV4cGVjdGVkVHlwZSwgZXhwbGljaXRUaW1lb3V0LCByZXNvbHZlKSB7XG4gIGNvbnN0IGlkID0gZWwuX2VuZElkID0gKytlbmRJZDtcbiAgY29uc3QgcmVzb2x2ZUlmTm90U3RhbGUgPSAoKSA9PiB7XG4gICAgaWYgKGlkID09PSBlbC5fZW5kSWQpIHtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9XG4gIH07XG4gIGlmIChleHBsaWNpdFRpbWVvdXQgIT0gbnVsbCkge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmVJZk5vdFN0YWxlLCBleHBsaWNpdFRpbWVvdXQpO1xuICB9XG4gIGNvbnN0IHsgdHlwZSwgdGltZW91dCwgcHJvcENvdW50IH0gPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcbiAgaWYgKCF0eXBlKSB7XG4gICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgfVxuICBjb25zdCBlbmRFdmVudCA9IHR5cGUgKyBcImVuZFwiO1xuICBsZXQgZW5kZWQgPSAwO1xuICBjb25zdCBlbmQgPSAoKSA9PiB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihlbmRFdmVudCwgb25FbmQpO1xuICAgIHJlc29sdmVJZk5vdFN0YWxlKCk7XG4gIH07XG4gIGNvbnN0IG9uRW5kID0gKGUpID0+IHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsICYmICsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH07XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9LCB0aW1lb3V0ICsgMSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZW5kRXZlbnQsIG9uRW5kKTtcbn1cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgY29uc3Qgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICBjb25zdCBnZXRTdHlsZVByb3BlcnRpZXMgPSAoa2V5KSA9PiAoc3R5bGVzW2tleV0gfHwgXCJcIikuc3BsaXQoXCIsIFwiKTtcbiAgY29uc3QgdHJhbnNpdGlvbkRlbGF5cyA9IGdldFN0eWxlUHJvcGVydGllcyhgJHtUUkFOU0lUSU9OfURlbGF5YCk7XG4gIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbnMgPSBnZXRTdHlsZVByb3BlcnRpZXMoYCR7VFJBTlNJVElPTn1EdXJhdGlvbmApO1xuICBjb25zdCB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gIGNvbnN0IGFuaW1hdGlvbkRlbGF5cyA9IGdldFN0eWxlUHJvcGVydGllcyhgJHtBTklNQVRJT059RGVsYXlgKTtcbiAgY29uc3QgYW5pbWF0aW9uRHVyYXRpb25zID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke0FOSU1BVElPTn1EdXJhdGlvbmApO1xuICBjb25zdCBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG4gIGxldCB0eXBlID0gbnVsbDtcbiAgbGV0IHRpbWVvdXQgPSAwO1xuICBsZXQgcHJvcENvdW50ID0gMDtcbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMCA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dCA/IFRSQU5TSVRJT04gOiBBTklNQVRJT04gOiBudWxsO1xuICAgIHByb3BDb3VudCA9IHR5cGUgPyB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGggOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoIDogMDtcbiAgfVxuICBjb25zdCBoYXNUcmFuc2Zvcm0gPSB0eXBlID09PSBUUkFOU0lUSU9OICYmIC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS8udGVzdChcbiAgICBnZXRTdHlsZVByb3BlcnRpZXMoYCR7VFJBTlNJVElPTn1Qcm9wZXJ0eWApLnRvU3RyaW5nKClcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIHRpbWVvdXQsXG4gICAgcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0VGltZW91dChkZWxheXMsIGR1cmF0aW9ucykge1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cbiAgcmV0dXJuIE1hdGgubWF4KC4uLmR1cmF0aW9ucy5tYXAoKGQsIGkpID0+IHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSkpKTtcbn1cbmZ1bmN0aW9uIHRvTXMocykge1xuICBpZiAocyA9PT0gXCJhdXRvXCIpIHJldHVybiAwO1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpLnJlcGxhY2UoXCIsXCIsIFwiLlwiKSkgKiAxZTM7XG59XG5mdW5jdGlvbiBmb3JjZVJlZmxvdygpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xufVxuXG5mdW5jdGlvbiBwYXRjaENsYXNzKGVsLCB2YWx1ZSwgaXNTVkcpIHtcbiAgY29uc3QgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbFt2dGNLZXldO1xuICBpZiAodHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICB2YWx1ZSA9ICh2YWx1ZSA/IFt2YWx1ZSwgLi4udHJhbnNpdGlvbkNsYXNzZXNdIDogWy4uLnRyYW5zaXRpb25DbGFzc2VzXSkuam9pbihcIiBcIik7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgfSBlbHNlIGlmIChpc1NWRykge1xuICAgIGVsLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5jbGFzc05hbWUgPSB2YWx1ZTtcbiAgfVxufVxuXG5jb25zdCB2U2hvd09yaWdpbmFsRGlzcGxheSA9IFN5bWJvbChcIl92b2RcIik7XG5jb25zdCB2U2hvd0hpZGRlbiA9IFN5bWJvbChcIl92c2hcIik7XG5jb25zdCB2U2hvdyA9IHtcbiAgYmVmb3JlTW91bnQoZWwsIHsgdmFsdWUgfSwgeyB0cmFuc2l0aW9uIH0pIHtcbiAgICBlbFt2U2hvd09yaWdpbmFsRGlzcGxheV0gPSBlbC5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiA/IFwiXCIgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgIGlmICh0cmFuc2l0aW9uICYmIHZhbHVlKSB7XG4gICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xuICAgIH1cbiAgfSxcbiAgbW91bnRlZChlbCwgeyB2YWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xuICAgIGlmICh0cmFuc2l0aW9uICYmIHZhbHVlKSB7XG4gICAgICB0cmFuc2l0aW9uLmVudGVyKGVsKTtcbiAgICB9XG4gIH0sXG4gIHVwZGF0ZWQoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XG4gICAgaWYgKCF2YWx1ZSA9PT0gIW9sZFZhbHVlKSByZXR1cm47XG4gICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcbiAgICAgICAgc2V0RGlzcGxheShlbCwgdHJ1ZSk7XG4gICAgICAgIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNpdGlvbi5sZWF2ZShlbCwgKCkgPT4ge1xuICAgICAgICAgIHNldERpc3BsYXkoZWwsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcbiAgICB9XG4gIH0sXG4gIGJlZm9yZVVubW91bnQoZWwsIHsgdmFsdWUgfSkge1xuICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcbiAgfVxufTtcbmlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gIHZTaG93Lm5hbWUgPSBcInNob3dcIjtcbn1cbmZ1bmN0aW9uIHNldERpc3BsYXkoZWwsIHZhbHVlKSB7XG4gIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsW3ZTaG93T3JpZ2luYWxEaXNwbGF5XSA6IFwibm9uZVwiO1xuICBlbFt2U2hvd0hpZGRlbl0gPSAhdmFsdWU7XG59XG5mdW5jdGlvbiBpbml0VlNob3dGb3JTU1IoKSB7XG4gIHZTaG93LmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSkgPT4ge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiB7IHN0eWxlOiB7IGRpc3BsYXk6IFwibm9uZVwiIH0gfTtcbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IENTU19WQVJfVEVYVCA9IFN5bWJvbCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gXCJDU1NfVkFSX1RFWFRcIiA6IFwiXCIpO1xuZnVuY3Rpb24gdXNlQ3NzVmFycyhnZXR0ZXIpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKCFpbnN0YW5jZSkge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgdXNlQ3NzVmFycyBpcyBjYWxsZWQgd2l0aG91dCBjdXJyZW50IGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UuYCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHVwZGF0ZVRlbGVwb3J0cyA9IGluc3RhbmNlLnV0ID0gKHZhcnMgPSBnZXR0ZXIoaW5zdGFuY2UucHJveHkpKSA9PiB7XG4gICAgQXJyYXkuZnJvbShcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYFtkYXRhLXYtb3duZXI9XCIke2luc3RhbmNlLnVpZH1cIl1gKVxuICAgICkuZm9yRWFjaCgobm9kZSkgPT4gc2V0VmFyc09uTm9kZShub2RlLCB2YXJzKSk7XG4gIH07XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgaW5zdGFuY2UuZ2V0Q3NzVmFycyA9ICgpID0+IGdldHRlcihpbnN0YW5jZS5wcm94eSk7XG4gIH1cbiAgY29uc3Qgc2V0VmFycyA9ICgpID0+IHtcbiAgICBjb25zdCB2YXJzID0gZ2V0dGVyKGluc3RhbmNlLnByb3h5KTtcbiAgICBpZiAoaW5zdGFuY2UuY2UpIHtcbiAgICAgIHNldFZhcnNPbk5vZGUoaW5zdGFuY2UuY2UsIHZhcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRWYXJzT25WTm9kZShpbnN0YW5jZS5zdWJUcmVlLCB2YXJzKTtcbiAgICB9XG4gICAgdXBkYXRlVGVsZXBvcnRzKHZhcnMpO1xuICB9O1xuICBvbkJlZm9yZVVwZGF0ZSgoKSA9PiB7XG4gICAgcXVldWVQb3N0Rmx1c2hDYihzZXRWYXJzKTtcbiAgfSk7XG4gIG9uTW91bnRlZCgoKSA9PiB7XG4gICAgd2F0Y2goc2V0VmFycywgTk9PUCwgeyBmbHVzaDogXCJwb3N0XCIgfSk7XG4gICAgY29uc3Qgb2IgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihzZXRWYXJzKTtcbiAgICBvYi5vYnNlcnZlKGluc3RhbmNlLnN1YlRyZWUuZWwucGFyZW50Tm9kZSwgeyBjaGlsZExpc3Q6IHRydWUgfSk7XG4gICAgb25Vbm1vdW50ZWQoKCkgPT4gb2IuZGlzY29ubmVjdCgpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzZXRWYXJzT25WTm9kZSh2bm9kZSwgdmFycykge1xuICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgY29uc3Qgc3VzcGVuc2UgPSB2bm9kZS5zdXNwZW5zZTtcbiAgICB2bm9kZSA9IHN1c3BlbnNlLmFjdGl2ZUJyYW5jaDtcbiAgICBpZiAoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCAmJiAhc3VzcGVuc2UuaXNIeWRyYXRpbmcpIHtcbiAgICAgIHN1c3BlbnNlLmVmZmVjdHMucHVzaCgoKSA9PiB7XG4gICAgICAgIHNldFZhcnNPblZOb2RlKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgdmFycyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKHZub2RlLmNvbXBvbmVudCkge1xuICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50LnN1YlRyZWU7XG4gIH1cbiAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEgJiYgdm5vZGUuZWwpIHtcbiAgICBzZXRWYXJzT25Ob2RlKHZub2RlLmVsLCB2YXJzKTtcbiAgfSBlbHNlIGlmICh2bm9kZS50eXBlID09PSBGcmFnbWVudCkge1xuICAgIHZub2RlLmNoaWxkcmVuLmZvckVhY2goKGMpID0+IHNldFZhcnNPblZOb2RlKGMsIHZhcnMpKTtcbiAgfSBlbHNlIGlmICh2bm9kZS50eXBlID09PSBTdGF0aWMpIHtcbiAgICBsZXQgeyBlbCwgYW5jaG9yIH0gPSB2bm9kZTtcbiAgICB3aGlsZSAoZWwpIHtcbiAgICAgIHNldFZhcnNPbk5vZGUoZWwsIHZhcnMpO1xuICAgICAgaWYgKGVsID09PSBhbmNob3IpIGJyZWFrO1xuICAgICAgZWwgPSBlbC5uZXh0U2libGluZztcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFZhcnNPbk5vZGUoZWwsIHZhcnMpIHtcbiAgaWYgKGVsLm5vZGVUeXBlID09PSAxKSB7XG4gICAgY29uc3Qgc3R5bGUgPSBlbC5zdHlsZTtcbiAgICBsZXQgY3NzVGV4dCA9IFwiXCI7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdmFycykge1xuICAgICAgc3R5bGUuc2V0UHJvcGVydHkoYC0tJHtrZXl9YCwgdmFyc1trZXldKTtcbiAgICAgIGNzc1RleHQgKz0gYC0tJHtrZXl9OiAke3ZhcnNba2V5XX07YDtcbiAgICB9XG4gICAgc3R5bGVbQ1NTX1ZBUl9URVhUXSA9IGNzc1RleHQ7XG4gIH1cbn1cblxuY29uc3QgZGlzcGxheVJFID0gLyhefDspXFxzKmRpc3BsYXlcXHMqOi87XG5mdW5jdGlvbiBwYXRjaFN0eWxlKGVsLCBwcmV2LCBuZXh0KSB7XG4gIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XG4gIGNvbnN0IGlzQ3NzU3RyaW5nID0gaXNTdHJpbmcobmV4dCk7XG4gIGxldCBoYXNDb250cm9sbGVkRGlzcGxheSA9IGZhbHNlO1xuICBpZiAobmV4dCAmJiAhaXNDc3NTdHJpbmcpIHtcbiAgICBpZiAocHJldikge1xuICAgICAgaWYgKCFpc1N0cmluZyhwcmV2KSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcmV2KSB7XG4gICAgICAgICAgaWYgKG5leHRba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICBzZXRTdHlsZShzdHlsZSwga2V5LCBcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgcHJldlN0eWxlIG9mIHByZXYuc3BsaXQoXCI7XCIpKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gcHJldlN0eWxlLnNsaWNlKDAsIHByZXZTdHlsZS5pbmRleE9mKFwiOlwiKSkudHJpbSgpO1xuICAgICAgICAgIGlmIChuZXh0W2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0U3R5bGUoc3R5bGUsIGtleSwgXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIG5leHQpIHtcbiAgICAgIGlmIChrZXkgPT09IFwiZGlzcGxheVwiKSB7XG4gICAgICAgIGhhc0NvbnRyb2xsZWREaXNwbGF5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNldFN0eWxlKHN0eWxlLCBrZXksIG5leHRba2V5XSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0Nzc1N0cmluZykge1xuICAgICAgaWYgKHByZXYgIT09IG5leHQpIHtcbiAgICAgICAgY29uc3QgY3NzVmFyVGV4dCA9IHN0eWxlW0NTU19WQVJfVEVYVF07XG4gICAgICAgIGlmIChjc3NWYXJUZXh0KSB7XG4gICAgICAgICAgbmV4dCArPSBcIjtcIiArIGNzc1ZhclRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGUuY3NzVGV4dCA9IG5leHQ7XG4gICAgICAgIGhhc0NvbnRyb2xsZWREaXNwbGF5ID0gZGlzcGxheVJFLnRlc3QobmV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcmV2KSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgICB9XG4gIH1cbiAgaWYgKHZTaG93T3JpZ2luYWxEaXNwbGF5IGluIGVsKSB7XG4gICAgZWxbdlNob3dPcmlnaW5hbERpc3BsYXldID0gaGFzQ29udHJvbGxlZERpc3BsYXkgPyBzdHlsZS5kaXNwbGF5IDogXCJcIjtcbiAgICBpZiAoZWxbdlNob3dIaWRkZW5dKSB7XG4gICAgICBzdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfVxuICB9XG59XG5jb25zdCBzZW1pY29sb25SRSA9IC9bXlxcXFxdO1xccyokLztcbmNvbnN0IGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG5mdW5jdGlvbiBzZXRTdHlsZShzdHlsZSwgbmFtZSwgdmFsKSB7XG4gIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICB2YWwuZm9yRWFjaCgodikgPT4gc2V0U3R5bGUoc3R5bGUsIG5hbWUsIHYpKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsID09IG51bGwpIHZhbCA9IFwiXCI7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGlmIChzZW1pY29sb25SRS50ZXN0KHZhbCkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgVW5leHBlY3RlZCBzZW1pY29sb24gYXQgdGhlIGVuZCBvZiAnJHtuYW1lfScgc3R5bGUgdmFsdWU6ICcke3ZhbH0nYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmFtZS5zdGFydHNXaXRoKFwiLS1cIikpIHtcbiAgICAgIHN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByZWZpeGVkID0gYXV0b1ByZWZpeChzdHlsZSwgbmFtZSk7XG4gICAgICBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgICAgIHN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgIGh5cGhlbmF0ZShwcmVmaXhlZCksXG4gICAgICAgICAgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsIFwiXCIpLFxuICAgICAgICAgIFwiaW1wb3J0YW50XCJcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlW3ByZWZpeGVkXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmNvbnN0IHByZWZpeGVzID0gW1wiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIl07XG5jb25zdCBwcmVmaXhDYWNoZSA9IHt9O1xuZnVuY3Rpb24gYXV0b1ByZWZpeChzdHlsZSwgcmF3TmFtZSkge1xuICBjb25zdCBjYWNoZWQgPSBwcmVmaXhDYWNoZVtyYXdOYW1lXTtcbiAgaWYgKGNhY2hlZCkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbiAgbGV0IG5hbWUgPSBjYW1lbGl6ZShyYXdOYW1lKTtcbiAgaWYgKG5hbWUgIT09IFwiZmlsdGVyXCIgJiYgbmFtZSBpbiBzdHlsZSkge1xuICAgIHJldHVybiBwcmVmaXhDYWNoZVtyYXdOYW1lXSA9IG5hbWU7XG4gIH1cbiAgbmFtZSA9IGNhcGl0YWxpemUobmFtZSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwcmVmaXhlZCA9IHByZWZpeGVzW2ldICsgbmFtZTtcbiAgICBpZiAocHJlZml4ZWQgaW4gc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhDYWNoZVtyYXdOYW1lXSA9IHByZWZpeGVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmF3TmFtZTtcbn1cblxuY29uc3QgeGxpbmtOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiO1xuZnVuY3Rpb24gcGF0Y2hBdHRyKGVsLCBrZXksIHZhbHVlLCBpc1NWRywgaW5zdGFuY2UsIGlzQm9vbGVhbiA9IGlzU3BlY2lhbEJvb2xlYW5BdHRyKGtleSkpIHtcbiAgaWYgKGlzU1ZHICYmIGtleS5zdGFydHNXaXRoKFwieGxpbms6XCIpKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleS5zbGljZSg2LCBrZXkubGVuZ3RoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBpc0Jvb2xlYW4gJiYgIWluY2x1ZGVCb29sZWFuQXR0cih2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoXG4gICAgICAgIGtleSxcbiAgICAgICAgaXNCb29sZWFuID8gXCJcIiA6IGlzU3ltYm9sKHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiB2YWx1ZVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGF0Y2hET01Qcm9wKGVsLCBrZXksIHZhbHVlLCBwYXJlbnRDb21wb25lbnQsIGF0dHJOYW1lKSB7XG4gIGlmIChrZXkgPT09IFwiaW5uZXJIVE1MXCIgfHwga2V5ID09PSBcInRleHRDb250ZW50XCIpIHtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgZWxba2V5XSA9IGtleSA9PT0gXCJpbm5lckhUTUxcIiA/IHVuc2FmZVRvVHJ1c3RlZEhUTUwodmFsdWUpIDogdmFsdWU7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0YWcgPSBlbC50YWdOYW1lO1xuICBpZiAoa2V5ID09PSBcInZhbHVlXCIgJiYgdGFnICE9PSBcIlBST0dSRVNTXCIgJiYgLy8gY3VzdG9tIGVsZW1lbnRzIG1heSB1c2UgX3ZhbHVlIGludGVybmFsbHlcbiAgIXRhZy5pbmNsdWRlcyhcIi1cIikpIHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRhZyA9PT0gXCJPUFRJT05cIiA/IGVsLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpIHx8IFwiXCIgOiBlbC52YWx1ZTtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlID09IG51bGwgPyAoXG4gICAgICAvLyAjMTE2NDc6IHZhbHVlIHNob3VsZCBiZSBzZXQgYXMgZW1wdHkgc3RyaW5nIGZvciBudWxsIGFuZCB1bmRlZmluZWQsXG4gICAgICAvLyBidXQgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiPiBzaG91bGQgYmUgc2V0IGFzICdvbicuXG4gICAgICBlbC50eXBlID09PSBcImNoZWNrYm94XCIgPyBcIm9uXCIgOiBcIlwiXG4gICAgKSA6IFN0cmluZyh2YWx1ZSk7XG4gICAgaWYgKG9sZFZhbHVlICE9PSBuZXdWYWx1ZSB8fCAhKFwiX3ZhbHVlXCIgaW4gZWwpKSB7XG4gICAgICBlbC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfVxuICAgIGVsLl92YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgbmVlZFJlbW92ZSA9IGZhbHNlO1xuICBpZiAodmFsdWUgPT09IFwiXCIgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgZWxba2V5XTtcbiAgICBpZiAodHlwZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHZhbHVlID0gaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09IG51bGwgJiYgdHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdmFsdWUgPSBcIlwiO1xuICAgICAgbmVlZFJlbW92ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICB2YWx1ZSA9IDA7XG4gICAgICBuZWVkUmVtb3ZlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICBlbFtrZXldID0gdmFsdWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhbmVlZFJlbW92ZSkge1xuICAgICAgd2FybihcbiAgICAgICAgYEZhaWxlZCBzZXR0aW5nIHByb3AgXCIke2tleX1cIiBvbiA8JHt0YWcudG9Mb3dlckNhc2UoKX0+OiB2YWx1ZSAke3ZhbHVlfSBpcyBpbnZhbGlkLmAsXG4gICAgICAgIGVcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIG5lZWRSZW1vdmUgJiYgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lIHx8IGtleSk7XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZWwsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5jb25zdCB2ZWlLZXkgPSBTeW1ib2woXCJfdmVpXCIpO1xuZnVuY3Rpb24gcGF0Y2hFdmVudChlbCwgcmF3TmFtZSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIGluc3RhbmNlID0gbnVsbCkge1xuICBjb25zdCBpbnZva2VycyA9IGVsW3ZlaUtleV0gfHwgKGVsW3ZlaUtleV0gPSB7fSk7XG4gIGNvbnN0IGV4aXN0aW5nSW52b2tlciA9IGludm9rZXJzW3Jhd05hbWVdO1xuICBpZiAobmV4dFZhbHVlICYmIGV4aXN0aW5nSW52b2tlcikge1xuICAgIGV4aXN0aW5nSW52b2tlci52YWx1ZSA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzYW5pdGl6ZUV2ZW50VmFsdWUobmV4dFZhbHVlLCByYXdOYW1lKSA6IG5leHRWYWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBbbmFtZSwgb3B0aW9uc10gPSBwYXJzZU5hbWUocmF3TmFtZSk7XG4gICAgaWYgKG5leHRWYWx1ZSkge1xuICAgICAgY29uc3QgaW52b2tlciA9IGludm9rZXJzW3Jhd05hbWVdID0gY3JlYXRlSW52b2tlcihcbiAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNhbml0aXplRXZlbnRWYWx1ZShuZXh0VmFsdWUsIHJhd05hbWUpIDogbmV4dFZhbHVlLFxuICAgICAgICBpbnN0YW5jZVxuICAgICAgKTtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGludm9rZXIsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoZXhpc3RpbmdJbnZva2VyKSB7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBleGlzdGluZ0ludm9rZXIsIG9wdGlvbnMpO1xuICAgICAgaW52b2tlcnNbcmF3TmFtZV0gPSB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5jb25zdCBvcHRpb25zTW9kaWZpZXJSRSA9IC8oPzpPbmNlfFBhc3NpdmV8Q2FwdHVyZSkkLztcbmZ1bmN0aW9uIHBhcnNlTmFtZShuYW1lKSB7XG4gIGxldCBvcHRpb25zO1xuICBpZiAob3B0aW9uc01vZGlmaWVyUkUudGVzdChuYW1lKSkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgICBsZXQgbTtcbiAgICB3aGlsZSAobSA9IG5hbWUubWF0Y2gob3B0aW9uc01vZGlmaWVyUkUpKSB7XG4gICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCBuYW1lLmxlbmd0aCAtIG1bMF0ubGVuZ3RoKTtcbiAgICAgIG9wdGlvbnNbbVswXS50b0xvd2VyQ2FzZSgpXSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGNvbnN0IGV2ZW50ID0gbmFtZVsyXSA9PT0gXCI6XCIgPyBuYW1lLnNsaWNlKDMpIDogaHlwaGVuYXRlKG5hbWUuc2xpY2UoMikpO1xuICByZXR1cm4gW2V2ZW50LCBvcHRpb25zXTtcbn1cbmxldCBjYWNoZWROb3cgPSAwO1xuY29uc3QgcCA9IC8qIEBfX1BVUkVfXyAqLyBQcm9taXNlLnJlc29sdmUoKTtcbmNvbnN0IGdldE5vdyA9ICgpID0+IGNhY2hlZE5vdyB8fCAocC50aGVuKCgpID0+IGNhY2hlZE5vdyA9IDApLCBjYWNoZWROb3cgPSBEYXRlLm5vdygpKTtcbmZ1bmN0aW9uIGNyZWF0ZUludm9rZXIoaW5pdGlhbFZhbHVlLCBpbnN0YW5jZSkge1xuICBjb25zdCBpbnZva2VyID0gKGUpID0+IHtcbiAgICBpZiAoIWUuX3Z0cykge1xuICAgICAgZS5fdnRzID0gRGF0ZS5ub3coKTtcbiAgICB9IGVsc2UgaWYgKGUuX3Z0cyA8PSBpbnZva2VyLmF0dGFjaGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgICAgcGF0Y2hTdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oZSwgaW52b2tlci52YWx1ZSksXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDUsXG4gICAgICBbZV1cbiAgICApO1xuICB9O1xuICBpbnZva2VyLnZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICBpbnZva2VyLmF0dGFjaGVkID0gZ2V0Tm93KCk7XG4gIHJldHVybiBpbnZva2VyO1xufVxuZnVuY3Rpb24gc2FuaXRpemVFdmVudFZhbHVlKHZhbHVlLCBwcm9wTmFtZSkge1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkgfHwgaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgd2FybihcbiAgICBgV3JvbmcgdHlwZSBwYXNzZWQgYXMgZXZlbnQgaGFuZGxlciB0byAke3Byb3BOYW1lfSAtIGRpZCB5b3UgZm9yZ2V0IEAgb3IgOiBpbiBmcm9udCBvZiB5b3VyIHByb3A/XG5FeHBlY3RlZCBmdW5jdGlvbiBvciBhcnJheSBvZiBmdW5jdGlvbnMsIHJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgdmFsdWV9LmBcbiAgKTtcbiAgcmV0dXJuIE5PT1A7XG59XG5mdW5jdGlvbiBwYXRjaFN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihlLCB2YWx1ZSkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCBvcmlnaW5hbFN0b3AgPSBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjtcbiAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9ICgpID0+IHtcbiAgICAgIG9yaWdpbmFsU3RvcC5jYWxsKGUpO1xuICAgICAgZS5fc3RvcHBlZCA9IHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gdmFsdWUubWFwKFxuICAgICAgKGZuKSA9PiAoZTIpID0+ICFlMi5fc3RvcHBlZCAmJiBmbiAmJiBmbihlMilcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5jb25zdCBpc05hdGl2ZU9uID0gKGtleSkgPT4ga2V5LmNoYXJDb2RlQXQoMCkgPT09IDExMSAmJiBrZXkuY2hhckNvZGVBdCgxKSA9PT0gMTEwICYmIC8vIGxvd2VyY2FzZSBsZXR0ZXJcbmtleS5jaGFyQ29kZUF0KDIpID4gOTYgJiYga2V5LmNoYXJDb2RlQXQoMikgPCAxMjM7XG5jb25zdCBwYXRjaFByb3AgPSAoZWwsIGtleSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIG5hbWVzcGFjZSwgcGFyZW50Q29tcG9uZW50KSA9PiB7XG4gIGNvbnN0IGlzU1ZHID0gbmFtZXNwYWNlID09PSBcInN2Z1wiO1xuICBpZiAoa2V5ID09PSBcImNsYXNzXCIpIHtcbiAgICBwYXRjaENsYXNzKGVsLCBuZXh0VmFsdWUsIGlzU1ZHKTtcbiAgfSBlbHNlIGlmIChrZXkgPT09IFwic3R5bGVcIikge1xuICAgIHBhdGNoU3R5bGUoZWwsIHByZXZWYWx1ZSwgbmV4dFZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc09uKGtleSkpIHtcbiAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpKSB7XG4gICAgICBwYXRjaEV2ZW50KGVsLCBrZXksIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBwYXJlbnRDb21wb25lbnQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChrZXlbMF0gPT09IFwiLlwiID8gKGtleSA9IGtleS5zbGljZSgxKSwgdHJ1ZSkgOiBrZXlbMF0gPT09IFwiXlwiID8gKGtleSA9IGtleS5zbGljZSgxKSwgZmFsc2UpIDogc2hvdWxkU2V0QXNQcm9wKGVsLCBrZXksIG5leHRWYWx1ZSwgaXNTVkcpKSB7XG4gICAgcGF0Y2hET01Qcm9wKGVsLCBrZXksIG5leHRWYWx1ZSk7XG4gICAgaWYgKCFlbC50YWdOYW1lLmluY2x1ZGVzKFwiLVwiKSAmJiAoa2V5ID09PSBcInZhbHVlXCIgfHwga2V5ID09PSBcImNoZWNrZWRcIiB8fCBrZXkgPT09IFwic2VsZWN0ZWRcIikpIHtcbiAgICAgIHBhdGNoQXR0cihlbCwga2V5LCBuZXh0VmFsdWUsIGlzU1ZHLCBwYXJlbnRDb21wb25lbnQsIGtleSAhPT0gXCJ2YWx1ZVwiKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoXG4gICAgLy8gIzExMDgxIGZvcmNlIHNldCBwcm9wcyBmb3IgcG9zc2libGUgYXN5bmMgY3VzdG9tIGVsZW1lbnRcbiAgICBlbC5faXNWdWVDRSAmJiAoL1tBLVpdLy50ZXN0KGtleSkgfHwgIWlzU3RyaW5nKG5leHRWYWx1ZSkpXG4gICkge1xuICAgIHBhdGNoRE9NUHJvcChlbCwgY2FtZWxpemUkMShrZXkpLCBuZXh0VmFsdWUsIHBhcmVudENvbXBvbmVudCwga2V5KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoa2V5ID09PSBcInRydWUtdmFsdWVcIikge1xuICAgICAgZWwuX3RydWVWYWx1ZSA9IG5leHRWYWx1ZTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJmYWxzZS12YWx1ZVwiKSB7XG4gICAgICBlbC5fZmFsc2VWYWx1ZSA9IG5leHRWYWx1ZTtcbiAgICB9XG4gICAgcGF0Y2hBdHRyKGVsLCBrZXksIG5leHRWYWx1ZSwgaXNTVkcpO1xuICB9XG59O1xuZnVuY3Rpb24gc2hvdWxkU2V0QXNQcm9wKGVsLCBrZXksIHZhbHVlLCBpc1NWRykge1xuICBpZiAoaXNTVkcpIHtcbiAgICBpZiAoa2V5ID09PSBcImlubmVySFRNTFwiIHx8IGtleSA9PT0gXCJ0ZXh0Q29udGVudFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGtleSBpbiBlbCAmJiBpc05hdGl2ZU9uKGtleSkgJiYgaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJzcGVsbGNoZWNrXCIgfHwga2V5ID09PSBcImRyYWdnYWJsZVwiIHx8IGtleSA9PT0gXCJ0cmFuc2xhdGVcIiB8fCBrZXkgPT09IFwiYXV0b2NvcnJlY3RcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoa2V5ID09PSBcImZvcm1cIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoa2V5ID09PSBcImxpc3RcIiAmJiBlbC50YWdOYW1lID09PSBcIklOUFVUXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJ0eXBlXCIgJiYgZWwudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChrZXkgPT09IFwid2lkdGhcIiB8fCBrZXkgPT09IFwiaGVpZ2h0XCIpIHtcbiAgICBjb25zdCB0YWcgPSBlbC50YWdOYW1lO1xuICAgIGlmICh0YWcgPT09IFwiSU1HXCIgfHwgdGFnID09PSBcIlZJREVPXCIgfHwgdGFnID09PSBcIkNBTlZBU1wiIHx8IHRhZyA9PT0gXCJTT1VSQ0VcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNOYXRpdmVPbihrZXkpICYmIGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4ga2V5IGluIGVsO1xufVxuXG5jb25zdCBSRU1PVkFMID0ge307XG4vKiEgI19fTk9fU0lERV9FRkZFQ1RTX18gKi9cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBkZWZpbmVDdXN0b21FbGVtZW50KG9wdGlvbnMsIGV4dHJhT3B0aW9ucywgX2NyZWF0ZUFwcCkge1xuICBjb25zdCBDb21wID0gZGVmaW5lQ29tcG9uZW50KG9wdGlvbnMsIGV4dHJhT3B0aW9ucyk7XG4gIGlmIChpc1BsYWluT2JqZWN0KENvbXApKSBleHRlbmQoQ29tcCwgZXh0cmFPcHRpb25zKTtcbiAgY2xhc3MgVnVlQ3VzdG9tRWxlbWVudCBleHRlbmRzIFZ1ZUVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKGluaXRpYWxQcm9wcykge1xuICAgICAgc3VwZXIoQ29tcCwgaW5pdGlhbFByb3BzLCBfY3JlYXRlQXBwKTtcbiAgICB9XG4gIH1cbiAgVnVlQ3VzdG9tRWxlbWVudC5kZWYgPSBDb21wO1xuICByZXR1cm4gVnVlQ3VzdG9tRWxlbWVudDtcbn1cbi8qISAjX19OT19TSURFX0VGRkVDVFNfXyAqL1xuY29uc3QgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudCA9IC8qIEBfX05PX1NJREVfRUZGRUNUU19fICovIChvcHRpb25zLCBleHRyYU9wdGlvbnMpID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBkZWZpbmVDdXN0b21FbGVtZW50KG9wdGlvbnMsIGV4dHJhT3B0aW9ucywgY3JlYXRlU1NSQXBwKTtcbn07XG5jb25zdCBCYXNlQ2xhc3MgPSB0eXBlb2YgSFRNTEVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBIVE1MRWxlbWVudCA6IGNsYXNzIHtcbn07XG5jbGFzcyBWdWVFbGVtZW50IGV4dGVuZHMgQmFzZUNsYXNzIHtcbiAgY29uc3RydWN0b3IoX2RlZiwgX3Byb3BzID0ge30sIF9jcmVhdGVBcHAgPSBjcmVhdGVBcHApIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2RlZiA9IF9kZWY7XG4gICAgdGhpcy5fcHJvcHMgPSBfcHJvcHM7XG4gICAgdGhpcy5fY3JlYXRlQXBwID0gX2NyZWF0ZUFwcDtcbiAgICB0aGlzLl9pc1Z1ZUNFID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fYXBwID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLl9ub25jZSA9IHRoaXMuX2RlZi5ub25jZTtcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZXNvbHZlZCA9IGZhbHNlO1xuICAgIHRoaXMuX251bWJlclByb3BzID0gbnVsbDtcbiAgICB0aGlzLl9zdHlsZUNoaWxkcmVuID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG4gICAgdGhpcy5fb2IgPSBudWxsO1xuICAgIGlmICh0aGlzLnNoYWRvd1Jvb3QgJiYgX2NyZWF0ZUFwcCAhPT0gY3JlYXRlQXBwKSB7XG4gICAgICB0aGlzLl9yb290ID0gdGhpcy5zaGFkb3dSb290O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB0aGlzLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgQ3VzdG9tIGVsZW1lbnQgaGFzIHByZS1yZW5kZXJlZCBkZWNsYXJhdGl2ZSBzaGFkb3cgcm9vdCBidXQgaXMgbm90IGRlZmluZWQgYXMgaHlkcmF0YWJsZS4gVXNlIFxcYGRlZmluZVNTUkN1c3RvbUVsZW1lbnRcXGAuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKF9kZWYuc2hhZG93Um9vdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiBcIm9wZW5cIiB9KTtcbiAgICAgICAgdGhpcy5fcm9vdCA9IHRoaXMuc2hhZG93Um9vdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQpIHJldHVybjtcbiAgICBpZiAoIXRoaXMuc2hhZG93Um9vdCAmJiAhdGhpcy5fcmVzb2x2ZWQpIHtcbiAgICAgIHRoaXMuX3BhcnNlU2xvdHMoKTtcbiAgICB9XG4gICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcbiAgICBsZXQgcGFyZW50ID0gdGhpcztcbiAgICB3aGlsZSAocGFyZW50ID0gcGFyZW50ICYmIChwYXJlbnQucGFyZW50Tm9kZSB8fCBwYXJlbnQuaG9zdCkpIHtcbiAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBWdWVFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5faW5zdGFuY2UpIHtcbiAgICAgIGlmICh0aGlzLl9yZXNvbHZlZCkge1xuICAgICAgICB0aGlzLl9tb3VudCh0aGlzLl9kZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmdSZXNvbHZlKSB7XG4gICAgICAgICAgdGhpcy5fcGVuZGluZ1Jlc29sdmUgPSBwYXJlbnQuX3BlbmRpbmdSZXNvbHZlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1Jlc29sdmUgPSB2b2lkIDA7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlRGVmKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcmVzb2x2ZURlZigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9zZXRQYXJlbnQocGFyZW50ID0gdGhpcy5fcGFyZW50KSB7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgdGhpcy5faW5zdGFuY2UucGFyZW50ID0gcGFyZW50Ll9pbnN0YW5jZTtcbiAgICAgIHRoaXMuX2luaGVyaXRQYXJlbnRDb250ZXh0KHBhcmVudCk7XG4gICAgfVxuICB9XG4gIF9pbmhlcml0UGFyZW50Q29udGV4dChwYXJlbnQgPSB0aGlzLl9wYXJlbnQpIHtcbiAgICBpZiAocGFyZW50ICYmIHRoaXMuX2FwcCkge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKFxuICAgICAgICB0aGlzLl9hcHAuX2NvbnRleHQucHJvdmlkZXMsXG4gICAgICAgIHBhcmVudC5faW5zdGFuY2UucHJvdmlkZXNcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIG5leHRUaWNrKCgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgIGlmICh0aGlzLl9vYikge1xuICAgICAgICAgIHRoaXMuX29iLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICB0aGlzLl9vYiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXBwICYmIHRoaXMuX2FwcC51bm1vdW50KCk7XG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkgdGhpcy5faW5zdGFuY2UuY2UgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuX2FwcCA9IHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogcmVzb2x2ZSBpbm5lciBjb21wb25lbnQgZGVmaW5pdGlvbiAoaGFuZGxlIHBvc3NpYmxlIGFzeW5jIGNvbXBvbmVudClcbiAgICovXG4gIF9yZXNvbHZlRGVmKCkge1xuICAgIGlmICh0aGlzLl9wZW5kaW5nUmVzb2x2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fc2V0QXR0cih0aGlzLmF0dHJpYnV0ZXNbaV0ubmFtZSk7XG4gICAgfVxuICAgIHRoaXMuX29iID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG11dGF0aW9ucykgPT4ge1xuICAgICAgZm9yIChjb25zdCBtIG9mIG11dGF0aW9ucykge1xuICAgICAgICB0aGlzLl9zZXRBdHRyKG0uYXR0cmlidXRlTmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fb2Iub2JzZXJ2ZSh0aGlzLCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XG4gICAgY29uc3QgcmVzb2x2ZSA9IChkZWYsIGlzQXN5bmMgPSBmYWxzZSkgPT4ge1xuICAgICAgdGhpcy5fcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5fcGVuZGluZ1Jlc29sdmUgPSB2b2lkIDA7XG4gICAgICBjb25zdCB7IHByb3BzLCBzdHlsZXMgfSA9IGRlZjtcbiAgICAgIGxldCBudW1iZXJQcm9wcztcbiAgICAgIGlmIChwcm9wcyAmJiAhaXNBcnJheShwcm9wcykpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgICBjb25zdCBvcHQgPSBwcm9wc1trZXldO1xuICAgICAgICAgIGlmIChvcHQgPT09IE51bWJlciB8fCBvcHQgJiYgb3B0LnR5cGUgPT09IE51bWJlcikge1xuICAgICAgICAgICAgaWYgKGtleSBpbiB0aGlzLl9wcm9wcykge1xuICAgICAgICAgICAgICB0aGlzLl9wcm9wc1trZXldID0gdG9OdW1iZXIodGhpcy5fcHJvcHNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAobnVtYmVyUHJvcHMgfHwgKG51bWJlclByb3BzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkpKVtjYW1lbGl6ZSQxKGtleSldID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX251bWJlclByb3BzID0gbnVtYmVyUHJvcHM7XG4gICAgICB0aGlzLl9yZXNvbHZlUHJvcHMoZGVmKTtcbiAgICAgIGlmICh0aGlzLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgdGhpcy5fYXBwbHlTdHlsZXMoc3R5bGVzKTtcbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzdHlsZXMpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkN1c3RvbSBlbGVtZW50IHN0eWxlIGluamVjdGlvbiBpcyBub3Qgc3VwcG9ydGVkIHdoZW4gdXNpbmcgc2hhZG93Um9vdDogZmFsc2VcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5fbW91bnQoZGVmKTtcbiAgICB9O1xuICAgIGNvbnN0IGFzeW5jRGVmID0gdGhpcy5fZGVmLl9fYXN5bmNMb2FkZXI7XG4gICAgaWYgKGFzeW5jRGVmKSB7XG4gICAgICB0aGlzLl9wZW5kaW5nUmVzb2x2ZSA9IGFzeW5jRGVmKCkudGhlbihcbiAgICAgICAgKGRlZikgPT4gcmVzb2x2ZSh0aGlzLl9kZWYgPSBkZWYsIHRydWUpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlKHRoaXMuX2RlZik7XG4gICAgfVxuICB9XG4gIF9tb3VudChkZWYpIHtcbiAgICBpZiAoKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSAmJiAhZGVmLm5hbWUpIHtcbiAgICAgIGRlZi5uYW1lID0gXCJWdWVFbGVtZW50XCI7XG4gICAgfVxuICAgIHRoaXMuX2FwcCA9IHRoaXMuX2NyZWF0ZUFwcChkZWYpO1xuICAgIHRoaXMuX2luaGVyaXRQYXJlbnRDb250ZXh0KCk7XG4gICAgaWYgKGRlZi5jb25maWd1cmVBcHApIHtcbiAgICAgIGRlZi5jb25maWd1cmVBcHAodGhpcy5fYXBwKTtcbiAgICB9XG4gICAgdGhpcy5fYXBwLl9jZVZOb2RlID0gdGhpcy5fY3JlYXRlVk5vZGUoKTtcbiAgICB0aGlzLl9hcHAubW91bnQodGhpcy5fcm9vdCk7XG4gICAgY29uc3QgZXhwb3NlZCA9IHRoaXMuX2luc3RhbmNlICYmIHRoaXMuX2luc3RhbmNlLmV4cG9zZWQ7XG4gICAgaWYgKCFleHBvc2VkKSByZXR1cm47XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZXhwb3NlZCkge1xuICAgICAgaWYgKCFoYXNPd24odGhpcywga2V5KSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgICAgLy8gdW53cmFwIHJlZiB0byBiZSBjb25zaXN0ZW50IHdpdGggcHVibGljIGluc3RhbmNlIGJlaGF2aW9yXG4gICAgICAgICAgZ2V0OiAoKSA9PiB1bnJlZihleHBvc2VkW2tleV0pXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIHdhcm4oYEV4cG9zZWQgcHJvcGVydHkgXCIke2tleX1cIiBhbHJlYWR5IGV4aXN0cyBvbiBjdXN0b20gZWxlbWVudC5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3Jlc29sdmVQcm9wcyhkZWYpIHtcbiAgICBjb25zdCB7IHByb3BzIH0gPSBkZWY7XG4gICAgY29uc3QgZGVjbGFyZWRQcm9wS2V5cyA9IGlzQXJyYXkocHJvcHMpID8gcHJvcHMgOiBPYmplY3Qua2V5cyhwcm9wcyB8fCB7fSk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcykpIHtcbiAgICAgIGlmIChrZXlbMF0gIT09IFwiX1wiICYmIGRlY2xhcmVkUHJvcEtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICB0aGlzLl9zZXRQcm9wKGtleSwgdGhpc1trZXldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgZGVjbGFyZWRQcm9wS2V5cy5tYXAoY2FtZWxpemUkMSkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRQcm9wKGtleSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWwpIHtcbiAgICAgICAgICB0aGlzLl9zZXRQcm9wKGtleSwgdmFsLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIF9zZXRBdHRyKGtleSkge1xuICAgIGlmIChrZXkuc3RhcnRzV2l0aChcImRhdGEtdi1cIikpIHJldHVybjtcbiAgICBjb25zdCBoYXMgPSB0aGlzLmhhc0F0dHJpYnV0ZShrZXkpO1xuICAgIGxldCB2YWx1ZSA9IGhhcyA/IHRoaXMuZ2V0QXR0cmlidXRlKGtleSkgOiBSRU1PVkFMO1xuICAgIGNvbnN0IGNhbWVsS2V5ID0gY2FtZWxpemUkMShrZXkpO1xuICAgIGlmIChoYXMgJiYgdGhpcy5fbnVtYmVyUHJvcHMgJiYgdGhpcy5fbnVtYmVyUHJvcHNbY2FtZWxLZXldKSB7XG4gICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICB9XG4gICAgdGhpcy5fc2V0UHJvcChjYW1lbEtleSwgdmFsdWUsIGZhbHNlLCB0cnVlKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfZ2V0UHJvcChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvcHNba2V5XTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfc2V0UHJvcChrZXksIHZhbCwgc2hvdWxkUmVmbGVjdCA9IHRydWUsIHNob3VsZFVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgaWYgKHZhbCAhPT0gdGhpcy5fcHJvcHNba2V5XSkge1xuICAgICAgaWYgKHZhbCA9PT0gUkVNT1ZBTCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fcHJvcHNba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Byb3BzW2tleV0gPSB2YWw7XG4gICAgICAgIGlmIChrZXkgPT09IFwia2V5XCIgJiYgdGhpcy5fYXBwKSB7XG4gICAgICAgICAgdGhpcy5fYXBwLl9jZVZOb2RlLmtleSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFVwZGF0ZSAmJiB0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRSZWZsZWN0KSB7XG4gICAgICAgIGNvbnN0IG9iID0gdGhpcy5fb2I7XG4gICAgICAgIG9iICYmIG9iLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgaWYgKHZhbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGh5cGhlbmF0ZShrZXkpLCBcIlwiKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShoeXBoZW5hdGUoa2V5KSwgdmFsICsgXCJcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoIXZhbCkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKGh5cGhlbmF0ZShrZXkpKTtcbiAgICAgICAgfVxuICAgICAgICBvYiAmJiBvYi5vYnNlcnZlKHRoaXMsIHsgYXR0cmlidXRlczogdHJ1ZSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3VwZGF0ZSgpIHtcbiAgICBjb25zdCB2bm9kZSA9IHRoaXMuX2NyZWF0ZVZOb2RlKCk7XG4gICAgaWYgKHRoaXMuX2FwcCkgdm5vZGUuYXBwQ29udGV4dCA9IHRoaXMuX2FwcC5fY29udGV4dDtcbiAgICByZW5kZXIodm5vZGUsIHRoaXMuX3Jvb3QpO1xuICB9XG4gIF9jcmVhdGVWTm9kZSgpIHtcbiAgICBjb25zdCBiYXNlUHJvcHMgPSB7fTtcbiAgICBpZiAoIXRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgYmFzZVByb3BzLm9uVm5vZGVNb3VudGVkID0gYmFzZVByb3BzLm9uVm5vZGVVcGRhdGVkID0gdGhpcy5fcmVuZGVyU2xvdHMuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZSh0aGlzLl9kZWYsIGV4dGVuZChiYXNlUHJvcHMsIHRoaXMuX3Byb3BzKSk7XG4gICAgaWYgKCF0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgdm5vZGUuY2UgPSAoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgaW5zdGFuY2UuY2UgPSB0aGlzO1xuICAgICAgICBpbnN0YW5jZS5pc0NFID0gdHJ1ZTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBpbnN0YW5jZS5jZVJlbG9hZCA9IChuZXdTdHlsZXMpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdHlsZXMpIHtcbiAgICAgICAgICAgICAgdGhpcy5fc3R5bGVzLmZvckVhY2goKHMpID0+IHRoaXMuX3Jvb3QucmVtb3ZlQ2hpbGQocykpO1xuICAgICAgICAgICAgICB0aGlzLl9zdHlsZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FwcGx5U3R5bGVzKG5ld1N0eWxlcyk7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpc3BhdGNoID0gKGV2ZW50LCBhcmdzKSA9PiB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgICAgbmV3IEN1c3RvbUV2ZW50KFxuICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgaXNQbGFpbk9iamVjdChhcmdzWzBdKSA/IGV4dGVuZCh7IGRldGFpbDogYXJncyB9LCBhcmdzWzBdKSA6IHsgZGV0YWlsOiBhcmdzIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgICAgICBpbnN0YW5jZS5lbWl0ID0gKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgZGlzcGF0Y2goZXZlbnQsIGFyZ3MpO1xuICAgICAgICAgIGlmIChoeXBoZW5hdGUoZXZlbnQpICE9PSBldmVudCkge1xuICAgICAgICAgICAgZGlzcGF0Y2goaHlwaGVuYXRlKGV2ZW50KSwgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zZXRQYXJlbnQoKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB2bm9kZTtcbiAgfVxuICBfYXBwbHlTdHlsZXMoc3R5bGVzLCBvd25lcikge1xuICAgIGlmICghc3R5bGVzKSByZXR1cm47XG4gICAgaWYgKG93bmVyKSB7XG4gICAgICBpZiAob3duZXIgPT09IHRoaXMuX2RlZiB8fCB0aGlzLl9zdHlsZUNoaWxkcmVuLmhhcyhvd25lcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3R5bGVDaGlsZHJlbi5hZGQob3duZXIpO1xuICAgIH1cbiAgICBjb25zdCBub25jZSA9IHRoaXMuX25vbmNlO1xuICAgIGZvciAobGV0IGkgPSBzdHlsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICBpZiAobm9uY2UpIHMuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgbm9uY2UpO1xuICAgICAgcy50ZXh0Q29udGVudCA9IHN0eWxlc1tpXTtcbiAgICAgIHRoaXMuc2hhZG93Um9vdC5wcmVwZW5kKHMpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgICAgaWYgKG93bmVyLl9faG1ySWQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2hpbGRTdHlsZXMpIHRoaXMuX2NoaWxkU3R5bGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGxldCBlbnRyeSA9IHRoaXMuX2NoaWxkU3R5bGVzLmdldChvd25lci5fX2htcklkKTtcbiAgICAgICAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY2hpbGRTdHlsZXMuc2V0KG93bmVyLl9faG1ySWQsIGVudHJ5ID0gW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW50cnkucHVzaChzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKHRoaXMuX3N0eWxlcyB8fCAodGhpcy5fc3R5bGVzID0gW10pKS5wdXNoKHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBPbmx5IGNhbGxlZCB3aGVuIHNoYWRvd1Jvb3QgaXMgZmFsc2VcbiAgICovXG4gIF9wYXJzZVNsb3RzKCkge1xuICAgIGNvbnN0IHNsb3RzID0gdGhpcy5fc2xvdHMgPSB7fTtcbiAgICBsZXQgbjtcbiAgICB3aGlsZSAobiA9IHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgY29uc3Qgc2xvdE5hbWUgPSBuLm5vZGVUeXBlID09PSAxICYmIG4uZ2V0QXR0cmlidXRlKFwic2xvdFwiKSB8fCBcImRlZmF1bHRcIjtcbiAgICAgIChzbG90c1tzbG90TmFtZV0gfHwgKHNsb3RzW3Nsb3ROYW1lXSA9IFtdKSkucHVzaChuKTtcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQobik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBPbmx5IGNhbGxlZCB3aGVuIHNoYWRvd1Jvb3QgaXMgZmFsc2VcbiAgICovXG4gIF9yZW5kZXJTbG90cygpIHtcbiAgICBjb25zdCBvdXRsZXRzID0gKHRoaXMuX3RlbGVwb3J0VGFyZ2V0IHx8IHRoaXMpLnF1ZXJ5U2VsZWN0b3JBbGwoXCJzbG90XCIpO1xuICAgIGNvbnN0IHNjb3BlSWQgPSB0aGlzLl9pbnN0YW5jZS50eXBlLl9fc2NvcGVJZDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dGxldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG8gPSBvdXRsZXRzW2ldO1xuICAgICAgY29uc3Qgc2xvdE5hbWUgPSBvLmdldEF0dHJpYnV0ZShcIm5hbWVcIikgfHwgXCJkZWZhdWx0XCI7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5fc2xvdHNbc2xvdE5hbWVdO1xuICAgICAgY29uc3QgcGFyZW50ID0gby5wYXJlbnROb2RlO1xuICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgZm9yIChjb25zdCBuIG9mIGNvbnRlbnQpIHtcbiAgICAgICAgICBpZiAoc2NvcGVJZCAmJiBuLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IHNjb3BlSWQgKyBcIi1zXCI7XG4gICAgICAgICAgICBjb25zdCB3YWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKG4sIDEpO1xuICAgICAgICAgICAgbi5zZXRBdHRyaWJ1dGUoaWQsIFwiXCIpO1xuICAgICAgICAgICAgbGV0IGNoaWxkO1xuICAgICAgICAgICAgd2hpbGUgKGNoaWxkID0gd2Fsa2VyLm5leHROb2RlKCkpIHtcbiAgICAgICAgICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKGlkLCBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShuLCBvKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKG8uZmlyc3RDaGlsZCkgcGFyZW50Lmluc2VydEJlZm9yZShvLmZpcnN0Q2hpbGQsIG8pO1xuICAgICAgfVxuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKG8pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfaW5qZWN0Q2hpbGRTdHlsZShjb21wKSB7XG4gICAgdGhpcy5fYXBwbHlTdHlsZXMoY29tcC5zdHlsZXMsIGNvbXApO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9yZW1vdmVDaGlsZFN0eWxlKGNvbXApIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgdGhpcy5fc3R5bGVDaGlsZHJlbi5kZWxldGUoY29tcCk7XG4gICAgICBpZiAodGhpcy5fY2hpbGRTdHlsZXMgJiYgY29tcC5fX2htcklkKSB7XG4gICAgICAgIGNvbnN0IG9sZFN0eWxlcyA9IHRoaXMuX2NoaWxkU3R5bGVzLmdldChjb21wLl9faG1ySWQpO1xuICAgICAgICBpZiAob2xkU3R5bGVzKSB7XG4gICAgICAgICAgb2xkU3R5bGVzLmZvckVhY2goKHMpID0+IHRoaXMuX3Jvb3QucmVtb3ZlQ2hpbGQocykpO1xuICAgICAgICAgIG9sZFN0eWxlcy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB1c2VIb3N0KGNhbGxlcikge1xuICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBjb25zdCBlbCA9IGluc3RhbmNlICYmIGluc3RhbmNlLmNlO1xuICBpZiAoZWwpIHtcbiAgICByZXR1cm4gZWw7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGAke2NhbGxlciB8fCBcInVzZUhvc3RcIn0gY2FsbGVkIHdpdGhvdXQgYW4gYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZS5gXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgJHtjYWxsZXIgfHwgXCJ1c2VIb3N0XCJ9IGNhbiBvbmx5IGJlIHVzZWQgaW4gY29tcG9uZW50cyBkZWZpbmVkIHZpYSBkZWZpbmVDdXN0b21FbGVtZW50LmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdXNlU2hhZG93Um9vdCgpIHtcbiAgY29uc3QgZWwgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gdXNlSG9zdChcInVzZVNoYWRvd1Jvb3RcIikgOiB1c2VIb3N0KCk7XG4gIHJldHVybiBlbCAmJiBlbC5zaGFkb3dSb290O1xufVxuXG5mdW5jdGlvbiB1c2VDc3NNb2R1bGUobmFtZSA9IFwiJHN0eWxlXCIpIHtcbiAge1xuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGB1c2VDc3NNb2R1bGUgbXVzdCBiZSBjYWxsZWQgaW5zaWRlIHNldHVwKClgKTtcbiAgICAgIHJldHVybiBFTVBUWV9PQko7XG4gICAgfVxuICAgIGNvbnN0IG1vZHVsZXMgPSBpbnN0YW5jZS50eXBlLl9fY3NzTW9kdWxlcztcbiAgICBpZiAoIW1vZHVsZXMpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgQ3VycmVudCBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIENTUyBtb2R1bGVzIGluamVjdGVkLmApO1xuICAgICAgcmV0dXJuIEVNUFRZX09CSjtcbiAgICB9XG4gICAgY29uc3QgbW9kID0gbW9kdWxlc1tuYW1lXTtcbiAgICBpZiAoIW1vZCkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGBDdXJyZW50IGluc3RhbmNlIGRvZXMgbm90IGhhdmUgQ1NTIG1vZHVsZSBuYW1lZCBcIiR7bmFtZX1cIi5gKTtcbiAgICAgIHJldHVybiBFTVBUWV9PQko7XG4gICAgfVxuICAgIHJldHVybiBtb2Q7XG4gIH1cbn1cblxuY29uc3QgcG9zaXRpb25NYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IG5ld1Bvc2l0aW9uTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBtb3ZlQ2JLZXkgPSBTeW1ib2woXCJfbW92ZUNiXCIpO1xuY29uc3QgZW50ZXJDYktleSA9IFN5bWJvbChcIl9lbnRlckNiXCIpO1xuY29uc3QgZGVjb3JhdGUgPSAodCkgPT4ge1xuICBkZWxldGUgdC5wcm9wcy5tb2RlO1xuICByZXR1cm4gdDtcbn07XG5jb25zdCBUcmFuc2l0aW9uR3JvdXBJbXBsID0gLyogQF9fUFVSRV9fICovIGRlY29yYXRlKHtcbiAgbmFtZTogXCJUcmFuc2l0aW9uR3JvdXBcIixcbiAgcHJvcHM6IC8qIEBfX1BVUkVfXyAqLyBleHRlbmQoe30sIFRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMsIHtcbiAgICB0YWc6IFN0cmluZyxcbiAgICBtb3ZlQ2xhc3M6IFN0cmluZ1xuICB9KSxcbiAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgY29uc3Qgc3RhdGUgPSB1c2VUcmFuc2l0aW9uU3RhdGUoKTtcbiAgICBsZXQgcHJldkNoaWxkcmVuO1xuICAgIGxldCBjaGlsZHJlbjtcbiAgICBvblVwZGF0ZWQoKCkgPT4ge1xuICAgICAgaWYgKCFwcmV2Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vdmVDbGFzcyA9IHByb3BzLm1vdmVDbGFzcyB8fCBgJHtwcm9wcy5uYW1lIHx8IFwidlwifS1tb3ZlYDtcbiAgICAgIGlmICghaGFzQ1NTVHJhbnNmb3JtKFxuICAgICAgICBwcmV2Q2hpbGRyZW5bMF0uZWwsXG4gICAgICAgIGluc3RhbmNlLnZub2RlLmVsLFxuICAgICAgICBtb3ZlQ2xhc3NcbiAgICAgICkpIHtcbiAgICAgICAgcHJldkNoaWxkcmVuID0gW107XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHByZXZDaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICAgIHByZXZDaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICAgIGNvbnN0IG1vdmVkQ2hpbGRyZW4gPSBwcmV2Q2hpbGRyZW4uZmlsdGVyKGFwcGx5VHJhbnNsYXRpb24pO1xuICAgICAgZm9yY2VSZWZsb3coKTtcbiAgICAgIG1vdmVkQ2hpbGRyZW4uZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICBjb25zdCBlbCA9IGMuZWw7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgc3R5bGUudHJhbnNmb3JtID0gc3R5bGUud2Via2l0VHJhbnNmb3JtID0gc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gXCJcIjtcbiAgICAgICAgY29uc3QgY2IgPSBlbFttb3ZlQ2JLZXldID0gKGUpID0+IHtcbiAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIiwgY2IpO1xuICAgICAgICAgICAgZWxbbW92ZUNiS2V5XSA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLCBjYik7XG4gICAgICB9KTtcbiAgICAgIHByZXZDaGlsZHJlbiA9IFtdO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCByYXdQcm9wcyA9IHRvUmF3KHByb3BzKTtcbiAgICAgIGNvbnN0IGNzc1RyYW5zaXRpb25Qcm9wcyA9IHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocmF3UHJvcHMpO1xuICAgICAgbGV0IHRhZyA9IHJhd1Byb3BzLnRhZyB8fCBGcmFnbWVudDtcbiAgICAgIHByZXZDaGlsZHJlbiA9IFtdO1xuICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgIGlmIChjaGlsZC5lbCAmJiBjaGlsZC5lbCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHByZXZDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhcbiAgICAgICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgICAgIHJlc29sdmVUcmFuc2l0aW9uSG9va3MoXG4gICAgICAgICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgICAgICAgY3NzVHJhbnNpdGlvblByb3BzLFxuICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQoXG4gICAgICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgICAgICBjaGlsZC5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCA/IGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihzbG90cy5kZWZhdWx0KCkpIDogW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChjaGlsZC5rZXkgIT0gbnVsbCkge1xuICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhcbiAgICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgICAgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhjaGlsZCwgY3NzVHJhbnNpdGlvblByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNoaWxkLnR5cGUgIT09IFRleHQpIHtcbiAgICAgICAgICB3YXJuKGA8VHJhbnNpdGlvbkdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkLmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlVk5vZGUodGFnLCBudWxsLCBjaGlsZHJlbik7XG4gICAgfTtcbiAgfVxufSk7XG5jb25zdCBUcmFuc2l0aW9uR3JvdXAgPSBUcmFuc2l0aW9uR3JvdXBJbXBsO1xuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMoYykge1xuICBjb25zdCBlbCA9IGMuZWw7XG4gIGlmIChlbFttb3ZlQ2JLZXldKSB7XG4gICAgZWxbbW92ZUNiS2V5XSgpO1xuICB9XG4gIGlmIChlbFtlbnRlckNiS2V5XSkge1xuICAgIGVsW2VudGVyQ2JLZXldKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uKGMpIHtcbiAgbmV3UG9zaXRpb25NYXAuc2V0KGMsIGMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xufVxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbihjKSB7XG4gIGNvbnN0IG9sZFBvcyA9IHBvc2l0aW9uTWFwLmdldChjKTtcbiAgY29uc3QgbmV3UG9zID0gbmV3UG9zaXRpb25NYXAuZ2V0KGMpO1xuICBjb25zdCBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIGNvbnN0IGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gIGlmIChkeCB8fCBkeSkge1xuICAgIGNvbnN0IHMgPSBjLmVsLnN0eWxlO1xuICAgIHMudHJhbnNmb3JtID0gcy53ZWJraXRUcmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7ZHh9cHgsJHtkeX1weClgO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gXCIwc1wiO1xuICAgIHJldHVybiBjO1xuICB9XG59XG5mdW5jdGlvbiBoYXNDU1NUcmFuc2Zvcm0oZWwsIHJvb3QsIG1vdmVDbGFzcykge1xuICBjb25zdCBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xuICBjb25zdCBfdnRjID0gZWxbdnRjS2V5XTtcbiAgaWYgKF92dGMpIHtcbiAgICBfdnRjLmZvckVhY2goKGNscykgPT4ge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaCgoYykgPT4gYyAmJiBjbG9uZS5jbGFzc0xpc3QucmVtb3ZlKGMpKTtcbiAgICB9KTtcbiAgfVxuICBtb3ZlQ2xhc3Muc3BsaXQoL1xccysvKS5mb3JFYWNoKChjKSA9PiBjICYmIGNsb25lLmNsYXNzTGlzdC5hZGQoYykpO1xuICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gIGNvbnN0IGNvbnRhaW5lciA9IHJvb3Qubm9kZVR5cGUgPT09IDEgPyByb290IDogcm9vdC5wYXJlbnROb2RlO1xuICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICBjb25zdCB7IGhhc1RyYW5zZm9ybSB9ID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xuICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICByZXR1cm4gaGFzVHJhbnNmb3JtO1xufVxuXG5jb25zdCBnZXRNb2RlbEFzc2lnbmVyID0gKHZub2RlKSA9PiB7XG4gIGNvbnN0IGZuID0gdm5vZGUucHJvcHNbXCJvblVwZGF0ZTptb2RlbFZhbHVlXCJdIHx8IGZhbHNlO1xuICByZXR1cm4gaXNBcnJheShmbikgPyAodmFsdWUpID0+IGludm9rZUFycmF5Rm5zKGZuLCB2YWx1ZSkgOiBmbjtcbn07XG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xufVxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZChlKSB7XG4gIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xuICBpZiAodGFyZ2V0LmNvbXBvc2luZykge1xuICAgIHRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJpbnB1dFwiKSk7XG4gIH1cbn1cbmNvbnN0IGFzc2lnbktleSA9IFN5bWJvbChcIl9hc3NpZ25cIik7XG5jb25zdCB2TW9kZWxUZXh0ID0ge1xuICBjcmVhdGVkKGVsLCB7IG1vZGlmaWVyczogeyBsYXp5LCB0cmltLCBudW1iZXIgfSB9LCB2bm9kZSkge1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBjb25zdCBjYXN0VG9OdW1iZXIgPSBudW1iZXIgfHwgdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudHlwZSA9PT0gXCJudW1iZXJcIjtcbiAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBsYXp5ID8gXCJjaGFuZ2VcIiA6IFwiaW5wdXRcIiwgKGUpID0+IHtcbiAgICAgIGlmIChlLnRhcmdldC5jb21wb3NpbmcpIHJldHVybjtcbiAgICAgIGxldCBkb21WYWx1ZSA9IGVsLnZhbHVlO1xuICAgICAgaWYgKHRyaW0pIHtcbiAgICAgICAgZG9tVmFsdWUgPSBkb21WYWx1ZS50cmltKCk7XG4gICAgICB9XG4gICAgICBpZiAoY2FzdFRvTnVtYmVyKSB7XG4gICAgICAgIGRvbVZhbHVlID0gbG9vc2VUb051bWJlcihkb21WYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbFthc3NpZ25LZXldKGRvbVZhbHVlKTtcbiAgICB9KTtcbiAgICBpZiAodHJpbSkge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgICBlbC52YWx1ZSA9IGVsLnZhbHVlLnRyaW0oKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIWxhenkpIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY29tcG9zaXRpb25zdGFydFwiLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjb21wb3NpdGlvbmVuZFwiLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY2hhbmdlXCIsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgIH1cbiAgfSxcbiAgLy8gc2V0IHZhbHVlIG9uIG1vdW50ZWQgc28gaXQncyBhZnRlciBtaW4vbWF4IGZvciB0eXBlPVwicmFuZ2VcIlxuICBtb3VudGVkKGVsLCB7IHZhbHVlIH0pIHtcbiAgICBlbC52YWx1ZSA9IHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWU7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShlbCwgeyB2YWx1ZSwgb2xkVmFsdWUsIG1vZGlmaWVyczogeyBsYXp5LCB0cmltLCBudW1iZXIgfSB9LCB2bm9kZSkge1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBpZiAoZWwuY29tcG9zaW5nKSByZXR1cm47XG4gICAgY29uc3QgZWxWYWx1ZSA9IChudW1iZXIgfHwgZWwudHlwZSA9PT0gXCJudW1iZXJcIikgJiYgIS9eMFxcZC8udGVzdChlbC52YWx1ZSkgPyBsb29zZVRvTnVtYmVyKGVsLnZhbHVlKSA6IGVsLnZhbHVlO1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZTtcbiAgICBpZiAoZWxWYWx1ZSA9PT0gbmV3VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsICYmIGVsLnR5cGUgIT09IFwicmFuZ2VcIikge1xuICAgICAgaWYgKGxhenkgJiYgdmFsdWUgPT09IG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0cmltICYmIGVsLnZhbHVlLnRyaW0oKSA9PT0gbmV3VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBlbC52YWx1ZSA9IG5ld1ZhbHVlO1xuICB9XG59O1xuY29uc3Qgdk1vZGVsQ2hlY2tib3ggPSB7XG4gIC8vICM0MDk2IGFycmF5IGNoZWNrYm94ZXMgbmVlZCB0byBiZSBkZWVwIHRyYXZlcnNlZFxuICBkZWVwOiB0cnVlLFxuICBjcmVhdGVkKGVsLCBfLCB2bm9kZSkge1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBtb2RlbFZhbHVlID0gZWwuX21vZGVsVmFsdWU7XG4gICAgICBjb25zdCBlbGVtZW50VmFsdWUgPSBnZXRWYWx1ZShlbCk7XG4gICAgICBjb25zdCBjaGVja2VkID0gZWwuY2hlY2tlZDtcbiAgICAgIGNvbnN0IGFzc2lnbiA9IGVsW2Fzc2lnbktleV07XG4gICAgICBpZiAoaXNBcnJheShtb2RlbFZhbHVlKSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IGxvb3NlSW5kZXhPZihtb2RlbFZhbHVlLCBlbGVtZW50VmFsdWUpO1xuICAgICAgICBjb25zdCBmb3VuZCA9IGluZGV4ICE9PSAtMTtcbiAgICAgICAgaWYgKGNoZWNrZWQgJiYgIWZvdW5kKSB7XG4gICAgICAgICAgYXNzaWduKG1vZGVsVmFsdWUuY29uY2F0KGVsZW1lbnRWYWx1ZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKCFjaGVja2VkICYmIGZvdW5kKSB7XG4gICAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBbLi4ubW9kZWxWYWx1ZV07XG4gICAgICAgICAgZmlsdGVyZWQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICBhc3NpZ24oZmlsdGVyZWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzU2V0KG1vZGVsVmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGNsb25lZCA9IG5ldyBTZXQobW9kZWxWYWx1ZSk7XG4gICAgICAgIGlmIChjaGVja2VkKSB7XG4gICAgICAgICAgY2xvbmVkLmFkZChlbGVtZW50VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsb25lZC5kZWxldGUoZWxlbWVudFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NpZ24oY2xvbmVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2lnbihnZXRDaGVja2JveFZhbHVlKGVsLCBjaGVja2VkKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIC8vIHNldCBpbml0aWFsIGNoZWNrZWQgb24gbW91bnQgdG8gd2FpdCBmb3IgdHJ1ZS12YWx1ZS9mYWxzZS12YWx1ZVxuICBtb3VudGVkOiBzZXRDaGVja2VkLFxuICBiZWZvcmVVcGRhdGUoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIHNldENoZWNrZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNldENoZWNrZWQoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHZub2RlKSB7XG4gIGVsLl9tb2RlbFZhbHVlID0gdmFsdWU7XG4gIGxldCBjaGVja2VkO1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjaGVja2VkID0gbG9vc2VJbmRleE9mKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSkgPiAtMTtcbiAgfSBlbHNlIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICBjaGVja2VkID0gdmFsdWUuaGFzKHZub2RlLnByb3BzLnZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsdWUgPT09IG9sZFZhbHVlKSByZXR1cm47XG4gICAgY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIGdldENoZWNrYm94VmFsdWUoZWwsIHRydWUpKTtcbiAgfVxuICBpZiAoZWwuY2hlY2tlZCAhPT0gY2hlY2tlZCkge1xuICAgIGVsLmNoZWNrZWQgPSBjaGVja2VkO1xuICB9XG59XG5jb25zdCB2TW9kZWxSYWRpbyA9IHtcbiAgY3JlYXRlZChlbCwgeyB2YWx1ZSB9LCB2bm9kZSkge1xuICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSk7XG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgIGVsW2Fzc2lnbktleV0oZ2V0VmFsdWUoZWwpKTtcbiAgICB9KTtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB2bm9kZSkge1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IHZNb2RlbFNlbGVjdCA9IHtcbiAgLy8gPHNlbGVjdCBtdWx0aXBsZT4gdmFsdWUgbmVlZCB0byBiZSBkZWVwIHRyYXZlcnNlZFxuICBkZWVwOiB0cnVlLFxuICBjcmVhdGVkKGVsLCB7IHZhbHVlLCBtb2RpZmllcnM6IHsgbnVtYmVyIH0gfSwgdm5vZGUpIHtcbiAgICBjb25zdCBpc1NldE1vZGVsID0gaXNTZXQodmFsdWUpO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkVmFsID0gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGVsLm9wdGlvbnMsIChvKSA9PiBvLnNlbGVjdGVkKS5tYXAoXG4gICAgICAgIChvKSA9PiBudW1iZXIgPyBsb29zZVRvTnVtYmVyKGdldFZhbHVlKG8pKSA6IGdldFZhbHVlKG8pXG4gICAgICApO1xuICAgICAgZWxbYXNzaWduS2V5XShcbiAgICAgICAgZWwubXVsdGlwbGUgPyBpc1NldE1vZGVsID8gbmV3IFNldChzZWxlY3RlZFZhbCkgOiBzZWxlY3RlZFZhbCA6IHNlbGVjdGVkVmFsWzBdXG4gICAgICApO1xuICAgICAgZWwuX2Fzc2lnbmluZyA9IHRydWU7XG4gICAgICBuZXh0VGljaygoKSA9PiB7XG4gICAgICAgIGVsLl9hc3NpZ25pbmcgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgfSxcbiAgLy8gc2V0IHZhbHVlIGluIG1vdW50ZWQgJiB1cGRhdGVkIGJlY2F1c2UgPHNlbGVjdD4gcmVsaWVzIG9uIGl0cyBjaGlsZHJlblxuICAvLyA8b3B0aW9uPnMuXG4gIG1vdW50ZWQoZWwsIHsgdmFsdWUgfSkge1xuICAgIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSk7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShlbCwgX2JpbmRpbmcsIHZub2RlKSB7XG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICB9LFxuICB1cGRhdGVkKGVsLCB7IHZhbHVlIH0pIHtcbiAgICBpZiAoIWVsLl9hc3NpZ25pbmcpIHtcbiAgICAgIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSk7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gc2V0U2VsZWN0ZWQoZWwsIHZhbHVlKSB7XG4gIGNvbnN0IGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgY29uc3QgaXNBcnJheVZhbHVlID0gaXNBcnJheSh2YWx1ZSk7XG4gIGlmIChpc011bHRpcGxlICYmICFpc0FycmF5VmFsdWUgJiYgIWlzU2V0KHZhbHVlKSkge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihcbiAgICAgIGA8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw+IGV4cGVjdHMgYW4gQXJyYXkgb3IgU2V0IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCAke09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpfS5gXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgY29uc3Qgb3B0aW9uVmFsdWUgPSBnZXRWYWx1ZShvcHRpb24pO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBpZiAoaXNBcnJheVZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvblR5cGUgPSB0eXBlb2Ygb3B0aW9uVmFsdWU7XG4gICAgICAgIGlmIChvcHRpb25UeXBlID09PSBcInN0cmluZ1wiIHx8IG9wdGlvblR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB2YWx1ZS5zb21lKCh2KSA9PiBTdHJpbmcodikgPT09IFN0cmluZyhvcHRpb25WYWx1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgb3B0aW9uVmFsdWUpID4gLTE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlLmhhcyhvcHRpb25WYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUgJiYgZWwuc2VsZWN0ZWRJbmRleCAhPT0gLTEpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFZhbHVlKGVsKSB7XG4gIHJldHVybiBcIl92YWx1ZVwiIGluIGVsID8gZWwuX3ZhbHVlIDogZWwudmFsdWU7XG59XG5mdW5jdGlvbiBnZXRDaGVja2JveFZhbHVlKGVsLCBjaGVja2VkKSB7XG4gIGNvbnN0IGtleSA9IGNoZWNrZWQgPyBcIl90cnVlVmFsdWVcIiA6IFwiX2ZhbHNlVmFsdWVcIjtcbiAgcmV0dXJuIGtleSBpbiBlbCA/IGVsW2tleV0gOiBjaGVja2VkO1xufVxuY29uc3Qgdk1vZGVsRHluYW1pYyA9IHtcbiAgY3JlYXRlZChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgbnVsbCwgXCJjcmVhdGVkXCIpO1xuICB9LFxuICBtb3VudGVkKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBudWxsLCBcIm1vdW50ZWRcIik7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSkge1xuICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUsIFwiYmVmb3JlVXBkYXRlXCIpO1xuICB9LFxuICB1cGRhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKSB7XG4gICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgXCJ1cGRhdGVkXCIpO1xuICB9XG59O1xuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNNb2RlbCh0YWdOYW1lLCB0eXBlKSB7XG4gIHN3aXRjaCAodGFnTmFtZSkge1xuICAgIGNhc2UgXCJTRUxFQ1RcIjpcbiAgICAgIHJldHVybiB2TW9kZWxTZWxlY3Q7XG4gICAgY2FzZSBcIlRFWFRBUkVBXCI6XG4gICAgICByZXR1cm4gdk1vZGVsVGV4dDtcbiAgICBkZWZhdWx0OlxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJjaGVja2JveFwiOlxuICAgICAgICAgIHJldHVybiB2TW9kZWxDaGVja2JveDtcbiAgICAgICAgY2FzZSBcInJhZGlvXCI6XG4gICAgICAgICAgcmV0dXJuIHZNb2RlbFJhZGlvO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB2TW9kZWxUZXh0O1xuICAgICAgfVxuICB9XG59XG5mdW5jdGlvbiBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCBob29rKSB7XG4gIGNvbnN0IG1vZGVsVG9Vc2UgPSByZXNvbHZlRHluYW1pY01vZGVsKFxuICAgIGVsLnRhZ05hbWUsXG4gICAgdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudHlwZVxuICApO1xuICBjb25zdCBmbiA9IG1vZGVsVG9Vc2VbaG9va107XG4gIGZuICYmIGZuKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKTtcbn1cbmZ1bmN0aW9uIGluaXRWTW9kZWxGb3JTU1IoKSB7XG4gIHZNb2RlbFRleHQuZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9KSA9PiAoeyB2YWx1ZSB9KTtcbiAgdk1vZGVsUmFkaW8uZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9LCB2bm9kZSkgPT4ge1xuICAgIGlmICh2bm9kZS5wcm9wcyAmJiBsb29zZUVxdWFsKHZub2RlLnByb3BzLnZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICB9XG4gIH07XG4gIHZNb2RlbENoZWNrYm94LmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSwgdm5vZGUpID0+IHtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGlmICh2bm9kZS5wcm9wcyAmJiBsb29zZUluZGV4T2YodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgICAgaWYgKHZub2RlLnByb3BzICYmIHZhbHVlLmhhcyh2bm9kZS5wcm9wcy52YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICB9XG4gIH07XG4gIHZNb2RlbER5bmFtaWMuZ2V0U1NSUHJvcHMgPSAoYmluZGluZywgdm5vZGUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZub2RlLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbW9kZWxUb1VzZSA9IHJlc29sdmVEeW5hbWljTW9kZWwoXG4gICAgICAvLyByZXNvbHZlRHluYW1pY01vZGVsIGV4cGVjdHMgYW4gdXBwZXJjYXNlIHRhZyBuYW1lLCBidXQgdm5vZGUudHlwZSBpcyBsb3dlcmNhc2VcbiAgICAgIHZub2RlLnR5cGUudG9VcHBlckNhc2UoKSxcbiAgICAgIHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnR5cGVcbiAgICApO1xuICAgIGlmIChtb2RlbFRvVXNlLmdldFNTUlByb3BzKSB7XG4gICAgICByZXR1cm4gbW9kZWxUb1VzZS5nZXRTU1JQcm9wcyhiaW5kaW5nLCB2bm9kZSk7XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBzeXN0ZW1Nb2RpZmllcnMgPSBbXCJjdHJsXCIsIFwic2hpZnRcIiwgXCJhbHRcIiwgXCJtZXRhXCJdO1xuY29uc3QgbW9kaWZpZXJHdWFyZHMgPSB7XG4gIHN0b3A6IChlKSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpLFxuICBwcmV2ZW50OiAoZSkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpLFxuICBzZWxmOiAoZSkgPT4gZS50YXJnZXQgIT09IGUuY3VycmVudFRhcmdldCxcbiAgY3RybDogKGUpID0+ICFlLmN0cmxLZXksXG4gIHNoaWZ0OiAoZSkgPT4gIWUuc2hpZnRLZXksXG4gIGFsdDogKGUpID0+ICFlLmFsdEtleSxcbiAgbWV0YTogKGUpID0+ICFlLm1ldGFLZXksXG4gIGxlZnQ6IChlKSA9PiBcImJ1dHRvblwiIGluIGUgJiYgZS5idXR0b24gIT09IDAsXG4gIG1pZGRsZTogKGUpID0+IFwiYnV0dG9uXCIgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMSxcbiAgcmlnaHQ6IChlKSA9PiBcImJ1dHRvblwiIGluIGUgJiYgZS5idXR0b24gIT09IDIsXG4gIGV4YWN0OiAoZSwgbW9kaWZpZXJzKSA9PiBzeXN0ZW1Nb2RpZmllcnMuc29tZSgobSkgPT4gZVtgJHttfUtleWBdICYmICFtb2RpZmllcnMuaW5jbHVkZXMobSkpXG59O1xuY29uc3Qgd2l0aE1vZGlmaWVycyA9IChmbiwgbW9kaWZpZXJzKSA9PiB7XG4gIGNvbnN0IGNhY2hlID0gZm4uX3dpdGhNb2RzIHx8IChmbi5fd2l0aE1vZHMgPSB7fSk7XG4gIGNvbnN0IGNhY2hlS2V5ID0gbW9kaWZpZXJzLmpvaW4oXCIuXCIpO1xuICByZXR1cm4gY2FjaGVbY2FjaGVLZXldIHx8IChjYWNoZVtjYWNoZUtleV0gPSAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZ3VhcmQgPSBtb2RpZmllckd1YXJkc1ttb2RpZmllcnNbaV1dO1xuICAgICAgaWYgKGd1YXJkICYmIGd1YXJkKGV2ZW50LCBtb2RpZmllcnMpKSByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBmbihldmVudCwgLi4uYXJncyk7XG4gIH0pO1xufTtcbmNvbnN0IGtleU5hbWVzID0ge1xuICBlc2M6IFwiZXNjYXBlXCIsXG4gIHNwYWNlOiBcIiBcIixcbiAgdXA6IFwiYXJyb3ctdXBcIixcbiAgbGVmdDogXCJhcnJvdy1sZWZ0XCIsXG4gIHJpZ2h0OiBcImFycm93LXJpZ2h0XCIsXG4gIGRvd246IFwiYXJyb3ctZG93blwiLFxuICBkZWxldGU6IFwiYmFja3NwYWNlXCJcbn07XG5jb25zdCB3aXRoS2V5cyA9IChmbiwgbW9kaWZpZXJzKSA9PiB7XG4gIGNvbnN0IGNhY2hlID0gZm4uX3dpdGhLZXlzIHx8IChmbi5fd2l0aEtleXMgPSB7fSk7XG4gIGNvbnN0IGNhY2hlS2V5ID0gbW9kaWZpZXJzLmpvaW4oXCIuXCIpO1xuICByZXR1cm4gY2FjaGVbY2FjaGVLZXldIHx8IChjYWNoZVtjYWNoZUtleV0gPSAoZXZlbnQpID0+IHtcbiAgICBpZiAoIShcImtleVwiIGluIGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBldmVudEtleSA9IGh5cGhlbmF0ZShldmVudC5rZXkpO1xuICAgIGlmIChtb2RpZmllcnMuc29tZShcbiAgICAgIChrKSA9PiBrID09PSBldmVudEtleSB8fCBrZXlOYW1lc1trXSA9PT0gZXZlbnRLZXlcbiAgICApKSB7XG4gICAgICByZXR1cm4gZm4oZXZlbnQpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5jb25zdCByZW5kZXJlck9wdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKHsgcGF0Y2hQcm9wIH0sIG5vZGVPcHMpO1xubGV0IHJlbmRlcmVyO1xubGV0IGVuYWJsZWRIeWRyYXRpb24gPSBmYWxzZTtcbmZ1bmN0aW9uIGVuc3VyZVJlbmRlcmVyKCkge1xuICByZXR1cm4gcmVuZGVyZXIgfHwgKHJlbmRlcmVyID0gY3JlYXRlUmVuZGVyZXIocmVuZGVyZXJPcHRpb25zKSk7XG59XG5mdW5jdGlvbiBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpIHtcbiAgcmVuZGVyZXIgPSBlbmFibGVkSHlkcmF0aW9uID8gcmVuZGVyZXIgOiBjcmVhdGVIeWRyYXRpb25SZW5kZXJlcihyZW5kZXJlck9wdGlvbnMpO1xuICBlbmFibGVkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgcmV0dXJuIHJlbmRlcmVyO1xufVxuY29uc3QgcmVuZGVyID0gKC4uLmFyZ3MpID0+IHtcbiAgZW5zdXJlUmVuZGVyZXIoKS5yZW5kZXIoLi4uYXJncyk7XG59O1xuY29uc3QgaHlkcmF0ZSA9ICguLi5hcmdzKSA9PiB7XG4gIGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkuaHlkcmF0ZSguLi5hcmdzKTtcbn07XG5jb25zdCBjcmVhdGVBcHAgPSAoLi4uYXJncykgPT4ge1xuICBjb25zdCBhcHAgPSBlbnN1cmVSZW5kZXJlcigpLmNyZWF0ZUFwcCguLi5hcmdzKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApO1xuICAgIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCk7XG4gIH1cbiAgY29uc3QgeyBtb3VudCB9ID0gYXBwO1xuICBhcHAubW91bnQgPSAoY29udGFpbmVyT3JTZWxlY3RvcikgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXJPclNlbGVjdG9yKTtcbiAgICBpZiAoIWNvbnRhaW5lcikgcmV0dXJuO1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IGFwcC5fY29tcG9uZW50O1xuICAgIGlmICghaXNGdW5jdGlvbihjb21wb25lbnQpICYmICFjb21wb25lbnQucmVuZGVyICYmICFjb21wb25lbnQudGVtcGxhdGUpIHtcbiAgICAgIGNvbXBvbmVudC50ZW1wbGF0ZSA9IGNvbnRhaW5lci5pbm5lckhUTUw7XG4gICAgfVxuICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgIGNvbnRhaW5lci50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgfVxuICAgIGNvbnN0IHByb3h5ID0gbW91bnQoY29udGFpbmVyLCBmYWxzZSwgcmVzb2x2ZVJvb3ROYW1lc3BhY2UoY29udGFpbmVyKSk7XG4gICAgaWYgKGNvbnRhaW5lciBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoXCJ2LWNsb2FrXCIpO1xuICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtdi1hcHBcIiwgXCJcIik7XG4gICAgfVxuICAgIHJldHVybiBwcm94eTtcbiAgfTtcbiAgcmV0dXJuIGFwcDtcbn07XG5jb25zdCBjcmVhdGVTU1JBcHAgPSAoLi4uYXJncykgPT4ge1xuICBjb25zdCBhcHAgPSBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpLmNyZWF0ZUFwcCguLi5hcmdzKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApO1xuICAgIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCk7XG4gIH1cbiAgY29uc3QgeyBtb3VudCB9ID0gYXBwO1xuICBhcHAubW91bnQgPSAoY29udGFpbmVyT3JTZWxlY3RvcikgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXJPclNlbGVjdG9yKTtcbiAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICByZXR1cm4gbW91bnQoY29udGFpbmVyLCB0cnVlLCByZXNvbHZlUm9vdE5hbWVzcGFjZShjb250YWluZXIpKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBhcHA7XG59O1xuZnVuY3Rpb24gcmVzb2x2ZVJvb3ROYW1lc3BhY2UoY29udGFpbmVyKSB7XG4gIGlmIChjb250YWluZXIgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSB7XG4gICAgcmV0dXJuIFwic3ZnXCI7XG4gIH1cbiAgaWYgKHR5cGVvZiBNYXRoTUxFbGVtZW50ID09PSBcImZ1bmN0aW9uXCIgJiYgY29udGFpbmVyIGluc3RhbmNlb2YgTWF0aE1MRWxlbWVudCkge1xuICAgIHJldHVybiBcIm1hdGhtbFwiO1xuICB9XG59XG5mdW5jdGlvbiBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsIFwiaXNOYXRpdmVUYWdcIiwge1xuICAgIHZhbHVlOiAodGFnKSA9PiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWR1RhZyh0YWcpIHx8IGlzTWF0aE1MVGFnKHRhZyksXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xufVxuZnVuY3Rpb24gaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKSB7XG4gIGlmIChpc1J1bnRpbWVPbmx5KCkpIHtcbiAgICBjb25zdCBpc0N1c3RvbUVsZW1lbnQgPSBhcHAuY29uZmlnLmlzQ3VzdG9tRWxlbWVudDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZywgXCJpc0N1c3RvbUVsZW1lbnRcIiwge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gaXNDdXN0b21FbGVtZW50O1xuICAgICAgfSxcbiAgICAgIHNldCgpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgVGhlIFxcYGlzQ3VzdG9tRWxlbWVudFxcYCBjb25maWcgb3B0aW9uIGlzIGRlcHJlY2F0ZWQuIFVzZSBcXGBjb21waWxlck9wdGlvbnMuaXNDdXN0b21FbGVtZW50XFxgIGluc3RlYWQuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGNvbXBpbGVyT3B0aW9ucyA9IGFwcC5jb25maWcuY29tcGlsZXJPcHRpb25zO1xuICAgIGNvbnN0IG1zZyA9IGBUaGUgXFxgY29tcGlsZXJPcHRpb25zXFxgIGNvbmZpZyBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyBhIGJ1aWxkIG9mIFZ1ZS5qcyB0aGF0IGluY2x1ZGVzIHRoZSBydW50aW1lIGNvbXBpbGVyIChha2EgXCJmdWxsIGJ1aWxkXCIpLiBTaW5jZSB5b3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQsIFxcYGNvbXBpbGVyT3B0aW9uc1xcYCBtdXN0IGJlIHBhc3NlZCB0byBcXGBAdnVlL2NvbXBpbGVyLWRvbVxcYCBpbiB0aGUgYnVpbGQgc2V0dXAgaW5zdGVhZC5cbi0gRm9yIHZ1ZS1sb2FkZXI6IHBhc3MgaXQgdmlhIHZ1ZS1sb2FkZXIncyBcXGBjb21waWxlck9wdGlvbnNcXGAgbG9hZGVyIG9wdGlvbi5cbi0gRm9yIHZ1ZS1jbGk6IHNlZSBodHRwczovL2NsaS52dWVqcy5vcmcvZ3VpZGUvd2VicGFjay5odG1sI21vZGlmeWluZy1vcHRpb25zLW9mLWEtbG9hZGVyXG4tIEZvciB2aXRlOiBwYXNzIGl0IHZpYSBAdml0ZWpzL3BsdWdpbi12dWUgb3B0aW9ucy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRlanMvdml0ZS1wbHVnaW4tdnVlL3RyZWUvbWFpbi9wYWNrYWdlcy9wbHVnaW4tdnVlI2V4YW1wbGUtZm9yLXBhc3Npbmctb3B0aW9ucy10by12dWVjb21waWxlci1zZmNgO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLCBcImNvbXBpbGVyT3B0aW9uc1wiLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgcmV0dXJuIGNvbXBpbGVyT3B0aW9ucztcbiAgICAgIH0sXG4gICAgICBzZXQoKSB7XG4gICAgICAgIHdhcm4obXNnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoaXNTdHJpbmcoY29udGFpbmVyKSkge1xuICAgIGNvbnN0IHJlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGFpbmVyKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhcmVzKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgRmFpbGVkIHRvIG1vdW50IGFwcDogbW91bnQgdGFyZ2V0IHNlbGVjdG9yIFwiJHtjb250YWluZXJ9XCIgcmV0dXJuZWQgbnVsbC5gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdpbmRvdy5TaGFkb3dSb290ICYmIGNvbnRhaW5lciBpbnN0YW5jZW9mIHdpbmRvdy5TaGFkb3dSb290ICYmIGNvbnRhaW5lci5tb2RlID09PSBcImNsb3NlZFwiKSB7XG4gICAgd2FybihcbiAgICAgIGBtb3VudGluZyBvbiBhIFNoYWRvd1Jvb3Qgd2l0aCBcXGB7bW9kZTogXCJjbG9zZWRcIn1cXGAgbWF5IGxlYWQgdG8gdW5wcmVkaWN0YWJsZSBidWdzYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNvbnRhaW5lcjtcbn1cbmxldCBzc3JEaXJlY3RpdmVJbml0aWFsaXplZCA9IGZhbHNlO1xuY29uc3QgaW5pdERpcmVjdGl2ZXNGb3JTU1IgPSAoKSA9PiB7XG4gIGlmICghc3NyRGlyZWN0aXZlSW5pdGlhbGl6ZWQpIHtcbiAgICBzc3JEaXJlY3RpdmVJbml0aWFsaXplZCA9IHRydWU7XG4gICAgaW5pdFZNb2RlbEZvclNTUigpO1xuICAgIGluaXRWU2hvd0ZvclNTUigpO1xuICB9XG59IDtcblxuZXhwb3J0IHsgVHJhbnNpdGlvbiwgVHJhbnNpdGlvbkdyb3VwLCBWdWVFbGVtZW50LCBjcmVhdGVBcHAsIGNyZWF0ZVNTUkFwcCwgZGVmaW5lQ3VzdG9tRWxlbWVudCwgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudCwgaHlkcmF0ZSwgaW5pdERpcmVjdGl2ZXNGb3JTU1IsIHJlbmRlciwgdXNlQ3NzTW9kdWxlLCB1c2VDc3NWYXJzLCB1c2VIb3N0LCB1c2VTaGFkb3dSb290LCB2TW9kZWxDaGVja2JveCwgdk1vZGVsRHluYW1pYywgdk1vZGVsUmFkaW8sIHZNb2RlbFNlbGVjdCwgdk1vZGVsVGV4dCwgdlNob3csIHdpdGhLZXlzLCB3aXRoTW9kaWZpZXJzIH07XG4iLCIvKipcbiogQHZ1ZS9ydW50aW1lLWNvcmUgdjMuNS4xNlxuKiAoYykgMjAxOC1wcmVzZW50IFl1eGkgKEV2YW4pIFlvdSBhbmQgVnVlIGNvbnRyaWJ1dG9yc1xuKiBAbGljZW5zZSBNSVRcbioqL1xuaW1wb3J0IHsgcGF1c2VUcmFja2luZywgcmVzZXRUcmFja2luZywgaXNSZWYsIHRvUmF3LCB0cmF2ZXJzZSwgc2hhbGxvd1JlZiwgcmVhZG9ubHksIGlzUmVhY3RpdmUsIHJlZiwgaXNTaGFsbG93LCBpc1JlYWRvbmx5LCBzaGFsbG93UmVhZEFycmF5LCB0b1JlYWRvbmx5LCB0b1JlYWN0aXZlLCBzaGFsbG93UmVhZG9ubHksIHRyYWNrLCByZWFjdGl2ZSwgc2hhbGxvd1JlYWN0aXZlLCB0cmlnZ2VyLCBSZWFjdGl2ZUVmZmVjdCwgd2F0Y2ggYXMgd2F0Y2gkMSwgY3VzdG9tUmVmLCBpc1Byb3h5LCBwcm94eVJlZnMsIG1hcmtSYXcsIEVmZmVjdFNjb3BlLCBjb21wdXRlZCBhcyBjb21wdXRlZCQxIH0gZnJvbSAnQHZ1ZS9yZWFjdGl2aXR5JztcbmV4cG9ydCB7IEVmZmVjdFNjb3BlLCBSZWFjdGl2ZUVmZmVjdCwgVHJhY2tPcFR5cGVzLCBUcmlnZ2VyT3BUeXBlcywgY3VzdG9tUmVmLCBlZmZlY3QsIGVmZmVjdFNjb3BlLCBnZXRDdXJyZW50U2NvcGUsIGdldEN1cnJlbnRXYXRjaGVyLCBpc1Byb3h5LCBpc1JlYWN0aXZlLCBpc1JlYWRvbmx5LCBpc1JlZiwgaXNTaGFsbG93LCBtYXJrUmF3LCBvblNjb3BlRGlzcG9zZSwgb25XYXRjaGVyQ2xlYW51cCwgcHJveHlSZWZzLCByZWFjdGl2ZSwgcmVhZG9ubHksIHJlZiwgc2hhbGxvd1JlYWN0aXZlLCBzaGFsbG93UmVhZG9ubHksIHNoYWxsb3dSZWYsIHN0b3AsIHRvUmF3LCB0b1JlZiwgdG9SZWZzLCB0b1ZhbHVlLCB0cmlnZ2VyUmVmLCB1bnJlZiB9IGZyb20gJ0B2dWUvcmVhY3Rpdml0eSc7XG5pbXBvcnQgeyBpc1N0cmluZywgaXNGdW5jdGlvbiwgRU1QVFlfT0JKLCBpc1Byb21pc2UsIGlzQXJyYXksIE5PT1AsIGdldEdsb2JhbFRoaXMsIGV4dGVuZCwgaXNCdWlsdEluRGlyZWN0aXZlLCBoYXNPd24sIHJlbW92ZSwgZGVmLCBpc09uLCBpc1Jlc2VydmVkUHJvcCwgbm9ybWFsaXplQ2xhc3MsIHN0cmluZ2lmeVN0eWxlLCBub3JtYWxpemVTdHlsZSwgaXNLbm93blN2Z0F0dHIsIGlzQm9vbGVhbkF0dHIsIGlzS25vd25IdG1sQXR0ciwgaW5jbHVkZUJvb2xlYW5BdHRyLCBpc1JlbmRlcmFibGVBdHRyVmFsdWUsIGdldEVzY2FwZWRDc3NWYXJOYW1lLCBpc09iamVjdCwgaXNSZWdFeHAsIGludm9rZUFycmF5Rm5zLCB0b0hhbmRsZXJLZXksIGNhbWVsaXplLCBjYXBpdGFsaXplLCBpc1N5bWJvbCwgaXNHbG9iYWxseUFsbG93ZWQsIE5PLCBFTVBUWV9BUlIsIGh5cGhlbmF0ZSwgbWFrZU1hcCwgdG9SYXdUeXBlLCBoYXNDaGFuZ2VkLCBsb29zZVRvTnVtYmVyLCBpc01vZGVsTGlzdGVuZXIsIHRvTnVtYmVyIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuZXhwb3J0IHsgY2FtZWxpemUsIGNhcGl0YWxpemUsIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVQcm9wcywgbm9ybWFsaXplU3R5bGUsIHRvRGlzcGxheVN0cmluZywgdG9IYW5kbGVyS2V5IH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5jb25zdCBzdGFjayA9IFtdO1xuZnVuY3Rpb24gcHVzaFdhcm5pbmdDb250ZXh0KHZub2RlKSB7XG4gIHN0YWNrLnB1c2godm5vZGUpO1xufVxuZnVuY3Rpb24gcG9wV2FybmluZ0NvbnRleHQoKSB7XG4gIHN0YWNrLnBvcCgpO1xufVxubGV0IGlzV2FybmluZyA9IGZhbHNlO1xuZnVuY3Rpb24gd2FybiQxKG1zZywgLi4uYXJncykge1xuICBpZiAoaXNXYXJuaW5nKSByZXR1cm47XG4gIGlzV2FybmluZyA9IHRydWU7XG4gIHBhdXNlVHJhY2tpbmcoKTtcbiAgY29uc3QgaW5zdGFuY2UgPSBzdGFjay5sZW5ndGggPyBzdGFja1tzdGFjay5sZW5ndGggLSAxXS5jb21wb25lbnQgOiBudWxsO1xuICBjb25zdCBhcHBXYXJuSGFuZGxlciA9IGluc3RhbmNlICYmIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLndhcm5IYW5kbGVyO1xuICBjb25zdCB0cmFjZSA9IGdldENvbXBvbmVudFRyYWNlKCk7XG4gIGlmIChhcHBXYXJuSGFuZGxlcikge1xuICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhcbiAgICAgIGFwcFdhcm5IYW5kbGVyLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICAxMSxcbiAgICAgIFtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgIG1zZyArIGFyZ3MubWFwKChhKSA9PiB7XG4gICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gYS50b1N0cmluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoYSkpICE9IG51bGwgPyBfYiA6IEpTT04uc3RyaW5naWZ5KGEpO1xuICAgICAgICB9KS5qb2luKFwiXCIpLFxuICAgICAgICBpbnN0YW5jZSAmJiBpbnN0YW5jZS5wcm94eSxcbiAgICAgICAgdHJhY2UubWFwKFxuICAgICAgICAgICh7IHZub2RlIH0pID0+IGBhdCA8JHtmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCB2bm9kZS50eXBlKX0+YFxuICAgICAgICApLmpvaW4oXCJcXG5cIiksXG4gICAgICAgIHRyYWNlXG4gICAgICBdXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB3YXJuQXJncyA9IFtgW1Z1ZSB3YXJuXTogJHttc2d9YCwgLi4uYXJnc107XG4gICAgaWYgKHRyYWNlLmxlbmd0aCAmJiAvLyBhdm9pZCBzcGFtbWluZyBjb25zb2xlIGR1cmluZyB0ZXN0c1xuICAgIHRydWUpIHtcbiAgICAgIHdhcm5BcmdzLnB1c2goYFxuYCwgLi4uZm9ybWF0VHJhY2UodHJhY2UpKTtcbiAgICB9XG4gICAgY29uc29sZS53YXJuKC4uLndhcm5BcmdzKTtcbiAgfVxuICByZXNldFRyYWNraW5nKCk7XG4gIGlzV2FybmluZyA9IGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50VHJhY2UoKSB7XG4gIGxldCBjdXJyZW50Vk5vZGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgaWYgKCFjdXJyZW50Vk5vZGUpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3Qgbm9ybWFsaXplZFN0YWNrID0gW107XG4gIHdoaWxlIChjdXJyZW50Vk5vZGUpIHtcbiAgICBjb25zdCBsYXN0ID0gbm9ybWFsaXplZFN0YWNrWzBdO1xuICAgIGlmIChsYXN0ICYmIGxhc3Qudm5vZGUgPT09IGN1cnJlbnRWTm9kZSkge1xuICAgICAgbGFzdC5yZWN1cnNlQ291bnQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgbm9ybWFsaXplZFN0YWNrLnB1c2goe1xuICAgICAgICB2bm9kZTogY3VycmVudFZOb2RlLFxuICAgICAgICByZWN1cnNlQ291bnQ6IDBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnRJbnN0YW5jZSA9IGN1cnJlbnRWTm9kZS5jb21wb25lbnQgJiYgY3VycmVudFZOb2RlLmNvbXBvbmVudC5wYXJlbnQ7XG4gICAgY3VycmVudFZOb2RlID0gcGFyZW50SW5zdGFuY2UgJiYgcGFyZW50SW5zdGFuY2Uudm5vZGU7XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWRTdGFjaztcbn1cbmZ1bmN0aW9uIGZvcm1hdFRyYWNlKHRyYWNlKSB7XG4gIGNvbnN0IGxvZ3MgPSBbXTtcbiAgdHJhY2UuZm9yRWFjaCgoZW50cnksIGkpID0+IHtcbiAgICBsb2dzLnB1c2goLi4uaSA9PT0gMCA/IFtdIDogW2BcbmBdLCAuLi5mb3JtYXRUcmFjZUVudHJ5KGVudHJ5KSk7XG4gIH0pO1xuICByZXR1cm4gbG9ncztcbn1cbmZ1bmN0aW9uIGZvcm1hdFRyYWNlRW50cnkoeyB2bm9kZSwgcmVjdXJzZUNvdW50IH0pIHtcbiAgY29uc3QgcG9zdGZpeCA9IHJlY3Vyc2VDb3VudCA+IDAgPyBgLi4uICgke3JlY3Vyc2VDb3VudH0gcmVjdXJzaXZlIGNhbGxzKWAgOiBgYDtcbiAgY29uc3QgaXNSb290ID0gdm5vZGUuY29tcG9uZW50ID8gdm5vZGUuY29tcG9uZW50LnBhcmVudCA9PSBudWxsIDogZmFsc2U7XG4gIGNvbnN0IG9wZW4gPSBgIGF0IDwke2Zvcm1hdENvbXBvbmVudE5hbWUoXG4gICAgdm5vZGUuY29tcG9uZW50LFxuICAgIHZub2RlLnR5cGUsXG4gICAgaXNSb290XG4gICl9YDtcbiAgY29uc3QgY2xvc2UgPSBgPmAgKyBwb3N0Zml4O1xuICByZXR1cm4gdm5vZGUucHJvcHMgPyBbb3BlbiwgLi4uZm9ybWF0UHJvcHModm5vZGUucHJvcHMpLCBjbG9zZV0gOiBbb3BlbiArIGNsb3NlXTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFByb3BzKHByb3BzKSB7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMpO1xuICBrZXlzLnNsaWNlKDAsIDMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIHJlcy5wdXNoKC4uLmZvcm1hdFByb3Aoa2V5LCBwcm9wc1trZXldKSk7XG4gIH0pO1xuICBpZiAoa2V5cy5sZW5ndGggPiAzKSB7XG4gICAgcmVzLnB1c2goYCAuLi5gKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZm9ybWF0UHJvcChrZXksIHZhbHVlLCByYXcpIHtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PSR7dmFsdWV9YF07XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PSR7dmFsdWV9YF07XG4gIH0gZWxzZSBpZiAoaXNSZWYodmFsdWUpKSB7XG4gICAgdmFsdWUgPSBmb3JtYXRQcm9wKGtleSwgdG9SYXcodmFsdWUudmFsdWUpLCB0cnVlKTtcbiAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT1SZWY8YCwgdmFsdWUsIGA+YF07XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICByZXR1cm4gW2Ake2tleX09Zm4ke3ZhbHVlLm5hbWUgPyBgPCR7dmFsdWUubmFtZX0+YCA6IGBgfWBdO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xuICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PWAsIHZhbHVlXTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0TnVtYmVyKHZhbCwgdHlwZSkge1xuICBpZiAoISEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHJldHVybjtcbiAgaWYgKHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgIT09IFwibnVtYmVyXCIpIHtcbiAgICB3YXJuJDEoYCR7dHlwZX0gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gZ290ICR7SlNPTi5zdHJpbmdpZnkodmFsKX0uYCk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4kMShgJHt0eXBlfSBpcyBOYU4gLSB0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuYCk7XG4gIH1cbn1cblxuY29uc3QgRXJyb3JDb2RlcyA9IHtcbiAgXCJTRVRVUF9GVU5DVElPTlwiOiAwLFxuICBcIjBcIjogXCJTRVRVUF9GVU5DVElPTlwiLFxuICBcIlJFTkRFUl9GVU5DVElPTlwiOiAxLFxuICBcIjFcIjogXCJSRU5ERVJfRlVOQ1RJT05cIixcbiAgXCJOQVRJVkVfRVZFTlRfSEFORExFUlwiOiA1LFxuICBcIjVcIjogXCJOQVRJVkVfRVZFTlRfSEFORExFUlwiLFxuICBcIkNPTVBPTkVOVF9FVkVOVF9IQU5ETEVSXCI6IDYsXG4gIFwiNlwiOiBcIkNPTVBPTkVOVF9FVkVOVF9IQU5ETEVSXCIsXG4gIFwiVk5PREVfSE9PS1wiOiA3LFxuICBcIjdcIjogXCJWTk9ERV9IT09LXCIsXG4gIFwiRElSRUNUSVZFX0hPT0tcIjogOCxcbiAgXCI4XCI6IFwiRElSRUNUSVZFX0hPT0tcIixcbiAgXCJUUkFOU0lUSU9OX0hPT0tcIjogOSxcbiAgXCI5XCI6IFwiVFJBTlNJVElPTl9IT09LXCIsXG4gIFwiQVBQX0VSUk9SX0hBTkRMRVJcIjogMTAsXG4gIFwiMTBcIjogXCJBUFBfRVJST1JfSEFORExFUlwiLFxuICBcIkFQUF9XQVJOX0hBTkRMRVJcIjogMTEsXG4gIFwiMTFcIjogXCJBUFBfV0FSTl9IQU5ETEVSXCIsXG4gIFwiRlVOQ1RJT05fUkVGXCI6IDEyLFxuICBcIjEyXCI6IFwiRlVOQ1RJT05fUkVGXCIsXG4gIFwiQVNZTkNfQ09NUE9ORU5UX0xPQURFUlwiOiAxMyxcbiAgXCIxM1wiOiBcIkFTWU5DX0NPTVBPTkVOVF9MT0FERVJcIixcbiAgXCJTQ0hFRFVMRVJcIjogMTQsXG4gIFwiMTRcIjogXCJTQ0hFRFVMRVJcIixcbiAgXCJDT01QT05FTlRfVVBEQVRFXCI6IDE1LFxuICBcIjE1XCI6IFwiQ09NUE9ORU5UX1VQREFURVwiLFxuICBcIkFQUF9VTk1PVU5UX0NMRUFOVVBcIjogMTYsXG4gIFwiMTZcIjogXCJBUFBfVU5NT1VOVF9DTEVBTlVQXCJcbn07XG5jb25zdCBFcnJvclR5cGVTdHJpbmdzJDEgPSB7XG4gIFtcInNwXCJdOiBcInNlcnZlclByZWZldGNoIGhvb2tcIixcbiAgW1wiYmNcIl06IFwiYmVmb3JlQ3JlYXRlIGhvb2tcIixcbiAgW1wiY1wiXTogXCJjcmVhdGVkIGhvb2tcIixcbiAgW1wiYm1cIl06IFwiYmVmb3JlTW91bnQgaG9va1wiLFxuICBbXCJtXCJdOiBcIm1vdW50ZWQgaG9va1wiLFxuICBbXCJidVwiXTogXCJiZWZvcmVVcGRhdGUgaG9va1wiLFxuICBbXCJ1XCJdOiBcInVwZGF0ZWRcIixcbiAgW1wiYnVtXCJdOiBcImJlZm9yZVVubW91bnQgaG9va1wiLFxuICBbXCJ1bVwiXTogXCJ1bm1vdW50ZWQgaG9va1wiLFxuICBbXCJhXCJdOiBcImFjdGl2YXRlZCBob29rXCIsXG4gIFtcImRhXCJdOiBcImRlYWN0aXZhdGVkIGhvb2tcIixcbiAgW1wiZWNcIl06IFwiZXJyb3JDYXB0dXJlZCBob29rXCIsXG4gIFtcInJ0Y1wiXTogXCJyZW5kZXJUcmFja2VkIGhvb2tcIixcbiAgW1wicnRnXCJdOiBcInJlbmRlclRyaWdnZXJlZCBob29rXCIsXG4gIFswXTogXCJzZXR1cCBmdW5jdGlvblwiLFxuICBbMV06IFwicmVuZGVyIGZ1bmN0aW9uXCIsXG4gIFsyXTogXCJ3YXRjaGVyIGdldHRlclwiLFxuICBbM106IFwid2F0Y2hlciBjYWxsYmFja1wiLFxuICBbNF06IFwid2F0Y2hlciBjbGVhbnVwIGZ1bmN0aW9uXCIsXG4gIFs1XTogXCJuYXRpdmUgZXZlbnQgaGFuZGxlclwiLFxuICBbNl06IFwiY29tcG9uZW50IGV2ZW50IGhhbmRsZXJcIixcbiAgWzddOiBcInZub2RlIGhvb2tcIixcbiAgWzhdOiBcImRpcmVjdGl2ZSBob29rXCIsXG4gIFs5XTogXCJ0cmFuc2l0aW9uIGhvb2tcIixcbiAgWzEwXTogXCJhcHAgZXJyb3JIYW5kbGVyXCIsXG4gIFsxMV06IFwiYXBwIHdhcm5IYW5kbGVyXCIsXG4gIFsxMl06IFwicmVmIGZ1bmN0aW9uXCIsXG4gIFsxM106IFwiYXN5bmMgY29tcG9uZW50IGxvYWRlclwiLFxuICBbMTRdOiBcInNjaGVkdWxlciBmbHVzaFwiLFxuICBbMTVdOiBcImNvbXBvbmVudCB1cGRhdGVcIixcbiAgWzE2XTogXCJhcHAgdW5tb3VudCBjbGVhbnVwIGZ1bmN0aW9uXCJcbn07XG5mdW5jdGlvbiBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGFyZ3MgPyBmbiguLi5hcmdzKSA6IGZuKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUpO1xuICB9XG59XG5mdW5jdGlvbiBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpIHtcbiAgaWYgKGlzRnVuY3Rpb24oZm4pKSB7XG4gICAgY29uc3QgcmVzID0gY2FsbFdpdGhFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncyk7XG4gICAgaWYgKHJlcyAmJiBpc1Byb21pc2UocmVzKSkge1xuICAgICAgcmVzLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBpZiAoaXNBcnJheShmbikpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXMucHVzaChjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhmbltpXSwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FybiQxKFxuICAgICAgYEludmFsaWQgdmFsdWUgdHlwZSBwYXNzZWQgdG8gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoKTogJHt0eXBlb2YgZm59YFxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUsIHRocm93SW5EZXYgPSB0cnVlKSB7XG4gIGNvbnN0IGNvbnRleHRWTm9kZSA9IGluc3RhbmNlID8gaW5zdGFuY2Uudm5vZGUgOiBudWxsO1xuICBjb25zdCB7IGVycm9ySGFuZGxlciwgdGhyb3dVbmhhbmRsZWRFcnJvckluUHJvZHVjdGlvbiB9ID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcgfHwgRU1QVFlfT0JKO1xuICBpZiAoaW5zdGFuY2UpIHtcbiAgICBsZXQgY3VyID0gaW5zdGFuY2UucGFyZW50O1xuICAgIGNvbnN0IGV4cG9zZWRJbnN0YW5jZSA9IGluc3RhbmNlLnByb3h5O1xuICAgIGNvbnN0IGVycm9ySW5mbyA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBFcnJvclR5cGVTdHJpbmdzJDFbdHlwZV0gOiBgaHR0cHM6Ly92dWVqcy5vcmcvZXJyb3ItcmVmZXJlbmNlLyNydW50aW1lLSR7dHlwZX1gO1xuICAgIHdoaWxlIChjdXIpIHtcbiAgICAgIGNvbnN0IGVycm9yQ2FwdHVyZWRIb29rcyA9IGN1ci5lYztcbiAgICAgIGlmIChlcnJvckNhcHR1cmVkSG9va3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlcnJvckNhcHR1cmVkSG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZXJyb3JDYXB0dXJlZEhvb2tzW2ldKGVyciwgZXhwb3NlZEluc3RhbmNlLCBlcnJvckluZm8pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3VyID0gY3VyLnBhcmVudDtcbiAgICB9XG4gICAgaWYgKGVycm9ySGFuZGxlcikge1xuICAgICAgcGF1c2VUcmFja2luZygpO1xuICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKGVycm9ySGFuZGxlciwgbnVsbCwgMTAsIFtcbiAgICAgICAgZXJyLFxuICAgICAgICBleHBvc2VkSW5zdGFuY2UsXG4gICAgICAgIGVycm9ySW5mb1xuICAgICAgXSk7XG4gICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGxvZ0Vycm9yKGVyciwgdHlwZSwgY29udGV4dFZOb2RlLCB0aHJvd0luRGV2LCB0aHJvd1VuaGFuZGxlZEVycm9ySW5Qcm9kdWN0aW9uKTtcbn1cbmZ1bmN0aW9uIGxvZ0Vycm9yKGVyciwgdHlwZSwgY29udGV4dFZOb2RlLCB0aHJvd0luRGV2ID0gdHJ1ZSwgdGhyb3dJblByb2QgPSBmYWxzZSkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IGluZm8gPSBFcnJvclR5cGVTdHJpbmdzJDFbdHlwZV07XG4gICAgaWYgKGNvbnRleHRWTm9kZSkge1xuICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KGNvbnRleHRWTm9kZSk7XG4gICAgfVxuICAgIHdhcm4kMShgVW5oYW5kbGVkIGVycm9yJHtpbmZvID8gYCBkdXJpbmcgZXhlY3V0aW9uIG9mICR7aW5mb31gIDogYGB9YCk7XG4gICAgaWYgKGNvbnRleHRWTm9kZSkge1xuICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICB9XG4gICAgaWYgKHRocm93SW5EZXYpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aHJvd0luUHJvZCkge1xuICAgIHRocm93IGVycjtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH1cbn1cblxuY29uc3QgcXVldWUgPSBbXTtcbmxldCBmbHVzaEluZGV4ID0gLTE7XG5jb25zdCBwZW5kaW5nUG9zdEZsdXNoQ2JzID0gW107XG5sZXQgYWN0aXZlUG9zdEZsdXNoQ2JzID0gbnVsbDtcbmxldCBwb3N0Rmx1c2hJbmRleCA9IDA7XG5jb25zdCByZXNvbHZlZFByb21pc2UgPSAvKiBAX19QVVJFX18gKi8gUHJvbWlzZS5yZXNvbHZlKCk7XG5sZXQgY3VycmVudEZsdXNoUHJvbWlzZSA9IG51bGw7XG5jb25zdCBSRUNVUlNJT05fTElNSVQgPSAxMDA7XG5mdW5jdGlvbiBuZXh0VGljayhmbikge1xuICBjb25zdCBwID0gY3VycmVudEZsdXNoUHJvbWlzZSB8fCByZXNvbHZlZFByb21pc2U7XG4gIHJldHVybiBmbiA/IHAudGhlbih0aGlzID8gZm4uYmluZCh0aGlzKSA6IGZuKSA6IHA7XG59XG5mdW5jdGlvbiBmaW5kSW5zZXJ0aW9uSW5kZXgoaWQpIHtcbiAgbGV0IHN0YXJ0ID0gZmx1c2hJbmRleCArIDE7XG4gIGxldCBlbmQgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChzdGFydCA8IGVuZCkge1xuICAgIGNvbnN0IG1pZGRsZSA9IHN0YXJ0ICsgZW5kID4+PiAxO1xuICAgIGNvbnN0IG1pZGRsZUpvYiA9IHF1ZXVlW21pZGRsZV07XG4gICAgY29uc3QgbWlkZGxlSm9iSWQgPSBnZXRJZChtaWRkbGVKb2IpO1xuICAgIGlmIChtaWRkbGVKb2JJZCA8IGlkIHx8IG1pZGRsZUpvYklkID09PSBpZCAmJiBtaWRkbGVKb2IuZmxhZ3MgJiAyKSB7XG4gICAgICBzdGFydCA9IG1pZGRsZSArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZCA9IG1pZGRsZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0YXJ0O1xufVxuZnVuY3Rpb24gcXVldWVKb2Ioam9iKSB7XG4gIGlmICghKGpvYi5mbGFncyAmIDEpKSB7XG4gICAgY29uc3Qgam9iSWQgPSBnZXRJZChqb2IpO1xuICAgIGNvbnN0IGxhc3RKb2IgPSBxdWV1ZVtxdWV1ZS5sZW5ndGggLSAxXTtcbiAgICBpZiAoIWxhc3RKb2IgfHwgLy8gZmFzdCBwYXRoIHdoZW4gdGhlIGpvYiBpZCBpcyBsYXJnZXIgdGhhbiB0aGUgdGFpbFxuICAgICEoam9iLmZsYWdzICYgMikgJiYgam9iSWQgPj0gZ2V0SWQobGFzdEpvYikpIHtcbiAgICAgIHF1ZXVlLnB1c2goam9iKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVldWUuc3BsaWNlKGZpbmRJbnNlcnRpb25JbmRleChqb2JJZCksIDAsIGpvYik7XG4gICAgfVxuICAgIGpvYi5mbGFncyB8PSAxO1xuICAgIHF1ZXVlRmx1c2goKTtcbiAgfVxufVxuZnVuY3Rpb24gcXVldWVGbHVzaCgpIHtcbiAgaWYgKCFjdXJyZW50Rmx1c2hQcm9taXNlKSB7XG4gICAgY3VycmVudEZsdXNoUHJvbWlzZSA9IHJlc29sdmVkUHJvbWlzZS50aGVuKGZsdXNoSm9icyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHF1ZXVlUG9zdEZsdXNoQ2IoY2IpIHtcbiAgaWYgKCFpc0FycmF5KGNiKSkge1xuICAgIGlmIChhY3RpdmVQb3N0Rmx1c2hDYnMgJiYgY2IuaWQgPT09IC0xKSB7XG4gICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMuc3BsaWNlKHBvc3RGbHVzaEluZGV4ICsgMSwgMCwgY2IpO1xuICAgIH0gZWxzZSBpZiAoIShjYi5mbGFncyAmIDEpKSB7XG4gICAgICBwZW5kaW5nUG9zdEZsdXNoQ2JzLnB1c2goY2IpO1xuICAgICAgY2IuZmxhZ3MgfD0gMTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGVuZGluZ1Bvc3RGbHVzaENicy5wdXNoKC4uLmNiKTtcbiAgfVxuICBxdWV1ZUZsdXNoKCk7XG59XG5mdW5jdGlvbiBmbHVzaFByZUZsdXNoQ2JzKGluc3RhbmNlLCBzZWVuLCBpID0gZmx1c2hJbmRleCArIDEpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBzZWVuID0gc2VlbiB8fCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGZvciAoOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjYiA9IHF1ZXVlW2ldO1xuICAgIGlmIChjYiAmJiBjYi5mbGFncyAmIDIpIHtcbiAgICAgIGlmIChpbnN0YW5jZSAmJiBjYi5pZCAhPT0gaW5zdGFuY2UudWlkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGNiKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHF1ZXVlLnNwbGljZShpLCAxKTtcbiAgICAgIGktLTtcbiAgICAgIGlmIChjYi5mbGFncyAmIDQpIHtcbiAgICAgICAgY2IuZmxhZ3MgJj0gLTI7XG4gICAgICB9XG4gICAgICBjYigpO1xuICAgICAgaWYgKCEoY2IuZmxhZ3MgJiA0KSkge1xuICAgICAgICBjYi5mbGFncyAmPSAtMjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZsdXNoUG9zdEZsdXNoQ2JzKHNlZW4pIHtcbiAgaWYgKHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoKSB7XG4gICAgY29uc3QgZGVkdXBlZCA9IFsuLi5uZXcgU2V0KHBlbmRpbmdQb3N0Rmx1c2hDYnMpXS5zb3J0KFxuICAgICAgKGEsIGIpID0+IGdldElkKGEpIC0gZ2V0SWQoYilcbiAgICApO1xuICAgIHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoID0gMDtcbiAgICBpZiAoYWN0aXZlUG9zdEZsdXNoQ2JzKSB7XG4gICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMucHVzaCguLi5kZWR1cGVkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYWN0aXZlUG9zdEZsdXNoQ2JzID0gZGVkdXBlZDtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgc2VlbiA9IHNlZW4gfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB9XG4gICAgZm9yIChwb3N0Rmx1c2hJbmRleCA9IDA7IHBvc3RGbHVzaEluZGV4IDwgYWN0aXZlUG9zdEZsdXNoQ2JzLmxlbmd0aDsgcG9zdEZsdXNoSW5kZXgrKykge1xuICAgICAgY29uc3QgY2IgPSBhY3RpdmVQb3N0Rmx1c2hDYnNbcG9zdEZsdXNoSW5kZXhdO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGNiKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjYi5mbGFncyAmIDQpIHtcbiAgICAgICAgY2IuZmxhZ3MgJj0gLTI7XG4gICAgICB9XG4gICAgICBpZiAoIShjYi5mbGFncyAmIDgpKSBjYigpO1xuICAgICAgY2IuZmxhZ3MgJj0gLTI7XG4gICAgfVxuICAgIGFjdGl2ZVBvc3RGbHVzaENicyA9IG51bGw7XG4gICAgcG9zdEZsdXNoSW5kZXggPSAwO1xuICB9XG59XG5jb25zdCBnZXRJZCA9IChqb2IpID0+IGpvYi5pZCA9PSBudWxsID8gam9iLmZsYWdzICYgMiA/IC0xIDogSW5maW5pdHkgOiBqb2IuaWQ7XG5mdW5jdGlvbiBmbHVzaEpvYnMoc2Vlbikge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHNlZW4gPSBzZWVuIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgY29uc3QgY2hlY2sgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gKGpvYikgPT4gY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGpvYikgOiBOT09QO1xuICB0cnkge1xuICAgIGZvciAoZmx1c2hJbmRleCA9IDA7IGZsdXNoSW5kZXggPCBxdWV1ZS5sZW5ndGg7IGZsdXNoSW5kZXgrKykge1xuICAgICAgY29uc3Qgam9iID0gcXVldWVbZmx1c2hJbmRleF07XG4gICAgICBpZiAoam9iICYmICEoam9iLmZsYWdzICYgOCkpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY2hlY2soam9iKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqb2IuZmxhZ3MgJiA0KSB7XG4gICAgICAgICAgam9iLmZsYWdzICY9IH4xO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhcbiAgICAgICAgICBqb2IsXG4gICAgICAgICAgam9iLmksXG4gICAgICAgICAgam9iLmkgPyAxNSA6IDE0XG4gICAgICAgICk7XG4gICAgICAgIGlmICghKGpvYi5mbGFncyAmIDQpKSB7XG4gICAgICAgICAgam9iLmZsYWdzICY9IH4xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGZvciAoOyBmbHVzaEluZGV4IDwgcXVldWUubGVuZ3RoOyBmbHVzaEluZGV4KyspIHtcbiAgICAgIGNvbnN0IGpvYiA9IHF1ZXVlW2ZsdXNoSW5kZXhdO1xuICAgICAgaWYgKGpvYikge1xuICAgICAgICBqb2IuZmxhZ3MgJj0gLTI7XG4gICAgICB9XG4gICAgfVxuICAgIGZsdXNoSW5kZXggPSAtMTtcbiAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgIGZsdXNoUG9zdEZsdXNoQ2JzKHNlZW4pO1xuICAgIGN1cnJlbnRGbHVzaFByb21pc2UgPSBudWxsO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggfHwgcGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGgpIHtcbiAgICAgIGZsdXNoSm9icyhzZWVuKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBmbikge1xuICBjb25zdCBjb3VudCA9IHNlZW4uZ2V0KGZuKSB8fCAwO1xuICBpZiAoY291bnQgPiBSRUNVUlNJT05fTElNSVQpIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGZuLmk7XG4gICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGluc3RhbmNlICYmIGdldENvbXBvbmVudE5hbWUoaW5zdGFuY2UudHlwZSk7XG4gICAgaGFuZGxlRXJyb3IoXG4gICAgICBgTWF4aW11bSByZWN1cnNpdmUgdXBkYXRlcyBleGNlZWRlZCR7Y29tcG9uZW50TmFtZSA/IGAgaW4gY29tcG9uZW50IDwke2NvbXBvbmVudE5hbWV9PmAgOiBgYH0uIFRoaXMgbWVhbnMgeW91IGhhdmUgYSByZWFjdGl2ZSBlZmZlY3QgdGhhdCBpcyBtdXRhdGluZyBpdHMgb3duIGRlcGVuZGVuY2llcyBhbmQgdGh1cyByZWN1cnNpdmVseSB0cmlnZ2VyaW5nIGl0c2VsZi4gUG9zc2libGUgc291cmNlcyBpbmNsdWRlIGNvbXBvbmVudCB0ZW1wbGF0ZSwgcmVuZGVyIGZ1bmN0aW9uLCB1cGRhdGVkIGhvb2sgb3Igd2F0Y2hlciBzb3VyY2UgZnVuY3Rpb24uYCxcbiAgICAgIG51bGwsXG4gICAgICAxMFxuICAgICk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc2Vlbi5zZXQoZm4sIGNvdW50ICsgMSk7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubGV0IGlzSG1yVXBkYXRpbmcgPSBmYWxzZTtcbmNvbnN0IGhtckRpcnR5Q29tcG9uZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5pZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfSE1SX1JVTlRJTUVfXyA9IHtcbiAgICBjcmVhdGVSZWNvcmQ6IHRyeVdyYXAoY3JlYXRlUmVjb3JkKSxcbiAgICByZXJlbmRlcjogdHJ5V3JhcChyZXJlbmRlciksXG4gICAgcmVsb2FkOiB0cnlXcmFwKHJlbG9hZClcbiAgfTtcbn1cbmNvbnN0IG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiByZWdpc3RlckhNUihpbnN0YW5jZSkge1xuICBjb25zdCBpZCA9IGluc3RhbmNlLnR5cGUuX19obXJJZDtcbiAgbGV0IHJlY29yZCA9IG1hcC5nZXQoaWQpO1xuICBpZiAoIXJlY29yZCkge1xuICAgIGNyZWF0ZVJlY29yZChpZCwgaW5zdGFuY2UudHlwZSk7XG4gICAgcmVjb3JkID0gbWFwLmdldChpZCk7XG4gIH1cbiAgcmVjb3JkLmluc3RhbmNlcy5hZGQoaW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gdW5yZWdpc3RlckhNUihpbnN0YW5jZSkge1xuICBtYXAuZ2V0KGluc3RhbmNlLnR5cGUuX19obXJJZCkuaW5zdGFuY2VzLmRlbGV0ZShpbnN0YW5jZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWNvcmQoaWQsIGluaXRpYWxEZWYpIHtcbiAgaWYgKG1hcC5oYXMoaWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG1hcC5zZXQoaWQsIHtcbiAgICBpbml0aWFsRGVmOiBub3JtYWxpemVDbGFzc0NvbXBvbmVudChpbml0aWFsRGVmKSxcbiAgICBpbnN0YW5jZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KClcbiAgfSk7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIHJldHVybiBpc0NsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkgPyBjb21wb25lbnQuX192Y2NPcHRzIDogY29tcG9uZW50O1xufVxuZnVuY3Rpb24gcmVyZW5kZXIoaWQsIG5ld1JlbmRlcikge1xuICBjb25zdCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcbiAgaWYgKCFyZWNvcmQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmVjb3JkLmluaXRpYWxEZWYucmVuZGVyID0gbmV3UmVuZGVyO1xuICBbLi4ucmVjb3JkLmluc3RhbmNlc10uZm9yRWFjaCgoaW5zdGFuY2UpID0+IHtcbiAgICBpZiAobmV3UmVuZGVyKSB7XG4gICAgICBpbnN0YW5jZS5yZW5kZXIgPSBuZXdSZW5kZXI7XG4gICAgICBub3JtYWxpemVDbGFzc0NvbXBvbmVudChpbnN0YW5jZS50eXBlKS5yZW5kZXIgPSBuZXdSZW5kZXI7XG4gICAgfVxuICAgIGluc3RhbmNlLnJlbmRlckNhY2hlID0gW107XG4gICAgaXNIbXJVcGRhdGluZyA9IHRydWU7XG4gICAgaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgaXNIbXJVcGRhdGluZyA9IGZhbHNlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJlbG9hZChpZCwgbmV3Q29tcCkge1xuICBjb25zdCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcbiAgaWYgKCFyZWNvcmQpIHJldHVybjtcbiAgbmV3Q29tcCA9IG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KG5ld0NvbXApO1xuICB1cGRhdGVDb21wb25lbnREZWYocmVjb3JkLmluaXRpYWxEZWYsIG5ld0NvbXApO1xuICBjb25zdCBpbnN0YW5jZXMgPSBbLi4ucmVjb3JkLmluc3RhbmNlc107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaV07XG4gICAgY29uc3Qgb2xkQ29tcCA9IG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGluc3RhbmNlLnR5cGUpO1xuICAgIGxldCBkaXJ0eUluc3RhbmNlcyA9IGhtckRpcnR5Q29tcG9uZW50cy5nZXQob2xkQ29tcCk7XG4gICAgaWYgKCFkaXJ0eUluc3RhbmNlcykge1xuICAgICAgaWYgKG9sZENvbXAgIT09IHJlY29yZC5pbml0aWFsRGVmKSB7XG4gICAgICAgIHVwZGF0ZUNvbXBvbmVudERlZihvbGRDb21wLCBuZXdDb21wKTtcbiAgICAgIH1cbiAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5zZXQob2xkQ29tcCwgZGlydHlJbnN0YW5jZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICB9XG4gICAgZGlydHlJbnN0YW5jZXMuYWRkKGluc3RhbmNlKTtcbiAgICBpbnN0YW5jZS5hcHBDb250ZXh0LnByb3BzQ2FjaGUuZGVsZXRlKGluc3RhbmNlLnR5cGUpO1xuICAgIGluc3RhbmNlLmFwcENvbnRleHQuZW1pdHNDYWNoZS5kZWxldGUoaW5zdGFuY2UudHlwZSk7XG4gICAgaW5zdGFuY2UuYXBwQ29udGV4dC5vcHRpb25zQ2FjaGUuZGVsZXRlKGluc3RhbmNlLnR5cGUpO1xuICAgIGlmIChpbnN0YW5jZS5jZVJlbG9hZCkge1xuICAgICAgZGlydHlJbnN0YW5jZXMuYWRkKGluc3RhbmNlKTtcbiAgICAgIGluc3RhbmNlLmNlUmVsb2FkKG5ld0NvbXAuc3R5bGVzKTtcbiAgICAgIGRpcnR5SW5zdGFuY2VzLmRlbGV0ZShpbnN0YW5jZSk7XG4gICAgfSBlbHNlIGlmIChpbnN0YW5jZS5wYXJlbnQpIHtcbiAgICAgIHF1ZXVlSm9iKCgpID0+IHtcbiAgICAgICAgaXNIbXJVcGRhdGluZyA9IHRydWU7XG4gICAgICAgIGluc3RhbmNlLnBhcmVudC51cGRhdGUoKTtcbiAgICAgICAgaXNIbXJVcGRhdGluZyA9IGZhbHNlO1xuICAgICAgICBkaXJ0eUluc3RhbmNlcy5kZWxldGUoaW5zdGFuY2UpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpbnN0YW5jZS5hcHBDb250ZXh0LnJlbG9hZCkge1xuICAgICAgaW5zdGFuY2UuYXBwQ29udGV4dC5yZWxvYWQoKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIltITVJdIFJvb3Qgb3IgbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSBtb2RpZmllZC4gRnVsbCByZWxvYWQgcmVxdWlyZWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpbnN0YW5jZS5yb290LmNlICYmIGluc3RhbmNlICE9PSBpbnN0YW5jZS5yb290KSB7XG4gICAgICBpbnN0YW5jZS5yb290LmNlLl9yZW1vdmVDaGlsZFN0eWxlKG9sZENvbXApO1xuICAgIH1cbiAgfVxuICBxdWV1ZVBvc3RGbHVzaENiKCgpID0+IHtcbiAgICBobXJEaXJ0eUNvbXBvbmVudHMuY2xlYXIoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnREZWYob2xkQ29tcCwgbmV3Q29tcCkge1xuICBleHRlbmQob2xkQ29tcCwgbmV3Q29tcCk7XG4gIGZvciAoY29uc3Qga2V5IGluIG9sZENvbXApIHtcbiAgICBpZiAoa2V5ICE9PSBcIl9fZmlsZVwiICYmICEoa2V5IGluIG5ld0NvbXApKSB7XG4gICAgICBkZWxldGUgb2xkQ29tcFtrZXldO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdHJ5V3JhcChmbikge1xuICByZXR1cm4gKGlkLCBhcmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKGlkLCBhcmcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBbSE1SXSBTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgVnVlIGNvbXBvbmVudCBob3QtcmVsb2FkLiBGdWxsIHJlbG9hZCByZXF1aXJlZC5gXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cblxubGV0IGRldnRvb2xzJDE7XG5sZXQgYnVmZmVyID0gW107XG5sZXQgZGV2dG9vbHNOb3RJbnN0YWxsZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGVtaXQkMShldmVudCwgLi4uYXJncykge1xuICBpZiAoZGV2dG9vbHMkMSkge1xuICAgIGRldnRvb2xzJDEuZW1pdChldmVudCwgLi4uYXJncyk7XG4gIH0gZWxzZSBpZiAoIWRldnRvb2xzTm90SW5zdGFsbGVkKSB7XG4gICAgYnVmZmVyLnB1c2goeyBldmVudCwgYXJncyB9KTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0RGV2dG9vbHNIb29rJDEoaG9vaywgdGFyZ2V0KSB7XG4gIHZhciBfYSwgX2I7XG4gIGRldnRvb2xzJDEgPSBob29rO1xuICBpZiAoZGV2dG9vbHMkMSkge1xuICAgIGRldnRvb2xzJDEuZW5hYmxlZCA9IHRydWU7XG4gICAgYnVmZmVyLmZvckVhY2goKHsgZXZlbnQsIGFyZ3MgfSkgPT4gZGV2dG9vbHMkMS5lbWl0KGV2ZW50LCAuLi5hcmdzKSk7XG4gICAgYnVmZmVyID0gW107XG4gIH0gZWxzZSBpZiAoXG4gICAgLy8gaGFuZGxlIGxhdGUgZGV2dG9vbHMgaW5qZWN0aW9uIC0gb25seSBkbyB0aGlzIGlmIHdlIGFyZSBpbiBhbiBhY3R1YWxcbiAgICAvLyBicm93c2VyIGVudmlyb25tZW50IHRvIGF2b2lkIHRoZSB0aW1lciBoYW5kbGUgc3RhbGxpbmcgdGVzdCBydW5uZXIgZXhpdFxuICAgIC8vICgjNDgxNSlcbiAgICB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIC8vIHNvbWUgZW52cyBtb2NrIHdpbmRvdyBidXQgbm90IGZ1bGx5XG4gICAgd2luZG93LkhUTUxFbGVtZW50ICYmIC8vIGFsc28gZXhjbHVkZSBqc2RvbVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICEoKF9iID0gKF9hID0gd2luZG93Lm5hdmlnYXRvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnVzZXJBZ2VudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKFwianNkb21cIikpXG4gICkge1xuICAgIGNvbnN0IHJlcGxheSA9IHRhcmdldC5fX1ZVRV9ERVZUT09MU19IT09LX1JFUExBWV9fID0gdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gfHwgW107XG4gICAgcmVwbGF5LnB1c2goKG5ld0hvb2spID0+IHtcbiAgICAgIHNldERldnRvb2xzSG9vayQxKG5ld0hvb2ssIHRhcmdldCk7XG4gICAgfSk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoIWRldnRvb2xzJDEpIHtcbiAgICAgICAgdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gPSBudWxsO1xuICAgICAgICBkZXZ0b29sc05vdEluc3RhbGxlZCA9IHRydWU7XG4gICAgICAgIGJ1ZmZlciA9IFtdO1xuICAgICAgfVxuICAgIH0sIDNlMyk7XG4gIH0gZWxzZSB7XG4gICAgZGV2dG9vbHNOb3RJbnN0YWxsZWQgPSB0cnVlO1xuICAgIGJ1ZmZlciA9IFtdO1xuICB9XG59XG5mdW5jdGlvbiBkZXZ0b29sc0luaXRBcHAoYXBwLCB2ZXJzaW9uKSB7XG4gIGVtaXQkMShcImFwcDppbml0XCIgLyogQVBQX0lOSVQgKi8sIGFwcCwgdmVyc2lvbiwge1xuICAgIEZyYWdtZW50LFxuICAgIFRleHQsXG4gICAgQ29tbWVudCxcbiAgICBTdGF0aWNcbiAgfSk7XG59XG5mdW5jdGlvbiBkZXZ0b29sc1VubW91bnRBcHAoYXBwKSB7XG4gIGVtaXQkMShcImFwcDp1bm1vdW50XCIgLyogQVBQX1VOTU9VTlQgKi8sIGFwcCk7XG59XG5jb25zdCBkZXZ0b29sc0NvbXBvbmVudEFkZGVkID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcImNvbXBvbmVudDphZGRlZFwiIC8qIENPTVBPTkVOVF9BRERFRCAqLyk7XG5jb25zdCBkZXZ0b29sc0NvbXBvbmVudFVwZGF0ZWQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFwiY29tcG9uZW50OnVwZGF0ZWRcIiAvKiBDT01QT05FTlRfVVBEQVRFRCAqLyk7XG5jb25zdCBfZGV2dG9vbHNDb21wb25lbnRSZW1vdmVkID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcbiAgXCJjb21wb25lbnQ6cmVtb3ZlZFwiIC8qIENPTVBPTkVOVF9SRU1PVkVEICovXG4pO1xuY29uc3QgZGV2dG9vbHNDb21wb25lbnRSZW1vdmVkID0gKGNvbXBvbmVudCkgPT4ge1xuICBpZiAoZGV2dG9vbHMkMSAmJiB0eXBlb2YgZGV2dG9vbHMkMS5jbGVhbnVwQnVmZmVyID09PSBcImZ1bmN0aW9uXCIgJiYgLy8gcmVtb3ZlIHRoZSBjb21wb25lbnQgaWYgaXQgd2Fzbid0IGJ1ZmZlcmVkXG4gICFkZXZ0b29scyQxLmNsZWFudXBCdWZmZXIoY29tcG9uZW50KSkge1xuICAgIF9kZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQoY29tcG9uZW50KTtcbiAgfVxufTtcbi8qISAjX19OT19TSURFX0VGRkVDVFNfXyAqL1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhob29rKSB7XG4gIHJldHVybiAoY29tcG9uZW50KSA9PiB7XG4gICAgZW1pdCQxKFxuICAgICAgaG9vayxcbiAgICAgIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCxcbiAgICAgIGNvbXBvbmVudC51aWQsXG4gICAgICBjb21wb25lbnQucGFyZW50ID8gY29tcG9uZW50LnBhcmVudC51aWQgOiB2b2lkIDAsXG4gICAgICBjb21wb25lbnRcbiAgICApO1xuICB9O1xufVxuY29uc3QgZGV2dG9vbHNQZXJmU3RhcnQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGV2dG9vbHNQZXJmb3JtYW5jZUhvb2soXCJwZXJmOnN0YXJ0XCIgLyogUEVSRk9STUFOQ0VfU1RBUlQgKi8pO1xuY29uc3QgZGV2dG9vbHNQZXJmRW5kID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURldnRvb2xzUGVyZm9ybWFuY2VIb29rKFwicGVyZjplbmRcIiAvKiBQRVJGT1JNQU5DRV9FTkQgKi8pO1xuZnVuY3Rpb24gY3JlYXRlRGV2dG9vbHNQZXJmb3JtYW5jZUhvb2soaG9vaykge1xuICByZXR1cm4gKGNvbXBvbmVudCwgdHlwZSwgdGltZSkgPT4ge1xuICAgIGVtaXQkMShob29rLCBjb21wb25lbnQuYXBwQ29udGV4dC5hcHAsIGNvbXBvbmVudC51aWQsIGNvbXBvbmVudCwgdHlwZSwgdGltZSk7XG4gIH07XG59XG5mdW5jdGlvbiBkZXZ0b29sc0NvbXBvbmVudEVtaXQoY29tcG9uZW50LCBldmVudCwgcGFyYW1zKSB7XG4gIGVtaXQkMShcbiAgICBcImNvbXBvbmVudDplbWl0XCIgLyogQ09NUE9ORU5UX0VNSVQgKi8sXG4gICAgY29tcG9uZW50LmFwcENvbnRleHQuYXBwLFxuICAgIGNvbXBvbmVudCxcbiAgICBldmVudCxcbiAgICBwYXJhbXNcbiAgKTtcbn1cblxubGV0IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XG5sZXQgY3VycmVudFNjb3BlSWQgPSBudWxsO1xuZnVuY3Rpb24gc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGluc3RhbmNlKSB7XG4gIGNvbnN0IHByZXYgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG4gIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IGluc3RhbmNlO1xuICBjdXJyZW50U2NvcGVJZCA9IGluc3RhbmNlICYmIGluc3RhbmNlLnR5cGUuX19zY29wZUlkIHx8IG51bGw7XG4gIHJldHVybiBwcmV2O1xufVxuZnVuY3Rpb24gcHVzaFNjb3BlSWQoaWQpIHtcbiAgY3VycmVudFNjb3BlSWQgPSBpZDtcbn1cbmZ1bmN0aW9uIHBvcFNjb3BlSWQoKSB7XG4gIGN1cnJlbnRTY29wZUlkID0gbnVsbDtcbn1cbmNvbnN0IHdpdGhTY29wZUlkID0gKF9pZCkgPT4gd2l0aEN0eDtcbmZ1bmN0aW9uIHdpdGhDdHgoZm4sIGN0eCA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSwgaXNOb25TY29wZWRTbG90KSB7XG4gIGlmICghY3R4KSByZXR1cm4gZm47XG4gIGlmIChmbi5fbikge1xuICAgIHJldHVybiBmbjtcbiAgfVxuICBjb25zdCByZW5kZXJGbldpdGhDb250ZXh0ID0gKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAocmVuZGVyRm5XaXRoQ29udGV4dC5fZCkge1xuICAgICAgc2V0QmxvY2tUcmFja2luZygtMSk7XG4gICAgfVxuICAgIGNvbnN0IHByZXZJbnN0YW5jZSA9IHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShjdHgpO1xuICAgIGxldCByZXM7XG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IGZuKC4uLmFyZ3MpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UocHJldkluc3RhbmNlKTtcbiAgICAgIGlmIChyZW5kZXJGbldpdGhDb250ZXh0Ll9kKSB7XG4gICAgICAgIHNldEJsb2NrVHJhY2tpbmcoMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkKGN0eCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG4gIHJlbmRlckZuV2l0aENvbnRleHQuX24gPSB0cnVlO1xuICByZW5kZXJGbldpdGhDb250ZXh0Ll9jID0gdHJ1ZTtcbiAgcmVuZGVyRm5XaXRoQ29udGV4dC5fZCA9IHRydWU7XG4gIHJldHVybiByZW5kZXJGbldpdGhDb250ZXh0O1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZSkge1xuICBpZiAoaXNCdWlsdEluRGlyZWN0aXZlKG5hbWUpKSB7XG4gICAgd2FybiQxKFwiRG8gbm90IHVzZSBidWlsdC1pbiBkaXJlY3RpdmUgaWRzIGFzIGN1c3RvbSBkaXJlY3RpdmUgaWQ6IFwiICsgbmFtZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdpdGhEaXJlY3RpdmVzKHZub2RlLCBkaXJlY3RpdmVzKSB7XG4gIGlmIChjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShgd2l0aERpcmVjdGl2ZXMgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgcmVuZGVyIGZ1bmN0aW9ucy5gKTtcbiAgICByZXR1cm4gdm5vZGU7XG4gIH1cbiAgY29uc3QgaW5zdGFuY2UgPSBnZXRDb21wb25lbnRQdWJsaWNJbnN0YW5jZShjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpO1xuICBjb25zdCBiaW5kaW5ncyA9IHZub2RlLmRpcnMgfHwgKHZub2RlLmRpcnMgPSBbXSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGlyZWN0aXZlcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBbZGlyLCB2YWx1ZSwgYXJnLCBtb2RpZmllcnMgPSBFTVBUWV9PQkpdID0gZGlyZWN0aXZlc1tpXTtcbiAgICBpZiAoZGlyKSB7XG4gICAgICBpZiAoaXNGdW5jdGlvbihkaXIpKSB7XG4gICAgICAgIGRpciA9IHtcbiAgICAgICAgICBtb3VudGVkOiBkaXIsXG4gICAgICAgICAgdXBkYXRlZDogZGlyXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoZGlyLmRlZXApIHtcbiAgICAgICAgdHJhdmVyc2UodmFsdWUpO1xuICAgICAgfVxuICAgICAgYmluZGluZ3MucHVzaCh7XG4gICAgICAgIGRpcixcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBvbGRWYWx1ZTogdm9pZCAwLFxuICAgICAgICBhcmcsXG4gICAgICAgIG1vZGlmaWVyc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2bm9kZTtcbn1cbmZ1bmN0aW9uIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIHByZXZWTm9kZSwgaW5zdGFuY2UsIG5hbWUpIHtcbiAgY29uc3QgYmluZGluZ3MgPSB2bm9kZS5kaXJzO1xuICBjb25zdCBvbGRCaW5kaW5ncyA9IHByZXZWTm9kZSAmJiBwcmV2Vk5vZGUuZGlycztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5kaW5ncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGJpbmRpbmcgPSBiaW5kaW5nc1tpXTtcbiAgICBpZiAob2xkQmluZGluZ3MpIHtcbiAgICAgIGJpbmRpbmcub2xkVmFsdWUgPSBvbGRCaW5kaW5nc1tpXS52YWx1ZTtcbiAgICB9XG4gICAgbGV0IGhvb2sgPSBiaW5kaW5nLmRpcltuYW1lXTtcbiAgICBpZiAoaG9vaykge1xuICAgICAgcGF1c2VUcmFja2luZygpO1xuICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgaW5zdGFuY2UsIDgsIFtcbiAgICAgICAgdm5vZGUuZWwsXG4gICAgICAgIGJpbmRpbmcsXG4gICAgICAgIHZub2RlLFxuICAgICAgICBwcmV2Vk5vZGVcbiAgICAgIF0pO1xuICAgICAgcmVzZXRUcmFja2luZygpO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBUZWxlcG9ydEVuZEtleSA9IFN5bWJvbChcIl92dGVcIik7XG5jb25zdCBpc1RlbGVwb3J0ID0gKHR5cGUpID0+IHR5cGUuX19pc1RlbGVwb3J0O1xuY29uc3QgaXNUZWxlcG9ydERpc2FibGVkID0gKHByb3BzKSA9PiBwcm9wcyAmJiAocHJvcHMuZGlzYWJsZWQgfHwgcHJvcHMuZGlzYWJsZWQgPT09IFwiXCIpO1xuY29uc3QgaXNUZWxlcG9ydERlZmVycmVkID0gKHByb3BzKSA9PiBwcm9wcyAmJiAocHJvcHMuZGVmZXIgfHwgcHJvcHMuZGVmZXIgPT09IFwiXCIpO1xuY29uc3QgaXNUYXJnZXRTVkcgPSAodGFyZ2V0KSA9PiB0eXBlb2YgU1ZHRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0YXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50O1xuY29uc3QgaXNUYXJnZXRNYXRoTUwgPSAodGFyZ2V0KSA9PiB0eXBlb2YgTWF0aE1MRWxlbWVudCA9PT0gXCJmdW5jdGlvblwiICYmIHRhcmdldCBpbnN0YW5jZW9mIE1hdGhNTEVsZW1lbnQ7XG5jb25zdCByZXNvbHZlVGFyZ2V0ID0gKHByb3BzLCBzZWxlY3QpID0+IHtcbiAgY29uc3QgdGFyZ2V0U2VsZWN0b3IgPSBwcm9wcyAmJiBwcm9wcy50bztcbiAgaWYgKGlzU3RyaW5nKHRhcmdldFNlbGVjdG9yKSkge1xuICAgIGlmICghc2VsZWN0KSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShcbiAgICAgICAgYEN1cnJlbnQgcmVuZGVyZXIgZG9lcyBub3Qgc3VwcG9ydCBzdHJpbmcgdGFyZ2V0IGZvciBUZWxlcG9ydHMuIChtaXNzaW5nIHF1ZXJ5U2VsZWN0b3IgcmVuZGVyZXIgb3B0aW9uKWBcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gc2VsZWN0KHRhcmdldFNlbGVjdG9yKTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICF0YXJnZXQgJiYgIWlzVGVsZXBvcnREaXNhYmxlZChwcm9wcykpIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGBGYWlsZWQgdG8gbG9jYXRlIFRlbGVwb3J0IHRhcmdldCB3aXRoIHNlbGVjdG9yIFwiJHt0YXJnZXRTZWxlY3Rvcn1cIi4gTm90ZSB0aGUgdGFyZ2V0IGVsZW1lbnQgbXVzdCBleGlzdCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkIC0gaS5lLiB0aGUgdGFyZ2V0IGNhbm5vdCBiZSByZW5kZXJlZCBieSB0aGUgY29tcG9uZW50IGl0c2VsZiwgYW5kIGlkZWFsbHkgc2hvdWxkIGJlIG91dHNpZGUgb2YgdGhlIGVudGlyZSBWdWUgY29tcG9uZW50IHRyZWUuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIXRhcmdldFNlbGVjdG9yICYmICFpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpKSB7XG4gICAgICB3YXJuJDEoYEludmFsaWQgVGVsZXBvcnQgdGFyZ2V0OiAke3RhcmdldFNlbGVjdG9yfWApO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0U2VsZWN0b3I7XG4gIH1cbn07XG5jb25zdCBUZWxlcG9ydEltcGwgPSB7XG4gIG5hbWU6IFwiVGVsZXBvcnRcIixcbiAgX19pc1RlbGVwb3J0OiB0cnVlLFxuICBwcm9jZXNzKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIGludGVybmFscykge1xuICAgIGNvbnN0IHtcbiAgICAgIG1jOiBtb3VudENoaWxkcmVuLFxuICAgICAgcGM6IHBhdGNoQ2hpbGRyZW4sXG4gICAgICBwYmM6IHBhdGNoQmxvY2tDaGlsZHJlbixcbiAgICAgIG86IHsgaW5zZXJ0LCBxdWVyeVNlbGVjdG9yLCBjcmVhdGVUZXh0LCBjcmVhdGVDb21tZW50IH1cbiAgICB9ID0gaW50ZXJuYWxzO1xuICAgIGNvbnN0IGRpc2FibGVkID0gaXNUZWxlcG9ydERpc2FibGVkKG4yLnByb3BzKTtcbiAgICBsZXQgeyBzaGFwZUZsYWcsIGNoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4gfSA9IG4yO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSG1yVXBkYXRpbmcpIHtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gbjIuZWwgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gY3JlYXRlQ29tbWVudChcInRlbGVwb3J0IHN0YXJ0XCIpIDogY3JlYXRlVGV4dChcIlwiKTtcbiAgICAgIGNvbnN0IG1haW5BbmNob3IgPSBuMi5hbmNob3IgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gY3JlYXRlQ29tbWVudChcInRlbGVwb3J0IGVuZFwiKSA6IGNyZWF0ZVRleHQoXCJcIik7XG4gICAgICBpbnNlcnQocGxhY2Vob2xkZXIsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIGluc2VydChtYWluQW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICBjb25zdCBtb3VudCA9IChjb250YWluZXIyLCBhbmNob3IyKSA9PiB7XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgICAgIGlmIChwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LmlzQ0UpIHtcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudC5jZS5fdGVsZXBvcnRUYXJnZXQgPSBjb250YWluZXIyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb3VudENoaWxkcmVuKFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICBjb250YWluZXIyLFxuICAgICAgICAgICAgYW5jaG9yMixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG1vdW50VG9UYXJnZXQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG4yLnRhcmdldCA9IHJlc29sdmVUYXJnZXQobjIucHJvcHMsIHF1ZXJ5U2VsZWN0b3IpO1xuICAgICAgICBjb25zdCB0YXJnZXRBbmNob3IgPSBwcmVwYXJlQW5jaG9yKHRhcmdldCwgbjIsIGNyZWF0ZVRleHQsIGluc2VydCk7XG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICBpZiAobmFtZXNwYWNlICE9PSBcInN2Z1wiICYmIGlzVGFyZ2V0U1ZHKHRhcmdldCkpIHtcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IFwic3ZnXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChuYW1lc3BhY2UgIT09IFwibWF0aG1sXCIgJiYgaXNUYXJnZXRNYXRoTUwodGFyZ2V0KSkge1xuICAgICAgICAgICAgbmFtZXNwYWNlID0gXCJtYXRobWxcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgICAgICAgbW91bnQodGFyZ2V0LCB0YXJnZXRBbmNob3IpO1xuICAgICAgICAgICAgdXBkYXRlQ3NzVmFycyhuMiwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFkaXNhYmxlZCkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIFwiSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQgb24gbW91bnQ6XCIsXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBgKCR7dHlwZW9mIHRhcmdldH0pYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgbW91bnQoY29udGFpbmVyLCBtYWluQW5jaG9yKTtcbiAgICAgICAgdXBkYXRlQ3NzVmFycyhuMiwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNUZWxlcG9ydERlZmVycmVkKG4yLnByb3BzKSkge1xuICAgICAgICBuMi5lbC5fX2lzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgIG1vdW50VG9UYXJnZXQoKTtcbiAgICAgICAgICBkZWxldGUgbjIuZWwuX19pc01vdW50ZWQ7XG4gICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vdW50VG9UYXJnZXQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVGVsZXBvcnREZWZlcnJlZChuMi5wcm9wcykgJiYgbjEuZWwuX19pc01vdW50ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgVGVsZXBvcnRJbXBsLnByb2Nlc3MoXG4gICAgICAgICAgICBuMSxcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgICAgICBpbnRlcm5hbHNcbiAgICAgICAgICApO1xuICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG4yLmVsID0gbjEuZWw7XG4gICAgICBuMi50YXJnZXRTdGFydCA9IG4xLnRhcmdldFN0YXJ0O1xuICAgICAgY29uc3QgbWFpbkFuY2hvciA9IG4yLmFuY2hvciA9IG4xLmFuY2hvcjtcbiAgICAgIGNvbnN0IHRhcmdldCA9IG4yLnRhcmdldCA9IG4xLnRhcmdldDtcbiAgICAgIGNvbnN0IHRhcmdldEFuY2hvciA9IG4yLnRhcmdldEFuY2hvciA9IG4xLnRhcmdldEFuY2hvcjtcbiAgICAgIGNvbnN0IHdhc0Rpc2FibGVkID0gaXNUZWxlcG9ydERpc2FibGVkKG4xLnByb3BzKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRDb250YWluZXIgPSB3YXNEaXNhYmxlZCA/IGNvbnRhaW5lciA6IHRhcmdldDtcbiAgICAgIGNvbnN0IGN1cnJlbnRBbmNob3IgPSB3YXNEaXNhYmxlZCA/IG1haW5BbmNob3IgOiB0YXJnZXRBbmNob3I7XG4gICAgICBpZiAobmFtZXNwYWNlID09PSBcInN2Z1wiIHx8IGlzVGFyZ2V0U1ZHKHRhcmdldCkpIHtcbiAgICAgICAgbmFtZXNwYWNlID0gXCJzdmdcIjtcbiAgICAgIH0gZWxzZSBpZiAobmFtZXNwYWNlID09PSBcIm1hdGhtbFwiIHx8IGlzVGFyZ2V0TWF0aE1MKHRhcmdldCkpIHtcbiAgICAgICAgbmFtZXNwYWNlID0gXCJtYXRobWxcIjtcbiAgICAgIH1cbiAgICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgICAgcGF0Y2hCbG9ja0NoaWxkcmVuKFxuICAgICAgICAgIG4xLmR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4sXG4gICAgICAgICAgY3VycmVudENvbnRhaW5lcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkc1xuICAgICAgICApO1xuICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMiwgISEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpO1xuICAgICAgfSBlbHNlIGlmICghb3B0aW1pemVkKSB7XG4gICAgICAgIHBhdGNoQ2hpbGRyZW4oXG4gICAgICAgICAgbjEsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY3VycmVudENvbnRhaW5lcixcbiAgICAgICAgICBjdXJyZW50QW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgaWYgKCF3YXNEaXNhYmxlZCkge1xuICAgICAgICAgIG1vdmVUZWxlcG9ydChcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgbWFpbkFuY2hvcixcbiAgICAgICAgICAgIGludGVybmFscyxcbiAgICAgICAgICAgIDFcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChuMi5wcm9wcyAmJiBuMS5wcm9wcyAmJiBuMi5wcm9wcy50byAhPT0gbjEucHJvcHMudG8pIHtcbiAgICAgICAgICAgIG4yLnByb3BzLnRvID0gbjEucHJvcHMudG87XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKG4yLnByb3BzICYmIG4yLnByb3BzLnRvKSAhPT0gKG4xLnByb3BzICYmIG4xLnByb3BzLnRvKSkge1xuICAgICAgICAgIGNvbnN0IG5leHRUYXJnZXQgPSBuMi50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KFxuICAgICAgICAgICAgbjIucHJvcHMsXG4gICAgICAgICAgICBxdWVyeVNlbGVjdG9yXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAobmV4dFRhcmdldCkge1xuICAgICAgICAgICAgbW92ZVRlbGVwb3J0KFxuICAgICAgICAgICAgICBuMixcbiAgICAgICAgICAgICAgbmV4dFRhcmdldCxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgaW50ZXJuYWxzLFxuICAgICAgICAgICAgICAwXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgICBcIkludmFsaWQgVGVsZXBvcnQgdGFyZ2V0IG9uIHVwZGF0ZTpcIixcbiAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICBgKCR7dHlwZW9mIHRhcmdldH0pYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAod2FzRGlzYWJsZWQpIHtcbiAgICAgICAgICBtb3ZlVGVsZXBvcnQoXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIHRhcmdldEFuY2hvcixcbiAgICAgICAgICAgIGludGVybmFscyxcbiAgICAgICAgICAgIDFcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB1cGRhdGVDc3NWYXJzKG4yLCBkaXNhYmxlZCk7XG4gICAgfVxuICB9LFxuICByZW1vdmUodm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHsgdW06IHVubW91bnQsIG86IHsgcmVtb3ZlOiBob3N0UmVtb3ZlIH0gfSwgZG9SZW1vdmUpIHtcbiAgICBjb25zdCB7XG4gICAgICBzaGFwZUZsYWcsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGFuY2hvcixcbiAgICAgIHRhcmdldFN0YXJ0LFxuICAgICAgdGFyZ2V0QW5jaG9yLFxuICAgICAgdGFyZ2V0LFxuICAgICAgcHJvcHNcbiAgICB9ID0gdm5vZGU7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgaG9zdFJlbW92ZSh0YXJnZXRTdGFydCk7XG4gICAgICBob3N0UmVtb3ZlKHRhcmdldEFuY2hvcik7XG4gICAgfVxuICAgIGRvUmVtb3ZlICYmIGhvc3RSZW1vdmUoYW5jaG9yKTtcbiAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgIGNvbnN0IHNob3VsZFJlbW92ZSA9IGRvUmVtb3ZlIHx8ICFpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICB1bm1vdW50KFxuICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBzaG91bGRSZW1vdmUsXG4gICAgICAgICAgISFjaGlsZC5keW5hbWljQ2hpbGRyZW5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1vdmU6IG1vdmVUZWxlcG9ydCxcbiAgaHlkcmF0ZTogaHlkcmF0ZVRlbGVwb3J0XG59O1xuZnVuY3Rpb24gbW92ZVRlbGVwb3J0KHZub2RlLCBjb250YWluZXIsIHBhcmVudEFuY2hvciwgeyBvOiB7IGluc2VydCB9LCBtOiBtb3ZlIH0sIG1vdmVUeXBlID0gMikge1xuICBpZiAobW92ZVR5cGUgPT09IDApIHtcbiAgICBpbnNlcnQodm5vZGUudGFyZ2V0QW5jaG9yLCBjb250YWluZXIsIHBhcmVudEFuY2hvcik7XG4gIH1cbiAgY29uc3QgeyBlbCwgYW5jaG9yLCBzaGFwZUZsYWcsIGNoaWxkcmVuLCBwcm9wcyB9ID0gdm5vZGU7XG4gIGNvbnN0IGlzUmVvcmRlciA9IG1vdmVUeXBlID09PSAyO1xuICBpZiAoaXNSZW9yZGVyKSB7XG4gICAgaW5zZXJ0KGVsLCBjb250YWluZXIsIHBhcmVudEFuY2hvcik7XG4gIH1cbiAgaWYgKCFpc1Jlb3JkZXIgfHwgaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xuICAgIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBtb3ZlKFxuICAgICAgICAgIGNoaWxkcmVuW2ldLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBwYXJlbnRBbmNob3IsXG4gICAgICAgICAgMlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoaXNSZW9yZGVyKSB7XG4gICAgaW5zZXJ0KGFuY2hvciwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xuICB9XG59XG5mdW5jdGlvbiBoeWRyYXRlVGVsZXBvcnQobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCB7XG4gIG86IHsgbmV4dFNpYmxpbmcsIHBhcmVudE5vZGUsIHF1ZXJ5U2VsZWN0b3IsIGluc2VydCwgY3JlYXRlVGV4dCB9XG59LCBoeWRyYXRlQ2hpbGRyZW4pIHtcbiAgY29uc3QgdGFyZ2V0ID0gdm5vZGUudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChcbiAgICB2bm9kZS5wcm9wcyxcbiAgICBxdWVyeVNlbGVjdG9yXG4gICk7XG4gIGlmICh0YXJnZXQpIHtcbiAgICBjb25zdCBkaXNhYmxlZCA9IGlzVGVsZXBvcnREaXNhYmxlZCh2bm9kZS5wcm9wcyk7XG4gICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHRhcmdldC5fbHBhIHx8IHRhcmdldC5maXJzdENoaWxkO1xuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxNikge1xuICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgIHZub2RlLmFuY2hvciA9IGh5ZHJhdGVDaGlsZHJlbihcbiAgICAgICAgICBuZXh0U2libGluZyhub2RlKSxcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBwYXJlbnROb2RlKG5vZGUpLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIHZub2RlLnRhcmdldFN0YXJ0ID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgdm5vZGUudGFyZ2V0QW5jaG9yID0gdGFyZ2V0Tm9kZSAmJiBuZXh0U2libGluZyh0YXJnZXROb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlLmFuY2hvciA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICBsZXQgdGFyZ2V0QW5jaG9yID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgd2hpbGUgKHRhcmdldEFuY2hvcikge1xuICAgICAgICAgIGlmICh0YXJnZXRBbmNob3IgJiYgdGFyZ2V0QW5jaG9yLm5vZGVUeXBlID09PSA4KSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0QW5jaG9yLmRhdGEgPT09IFwidGVsZXBvcnQgc3RhcnQgYW5jaG9yXCIpIHtcbiAgICAgICAgICAgICAgdm5vZGUudGFyZ2V0U3RhcnQgPSB0YXJnZXRBbmNob3I7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldEFuY2hvci5kYXRhID09PSBcInRlbGVwb3J0IGFuY2hvclwiKSB7XG4gICAgICAgICAgICAgIHZub2RlLnRhcmdldEFuY2hvciA9IHRhcmdldEFuY2hvcjtcbiAgICAgICAgICAgICAgdGFyZ2V0Ll9scGEgPSB2bm9kZS50YXJnZXRBbmNob3IgJiYgbmV4dFNpYmxpbmcodm5vZGUudGFyZ2V0QW5jaG9yKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldEFuY2hvciA9IG5leHRTaWJsaW5nKHRhcmdldEFuY2hvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2bm9kZS50YXJnZXRBbmNob3IpIHtcbiAgICAgICAgICBwcmVwYXJlQW5jaG9yKHRhcmdldCwgdm5vZGUsIGNyZWF0ZVRleHQsIGluc2VydCk7XG4gICAgICAgIH1cbiAgICAgICAgaHlkcmF0ZUNoaWxkcmVuKFxuICAgICAgICAgIHRhcmdldE5vZGUgJiYgbmV4dFNpYmxpbmcodGFyZ2V0Tm9kZSksXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUNzc1ZhcnModm5vZGUsIGRpc2FibGVkKTtcbiAgfVxuICByZXR1cm4gdm5vZGUuYW5jaG9yICYmIG5leHRTaWJsaW5nKHZub2RlLmFuY2hvcik7XG59XG5jb25zdCBUZWxlcG9ydCA9IFRlbGVwb3J0SW1wbDtcbmZ1bmN0aW9uIHVwZGF0ZUNzc1ZhcnModm5vZGUsIGlzRGlzYWJsZWQpIHtcbiAgY29uc3QgY3R4ID0gdm5vZGUuY3R4O1xuICBpZiAoY3R4ICYmIGN0eC51dCkge1xuICAgIGxldCBub2RlLCBhbmNob3I7XG4gICAgaWYgKGlzRGlzYWJsZWQpIHtcbiAgICAgIG5vZGUgPSB2bm9kZS5lbDtcbiAgICAgIGFuY2hvciA9IHZub2RlLmFuY2hvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IHZub2RlLnRhcmdldFN0YXJ0O1xuICAgICAgYW5jaG9yID0gdm5vZGUudGFyZ2V0QW5jaG9yO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZSAmJiBub2RlICE9PSBhbmNob3IpIHtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxKSBub2RlLnNldEF0dHJpYnV0ZShcImRhdGEtdi1vd25lclwiLCBjdHgudWlkKTtcbiAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICBjdHgudXQoKTtcbiAgfVxufVxuZnVuY3Rpb24gcHJlcGFyZUFuY2hvcih0YXJnZXQsIHZub2RlLCBjcmVhdGVUZXh0LCBpbnNlcnQpIHtcbiAgY29uc3QgdGFyZ2V0U3RhcnQgPSB2bm9kZS50YXJnZXRTdGFydCA9IGNyZWF0ZVRleHQoXCJcIik7XG4gIGNvbnN0IHRhcmdldEFuY2hvciA9IHZub2RlLnRhcmdldEFuY2hvciA9IGNyZWF0ZVRleHQoXCJcIik7XG4gIHRhcmdldFN0YXJ0W1RlbGVwb3J0RW5kS2V5XSA9IHRhcmdldEFuY2hvcjtcbiAgaWYgKHRhcmdldCkge1xuICAgIGluc2VydCh0YXJnZXRTdGFydCwgdGFyZ2V0KTtcbiAgICBpbnNlcnQodGFyZ2V0QW5jaG9yLCB0YXJnZXQpO1xuICB9XG4gIHJldHVybiB0YXJnZXRBbmNob3I7XG59XG5cbmNvbnN0IGxlYXZlQ2JLZXkgPSBTeW1ib2woXCJfbGVhdmVDYlwiKTtcbmNvbnN0IGVudGVyQ2JLZXkgPSBTeW1ib2woXCJfZW50ZXJDYlwiKTtcbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb25TdGF0ZSgpIHtcbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgaXNNb3VudGVkOiBmYWxzZSxcbiAgICBpc0xlYXZpbmc6IGZhbHNlLFxuICAgIGlzVW5tb3VudGluZzogZmFsc2UsXG4gICAgbGVhdmluZ1ZOb2RlczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxuICB9O1xuICBvbk1vdW50ZWQoKCkgPT4ge1xuICAgIHN0YXRlLmlzTW91bnRlZCA9IHRydWU7XG4gIH0pO1xuICBvbkJlZm9yZVVubW91bnQoKCkgPT4ge1xuICAgIHN0YXRlLmlzVW5tb3VudGluZyA9IHRydWU7XG4gIH0pO1xuICByZXR1cm4gc3RhdGU7XG59XG5jb25zdCBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvciA9IFtGdW5jdGlvbiwgQXJyYXldO1xuY29uc3QgQmFzZVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSB7XG4gIG1vZGU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBwZXJzaXN0ZWQ6IEJvb2xlYW4sXG4gIC8vIGVudGVyXG4gIG9uQmVmb3JlRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25BZnRlckVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25FbnRlckNhbmNlbGxlZDogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIC8vIGxlYXZlXG4gIG9uQmVmb3JlTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25BZnRlckxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25MZWF2ZUNhbmNlbGxlZDogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIC8vIGFwcGVhclxuICBvbkJlZm9yZUFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25BZnRlckFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uQXBwZWFyQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvclxufTtcbmNvbnN0IHJlY3Vyc2l2ZUdldFN1YnRyZWUgPSAoaW5zdGFuY2UpID0+IHtcbiAgY29uc3Qgc3ViVHJlZSA9IGluc3RhbmNlLnN1YlRyZWU7XG4gIHJldHVybiBzdWJUcmVlLmNvbXBvbmVudCA/IHJlY3Vyc2l2ZUdldFN1YnRyZWUoc3ViVHJlZS5jb21wb25lbnQpIDogc3ViVHJlZTtcbn07XG5jb25zdCBCYXNlVHJhbnNpdGlvbkltcGwgPSB7XG4gIG5hbWU6IGBCYXNlVHJhbnNpdGlvbmAsXG4gIHByb3BzOiBCYXNlVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyxcbiAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgY29uc3Qgc3RhdGUgPSB1c2VUcmFuc2l0aW9uU3RhdGUoKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0ICYmIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihzbG90cy5kZWZhdWx0KCksIHRydWUpO1xuICAgICAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoaWxkID0gZmluZE5vbkNvbW1lbnRDaGlsZChjaGlsZHJlbik7XG4gICAgICBjb25zdCByYXdQcm9wcyA9IHRvUmF3KHByb3BzKTtcbiAgICAgIGNvbnN0IHsgbW9kZSB9ID0gcmF3UHJvcHM7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBtb2RlICYmIG1vZGUgIT09IFwiaW4tb3V0XCIgJiYgbW9kZSAhPT0gXCJvdXQtaW5cIiAmJiBtb2RlICE9PSBcImRlZmF1bHRcIikge1xuICAgICAgICB3YXJuJDEoYGludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICR7bW9kZX1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5pc0xlYXZpbmcpIHtcbiAgICAgICAgcmV0dXJuIGVtcHR5UGxhY2Vob2xkZXIoY2hpbGQpO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5uZXJDaGlsZCA9IGdldElubmVyQ2hpbGQkMShjaGlsZCk7XG4gICAgICBpZiAoIWlubmVyQ2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGVtcHR5UGxhY2Vob2xkZXIoY2hpbGQpO1xuICAgICAgfVxuICAgICAgbGV0IGVudGVySG9va3MgPSByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKFxuICAgICAgICBpbm5lckNoaWxkLFxuICAgICAgICByYXdQcm9wcyxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGluc3RhbmNlLFxuICAgICAgICAvLyAjMTEwNjEsIGVuc3VyZSBlbnRlckhvb2tzIGlzIGZyZXNoIGFmdGVyIGNsb25lXG4gICAgICAgIChob29rcykgPT4gZW50ZXJIb29rcyA9IGhvb2tzXG4gICAgICApO1xuICAgICAgaWYgKGlubmVyQ2hpbGQudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3MoaW5uZXJDaGlsZCwgZW50ZXJIb29rcyk7XG4gICAgICB9XG4gICAgICBsZXQgb2xkSW5uZXJDaGlsZCA9IGluc3RhbmNlLnN1YlRyZWUgJiYgZ2V0SW5uZXJDaGlsZCQxKGluc3RhbmNlLnN1YlRyZWUpO1xuICAgICAgaWYgKG9sZElubmVyQ2hpbGQgJiYgb2xkSW5uZXJDaGlsZC50eXBlICE9PSBDb21tZW50ICYmICFpc1NhbWVWTm9kZVR5cGUoaW5uZXJDaGlsZCwgb2xkSW5uZXJDaGlsZCkgJiYgcmVjdXJzaXZlR2V0U3VidHJlZShpbnN0YW5jZSkudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICBsZXQgbGVhdmluZ0hvb2tzID0gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhcbiAgICAgICAgICBvbGRJbm5lckNoaWxkLFxuICAgICAgICAgIHJhd1Byb3BzLFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICk7XG4gICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhvbGRJbm5lckNoaWxkLCBsZWF2aW5nSG9va3MpO1xuICAgICAgICBpZiAobW9kZSA9PT0gXCJvdXQtaW5cIiAmJiBpbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgICAgICBzdGF0ZS5pc0xlYXZpbmcgPSB0cnVlO1xuICAgICAgICAgIGxlYXZpbmdIb29rcy5hZnRlckxlYXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgc3RhdGUuaXNMZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIShpbnN0YW5jZS5qb2IuZmxhZ3MgJiA4KSkge1xuICAgICAgICAgICAgICBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBsZWF2aW5nSG9va3MuYWZ0ZXJMZWF2ZTtcbiAgICAgICAgICAgIG9sZElubmVyQ2hpbGQgPSB2b2lkIDA7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gXCJpbi1vdXRcIiAmJiBpbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgICAgICBsZWF2aW5nSG9va3MuZGVsYXlMZWF2ZSA9IChlbCwgZWFybHlSZW1vdmUsIGRlbGF5ZWRMZWF2ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShcbiAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgIG9sZElubmVyQ2hpbGRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZWF2aW5nVk5vZGVzQ2FjaGVbU3RyaW5nKG9sZElubmVyQ2hpbGQua2V5KV0gPSBvbGRJbm5lckNoaWxkO1xuICAgICAgICAgICAgZWxbbGVhdmVDYktleV0gPSAoKSA9PiB7XG4gICAgICAgICAgICAgIGVhcmx5UmVtb3ZlKCk7XG4gICAgICAgICAgICAgIGVsW2xlYXZlQ2JLZXldID0gdm9pZCAwO1xuICAgICAgICAgICAgICBkZWxldGUgZW50ZXJIb29rcy5kZWxheWVkTGVhdmU7XG4gICAgICAgICAgICAgIG9sZElubmVyQ2hpbGQgPSB2b2lkIDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZW50ZXJIb29rcy5kZWxheWVkTGVhdmUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIGRlbGF5ZWRMZWF2ZSgpO1xuICAgICAgICAgICAgICBkZWxldGUgZW50ZXJIb29rcy5kZWxheWVkTGVhdmU7XG4gICAgICAgICAgICAgIG9sZElubmVyQ2hpbGQgPSB2b2lkIDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2xkSW5uZXJDaGlsZCA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvbGRJbm5lckNoaWxkKSB7XG4gICAgICAgIG9sZElubmVyQ2hpbGQgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIGZpbmROb25Db21tZW50Q2hpbGQoY2hpbGRyZW4pIHtcbiAgbGV0IGNoaWxkID0gY2hpbGRyZW5bMF07XG4gIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgbGV0IGhhc0ZvdW5kID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBjIG9mIGNoaWxkcmVuKSB7XG4gICAgICBpZiAoYy50eXBlICE9PSBDb21tZW50KSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGhhc0ZvdW5kKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgXCI8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50IG9yIGNvbXBvbmVudC4gVXNlIDx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkID0gYztcbiAgICAgICAgaGFzRm91bmQgPSB0cnVlO1xuICAgICAgICBpZiAoISEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGQ7XG59XG5jb25zdCBCYXNlVHJhbnNpdGlvbiA9IEJhc2VUcmFuc2l0aW9uSW1wbDtcbmZ1bmN0aW9uIGdldExlYXZpbmdOb2Rlc0ZvclR5cGUoc3RhdGUsIHZub2RlKSB7XG4gIGNvbnN0IHsgbGVhdmluZ1ZOb2RlcyB9ID0gc3RhdGU7XG4gIGxldCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBsZWF2aW5nVk5vZGVzLmdldCh2bm9kZS50eXBlKTtcbiAgaWYgKCFsZWF2aW5nVk5vZGVzQ2FjaGUpIHtcbiAgICBsZWF2aW5nVk5vZGVzQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZWF2aW5nVk5vZGVzLnNldCh2bm9kZS50eXBlLCBsZWF2aW5nVk5vZGVzQ2FjaGUpO1xuICB9XG4gIHJldHVybiBsZWF2aW5nVk5vZGVzQ2FjaGU7XG59XG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKHZub2RlLCBwcm9wcywgc3RhdGUsIGluc3RhbmNlLCBwb3N0Q2xvbmUpIHtcbiAgY29uc3Qge1xuICAgIGFwcGVhcixcbiAgICBtb2RlLFxuICAgIHBlcnNpc3RlZCA9IGZhbHNlLFxuICAgIG9uQmVmb3JlRW50ZXIsXG4gICAgb25FbnRlcixcbiAgICBvbkFmdGVyRW50ZXIsXG4gICAgb25FbnRlckNhbmNlbGxlZCxcbiAgICBvbkJlZm9yZUxlYXZlLFxuICAgIG9uTGVhdmUsXG4gICAgb25BZnRlckxlYXZlLFxuICAgIG9uTGVhdmVDYW5jZWxsZWQsXG4gICAgb25CZWZvcmVBcHBlYXIsXG4gICAgb25BcHBlYXIsXG4gICAgb25BZnRlckFwcGVhcixcbiAgICBvbkFwcGVhckNhbmNlbGxlZFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGtleSA9IFN0cmluZyh2bm9kZS5rZXkpO1xuICBjb25zdCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCB2bm9kZSk7XG4gIGNvbnN0IGNhbGxIb29rID0gKGhvb2ssIGFyZ3MpID0+IHtcbiAgICBob29rICYmIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgICAgaG9vayxcbiAgICAgIGluc3RhbmNlLFxuICAgICAgOSxcbiAgICAgIGFyZ3NcbiAgICApO1xuICB9O1xuICBjb25zdCBjYWxsQXN5bmNIb29rID0gKGhvb2ssIGFyZ3MpID0+IHtcbiAgICBjb25zdCBkb25lID0gYXJnc1sxXTtcbiAgICBjYWxsSG9vayhob29rLCBhcmdzKTtcbiAgICBpZiAoaXNBcnJheShob29rKSkge1xuICAgICAgaWYgKGhvb2suZXZlcnkoKGhvb2syKSA9PiBob29rMi5sZW5ndGggPD0gMSkpIGRvbmUoKTtcbiAgICB9IGVsc2UgaWYgKGhvb2subGVuZ3RoIDw9IDEpIHtcbiAgICAgIGRvbmUoKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGhvb2tzID0ge1xuICAgIG1vZGUsXG4gICAgcGVyc2lzdGVkLFxuICAgIGJlZm9yZUVudGVyKGVsKSB7XG4gICAgICBsZXQgaG9vayA9IG9uQmVmb3JlRW50ZXI7XG4gICAgICBpZiAoIXN0YXRlLmlzTW91bnRlZCkge1xuICAgICAgICBpZiAoYXBwZWFyKSB7XG4gICAgICAgICAgaG9vayA9IG9uQmVmb3JlQXBwZWFyIHx8IG9uQmVmb3JlRW50ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZWxbbGVhdmVDYktleV0pIHtcbiAgICAgICAgZWxbbGVhdmVDYktleV0oXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICAgIC8qIGNhbmNlbGxlZCAqL1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgbGVhdmluZ1ZOb2RlID0gbGVhdmluZ1ZOb2Rlc0NhY2hlW2tleV07XG4gICAgICBpZiAobGVhdmluZ1ZOb2RlICYmIGlzU2FtZVZOb2RlVHlwZSh2bm9kZSwgbGVhdmluZ1ZOb2RlKSAmJiBsZWF2aW5nVk5vZGUuZWxbbGVhdmVDYktleV0pIHtcbiAgICAgICAgbGVhdmluZ1ZOb2RlLmVsW2xlYXZlQ2JLZXldKCk7XG4gICAgICB9XG4gICAgICBjYWxsSG9vayhob29rLCBbZWxdKTtcbiAgICB9LFxuICAgIGVudGVyKGVsKSB7XG4gICAgICBsZXQgaG9vayA9IG9uRW50ZXI7XG4gICAgICBsZXQgYWZ0ZXJIb29rID0gb25BZnRlckVudGVyO1xuICAgICAgbGV0IGNhbmNlbEhvb2sgPSBvbkVudGVyQ2FuY2VsbGVkO1xuICAgICAgaWYgKCFzdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgICAgaWYgKGFwcGVhcikge1xuICAgICAgICAgIGhvb2sgPSBvbkFwcGVhciB8fCBvbkVudGVyO1xuICAgICAgICAgIGFmdGVySG9vayA9IG9uQWZ0ZXJBcHBlYXIgfHwgb25BZnRlckVudGVyO1xuICAgICAgICAgIGNhbmNlbEhvb2sgPSBvbkFwcGVhckNhbmNlbGxlZCB8fCBvbkVudGVyQ2FuY2VsbGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICAgICAgY29uc3QgZG9uZSA9IGVsW2VudGVyQ2JLZXldID0gKGNhbmNlbGxlZCkgPT4ge1xuICAgICAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICBjYWxsSG9vayhjYW5jZWxIb29rLCBbZWxdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsSG9vayhhZnRlckhvb2ssIFtlbF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob29rcy5kZWxheWVkTGVhdmUpIHtcbiAgICAgICAgICBob29rcy5kZWxheWVkTGVhdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbFtlbnRlckNiS2V5XSA9IHZvaWQgMDtcbiAgICAgIH07XG4gICAgICBpZiAoaG9vaykge1xuICAgICAgICBjYWxsQXN5bmNIb29rKGhvb2ssIFtlbCwgZG9uZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbGVhdmUoZWwsIHJlbW92ZSkge1xuICAgICAgY29uc3Qga2V5MiA9IFN0cmluZyh2bm9kZS5rZXkpO1xuICAgICAgaWYgKGVsW2VudGVyQ2JLZXldKSB7XG4gICAgICAgIGVsW2VudGVyQ2JLZXldKFxuICAgICAgICAgIHRydWVcbiAgICAgICAgICAvKiBjYW5jZWxsZWQgKi9cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5pc1VubW91bnRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgY2FsbEhvb2sob25CZWZvcmVMZWF2ZSwgW2VsXSk7XG4gICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgICBjb25zdCBkb25lID0gZWxbbGVhdmVDYktleV0gPSAoY2FuY2VsbGVkKSA9PiB7XG4gICAgICAgIGlmIChjYWxsZWQpIHJldHVybjtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgcmVtb3ZlKCk7XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICBjYWxsSG9vayhvbkxlYXZlQ2FuY2VsbGVkLCBbZWxdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsSG9vayhvbkFmdGVyTGVhdmUsIFtlbF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsW2xlYXZlQ2JLZXldID0gdm9pZCAwO1xuICAgICAgICBpZiAobGVhdmluZ1ZOb2Rlc0NhY2hlW2tleTJdID09PSB2bm9kZSkge1xuICAgICAgICAgIGRlbGV0ZSBsZWF2aW5nVk5vZGVzQ2FjaGVba2V5Ml07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBsZWF2aW5nVk5vZGVzQ2FjaGVba2V5Ml0gPSB2bm9kZTtcbiAgICAgIGlmIChvbkxlYXZlKSB7XG4gICAgICAgIGNhbGxBc3luY0hvb2sob25MZWF2ZSwgW2VsLCBkb25lXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb25lKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbG9uZSh2bm9kZTIpIHtcbiAgICAgIGNvbnN0IGhvb2tzMiA9IHJlc29sdmVUcmFuc2l0aW9uSG9va3MoXG4gICAgICAgIHZub2RlMixcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgcG9zdENsb25lXG4gICAgICApO1xuICAgICAgaWYgKHBvc3RDbG9uZSkgcG9zdENsb25lKGhvb2tzMik7XG4gICAgICByZXR1cm4gaG9va3MyO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGhvb2tzO1xufVxuZnVuY3Rpb24gZW1wdHlQbGFjZWhvbGRlcih2bm9kZSkge1xuICBpZiAoaXNLZWVwQWxpdmUodm5vZGUpKSB7XG4gICAgdm5vZGUgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICB2bm9kZS5jaGlsZHJlbiA9IG51bGw7XG4gICAgcmV0dXJuIHZub2RlO1xuICB9XG59XG5mdW5jdGlvbiBnZXRJbm5lckNoaWxkJDEodm5vZGUpIHtcbiAgaWYgKCFpc0tlZXBBbGl2ZSh2bm9kZSkpIHtcbiAgICBpZiAoaXNUZWxlcG9ydCh2bm9kZS50eXBlKSAmJiB2bm9kZS5jaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGZpbmROb25Db21tZW50Q2hpbGQodm5vZGUuY2hpbGRyZW4pO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGU7XG4gIH1cbiAgaWYgKHZub2RlLmNvbXBvbmVudCkge1xuICAgIHJldHVybiB2bm9kZS5jb21wb25lbnQuc3ViVHJlZTtcbiAgfVxuICBjb25zdCB7IHNoYXBlRmxhZywgY2hpbGRyZW4gfSA9IHZub2RlO1xuICBpZiAoY2hpbGRyZW4pIHtcbiAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlblswXTtcbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDMyICYmIGlzRnVuY3Rpb24oY2hpbGRyZW4uZGVmYXVsdCkpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbi5kZWZhdWx0KCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRUcmFuc2l0aW9uSG9va3Modm5vZGUsIGhvb2tzKSB7XG4gIGlmICh2bm9kZS5zaGFwZUZsYWcgJiA2ICYmIHZub2RlLmNvbXBvbmVudCkge1xuICAgIHZub2RlLnRyYW5zaXRpb24gPSBob29rcztcbiAgICBzZXRUcmFuc2l0aW9uSG9va3Modm5vZGUuY29tcG9uZW50LnN1YlRyZWUsIGhvb2tzKTtcbiAgfSBlbHNlIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxMjgpIHtcbiAgICB2bm9kZS5zc0NvbnRlbnQudHJhbnNpdGlvbiA9IGhvb2tzLmNsb25lKHZub2RlLnNzQ29udGVudCk7XG4gICAgdm5vZGUuc3NGYWxsYmFjay50cmFuc2l0aW9uID0gaG9va3MuY2xvbmUodm5vZGUuc3NGYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgdm5vZGUudHJhbnNpdGlvbiA9IGhvb2tzO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oY2hpbGRyZW4sIGtlZXBDb21tZW50ID0gZmFsc2UsIHBhcmVudEtleSkge1xuICBsZXQgcmV0ID0gW107XG4gIGxldCBrZXllZEZyYWdtZW50Q291bnQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgY29uc3Qga2V5ID0gcGFyZW50S2V5ID09IG51bGwgPyBjaGlsZC5rZXkgOiBTdHJpbmcocGFyZW50S2V5KSArIFN0cmluZyhjaGlsZC5rZXkgIT0gbnVsbCA/IGNoaWxkLmtleSA6IGkpO1xuICAgIGlmIChjaGlsZC50eXBlID09PSBGcmFnbWVudCkge1xuICAgICAgaWYgKGNoaWxkLnBhdGNoRmxhZyAmIDEyOCkga2V5ZWRGcmFnbWVudENvdW50Kys7XG4gICAgICByZXQgPSByZXQuY29uY2F0KFxuICAgICAgICBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oY2hpbGQuY2hpbGRyZW4sIGtlZXBDb21tZW50LCBrZXkpXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoa2VlcENvbW1lbnQgfHwgY2hpbGQudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgcmV0LnB1c2goa2V5ICE9IG51bGwgPyBjbG9uZVZOb2RlKGNoaWxkLCB7IGtleSB9KSA6IGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgaWYgKGtleWVkRnJhZ21lbnRDb3VudCA+IDEpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJldC5sZW5ndGg7IGkrKykge1xuICAgICAgcmV0W2ldLnBhdGNoRmxhZyA9IC0yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKiEgI19fTk9fU0lERV9FRkZFQ1RTX18gKi9cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBkZWZpbmVDb21wb25lbnQob3B0aW9ucywgZXh0cmFPcHRpb25zKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKG9wdGlvbnMpID8gKFxuICAgIC8vICM4MjM2OiBleHRlbmQgY2FsbCBhbmQgb3B0aW9ucy5uYW1lIGFjY2VzcyBhcmUgY29uc2lkZXJlZCBzaWRlLWVmZmVjdHNcbiAgICAvLyBieSBSb2xsdXAsIHNvIHdlIGhhdmUgdG8gd3JhcCBpdCBpbiBhIHB1cmUtYW5ub3RhdGVkIElJRkUuXG4gICAgLyogQF9fUFVSRV9fICovICgoKSA9PiBleHRlbmQoeyBuYW1lOiBvcHRpb25zLm5hbWUgfSwgZXh0cmFPcHRpb25zLCB7IHNldHVwOiBvcHRpb25zIH0pKSgpXG4gICkgOiBvcHRpb25zO1xufVxuXG5mdW5jdGlvbiB1c2VJZCgpIHtcbiAgY29uc3QgaSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBpZiAoaSkge1xuICAgIHJldHVybiAoaS5hcHBDb250ZXh0LmNvbmZpZy5pZFByZWZpeCB8fCBcInZcIikgKyBcIi1cIiArIGkuaWRzWzBdICsgaS5pZHNbMV0rKztcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FybiQxKFxuICAgICAgYHVzZUlkKCkgaXMgY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZSB0byBiZSBhc3NvY2lhdGVkIHdpdGguYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIFwiXCI7XG59XG5mdW5jdGlvbiBtYXJrQXN5bmNCb3VuZGFyeShpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5pZHMgPSBbaW5zdGFuY2UuaWRzWzBdICsgaW5zdGFuY2UuaWRzWzJdKysgKyBcIi1cIiwgMCwgMF07XG59XG5cbmNvbnN0IGtub3duVGVtcGxhdGVSZWZzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG5mdW5jdGlvbiB1c2VUZW1wbGF0ZVJlZihrZXkpIHtcbiAgY29uc3QgaSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBjb25zdCByID0gc2hhbGxvd1JlZihudWxsKTtcbiAgaWYgKGkpIHtcbiAgICBjb25zdCByZWZzID0gaS5yZWZzID09PSBFTVBUWV9PQkogPyBpLnJlZnMgPSB7fSA6IGkucmVmcztcbiAgICBsZXQgZGVzYztcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAoZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocmVmcywga2V5KSkgJiYgIWRlc2MuY29uZmlndXJhYmxlKSB7XG4gICAgICB3YXJuJDEoYHVzZVRlbXBsYXRlUmVmKCcke2tleX0nKSBhbHJlYWR5IGV4aXN0cy5gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlZnMsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IHIudmFsdWUsXG4gICAgICAgIHNldDogKHZhbCkgPT4gci52YWx1ZSA9IHZhbFxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgdXNlVGVtcGxhdGVSZWYoKSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlIHRvIGJlIGFzc29jaWF0ZWQgd2l0aC5gXG4gICAgKTtcbiAgfVxuICBjb25zdCByZXQgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gcmVhZG9ubHkocikgOiByO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGtub3duVGVtcGxhdGVSZWZzLmFkZChyZXQpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHNldFJlZihyYXdSZWYsIG9sZFJhd1JlZiwgcGFyZW50U3VzcGVuc2UsIHZub2RlLCBpc1VubW91bnQgPSBmYWxzZSkge1xuICBpZiAoaXNBcnJheShyYXdSZWYpKSB7XG4gICAgcmF3UmVmLmZvckVhY2goXG4gICAgICAociwgaSkgPT4gc2V0UmVmKFxuICAgICAgICByLFxuICAgICAgICBvbGRSYXdSZWYgJiYgKGlzQXJyYXkob2xkUmF3UmVmKSA/IG9sZFJhd1JlZltpXSA6IG9sZFJhd1JlZiksXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgaXNVbm1vdW50XG4gICAgICApXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGlzQXN5bmNXcmFwcGVyKHZub2RlKSAmJiAhaXNVbm1vdW50KSB7XG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDUxMiAmJiB2bm9kZS50eXBlLl9fYXN5bmNSZXNvbHZlZCAmJiB2bm9kZS5jb21wb25lbnQuc3ViVHJlZS5jb21wb25lbnQpIHtcbiAgICAgIHNldFJlZihyYXdSZWYsIG9sZFJhd1JlZiwgcGFyZW50U3VzcGVuc2UsIHZub2RlLmNvbXBvbmVudC5zdWJUcmVlKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJlZlZhbHVlID0gdm5vZGUuc2hhcGVGbGFnICYgNCA/IGdldENvbXBvbmVudFB1YmxpY0luc3RhbmNlKHZub2RlLmNvbXBvbmVudCkgOiB2bm9kZS5lbDtcbiAgY29uc3QgdmFsdWUgPSBpc1VubW91bnQgPyBudWxsIDogcmVmVmFsdWU7XG4gIGNvbnN0IHsgaTogb3duZXIsIHI6IHJlZiB9ID0gcmF3UmVmO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhb3duZXIpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgTWlzc2luZyByZWYgb3duZXIgY29udGV4dC4gcmVmIGNhbm5vdCBiZSB1c2VkIG9uIGhvaXN0ZWQgdm5vZGVzLiBBIHZub2RlIHdpdGggcmVmIG11c3QgYmUgY3JlYXRlZCBpbnNpZGUgdGhlIHJlbmRlciBmdW5jdGlvbi5gXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb2xkUmVmID0gb2xkUmF3UmVmICYmIG9sZFJhd1JlZi5yO1xuICBjb25zdCByZWZzID0gb3duZXIucmVmcyA9PT0gRU1QVFlfT0JKID8gb3duZXIucmVmcyA9IHt9IDogb3duZXIucmVmcztcbiAgY29uc3Qgc2V0dXBTdGF0ZSA9IG93bmVyLnNldHVwU3RhdGU7XG4gIGNvbnN0IHJhd1NldHVwU3RhdGUgPSB0b1JhdyhzZXR1cFN0YXRlKTtcbiAgY29uc3QgY2FuU2V0U2V0dXBSZWYgPSBzZXR1cFN0YXRlID09PSBFTVBUWV9PQkogPyAoKSA9PiBmYWxzZSA6IChrZXkpID0+IHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgaWYgKGhhc093bihyYXdTZXR1cFN0YXRlLCBrZXkpICYmICFpc1JlZihyYXdTZXR1cFN0YXRlW2tleV0pKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBgVGVtcGxhdGUgcmVmIFwiJHtrZXl9XCIgdXNlZCBvbiBhIG5vbi1yZWYgdmFsdWUuIEl0IHdpbGwgbm90IHdvcmsgaW4gdGhlIHByb2R1Y3Rpb24gYnVpbGQuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGtub3duVGVtcGxhdGVSZWZzLmhhcyhyYXdTZXR1cFN0YXRlW2tleV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhhc093bihyYXdTZXR1cFN0YXRlLCBrZXkpO1xuICB9O1xuICBpZiAob2xkUmVmICE9IG51bGwgJiYgb2xkUmVmICE9PSByZWYpIHtcbiAgICBpZiAoaXNTdHJpbmcob2xkUmVmKSkge1xuICAgICAgcmVmc1tvbGRSZWZdID0gbnVsbDtcbiAgICAgIGlmIChjYW5TZXRTZXR1cFJlZihvbGRSZWYpKSB7XG4gICAgICAgIHNldHVwU3RhdGVbb2xkUmVmXSA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1JlZihvbGRSZWYpKSB7XG4gICAgICBvbGRSZWYudmFsdWUgPSBudWxsO1xuICAgIH1cbiAgfVxuICBpZiAoaXNGdW5jdGlvbihyZWYpKSB7XG4gICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKHJlZiwgb3duZXIsIDEyLCBbdmFsdWUsIHJlZnNdKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBfaXNTdHJpbmcgPSBpc1N0cmluZyhyZWYpO1xuICAgIGNvbnN0IF9pc1JlZiA9IGlzUmVmKHJlZik7XG4gICAgaWYgKF9pc1N0cmluZyB8fCBfaXNSZWYpIHtcbiAgICAgIGNvbnN0IGRvU2V0ID0gKCkgPT4ge1xuICAgICAgICBpZiAocmF3UmVmLmYpIHtcbiAgICAgICAgICBjb25zdCBleGlzdGluZyA9IF9pc1N0cmluZyA/IGNhblNldFNldHVwUmVmKHJlZikgPyBzZXR1cFN0YXRlW3JlZl0gOiByZWZzW3JlZl0gOiByZWYudmFsdWU7XG4gICAgICAgICAgaWYgKGlzVW5tb3VudCkge1xuICAgICAgICAgICAgaXNBcnJheShleGlzdGluZykgJiYgcmVtb3ZlKGV4aXN0aW5nLCByZWZWYWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaXNBcnJheShleGlzdGluZykpIHtcbiAgICAgICAgICAgICAgaWYgKF9pc1N0cmluZykge1xuICAgICAgICAgICAgICAgIHJlZnNbcmVmXSA9IFtyZWZWYWx1ZV07XG4gICAgICAgICAgICAgICAgaWYgKGNhblNldFNldHVwUmVmKHJlZikpIHtcbiAgICAgICAgICAgICAgICAgIHNldHVwU3RhdGVbcmVmXSA9IHJlZnNbcmVmXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVmLnZhbHVlID0gW3JlZlZhbHVlXTtcbiAgICAgICAgICAgICAgICBpZiAocmF3UmVmLmspIHJlZnNbcmF3UmVmLmtdID0gcmVmLnZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFleGlzdGluZy5pbmNsdWRlcyhyZWZWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgZXhpc3RpbmcucHVzaChyZWZWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKF9pc1N0cmluZykge1xuICAgICAgICAgIHJlZnNbcmVmXSA9IHZhbHVlO1xuICAgICAgICAgIGlmIChjYW5TZXRTZXR1cFJlZihyZWYpKSB7XG4gICAgICAgICAgICBzZXR1cFN0YXRlW3JlZl0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoX2lzUmVmKSB7XG4gICAgICAgICAgcmVmLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgaWYgKHJhd1JlZi5rKSByZWZzW3Jhd1JlZi5rXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuJDEoXCJJbnZhbGlkIHRlbXBsYXRlIHJlZiB0eXBlOlwiLCByZWYsIGAoJHt0eXBlb2YgcmVmfSlgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBkb1NldC5pZCA9IC0xO1xuICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoZG9TZXQsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvU2V0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuJDEoXCJJbnZhbGlkIHRlbXBsYXRlIHJlZiB0eXBlOlwiLCByZWYsIGAoJHt0eXBlb2YgcmVmfSlgKTtcbiAgICB9XG4gIH1cbn1cblxubGV0IGhhc0xvZ2dlZE1pc21hdGNoRXJyb3IgPSBmYWxzZTtcbmNvbnN0IGxvZ01pc21hdGNoRXJyb3IgPSAoKSA9PiB7XG4gIGlmIChoYXNMb2dnZWRNaXNtYXRjaEVycm9yKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUuZXJyb3IoXCJIeWRyYXRpb24gY29tcGxldGVkIGJ1dCBjb250YWlucyBtaXNtYXRjaGVzLlwiKTtcbiAgaGFzTG9nZ2VkTWlzbWF0Y2hFcnJvciA9IHRydWU7XG59O1xuY29uc3QgaXNTVkdDb250YWluZXIgPSAoY29udGFpbmVyKSA9PiBjb250YWluZXIubmFtZXNwYWNlVVJJLmluY2x1ZGVzKFwic3ZnXCIpICYmIGNvbnRhaW5lci50YWdOYW1lICE9PSBcImZvcmVpZ25PYmplY3RcIjtcbmNvbnN0IGlzTWF0aE1MQ29udGFpbmVyID0gKGNvbnRhaW5lcikgPT4gY29udGFpbmVyLm5hbWVzcGFjZVVSSS5pbmNsdWRlcyhcIk1hdGhNTFwiKTtcbmNvbnN0IGdldENvbnRhaW5lclR5cGUgPSAoY29udGFpbmVyKSA9PiB7XG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgIT09IDEpIHJldHVybiB2b2lkIDA7XG4gIGlmIChpc1NWR0NvbnRhaW5lcihjb250YWluZXIpKSByZXR1cm4gXCJzdmdcIjtcbiAgaWYgKGlzTWF0aE1MQ29udGFpbmVyKGNvbnRhaW5lcikpIHJldHVybiBcIm1hdGhtbFwiO1xuICByZXR1cm4gdm9pZCAwO1xufTtcbmNvbnN0IGlzQ29tbWVudCA9IChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSA4O1xuZnVuY3Rpb24gY3JlYXRlSHlkcmF0aW9uRnVuY3Rpb25zKHJlbmRlcmVySW50ZXJuYWxzKSB7XG4gIGNvbnN0IHtcbiAgICBtdDogbW91bnRDb21wb25lbnQsXG4gICAgcDogcGF0Y2gsXG4gICAgbzoge1xuICAgICAgcGF0Y2hQcm9wLFxuICAgICAgY3JlYXRlVGV4dCxcbiAgICAgIG5leHRTaWJsaW5nLFxuICAgICAgcGFyZW50Tm9kZSxcbiAgICAgIHJlbW92ZSxcbiAgICAgIGluc2VydCxcbiAgICAgIGNyZWF0ZUNvbW1lbnRcbiAgICB9XG4gIH0gPSByZW5kZXJlckludGVybmFscztcbiAgY29uc3QgaHlkcmF0ZSA9ICh2bm9kZSwgY29udGFpbmVyKSA9PiB7XG4gICAgaWYgKCFjb250YWluZXIuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pICYmIHdhcm4kMShcbiAgICAgICAgYEF0dGVtcHRpbmcgdG8gaHlkcmF0ZSBleGlzdGluZyBtYXJrdXAgYnV0IGNvbnRhaW5lciBpcyBlbXB0eS4gUGVyZm9ybWluZyBmdWxsIG1vdW50IGluc3RlYWQuYFxuICAgICAgKTtcbiAgICAgIHBhdGNoKG51bGwsIHZub2RlLCBjb250YWluZXIpO1xuICAgICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcbiAgICAgIGNvbnRhaW5lci5fdm5vZGUgPSB2bm9kZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaHlkcmF0ZU5vZGUoY29udGFpbmVyLmZpcnN0Q2hpbGQsIHZub2RlLCBudWxsLCBudWxsLCBudWxsKTtcbiAgICBmbHVzaFBvc3RGbHVzaENicygpO1xuICAgIGNvbnRhaW5lci5fdm5vZGUgPSB2bm9kZTtcbiAgfTtcbiAgY29uc3QgaHlkcmF0ZU5vZGUgPSAobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcbiAgICBvcHRpbWl6ZWQgPSBvcHRpbWl6ZWQgfHwgISF2bm9kZS5keW5hbWljQ2hpbGRyZW47XG4gICAgY29uc3QgaXNGcmFnbWVudFN0YXJ0ID0gaXNDb21tZW50KG5vZGUpICYmIG5vZGUuZGF0YSA9PT0gXCJbXCI7XG4gICAgY29uc3Qgb25NaXNtYXRjaCA9ICgpID0+IGhhbmRsZU1pc21hdGNoKFxuICAgICAgbm9kZSxcbiAgICAgIHZub2RlLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICBzbG90U2NvcGVJZHMsXG4gICAgICBpc0ZyYWdtZW50U3RhcnRcbiAgICApO1xuICAgIGNvbnN0IHsgdHlwZSwgcmVmLCBzaGFwZUZsYWcsIHBhdGNoRmxhZyB9ID0gdm5vZGU7XG4gICAgbGV0IGRvbVR5cGUgPSBub2RlLm5vZGVUeXBlO1xuICAgIHZub2RlLmVsID0gbm9kZTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGRlZihub2RlLCBcIl9fdm5vZGVcIiwgdm5vZGUsIHRydWUpO1xuICAgICAgZGVmKG5vZGUsIFwiX192dWVQYXJlbnRDb21wb25lbnRcIiwgcGFyZW50Q29tcG9uZW50LCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKHBhdGNoRmxhZyA9PT0gLTIpIHtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICB9XG4gICAgbGV0IG5leHROb2RlID0gbnVsbDtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgVGV4dDpcbiAgICAgICAgaWYgKGRvbVR5cGUgIT09IDMpIHtcbiAgICAgICAgICBpZiAodm5vZGUuY2hpbGRyZW4gPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGluc2VydCh2bm9kZS5lbCA9IGNyZWF0ZVRleHQoXCJcIiksIHBhcmVudE5vZGUobm9kZSksIG5vZGUpO1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBub2RlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG5vZGUuZGF0YSAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgd2FybiQxKFxuICAgICAgICAgICAgICBgSHlkcmF0aW9uIHRleHQgbWlzbWF0Y2ggaW5gLFxuICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgIGBcbiAgLSByZW5kZXJlZCBvbiBzZXJ2ZXI6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhXG4gICAgICAgICAgICAgICl9XG4gIC0gZXhwZWN0ZWQgb24gY2xpZW50OiAke0pTT04uc3RyaW5naWZ5KHZub2RlLmNoaWxkcmVuKX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbG9nTWlzbWF0Y2hFcnJvcigpO1xuICAgICAgICAgICAgbm9kZS5kYXRhID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENvbW1lbnQ6XG4gICAgICAgIGlmIChpc1RlbXBsYXRlTm9kZShub2RlKSkge1xuICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgcmVwbGFjZU5vZGUoXG4gICAgICAgICAgICB2bm9kZS5lbCA9IG5vZGUuY29udGVudC5maXJzdENoaWxkLFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoZG9tVHlwZSAhPT0gOCB8fCBpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdGF0aWM6XG4gICAgICAgIGlmIChpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICBub2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgZG9tVHlwZSA9IG5vZGUubm9kZVR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvbVR5cGUgPT09IDEgfHwgZG9tVHlwZSA9PT0gMykge1xuICAgICAgICAgIG5leHROb2RlID0gbm9kZTtcbiAgICAgICAgICBjb25zdCBuZWVkVG9BZG9wdENvbnRlbnQgPSAhdm5vZGUuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdm5vZGUuc3RhdGljQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKG5lZWRUb0Fkb3B0Q29udGVudClcbiAgICAgICAgICAgICAgdm5vZGUuY2hpbGRyZW4gKz0gbmV4dE5vZGUubm9kZVR5cGUgPT09IDEgPyBuZXh0Tm9kZS5vdXRlckhUTUwgOiBuZXh0Tm9kZS5kYXRhO1xuICAgICAgICAgICAgaWYgKGkgPT09IHZub2RlLnN0YXRpY0NvdW50IC0gMSkge1xuICAgICAgICAgICAgICB2bm9kZS5hbmNob3IgPSBuZXh0Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobmV4dE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaXNGcmFnbWVudFN0YXJ0ID8gbmV4dFNpYmxpbmcobmV4dE5vZGUpIDogbmV4dE5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25NaXNtYXRjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGcmFnbWVudDpcbiAgICAgICAgaWYgKCFpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IGh5ZHJhdGVGcmFnbWVudChcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxKSB7XG4gICAgICAgICAgaWYgKChkb21UeXBlICE9PSAxIHx8IHZub2RlLnR5cGUudG9Mb3dlckNhc2UoKSAhPT0gbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpICYmICFpc1RlbXBsYXRlTm9kZShub2RlKSkge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gaHlkcmF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgIHZub2RlLFxuICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgNikge1xuICAgICAgICAgIHZub2RlLnNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkcztcbiAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xuICAgICAgICAgIGlmIChpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gbG9jYXRlQ2xvc2luZ0FuY2hvcihub2RlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzQ29tbWVudChub2RlKSAmJiBub2RlLmRhdGEgPT09IFwidGVsZXBvcnQgc3RhcnRcIikge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBsb2NhdGVDbG9zaW5nQW5jaG9yKG5vZGUsIG5vZGUuZGF0YSwgXCJ0ZWxlcG9ydCBlbmRcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1vdW50Q29tcG9uZW50KFxuICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBnZXRDb250YWluZXJUeXBlKGNvbnRhaW5lciksXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChpc0FzeW5jV3JhcHBlcih2bm9kZSkgJiYgIXZub2RlLnR5cGUuX19hc3luY1Jlc29sdmVkKSB7XG4gICAgICAgICAgICBsZXQgc3ViVHJlZTtcbiAgICAgICAgICAgIGlmIChpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICAgICAgc3ViVHJlZSA9IGNyZWF0ZVZOb2RlKEZyYWdtZW50KTtcbiAgICAgICAgICAgICAgc3ViVHJlZS5hbmNob3IgPSBuZXh0Tm9kZSA/IG5leHROb2RlLnByZXZpb3VzU2libGluZyA6IGNvbnRhaW5lci5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdWJUcmVlID0gbm9kZS5ub2RlVHlwZSA9PT0gMyA/IGNyZWF0ZVRleHRWTm9kZShcIlwiKSA6IGNyZWF0ZVZOb2RlKFwiZGl2XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3ViVHJlZS5lbCA9IG5vZGU7XG4gICAgICAgICAgICB2bm9kZS5jb21wb25lbnQuc3ViVHJlZSA9IHN1YlRyZWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDY0KSB7XG4gICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDgpIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IHZub2RlLnR5cGUuaHlkcmF0ZShcbiAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICAgICAgICByZW5kZXJlckludGVybmFscyxcbiAgICAgICAgICAgICAgaHlkcmF0ZUNoaWxkcmVuXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IHZub2RlLnR5cGUuaHlkcmF0ZShcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgZ2V0Q29udGFpbmVyVHlwZShwYXJlbnROb2RlKG5vZGUpKSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgICAgIHJlbmRlcmVySW50ZXJuYWxzLFxuICAgICAgICAgICAgaHlkcmF0ZU5vZGVcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fKSB7XG4gICAgICAgICAgd2FybiQxKFwiSW52YWxpZCBIb3N0Vk5vZGUgdHlwZTpcIiwgdHlwZSwgYCgke3R5cGVvZiB0eXBlfSlgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVmICE9IG51bGwpIHtcbiAgICAgIHNldFJlZihyZWYsIG51bGwsIHBhcmVudFN1c3BlbnNlLCB2bm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0Tm9kZTtcbiAgfTtcbiAgY29uc3QgaHlkcmF0ZUVsZW1lbnQgPSAoZWwsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIG9wdGltaXplZCA9IG9wdGltaXplZCB8fCAhIXZub2RlLmR5bmFtaWNDaGlsZHJlbjtcbiAgICBjb25zdCB7IHR5cGUsIHByb3BzLCBwYXRjaEZsYWcsIHNoYXBlRmxhZywgZGlycywgdHJhbnNpdGlvbiB9ID0gdm5vZGU7XG4gICAgY29uc3QgZm9yY2VQYXRjaCA9IHR5cGUgPT09IFwiaW5wdXRcIiB8fCB0eXBlID09PSBcIm9wdGlvblwiO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IGZvcmNlUGF0Y2ggfHwgcGF0Y2hGbGFnICE9PSAtMSkge1xuICAgICAgaWYgKGRpcnMpIHtcbiAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcImNyZWF0ZWRcIik7XG4gICAgICB9XG4gICAgICBsZXQgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgPSBmYWxzZTtcbiAgICAgIGlmIChpc1RlbXBsYXRlTm9kZShlbCkpIHtcbiAgICAgICAgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgPSBuZWVkVHJhbnNpdGlvbihcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIC8vIG5vIG5lZWQgY2hlY2sgcGFyZW50U3VzcGVuc2UgaW4gaHlkcmF0aW9uXG4gICAgICAgICAgdHJhbnNpdGlvblxuICAgICAgICApICYmIHBhcmVudENvbXBvbmVudCAmJiBwYXJlbnRDb21wb25lbnQudm5vZGUucHJvcHMgJiYgcGFyZW50Q29tcG9uZW50LnZub2RlLnByb3BzLmFwcGVhcjtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGVsLmNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzKSB7XG4gICAgICAgICAgY29uc3QgY2xzID0gY29udGVudC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICAgICAgICBpZiAoY2xzKSBjb250ZW50LiRjbHMgPSBjbHM7XG4gICAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXBsYWNlTm9kZShjb250ZW50LCBlbCwgcGFyZW50Q29tcG9uZW50KTtcbiAgICAgICAgdm5vZGUuZWwgPSBlbCA9IGNvbnRlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoc2hhcGVGbGFnICYgMTYgJiYgLy8gc2tpcCBpZiBlbGVtZW50IGhhcyBpbm5lckhUTUwgLyB0ZXh0Q29udGVudFxuICAgICAgIShwcm9wcyAmJiAocHJvcHMuaW5uZXJIVE1MIHx8IHByb3BzLnRleHRDb250ZW50KSkpIHtcbiAgICAgICAgbGV0IG5leHQgPSBoeWRyYXRlQ2hpbGRyZW4oXG4gICAgICAgICAgZWwuZmlyc3RDaGlsZCxcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBlbCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBsZXQgaGFzV2FybmVkID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChuZXh0KSB7XG4gICAgICAgICAgaWYgKCFpc01pc21hdGNoQWxsb3dlZChlbCwgMSAvKiBDSElMRFJFTiAqLykpIHtcbiAgICAgICAgICAgIGlmICgoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pICYmICFoYXNXYXJuZWQpIHtcbiAgICAgICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgICAgIGBIeWRyYXRpb24gY2hpbGRyZW4gbWlzbWF0Y2ggb25gLFxuICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgIGBcblNlcnZlciByZW5kZXJlZCBlbGVtZW50IGNvbnRhaW5zIG1vcmUgY2hpbGQgbm9kZXMgdGhhbiBjbGllbnQgdmRvbS5gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dNaXNtYXRjaEVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGN1ciA9IG5leHQ7XG4gICAgICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgcmVtb3ZlKGN1cik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgOCkge1xuICAgICAgICBsZXQgY2xpZW50VGV4dCA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgICBpZiAoY2xpZW50VGV4dFswXSA9PT0gXCJcXG5cIiAmJiAoZWwudGFnTmFtZSA9PT0gXCJQUkVcIiB8fCBlbC50YWdOYW1lID09PSBcIlRFWFRBUkVBXCIpKSB7XG4gICAgICAgICAgY2xpZW50VGV4dCA9IGNsaWVudFRleHQuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsLnRleHRDb250ZW50ICE9PSBjbGllbnRUZXh0KSB7XG4gICAgICAgICAgaWYgKCFpc01pc21hdGNoQWxsb3dlZChlbCwgMCAvKiBURVhUICovKSkge1xuICAgICAgICAgICAgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fKSAmJiB3YXJuJDEoXG4gICAgICAgICAgICAgIGBIeWRyYXRpb24gdGV4dCBjb250ZW50IG1pc21hdGNoIG9uYCxcbiAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgIGBcbiAgLSByZW5kZXJlZCBvbiBzZXJ2ZXI6ICR7ZWwudGV4dENvbnRlbnR9XG4gIC0gZXhwZWN0ZWQgb24gY2xpZW50OiAke3Zub2RlLmNoaWxkcmVufWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsb2dNaXNtYXRjaEVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsLnRleHRDb250ZW50ID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcykge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18gfHwgZm9yY2VQYXRjaCB8fCAhb3B0aW1pemVkIHx8IHBhdGNoRmxhZyAmICgxNiB8IDMyKSkge1xuICAgICAgICAgIGNvbnN0IGlzQ3VzdG9tRWxlbWVudCA9IGVsLnRhZ05hbWUuaW5jbHVkZXMoXCItXCIpO1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgICAgICBpZiAoKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fKSAmJiAvLyAjMTExODkgc2tpcCBpZiB0aGlzIG5vZGUgaGFzIGRpcmVjdGl2ZXMgdGhhdCBoYXZlIGNyZWF0ZWQgaG9va3NcbiAgICAgICAgICAgIC8vIGFzIGl0IGNvdWxkIGhhdmUgbXV0YXRlZCB0aGUgRE9NIGluIGFueSBwb3NzaWJsZSB3YXlcbiAgICAgICAgICAgICEoZGlycyAmJiBkaXJzLnNvbWUoKGQpID0+IGQuZGlyLmNyZWF0ZWQpKSAmJiBwcm9wSGFzTWlzbWF0Y2goZWwsIGtleSwgcHJvcHNba2V5XSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgbG9nTWlzbWF0Y2hFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcmNlUGF0Y2ggJiYgKGtleS5lbmRzV2l0aChcInZhbHVlXCIpIHx8IGtleSA9PT0gXCJpbmRldGVybWluYXRlXCIpIHx8IGlzT24oa2V5KSAmJiAhaXNSZXNlcnZlZFByb3Aoa2V5KSB8fCAvLyBmb3JjZSBoeWRyYXRlIHYtYmluZCB3aXRoIC5wcm9wIG1vZGlmaWVyc1xuICAgICAgICAgICAga2V5WzBdID09PSBcIi5cIiB8fCBpc0N1c3RvbUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgcGF0Y2hQcm9wKGVsLCBrZXksIG51bGwsIHByb3BzW2tleV0sIHZvaWQgMCwgcGFyZW50Q29tcG9uZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcHMub25DbGljaykge1xuICAgICAgICAgIHBhdGNoUHJvcChcbiAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgXCJvbkNsaWNrXCIsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcHJvcHMub25DbGljayxcbiAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAocGF0Y2hGbGFnICYgNCAmJiBpc1JlYWN0aXZlKHByb3BzLnN0eWxlKSkge1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzLnN0eWxlKSBwcm9wcy5zdHlsZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgdm5vZGVIb29rcztcbiAgICAgIGlmICh2bm9kZUhvb2tzID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSB7XG4gICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2tzLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICAgIH1cbiAgICAgIGlmIChkaXJzKSB7XG4gICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJiZWZvcmVNb3VudFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICgodm5vZGVIb29rcyA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSB8fCBkaXJzIHx8IG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzKSB7XG4gICAgICAgIHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlKCgpID0+IHtcbiAgICAgICAgICB2bm9kZUhvb2tzICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2tzLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICAgICAgICBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyAmJiB0cmFuc2l0aW9uLmVudGVyKGVsKTtcbiAgICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJtb3VudGVkXCIpO1xuICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbC5uZXh0U2libGluZztcbiAgfTtcbiAgY29uc3QgaHlkcmF0ZUNoaWxkcmVuID0gKG5vZGUsIHBhcmVudFZOb2RlLCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgb3B0aW1pemVkID0gb3B0aW1pemVkIHx8ICEhcGFyZW50Vk5vZGUuZHluYW1pY0NoaWxkcmVuO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50Vk5vZGUuY2hpbGRyZW47XG4gICAgY29uc3QgbCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBsZXQgaGFzV2FybmVkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IHZub2RlID0gb3B0aW1pemVkID8gY2hpbGRyZW5baV0gOiBjaGlsZHJlbltpXSA9IG5vcm1hbGl6ZVZOb2RlKGNoaWxkcmVuW2ldKTtcbiAgICAgIGNvbnN0IGlzVGV4dCA9IHZub2RlLnR5cGUgPT09IFRleHQ7XG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICBpZiAoaXNUZXh0ICYmICFvcHRpbWl6ZWQpIHtcbiAgICAgICAgICBpZiAoaSArIDEgPCBsICYmIG5vcm1hbGl6ZVZOb2RlKGNoaWxkcmVuW2kgKyAxXSkudHlwZSA9PT0gVGV4dCkge1xuICAgICAgICAgICAgaW5zZXJ0KFxuICAgICAgICAgICAgICBjcmVhdGVUZXh0KFxuICAgICAgICAgICAgICAgIG5vZGUuZGF0YS5zbGljZSh2bm9kZS5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgICAgbmV4dFNpYmxpbmcobm9kZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBub2RlLmRhdGEgPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IGh5ZHJhdGVOb2RlKFxuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNUZXh0ICYmICF2bm9kZS5jaGlsZHJlbikge1xuICAgICAgICBpbnNlcnQodm5vZGUuZWwgPSBjcmVhdGVUZXh0KFwiXCIpLCBjb250YWluZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFpc01pc21hdGNoQWxsb3dlZChjb250YWluZXIsIDEgLyogQ0hJTERSRU4gKi8pKSB7XG4gICAgICAgICAgaWYgKCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgIWhhc1dhcm5lZCkge1xuICAgICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgICBgSHlkcmF0aW9uIGNoaWxkcmVuIG1pc21hdGNoIG9uYCxcbiAgICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgICBgXG5TZXJ2ZXIgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBmZXdlciBjaGlsZCBub2RlcyB0aGFuIGNsaWVudCB2ZG9tLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2dNaXNtYXRjaEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgZ2V0Q29udGFpbmVyVHlwZShjb250YWluZXIpLFxuICAgICAgICAgIHNsb3RTY29wZUlkc1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcbiAgY29uc3QgaHlkcmF0ZUZyYWdtZW50ID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IHsgc2xvdFNjb3BlSWRzOiBmcmFnbWVudFNsb3RTY29wZUlkcyB9ID0gdm5vZGU7XG4gICAgaWYgKGZyYWdtZW50U2xvdFNjb3BlSWRzKSB7XG4gICAgICBzbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHMgPyBzbG90U2NvcGVJZHMuY29uY2F0KGZyYWdtZW50U2xvdFNjb3BlSWRzKSA6IGZyYWdtZW50U2xvdFNjb3BlSWRzO1xuICAgIH1cbiAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xuICAgIGNvbnN0IG5leHQgPSBoeWRyYXRlQ2hpbGRyZW4oXG4gICAgICBuZXh0U2libGluZyhub2RlKSxcbiAgICAgIHZub2RlLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICBzbG90U2NvcGVJZHMsXG4gICAgICBvcHRpbWl6ZWRcbiAgICApO1xuICAgIGlmIChuZXh0ICYmIGlzQ29tbWVudChuZXh0KSAmJiBuZXh0LmRhdGEgPT09IFwiXVwiKSB7XG4gICAgICByZXR1cm4gbmV4dFNpYmxpbmcodm5vZGUuYW5jaG9yID0gbmV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ01pc21hdGNoRXJyb3IoKTtcbiAgICAgIGluc2VydCh2bm9kZS5hbmNob3IgPSBjcmVhdGVDb21tZW50KGBdYCksIGNvbnRhaW5lciwgbmV4dCk7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGhhbmRsZU1pc21hdGNoID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIGlzRnJhZ21lbnQpID0+IHtcbiAgICBpZiAoIWlzTWlzbWF0Y2hBbGxvd2VkKG5vZGUucGFyZW50RWxlbWVudCwgMSAvKiBDSElMRFJFTiAqLykpIHtcbiAgICAgICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgd2FybiQxKFxuICAgICAgICBgSHlkcmF0aW9uIG5vZGUgbWlzbWF0Y2g6XG4tIHJlbmRlcmVkIG9uIHNlcnZlcjpgLFxuICAgICAgICBub2RlLFxuICAgICAgICBub2RlLm5vZGVUeXBlID09PSAzID8gYCh0ZXh0KWAgOiBpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSBcIltcIiA/IGAoc3RhcnQgb2YgZnJhZ21lbnQpYCA6IGBgLFxuICAgICAgICBgXG4tIGV4cGVjdGVkIG9uIGNsaWVudDpgLFxuICAgICAgICB2bm9kZS50eXBlXG4gICAgICApO1xuICAgICAgbG9nTWlzbWF0Y2hFcnJvcigpO1xuICAgIH1cbiAgICB2bm9kZS5lbCA9IG51bGw7XG4gICAgaWYgKGlzRnJhZ21lbnQpIHtcbiAgICAgIGNvbnN0IGVuZCA9IGxvY2F0ZUNsb3NpbmdBbmNob3Iobm9kZSk7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCBuZXh0MiA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICBpZiAobmV4dDIgJiYgbmV4dDIgIT09IGVuZCkge1xuICAgICAgICAgIHJlbW92ZShuZXh0Mik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbmV4dCA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudE5vZGUobm9kZSk7XG4gICAgcmVtb3ZlKG5vZGUpO1xuICAgIHBhdGNoKFxuICAgICAgbnVsbCxcbiAgICAgIHZub2RlLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgbmV4dCxcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgZ2V0Q29udGFpbmVyVHlwZShjb250YWluZXIpLFxuICAgICAgc2xvdFNjb3BlSWRzXG4gICAgKTtcbiAgICBpZiAocGFyZW50Q29tcG9uZW50KSB7XG4gICAgICBwYXJlbnRDb21wb25lbnQudm5vZGUuZWwgPSB2bm9kZS5lbDtcbiAgICAgIHVwZGF0ZUhPQ0hvc3RFbChwYXJlbnRDb21wb25lbnQsIHZub2RlLmVsKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQ7XG4gIH07XG4gIGNvbnN0IGxvY2F0ZUNsb3NpbmdBbmNob3IgPSAobm9kZSwgb3BlbiA9IFwiW1wiLCBjbG9zZSA9IFwiXVwiKSA9PiB7XG4gICAgbGV0IG1hdGNoID0gMDtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgbm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgaWYgKG5vZGUgJiYgaXNDb21tZW50KG5vZGUpKSB7XG4gICAgICAgIGlmIChub2RlLmRhdGEgPT09IG9wZW4pIG1hdGNoKys7XG4gICAgICAgIGlmIChub2RlLmRhdGEgPT09IGNsb3NlKSB7XG4gICAgICAgICAgaWYgKG1hdGNoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9O1xuICBjb25zdCByZXBsYWNlTm9kZSA9IChuZXdOb2RlLCBvbGROb2RlLCBwYXJlbnRDb21wb25lbnQpID0+IHtcbiAgICBjb25zdCBwYXJlbnROb2RlMiA9IG9sZE5vZGUucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50Tm9kZTIpIHtcbiAgICAgIHBhcmVudE5vZGUyLnJlcGxhY2VDaGlsZChuZXdOb2RlLCBvbGROb2RlKTtcbiAgICB9XG4gICAgbGV0IHBhcmVudCA9IHBhcmVudENvbXBvbmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LnZub2RlLmVsID09PSBvbGROb2RlKSB7XG4gICAgICAgIHBhcmVudC52bm9kZS5lbCA9IHBhcmVudC5zdWJUcmVlLmVsID0gbmV3Tm9kZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICB9O1xuICBjb25zdCBpc1RlbXBsYXRlTm9kZSA9IChub2RlKSA9PiB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgbm9kZS50YWdOYW1lID09PSBcIlRFTVBMQVRFXCI7XG4gIH07XG4gIHJldHVybiBbaHlkcmF0ZSwgaHlkcmF0ZU5vZGVdO1xufVxuZnVuY3Rpb24gcHJvcEhhc01pc21hdGNoKGVsLCBrZXksIGNsaWVudFZhbHVlLCB2bm9kZSwgaW5zdGFuY2UpIHtcbiAgbGV0IG1pc21hdGNoVHlwZTtcbiAgbGV0IG1pc21hdGNoS2V5O1xuICBsZXQgYWN0dWFsO1xuICBsZXQgZXhwZWN0ZWQ7XG4gIGlmIChrZXkgPT09IFwiY2xhc3NcIikge1xuICAgIGlmIChlbC4kY2xzKSB7XG4gICAgICBhY3R1YWwgPSBlbC4kY2xzO1xuICAgICAgZGVsZXRlIGVsLiRjbHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjdHVhbCA9IGVsLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpO1xuICAgIH1cbiAgICBleHBlY3RlZCA9IG5vcm1hbGl6ZUNsYXNzKGNsaWVudFZhbHVlKTtcbiAgICBpZiAoIWlzU2V0RXF1YWwodG9DbGFzc1NldChhY3R1YWwgfHwgXCJcIiksIHRvQ2xhc3NTZXQoZXhwZWN0ZWQpKSkge1xuICAgICAgbWlzbWF0Y2hUeXBlID0gMiAvKiBDTEFTUyAqLztcbiAgICAgIG1pc21hdGNoS2V5ID0gYGNsYXNzYDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoa2V5ID09PSBcInN0eWxlXCIpIHtcbiAgICBhY3R1YWwgPSBlbC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSB8fCBcIlwiO1xuICAgIGV4cGVjdGVkID0gaXNTdHJpbmcoY2xpZW50VmFsdWUpID8gY2xpZW50VmFsdWUgOiBzdHJpbmdpZnlTdHlsZShub3JtYWxpemVTdHlsZShjbGllbnRWYWx1ZSkpO1xuICAgIGNvbnN0IGFjdHVhbE1hcCA9IHRvU3R5bGVNYXAoYWN0dWFsKTtcbiAgICBjb25zdCBleHBlY3RlZE1hcCA9IHRvU3R5bGVNYXAoZXhwZWN0ZWQpO1xuICAgIGlmICh2bm9kZS5kaXJzKSB7XG4gICAgICBmb3IgKGNvbnN0IHsgZGlyLCB2YWx1ZSB9IG9mIHZub2RlLmRpcnMpIHtcbiAgICAgICAgaWYgKGRpci5uYW1lID09PSBcInNob3dcIiAmJiAhdmFsdWUpIHtcbiAgICAgICAgICBleHBlY3RlZE1hcC5zZXQoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgIHJlc29sdmVDc3NWYXJzKGluc3RhbmNlLCB2bm9kZSwgZXhwZWN0ZWRNYXApO1xuICAgIH1cbiAgICBpZiAoIWlzTWFwRXF1YWwoYWN0dWFsTWFwLCBleHBlY3RlZE1hcCkpIHtcbiAgICAgIG1pc21hdGNoVHlwZSA9IDMgLyogU1RZTEUgKi87XG4gICAgICBtaXNtYXRjaEtleSA9IFwic3R5bGVcIjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZWwgaW5zdGFuY2VvZiBTVkdFbGVtZW50ICYmIGlzS25vd25TdmdBdHRyKGtleSkgfHwgZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiAoaXNCb29sZWFuQXR0cihrZXkpIHx8IGlzS25vd25IdG1sQXR0cihrZXkpKSkge1xuICAgIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAgIGFjdHVhbCA9IGVsLmhhc0F0dHJpYnV0ZShrZXkpO1xuICAgICAgZXhwZWN0ZWQgPSBpbmNsdWRlQm9vbGVhbkF0dHIoY2xpZW50VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoY2xpZW50VmFsdWUgPT0gbnVsbCkge1xuICAgICAgYWN0dWFsID0gZWwuaGFzQXR0cmlidXRlKGtleSk7XG4gICAgICBleHBlY3RlZCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZWwuaGFzQXR0cmlidXRlKGtleSkpIHtcbiAgICAgICAgYWN0dWFsID0gZWwuZ2V0QXR0cmlidXRlKGtleSk7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJ2YWx1ZVwiICYmIGVsLnRhZ05hbWUgPT09IFwiVEVYVEFSRUFcIikge1xuICAgICAgICBhY3R1YWwgPSBlbC52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdHVhbCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZXhwZWN0ZWQgPSBpc1JlbmRlcmFibGVBdHRyVmFsdWUoY2xpZW50VmFsdWUpID8gU3RyaW5nKGNsaWVudFZhbHVlKSA6IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgICAgbWlzbWF0Y2hUeXBlID0gNCAvKiBBVFRSSUJVVEUgKi87XG4gICAgICBtaXNtYXRjaEtleSA9IGtleTtcbiAgICB9XG4gIH1cbiAgaWYgKG1pc21hdGNoVHlwZSAhPSBudWxsICYmICFpc01pc21hdGNoQWxsb3dlZChlbCwgbWlzbWF0Y2hUeXBlKSkge1xuICAgIGNvbnN0IGZvcm1hdCA9ICh2KSA9PiB2ID09PSBmYWxzZSA/IGAobm90IHJlbmRlcmVkKWAgOiBgJHttaXNtYXRjaEtleX09XCIke3Z9XCJgO1xuICAgIGNvbnN0IHByZVNlZ21lbnQgPSBgSHlkcmF0aW9uICR7TWlzbWF0Y2hUeXBlU3RyaW5nW21pc21hdGNoVHlwZV19IG1pc21hdGNoIG9uYDtcbiAgICBjb25zdCBwb3N0U2VnbWVudCA9IGBcbiAgLSByZW5kZXJlZCBvbiBzZXJ2ZXI6ICR7Zm9ybWF0KGFjdHVhbCl9XG4gIC0gZXhwZWN0ZWQgb24gY2xpZW50OiAke2Zvcm1hdChleHBlY3RlZCl9XG4gIE5vdGU6IHRoaXMgbWlzbWF0Y2ggaXMgY2hlY2stb25seS4gVGhlIERPTSB3aWxsIG5vdCBiZSByZWN0aWZpZWQgaW4gcHJvZHVjdGlvbiBkdWUgdG8gcGVyZm9ybWFuY2Ugb3ZlcmhlYWQuXG4gIFlvdSBzaG91bGQgZml4IHRoZSBzb3VyY2Ugb2YgdGhlIG1pc21hdGNoLmA7XG4gICAge1xuICAgICAgd2FybiQxKHByZVNlZ21lbnQsIGVsLCBwb3N0U2VnbWVudCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHRvQ2xhc3NTZXQoc3RyKSB7XG4gIHJldHVybiBuZXcgU2V0KHN0ci50cmltKCkuc3BsaXQoL1xccysvKSk7XG59XG5mdW5jdGlvbiBpc1NldEVxdWFsKGEsIGIpIHtcbiAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3QgcyBvZiBhKSB7XG4gICAgaWYgKCFiLmhhcyhzKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHRvU3R5bGVNYXAoc3RyKSB7XG4gIGNvbnN0IHN0eWxlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZm9yIChjb25zdCBpdGVtIG9mIHN0ci5zcGxpdChcIjtcIikpIHtcbiAgICBsZXQgW2tleSwgdmFsdWVdID0gaXRlbS5zcGxpdChcIjpcIik7XG4gICAga2V5ID0ga2V5LnRyaW0oKTtcbiAgICB2YWx1ZSA9IHZhbHVlICYmIHZhbHVlLnRyaW0oKTtcbiAgICBpZiAoa2V5ICYmIHZhbHVlKSB7XG4gICAgICBzdHlsZU1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZU1hcDtcbn1cbmZ1bmN0aW9uIGlzTWFwRXF1YWwoYSwgYikge1xuICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgYSkge1xuICAgIGlmICh2YWx1ZSAhPT0gYi5nZXQoa2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVDc3NWYXJzKGluc3RhbmNlLCB2bm9kZSwgZXhwZWN0ZWRNYXApIHtcbiAgY29uc3Qgcm9vdCA9IGluc3RhbmNlLnN1YlRyZWU7XG4gIGlmIChpbnN0YW5jZS5nZXRDc3NWYXJzICYmICh2bm9kZSA9PT0gcm9vdCB8fCByb290ICYmIHJvb3QudHlwZSA9PT0gRnJhZ21lbnQgJiYgcm9vdC5jaGlsZHJlbi5pbmNsdWRlcyh2bm9kZSkpKSB7XG4gICAgY29uc3QgY3NzVmFycyA9IGluc3RhbmNlLmdldENzc1ZhcnMoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjc3NWYXJzKSB7XG4gICAgICBleHBlY3RlZE1hcC5zZXQoXG4gICAgICAgIGAtLSR7Z2V0RXNjYXBlZENzc1Zhck5hbWUoa2V5LCBmYWxzZSl9YCxcbiAgICAgICAgU3RyaW5nKGNzc1ZhcnNba2V5XSlcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmICh2bm9kZSA9PT0gcm9vdCAmJiBpbnN0YW5jZS5wYXJlbnQpIHtcbiAgICByZXNvbHZlQ3NzVmFycyhpbnN0YW5jZS5wYXJlbnQsIGluc3RhbmNlLnZub2RlLCBleHBlY3RlZE1hcCk7XG4gIH1cbn1cbmNvbnN0IGFsbG93TWlzbWF0Y2hBdHRyID0gXCJkYXRhLWFsbG93LW1pc21hdGNoXCI7XG5jb25zdCBNaXNtYXRjaFR5cGVTdHJpbmcgPSB7XG4gIFswIC8qIFRFWFQgKi9dOiBcInRleHRcIixcbiAgWzEgLyogQ0hJTERSRU4gKi9dOiBcImNoaWxkcmVuXCIsXG4gIFsyIC8qIENMQVNTICovXTogXCJjbGFzc1wiLFxuICBbMyAvKiBTVFlMRSAqL106IFwic3R5bGVcIixcbiAgWzQgLyogQVRUUklCVVRFICovXTogXCJhdHRyaWJ1dGVcIlxufTtcbmZ1bmN0aW9uIGlzTWlzbWF0Y2hBbGxvd2VkKGVsLCBhbGxvd2VkVHlwZSkge1xuICBpZiAoYWxsb3dlZFR5cGUgPT09IDAgLyogVEVYVCAqLyB8fCBhbGxvd2VkVHlwZSA9PT0gMSAvKiBDSElMRFJFTiAqLykge1xuICAgIHdoaWxlIChlbCAmJiAhZWwuaGFzQXR0cmlidXRlKGFsbG93TWlzbWF0Y2hBdHRyKSkge1xuICAgICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgfVxuICBjb25zdCBhbGxvd2VkQXR0ciA9IGVsICYmIGVsLmdldEF0dHJpYnV0ZShhbGxvd01pc21hdGNoQXR0cik7XG4gIGlmIChhbGxvd2VkQXR0ciA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKGFsbG93ZWRBdHRyID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbGlzdCA9IGFsbG93ZWRBdHRyLnNwbGl0KFwiLFwiKTtcbiAgICBpZiAoYWxsb3dlZFR5cGUgPT09IDAgLyogVEVYVCAqLyAmJiBsaXN0LmluY2x1ZGVzKFwiY2hpbGRyZW5cIikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gYWxsb3dlZEF0dHIuc3BsaXQoXCIsXCIpLmluY2x1ZGVzKE1pc21hdGNoVHlwZVN0cmluZ1thbGxvd2VkVHlwZV0pO1xuICB9XG59XG5cbmNvbnN0IHJlcXVlc3RJZGxlQ2FsbGJhY2sgPSBnZXRHbG9iYWxUaGlzKCkucmVxdWVzdElkbGVDYWxsYmFjayB8fCAoKGNiKSA9PiBzZXRUaW1lb3V0KGNiLCAxKSk7XG5jb25zdCBjYW5jZWxJZGxlQ2FsbGJhY2sgPSBnZXRHbG9iYWxUaGlzKCkuY2FuY2VsSWRsZUNhbGxiYWNrIHx8ICgoaWQpID0+IGNsZWFyVGltZW91dChpZCkpO1xuY29uc3QgaHlkcmF0ZU9uSWRsZSA9ICh0aW1lb3V0ID0gMWU0KSA9PiAoaHlkcmF0ZSkgPT4ge1xuICBjb25zdCBpZCA9IHJlcXVlc3RJZGxlQ2FsbGJhY2soaHlkcmF0ZSwgeyB0aW1lb3V0IH0pO1xuICByZXR1cm4gKCkgPT4gY2FuY2VsSWRsZUNhbGxiYWNrKGlkKTtcbn07XG5mdW5jdGlvbiBlbGVtZW50SXNWaXNpYmxlSW5WaWV3cG9ydChlbCkge1xuICBjb25zdCB7IHRvcCwgbGVmdCwgYm90dG9tLCByaWdodCB9ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IHsgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGggfSA9IHdpbmRvdztcbiAgcmV0dXJuICh0b3AgPiAwICYmIHRvcCA8IGlubmVySGVpZ2h0IHx8IGJvdHRvbSA+IDAgJiYgYm90dG9tIDwgaW5uZXJIZWlnaHQpICYmIChsZWZ0ID4gMCAmJiBsZWZ0IDwgaW5uZXJXaWR0aCB8fCByaWdodCA+IDAgJiYgcmlnaHQgPCBpbm5lcldpZHRoKTtcbn1cbmNvbnN0IGh5ZHJhdGVPblZpc2libGUgPSAob3B0cykgPT4gKGh5ZHJhdGUsIGZvckVhY2gpID0+IHtcbiAgY29uc3Qgb2IgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICBmb3IgKGNvbnN0IGUgb2YgZW50cmllcykge1xuICAgICAgaWYgKCFlLmlzSW50ZXJzZWN0aW5nKSBjb250aW51ZTtcbiAgICAgIG9iLmRpc2Nvbm5lY3QoKTtcbiAgICAgIGh5ZHJhdGUoKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSwgb3B0cyk7XG4gIGZvckVhY2goKGVsKSA9PiB7XG4gICAgaWYgKCEoZWwgaW5zdGFuY2VvZiBFbGVtZW50KSkgcmV0dXJuO1xuICAgIGlmIChlbGVtZW50SXNWaXNpYmxlSW5WaWV3cG9ydChlbCkpIHtcbiAgICAgIGh5ZHJhdGUoKTtcbiAgICAgIG9iLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2Iub2JzZXJ2ZShlbCk7XG4gIH0pO1xuICByZXR1cm4gKCkgPT4gb2IuZGlzY29ubmVjdCgpO1xufTtcbmNvbnN0IGh5ZHJhdGVPbk1lZGlhUXVlcnkgPSAocXVlcnkpID0+IChoeWRyYXRlKSA9PiB7XG4gIGlmIChxdWVyeSkge1xuICAgIGNvbnN0IG1xbCA9IG1hdGNoTWVkaWEocXVlcnkpO1xuICAgIGlmIChtcWwubWF0Y2hlcykge1xuICAgICAgaHlkcmF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtcWwuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoeWRyYXRlLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICByZXR1cm4gKCkgPT4gbXFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaHlkcmF0ZSk7XG4gICAgfVxuICB9XG59O1xuY29uc3QgaHlkcmF0ZU9uSW50ZXJhY3Rpb24gPSAoaW50ZXJhY3Rpb25zID0gW10pID0+IChoeWRyYXRlLCBmb3JFYWNoKSA9PiB7XG4gIGlmIChpc1N0cmluZyhpbnRlcmFjdGlvbnMpKSBpbnRlcmFjdGlvbnMgPSBbaW50ZXJhY3Rpb25zXTtcbiAgbGV0IGhhc0h5ZHJhdGVkID0gZmFsc2U7XG4gIGNvbnN0IGRvSHlkcmF0ZSA9IChlKSA9PiB7XG4gICAgaWYgKCFoYXNIeWRyYXRlZCkge1xuICAgICAgaGFzSHlkcmF0ZWQgPSB0cnVlO1xuICAgICAgdGVhcmRvd24oKTtcbiAgICAgIGh5ZHJhdGUoKTtcbiAgICAgIGUudGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IGUuY29uc3RydWN0b3IoZS50eXBlLCBlKSk7XG4gICAgfVxuICB9O1xuICBjb25zdCB0ZWFyZG93biA9ICgpID0+IHtcbiAgICBmb3JFYWNoKChlbCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBpIG9mIGludGVyYWN0aW9ucykge1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGksIGRvSHlkcmF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGZvckVhY2goKGVsKSA9PiB7XG4gICAgZm9yIChjb25zdCBpIG9mIGludGVyYWN0aW9ucykge1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihpLCBkb0h5ZHJhdGUsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGVhcmRvd247XG59O1xuZnVuY3Rpb24gZm9yRWFjaEVsZW1lbnQobm9kZSwgY2IpIHtcbiAgaWYgKGlzQ29tbWVudChub2RlKSAmJiBub2RlLmRhdGEgPT09IFwiW1wiKSB7XG4gICAgbGV0IGRlcHRoID0gMTtcbiAgICBsZXQgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgd2hpbGUgKG5leHQpIHtcbiAgICAgIGlmIChuZXh0Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGNiKG5leHQpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzQ29tbWVudChuZXh0KSkge1xuICAgICAgICBpZiAobmV4dC5kYXRhID09PSBcIl1cIikge1xuICAgICAgICAgIGlmICgtLWRlcHRoID09PSAwKSBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0LmRhdGEgPT09IFwiW1wiKSB7XG4gICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNiKG5vZGUpO1xuICB9XG59XG5cbmNvbnN0IGlzQXN5bmNXcmFwcGVyID0gKGkpID0+ICEhaS50eXBlLl9fYXN5bmNMb2FkZXI7XG4vKiEgI19fTk9fU0lERV9FRkZFQ1RTX18gKi9cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBkZWZpbmVBc3luY0NvbXBvbmVudChzb3VyY2UpIHtcbiAgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xuICAgIHNvdXJjZSA9IHsgbG9hZGVyOiBzb3VyY2UgfTtcbiAgfVxuICBjb25zdCB7XG4gICAgbG9hZGVyLFxuICAgIGxvYWRpbmdDb21wb25lbnQsXG4gICAgZXJyb3JDb21wb25lbnQsXG4gICAgZGVsYXkgPSAyMDAsXG4gICAgaHlkcmF0ZTogaHlkcmF0ZVN0cmF0ZWd5LFxuICAgIHRpbWVvdXQsXG4gICAgLy8gdW5kZWZpbmVkID0gbmV2ZXIgdGltZXMgb3V0XG4gICAgc3VzcGVuc2libGUgPSB0cnVlLFxuICAgIG9uRXJyb3I6IHVzZXJPbkVycm9yXG4gIH0gPSBzb3VyY2U7XG4gIGxldCBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XG4gIGxldCByZXNvbHZlZENvbXA7XG4gIGxldCByZXRyaWVzID0gMDtcbiAgY29uc3QgcmV0cnkgPSAoKSA9PiB7XG4gICAgcmV0cmllcysrO1xuICAgIHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcbiAgICByZXR1cm4gbG9hZCgpO1xuICB9O1xuICBjb25zdCBsb2FkID0gKCkgPT4ge1xuICAgIGxldCB0aGlzUmVxdWVzdDtcbiAgICByZXR1cm4gcGVuZGluZ1JlcXVlc3QgfHwgKHRoaXNSZXF1ZXN0ID0gcGVuZGluZ1JlcXVlc3QgPSBsb2FkZXIoKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICBlcnIgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyKSk7XG4gICAgICBpZiAodXNlck9uRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBjb25zdCB1c2VyUmV0cnkgPSAoKSA9PiByZXNvbHZlKHJldHJ5KCkpO1xuICAgICAgICAgIGNvbnN0IHVzZXJGYWlsID0gKCkgPT4gcmVqZWN0KGVycik7XG4gICAgICAgICAgdXNlck9uRXJyb3IoZXJyLCB1c2VyUmV0cnksIHVzZXJGYWlsLCByZXRyaWVzICsgMSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH0pLnRoZW4oKGNvbXApID0+IHtcbiAgICAgIGlmICh0aGlzUmVxdWVzdCAhPT0gcGVuZGluZ1JlcXVlc3QgJiYgcGVuZGluZ1JlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIHBlbmRpbmdSZXF1ZXN0O1xuICAgICAgfVxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWNvbXApIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGBBc3luYyBjb21wb25lbnQgbG9hZGVyIHJlc29sdmVkIHRvIHVuZGVmaW5lZC4gSWYgeW91IGFyZSB1c2luZyByZXRyeSgpLCBtYWtlIHN1cmUgdG8gcmV0dXJuIGl0cyByZXR1cm4gdmFsdWUuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXAgJiYgKGNvbXAuX19lc01vZHVsZSB8fCBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09IFwiTW9kdWxlXCIpKSB7XG4gICAgICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjb21wICYmICFpc09iamVjdChjb21wKSAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXN5bmMgY29tcG9uZW50IGxvYWQgcmVzdWx0OiAke2NvbXB9YCk7XG4gICAgICB9XG4gICAgICByZXNvbHZlZENvbXAgPSBjb21wO1xuICAgICAgcmV0dXJuIGNvbXA7XG4gICAgfSkpO1xuICB9O1xuICByZXR1cm4gZGVmaW5lQ29tcG9uZW50KHtcbiAgICBuYW1lOiBcIkFzeW5jQ29tcG9uZW50V3JhcHBlclwiLFxuICAgIF9fYXN5bmNMb2FkZXI6IGxvYWQsXG4gICAgX19hc3luY0h5ZHJhdGUoZWwsIGluc3RhbmNlLCBoeWRyYXRlKSB7XG4gICAgICBsZXQgcGF0Y2hlZCA9IGZhbHNlO1xuICAgICAgY29uc3QgZG9IeWRyYXRlID0gaHlkcmF0ZVN0cmF0ZWd5ID8gKCkgPT4ge1xuICAgICAgICBjb25zdCBwZXJmb3JtSHlkcmF0ZSA9ICgpID0+IHtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBwYXRjaGVkKSB7XG4gICAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAgIGBTa2lwcGluZyBsYXp5IGh5ZHJhdGlvbiBmb3IgY29tcG9uZW50ICcke2dldENvbXBvbmVudE5hbWUocmVzb2x2ZWRDb21wKX0nOiBpdCB3YXMgdXBkYXRlZCBiZWZvcmUgbGF6eSBoeWRyYXRpb24gcGVyZm9ybWVkLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGh5ZHJhdGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdGVhcmRvd24gPSBoeWRyYXRlU3RyYXRlZ3koXG4gICAgICAgICAgcGVyZm9ybUh5ZHJhdGUsXG4gICAgICAgICAgKGNiKSA9PiBmb3JFYWNoRWxlbWVudChlbCwgY2IpXG4gICAgICAgICk7XG4gICAgICAgIGlmICh0ZWFyZG93bikge1xuICAgICAgICAgIChpbnN0YW5jZS5idW0gfHwgKGluc3RhbmNlLmJ1bSA9IFtdKSkucHVzaCh0ZWFyZG93bik7XG4gICAgICAgIH1cbiAgICAgICAgKGluc3RhbmNlLnUgfHwgKGluc3RhbmNlLnUgPSBbXSkpLnB1c2goKCkgPT4gcGF0Y2hlZCA9IHRydWUpO1xuICAgICAgfSA6IGh5ZHJhdGU7XG4gICAgICBpZiAocmVzb2x2ZWRDb21wKSB7XG4gICAgICAgIGRvSHlkcmF0ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9hZCgpLnRoZW4oKCkgPT4gIWluc3RhbmNlLmlzVW5tb3VudGVkICYmIGRvSHlkcmF0ZSgpKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldCBfX2FzeW5jUmVzb2x2ZWQoKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZWRDb21wO1xuICAgIH0sXG4gICAgc2V0dXAoKSB7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICAgIG1hcmtBc3luY0JvdW5kYXJ5KGluc3RhbmNlKTtcbiAgICAgIGlmIChyZXNvbHZlZENvbXApIHtcbiAgICAgICAgcmV0dXJuICgpID0+IGNyZWF0ZUlubmVyQ29tcChyZXNvbHZlZENvbXAsIGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgaGFuZGxlRXJyb3IoXG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIDEzLFxuICAgICAgICAgICFlcnJvckNvbXBvbmVudFxuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIGlmIChzdXNwZW5zaWJsZSAmJiBpbnN0YW5jZS5zdXNwZW5zZSB8fCBpc0luU1NSQ29tcG9uZW50U2V0dXApIHtcbiAgICAgICAgcmV0dXJuIGxvYWQoKS50aGVuKChjb21wKSA9PiB7XG4gICAgICAgICAgcmV0dXJuICgpID0+IGNyZWF0ZUlubmVyQ29tcChjb21wLCBpbnN0YW5jZSk7XG4gICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgcmV0dXJuICgpID0+IGVycm9yQ29tcG9uZW50ID8gY3JlYXRlVk5vZGUoZXJyb3JDb21wb25lbnQsIHtcbiAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICB9KSA6IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgbG9hZGVkID0gcmVmKGZhbHNlKTtcbiAgICAgIGNvbnN0IGVycm9yID0gcmVmKCk7XG4gICAgICBjb25zdCBkZWxheWVkID0gcmVmKCEhZGVsYXkpO1xuICAgICAgaWYgKGRlbGF5KSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGRlbGF5ZWQudmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAoIWxvYWRlZC52YWx1ZSAmJiAhZXJyb3IudmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYEFzeW5jIGNvbXBvbmVudCB0aW1lZCBvdXQgYWZ0ZXIgJHt0aW1lb3V0fW1zLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgICBlcnJvci52YWx1ZSA9IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgbG9hZCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBsb2FkZWQudmFsdWUgPSB0cnVlO1xuICAgICAgICBpZiAoaW5zdGFuY2UucGFyZW50ICYmIGlzS2VlcEFsaXZlKGluc3RhbmNlLnBhcmVudC52bm9kZSkpIHtcbiAgICAgICAgICBpbnN0YW5jZS5wYXJlbnQudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICBlcnJvci52YWx1ZSA9IGVycjtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKGxvYWRlZC52YWx1ZSAmJiByZXNvbHZlZENvbXApIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlSW5uZXJDb21wKHJlc29sdmVkQ29tcCwgaW5zdGFuY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yLnZhbHVlICYmIGVycm9yQ29tcG9uZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKGVycm9yQ29tcG9uZW50LCB7XG4gICAgICAgICAgICBlcnJvcjogZXJyb3IudmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2FkaW5nQ29tcG9uZW50ICYmICFkZWxheWVkLnZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKGxvYWRpbmdDb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVJbm5lckNvbXAoY29tcCwgcGFyZW50KSB7XG4gIGNvbnN0IHsgcmVmOiByZWYyLCBwcm9wcywgY2hpbGRyZW4sIGNlIH0gPSBwYXJlbnQudm5vZGU7XG4gIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUoY29tcCwgcHJvcHMsIGNoaWxkcmVuKTtcbiAgdm5vZGUucmVmID0gcmVmMjtcbiAgdm5vZGUuY2UgPSBjZTtcbiAgZGVsZXRlIHBhcmVudC52bm9kZS5jZTtcbiAgcmV0dXJuIHZub2RlO1xufVxuXG5jb25zdCBpc0tlZXBBbGl2ZSA9ICh2bm9kZSkgPT4gdm5vZGUudHlwZS5fX2lzS2VlcEFsaXZlO1xuY29uc3QgS2VlcEFsaXZlSW1wbCA9IHtcbiAgbmFtZTogYEtlZXBBbGl2ZWAsXG4gIC8vIE1hcmtlciBmb3Igc3BlY2lhbCBoYW5kbGluZyBpbnNpZGUgdGhlIHJlbmRlcmVyLiBXZSBhcmUgbm90IHVzaW5nIGEgPT09XG4gIC8vIGNoZWNrIGRpcmVjdGx5IG9uIEtlZXBBbGl2ZSBpbiB0aGUgcmVuZGVyZXIsIGJlY2F1c2UgaW1wb3J0aW5nIGl0IGRpcmVjdGx5XG4gIC8vIHdvdWxkIHByZXZlbnQgaXQgZnJvbSBiZWluZyB0cmVlLXNoYWtlbi5cbiAgX19pc0tlZXBBbGl2ZTogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XSxcbiAgICBleGNsdWRlOiBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XSxcbiAgICBtYXg6IFtTdHJpbmcsIE51bWJlcl1cbiAgfSxcbiAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgY29uc3Qgc2hhcmVkQ29udGV4dCA9IGluc3RhbmNlLmN0eDtcbiAgICBpZiAoIXNoYXJlZENvbnRleHQucmVuZGVyZXIpIHtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCAmJiBzbG90cy5kZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgPyBjaGlsZHJlblswXSA6IGNoaWxkcmVuO1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGxldCBjdXJyZW50ID0gbnVsbDtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGluc3RhbmNlLl9fdl9jYWNoZSA9IGNhY2hlO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnRTdXNwZW5zZSA9IGluc3RhbmNlLnN1c3BlbnNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlbmRlcmVyOiB7XG4gICAgICAgIHA6IHBhdGNoLFxuICAgICAgICBtOiBtb3ZlLFxuICAgICAgICB1bTogX3VubW91bnQsXG4gICAgICAgIG86IHsgY3JlYXRlRWxlbWVudCB9XG4gICAgICB9XG4gICAgfSA9IHNoYXJlZENvbnRleHQ7XG4gICAgY29uc3Qgc3RvcmFnZUNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgc2hhcmVkQ29udGV4dC5hY3RpdmF0ZSA9ICh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIG5hbWVzcGFjZSwgb3B0aW1pemVkKSA9PiB7XG4gICAgICBjb25zdCBpbnN0YW5jZTIgPSB2bm9kZS5jb21wb25lbnQ7XG4gICAgICBtb3ZlKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgMCwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgcGF0Y2goXG4gICAgICAgIGluc3RhbmNlMi52bm9kZSxcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBpbnN0YW5jZTIsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHZub2RlLnNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaW5zdGFuY2UyLmlzRGVhY3RpdmF0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGluc3RhbmNlMi5hKSB7XG4gICAgICAgICAgaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UyLmEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZub2RlSG9vayA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLm9uVm5vZGVNb3VudGVkO1xuICAgICAgICBpZiAodm5vZGVIb29rKSB7XG4gICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgaW5zdGFuY2UyLnBhcmVudCwgdm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgZGV2dG9vbHNDb21wb25lbnRBZGRlZChpbnN0YW5jZTIpO1xuICAgICAgfVxuICAgIH07XG4gICAgc2hhcmVkQ29udGV4dC5kZWFjdGl2YXRlID0gKHZub2RlKSA9PiB7XG4gICAgICBjb25zdCBpbnN0YW5jZTIgPSB2bm9kZS5jb21wb25lbnQ7XG4gICAgICBpbnZhbGlkYXRlTW91bnQoaW5zdGFuY2UyLm0pO1xuICAgICAgaW52YWxpZGF0ZU1vdW50KGluc3RhbmNlMi5hKTtcbiAgICAgIG1vdmUodm5vZGUsIHN0b3JhZ2VDb250YWluZXIsIG51bGwsIDEsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChpbnN0YW5jZTIuZGEpIHtcbiAgICAgICAgICBpbnZva2VBcnJheUZucyhpbnN0YW5jZTIuZGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZub2RlSG9vayA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLm9uVm5vZGVVbm1vdW50ZWQ7XG4gICAgICAgIGlmICh2bm9kZUhvb2spIHtcbiAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBpbnN0YW5jZTIucGFyZW50LCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UyLmlzRGVhY3RpdmF0ZWQgPSB0cnVlO1xuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgIGRldnRvb2xzQ29tcG9uZW50QWRkZWQoaW5zdGFuY2UyKTtcbiAgICAgIH1cbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHRydWUpIHtcbiAgICAgICAgaW5zdGFuY2UyLl9fa2VlcEFsaXZlU3RvcmFnZUNvbnRhaW5lciA9IHN0b3JhZ2VDb250YWluZXI7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiB1bm1vdW50KHZub2RlKSB7XG4gICAgICByZXNldFNoYXBlRmxhZyh2bm9kZSk7XG4gICAgICBfdW5tb3VudCh2bm9kZSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJ1bmVDYWNoZShmaWx0ZXIpIHtcbiAgICAgIGNhY2hlLmZvckVhY2goKHZub2RlLCBrZXkpID0+IHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodm5vZGUudHlwZSk7XG4gICAgICAgIGlmIChuYW1lICYmICFmaWx0ZXIobmFtZSkpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeShrZXkpIHtcbiAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChrZXkpO1xuICAgICAgaWYgKGNhY2hlZCAmJiAoIWN1cnJlbnQgfHwgIWlzU2FtZVZOb2RlVHlwZShjYWNoZWQsIGN1cnJlbnQpKSkge1xuICAgICAgICB1bm1vdW50KGNhY2hlZCk7XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgcmVzZXRTaGFwZUZsYWcoY3VycmVudCk7XG4gICAgICB9XG4gICAgICBjYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgIGtleXMuZGVsZXRlKGtleSk7XG4gICAgfVxuICAgIHdhdGNoKFxuICAgICAgKCkgPT4gW3Byb3BzLmluY2x1ZGUsIHByb3BzLmV4Y2x1ZGVdLFxuICAgICAgKFtpbmNsdWRlLCBleGNsdWRlXSkgPT4ge1xuICAgICAgICBpbmNsdWRlICYmIHBydW5lQ2FjaGUoKG5hbWUpID0+IG1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpO1xuICAgICAgICBleGNsdWRlICYmIHBydW5lQ2FjaGUoKG5hbWUpID0+ICFtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKTtcbiAgICAgIH0sXG4gICAgICAvLyBwcnVuZSBwb3N0LXJlbmRlciBhZnRlciBgY3VycmVudGAgaGFzIGJlZW4gdXBkYXRlZFxuICAgICAgeyBmbHVzaDogXCJwb3N0XCIsIGRlZXA6IHRydWUgfVxuICAgICk7XG4gICAgbGV0IHBlbmRpbmdDYWNoZUtleSA9IG51bGw7XG4gICAgY29uc3QgY2FjaGVTdWJ0cmVlID0gKCkgPT4ge1xuICAgICAgaWYgKHBlbmRpbmdDYWNoZUtleSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChpc1N1c3BlbnNlKGluc3RhbmNlLnN1YlRyZWUudHlwZSkpIHtcbiAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgY2FjaGUuc2V0KHBlbmRpbmdDYWNoZUtleSwgZ2V0SW5uZXJDaGlsZChpbnN0YW5jZS5zdWJUcmVlKSk7XG4gICAgICAgICAgfSwgaW5zdGFuY2Uuc3ViVHJlZS5zdXNwZW5zZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FjaGUuc2V0KHBlbmRpbmdDYWNoZUtleSwgZ2V0SW5uZXJDaGlsZChpbnN0YW5jZS5zdWJUcmVlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIG9uTW91bnRlZChjYWNoZVN1YnRyZWUpO1xuICAgIG9uVXBkYXRlZChjYWNoZVN1YnRyZWUpO1xuICAgIG9uQmVmb3JlVW5tb3VudCgoKSA9PiB7XG4gICAgICBjYWNoZS5mb3JFYWNoKChjYWNoZWQpID0+IHtcbiAgICAgICAgY29uc3QgeyBzdWJUcmVlLCBzdXNwZW5zZSB9ID0gaW5zdGFuY2U7XG4gICAgICAgIGNvbnN0IHZub2RlID0gZ2V0SW5uZXJDaGlsZChzdWJUcmVlKTtcbiAgICAgICAgaWYgKGNhY2hlZC50eXBlID09PSB2bm9kZS50eXBlICYmIGNhY2hlZC5rZXkgPT09IHZub2RlLmtleSkge1xuICAgICAgICAgIHJlc2V0U2hhcGVGbGFnKHZub2RlKTtcbiAgICAgICAgICBjb25zdCBkYSA9IHZub2RlLmNvbXBvbmVudC5kYTtcbiAgICAgICAgICBkYSAmJiBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoZGEsIHN1c3BlbnNlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdW5tb3VudChjYWNoZWQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHBlbmRpbmdDYWNoZUtleSA9IG51bGw7XG4gICAgICBpZiAoIXNsb3RzLmRlZmF1bHQpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0KCk7XG4gICAgICBjb25zdCByYXdWTm9kZSA9IGNoaWxkcmVuWzBdO1xuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuJDEoYEtlZXBBbGl2ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IG9uZSBjb21wb25lbnQgY2hpbGQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgIH0gZWxzZSBpZiAoIWlzVk5vZGUocmF3Vk5vZGUpIHx8ICEocmF3Vk5vZGUuc2hhcGVGbGFnICYgNCkgJiYgIShyYXdWTm9kZS5zaGFwZUZsYWcgJiAxMjgpKSB7XG4gICAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm4gcmF3Vk5vZGU7XG4gICAgICB9XG4gICAgICBsZXQgdm5vZGUgPSBnZXRJbm5lckNoaWxkKHJhd1ZOb2RlKTtcbiAgICAgIGlmICh2bm9kZS50eXBlID09PSBDb21tZW50KSB7XG4gICAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm4gdm5vZGU7XG4gICAgICB9XG4gICAgICBjb25zdCBjb21wID0gdm5vZGUudHlwZTtcbiAgICAgIGNvbnN0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFxuICAgICAgICBpc0FzeW5jV3JhcHBlcih2bm9kZSkgPyB2bm9kZS50eXBlLl9fYXN5bmNSZXNvbHZlZCB8fCB7fSA6IGNvbXBcbiAgICAgICk7XG4gICAgICBjb25zdCB7IGluY2x1ZGUsIGV4Y2x1ZGUsIG1heCB9ID0gcHJvcHM7XG4gICAgICBpZiAoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpIHx8IGV4Y2x1ZGUgJiYgbmFtZSAmJiBtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKSB7XG4gICAgICAgIHZub2RlLnNoYXBlRmxhZyAmPSAtMjU3O1xuICAgICAgICBjdXJyZW50ID0gdm5vZGU7XG4gICAgICAgIHJldHVybiByYXdWTm9kZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtleSA9IHZub2RlLmtleSA9PSBudWxsID8gY29tcCA6IHZub2RlLmtleTtcbiAgICAgIGNvbnN0IGNhY2hlZFZOb2RlID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICBpZiAodm5vZGUuZWwpIHtcbiAgICAgICAgdm5vZGUgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICAgICAgaWYgKHJhd1ZOb2RlLnNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgICAgIHJhd1ZOb2RlLnNzQ29udGVudCA9IHZub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwZW5kaW5nQ2FjaGVLZXkgPSBrZXk7XG4gICAgICBpZiAoY2FjaGVkVk5vZGUpIHtcbiAgICAgICAgdm5vZGUuZWwgPSBjYWNoZWRWTm9kZS5lbDtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50ID0gY2FjaGVkVk5vZGUuY29tcG9uZW50O1xuICAgICAgICBpZiAodm5vZGUudHJhbnNpdGlvbikge1xuICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZSwgdm5vZGUudHJhbnNpdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdm5vZGUuc2hhcGVGbGFnIHw9IDUxMjtcbiAgICAgICAga2V5cy5kZWxldGUoa2V5KTtcbiAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgICAgIGlmIChtYXggJiYga2V5cy5zaXplID4gcGFyc2VJbnQobWF4LCAxMCkpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoa2V5cy52YWx1ZXMoKS5uZXh0KCkudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2bm9kZS5zaGFwZUZsYWcgfD0gMjU2O1xuICAgICAgY3VycmVudCA9IHZub2RlO1xuICAgICAgcmV0dXJuIGlzU3VzcGVuc2UocmF3Vk5vZGUudHlwZSkgPyByYXdWTm9kZSA6IHZub2RlO1xuICAgIH07XG4gIH1cbn07XG5jb25zdCBLZWVwQWxpdmUgPSBLZWVwQWxpdmVJbXBsO1xuZnVuY3Rpb24gbWF0Y2hlcyhwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmIChpc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc29tZSgocCkgPT4gbWF0Y2hlcyhwLCBuYW1lKSk7XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmcocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdChcIixcIikuaW5jbHVkZXMobmFtZSk7XG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICBwYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBvbkFjdGl2YXRlZChob29rLCB0YXJnZXQpIHtcbiAgcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIFwiYVwiLCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gb25EZWFjdGl2YXRlZChob29rLCB0YXJnZXQpIHtcbiAgcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIFwiZGFcIiwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyS2VlcEFsaXZlSG9vayhob29rLCB0eXBlLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpIHtcbiAgY29uc3Qgd3JhcHBlZEhvb2sgPSBob29rLl9fd2RjIHx8IChob29rLl9fd2RjID0gKCkgPT4ge1xuICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0O1xuICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICBpZiAoY3VycmVudC5pc0RlYWN0aXZhdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGhvb2soKTtcbiAgfSk7XG4gIGluamVjdEhvb2sodHlwZSwgd3JhcHBlZEhvb2ssIHRhcmdldCk7XG4gIGlmICh0YXJnZXQpIHtcbiAgICBsZXQgY3VycmVudCA9IHRhcmdldC5wYXJlbnQ7XG4gICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudC5wYXJlbnQpIHtcbiAgICAgIGlmIChpc0tlZXBBbGl2ZShjdXJyZW50LnBhcmVudC52bm9kZSkpIHtcbiAgICAgICAgaW5qZWN0VG9LZWVwQWxpdmVSb290KHdyYXBwZWRIb29rLCB0eXBlLCB0YXJnZXQsIGN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaW5qZWN0VG9LZWVwQWxpdmVSb290KGhvb2ssIHR5cGUsIHRhcmdldCwga2VlcEFsaXZlUm9vdCkge1xuICBjb25zdCBpbmplY3RlZCA9IGluamVjdEhvb2soXG4gICAgdHlwZSxcbiAgICBob29rLFxuICAgIGtlZXBBbGl2ZVJvb3QsXG4gICAgdHJ1ZVxuICAgIC8qIHByZXBlbmQgKi9cbiAgKTtcbiAgb25Vbm1vdW50ZWQoKCkgPT4ge1xuICAgIHJlbW92ZShrZWVwQWxpdmVSb290W3R5cGVdLCBpbmplY3RlZCk7XG4gIH0sIHRhcmdldCk7XG59XG5mdW5jdGlvbiByZXNldFNoYXBlRmxhZyh2bm9kZSkge1xuICB2bm9kZS5zaGFwZUZsYWcgJj0gLTI1NztcbiAgdm5vZGUuc2hhcGVGbGFnICY9IC01MTM7XG59XG5mdW5jdGlvbiBnZXRJbm5lckNoaWxkKHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5zaGFwZUZsYWcgJiAxMjggPyB2bm9kZS5zc0NvbnRlbnQgOiB2bm9kZTtcbn1cblxuZnVuY3Rpb24gaW5qZWN0SG9vayh0eXBlLCBob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UsIHByZXBlbmQgPSBmYWxzZSkge1xuICBpZiAodGFyZ2V0KSB7XG4gICAgY29uc3QgaG9va3MgPSB0YXJnZXRbdHlwZV0gfHwgKHRhcmdldFt0eXBlXSA9IFtdKTtcbiAgICBjb25zdCB3cmFwcGVkSG9vayA9IGhvb2suX193ZWggfHwgKGhvb2suX193ZWggPSAoLi4uYXJncykgPT4ge1xuICAgICAgcGF1c2VUcmFja2luZygpO1xuICAgICAgY29uc3QgcmVzZXQgPSBzZXRDdXJyZW50SW5zdGFuY2UodGFyZ2V0KTtcbiAgICAgIGNvbnN0IHJlcyA9IGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIHRhcmdldCwgdHlwZSwgYXJncyk7XG4gICAgICByZXNldCgpO1xuICAgICAgcmVzZXRUcmFja2luZygpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9KTtcbiAgICBpZiAocHJlcGVuZCkge1xuICAgICAgaG9va3MudW5zaGlmdCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvb2tzLnB1c2god3JhcHBlZEhvb2spO1xuICAgIH1cbiAgICByZXR1cm4gd3JhcHBlZEhvb2s7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IGFwaU5hbWUgPSB0b0hhbmRsZXJLZXkoRXJyb3JUeXBlU3RyaW5ncyQxW3R5cGVdLnJlcGxhY2UoLyBob29rJC8sIFwiXCIpKTtcbiAgICB3YXJuJDEoXG4gICAgICBgJHthcGlOYW1lfSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlIHRvIGJlIGFzc29jaWF0ZWQgd2l0aC4gTGlmZWN5Y2xlIGluamVjdGlvbiBBUElzIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGV4ZWN1dGlvbiBvZiBzZXR1cCgpLmAgKyAoYCBJZiB5b3UgYXJlIHVzaW5nIGFzeW5jIHNldHVwKCksIG1ha2Ugc3VyZSB0byByZWdpc3RlciBsaWZlY3ljbGUgaG9va3MgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdCBzdGF0ZW1lbnQuYCApXG4gICAgKTtcbiAgfVxufVxuY29uc3QgY3JlYXRlSG9vayA9IChsaWZlY3ljbGUpID0+IChob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpID0+IHtcbiAgaWYgKCFpc0luU1NSQ29tcG9uZW50U2V0dXAgfHwgbGlmZWN5Y2xlID09PSBcInNwXCIpIHtcbiAgICBpbmplY3RIb29rKGxpZmVjeWNsZSwgKC4uLmFyZ3MpID0+IGhvb2soLi4uYXJncyksIHRhcmdldCk7XG4gIH1cbn07XG5jb25zdCBvbkJlZm9yZU1vdW50ID0gY3JlYXRlSG9vayhcImJtXCIpO1xuY29uc3Qgb25Nb3VudGVkID0gY3JlYXRlSG9vayhcIm1cIik7XG5jb25zdCBvbkJlZm9yZVVwZGF0ZSA9IGNyZWF0ZUhvb2soXG4gIFwiYnVcIlxuKTtcbmNvbnN0IG9uVXBkYXRlZCA9IGNyZWF0ZUhvb2soXCJ1XCIpO1xuY29uc3Qgb25CZWZvcmVVbm1vdW50ID0gY3JlYXRlSG9vayhcbiAgXCJidW1cIlxuKTtcbmNvbnN0IG9uVW5tb3VudGVkID0gY3JlYXRlSG9vayhcInVtXCIpO1xuY29uc3Qgb25TZXJ2ZXJQcmVmZXRjaCA9IGNyZWF0ZUhvb2soXG4gIFwic3BcIlxuKTtcbmNvbnN0IG9uUmVuZGVyVHJpZ2dlcmVkID0gY3JlYXRlSG9vayhcInJ0Z1wiKTtcbmNvbnN0IG9uUmVuZGVyVHJhY2tlZCA9IGNyZWF0ZUhvb2soXCJydGNcIik7XG5mdW5jdGlvbiBvbkVycm9yQ2FwdHVyZWQoaG9vaywgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlKSB7XG4gIGluamVjdEhvb2soXCJlY1wiLCBob29rLCB0YXJnZXQpO1xufVxuXG5jb25zdCBDT01QT05FTlRTID0gXCJjb21wb25lbnRzXCI7XG5jb25zdCBESVJFQ1RJVkVTID0gXCJkaXJlY3RpdmVzXCI7XG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50KG5hbWUsIG1heWJlU2VsZlJlZmVyZW5jZSkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KENPTVBPTkVOVFMsIG5hbWUsIHRydWUsIG1heWJlU2VsZlJlZmVyZW5jZSkgfHwgbmFtZTtcbn1cbmNvbnN0IE5VTExfRFlOQU1JQ19DT01QT05FTlQgPSBTeW1ib2wuZm9yKFwidi1uZGNcIik7XG5mdW5jdGlvbiByZXNvbHZlRHluYW1pY0NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgaWYgKGlzU3RyaW5nKGNvbXBvbmVudCkpIHtcbiAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KENPTVBPTkVOVFMsIGNvbXBvbmVudCwgZmFsc2UpIHx8IGNvbXBvbmVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29tcG9uZW50IHx8IE5VTExfRFlOQU1JQ19DT01QT05FTlQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVEaXJlY3RpdmUobmFtZSkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KERJUkVDVElWRVMsIG5hbWUpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0KHR5cGUsIG5hbWUsIHdhcm5NaXNzaW5nID0gdHJ1ZSwgbWF5YmVTZWxmUmVmZXJlbmNlID0gZmFsc2UpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgfHwgY3VycmVudEluc3RhbmNlO1xuICBpZiAoaW5zdGFuY2UpIHtcbiAgICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xuICAgIGlmICh0eXBlID09PSBDT01QT05FTlRTKSB7XG4gICAgICBjb25zdCBzZWxmTmFtZSA9IGdldENvbXBvbmVudE5hbWUoXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgICBpZiAoc2VsZk5hbWUgJiYgKHNlbGZOYW1lID09PSBuYW1lIHx8IHNlbGZOYW1lID09PSBjYW1lbGl6ZShuYW1lKSB8fCBzZWxmTmFtZSA9PT0gY2FwaXRhbGl6ZShjYW1lbGl6ZShuYW1lKSkpKSB7XG4gICAgICAgIHJldHVybiBDb21wb25lbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IChcbiAgICAgIC8vIGxvY2FsIHJlZ2lzdHJhdGlvblxuICAgICAgLy8gY2hlY2sgaW5zdGFuY2VbdHlwZV0gZmlyc3Qgd2hpY2ggaXMgcmVzb2x2ZWQgZm9yIG9wdGlvbnMgQVBJXG4gICAgICByZXNvbHZlKGluc3RhbmNlW3R5cGVdIHx8IENvbXBvbmVudFt0eXBlXSwgbmFtZSkgfHwgLy8gZ2xvYmFsIHJlZ2lzdHJhdGlvblxuICAgICAgcmVzb2x2ZShpbnN0YW5jZS5hcHBDb250ZXh0W3R5cGVdLCBuYW1lKVxuICAgICk7XG4gICAgaWYgKCFyZXMgJiYgbWF5YmVTZWxmUmVmZXJlbmNlKSB7XG4gICAgICByZXR1cm4gQ29tcG9uZW50O1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgICBjb25zdCBleHRyYSA9IHR5cGUgPT09IENPTVBPTkVOVFMgPyBgXG5JZiB0aGlzIGlzIGEgbmF0aXZlIGN1c3RvbSBlbGVtZW50LCBtYWtlIHN1cmUgdG8gZXhjbHVkZSBpdCBmcm9tIGNvbXBvbmVudCByZXNvbHV0aW9uIHZpYSBjb21waWxlck9wdGlvbnMuaXNDdXN0b21FbGVtZW50LmAgOiBgYDtcbiAgICAgIHdhcm4kMShgRmFpbGVkIHRvIHJlc29sdmUgJHt0eXBlLnNsaWNlKDAsIC0xKX06ICR7bmFtZX0ke2V4dHJhfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgcmVzb2x2ZSR7Y2FwaXRhbGl6ZSh0eXBlLnNsaWNlKDAsIC0xKSl9IGNhbiBvbmx5IGJlIHVzZWQgaW4gcmVuZGVyKCkgb3Igc2V0dXAoKS5gXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZShyZWdpc3RyeSwgbmFtZSkge1xuICByZXR1cm4gcmVnaXN0cnkgJiYgKHJlZ2lzdHJ5W25hbWVdIHx8IHJlZ2lzdHJ5W2NhbWVsaXplKG5hbWUpXSB8fCByZWdpc3RyeVtjYXBpdGFsaXplKGNhbWVsaXplKG5hbWUpKV0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJMaXN0KHNvdXJjZSwgcmVuZGVySXRlbSwgY2FjaGUsIGluZGV4KSB7XG4gIGxldCByZXQ7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlICYmIGNhY2hlW2luZGV4XTtcbiAgY29uc3Qgc291cmNlSXNBcnJheSA9IGlzQXJyYXkoc291cmNlKTtcbiAgaWYgKHNvdXJjZUlzQXJyYXkgfHwgaXNTdHJpbmcoc291cmNlKSkge1xuICAgIGNvbnN0IHNvdXJjZUlzUmVhY3RpdmVBcnJheSA9IHNvdXJjZUlzQXJyYXkgJiYgaXNSZWFjdGl2ZShzb3VyY2UpO1xuICAgIGxldCBuZWVkc1dyYXAgPSBmYWxzZTtcbiAgICBsZXQgaXNSZWFkb25seVNvdXJjZSA9IGZhbHNlO1xuICAgIGlmIChzb3VyY2VJc1JlYWN0aXZlQXJyYXkpIHtcbiAgICAgIG5lZWRzV3JhcCA9ICFpc1NoYWxsb3coc291cmNlKTtcbiAgICAgIGlzUmVhZG9ubHlTb3VyY2UgPSBpc1JlYWRvbmx5KHNvdXJjZSk7XG4gICAgICBzb3VyY2UgPSBzaGFsbG93UmVhZEFycmF5KHNvdXJjZSk7XG4gICAgfVxuICAgIHJldCA9IG5ldyBBcnJheShzb3VyY2UubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oXG4gICAgICAgIG5lZWRzV3JhcCA/IGlzUmVhZG9ubHlTb3VyY2UgPyB0b1JlYWRvbmx5KHRvUmVhY3RpdmUoc291cmNlW2ldKSkgOiB0b1JlYWN0aXZlKHNvdXJjZVtpXSkgOiBzb3VyY2VbaV0sXG4gICAgICAgIGksXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgY2FjaGVkICYmIGNhY2hlZFtpXVxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNvdXJjZSA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFOdW1iZXIuaXNJbnRlZ2VyKHNvdXJjZSkpIHtcbiAgICAgIHdhcm4kMShgVGhlIHYtZm9yIHJhbmdlIGV4cGVjdCBhbiBpbnRlZ2VyIHZhbHVlIGJ1dCBnb3QgJHtzb3VyY2V9LmApO1xuICAgIH1cbiAgICByZXQgPSBuZXcgQXJyYXkoc291cmNlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZTsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXJJdGVtKGkgKyAxLCBpLCB2b2lkIDAsIGNhY2hlZCAmJiBjYWNoZWRbaV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChzb3VyY2UpKSB7XG4gICAgaWYgKHNvdXJjZVtTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgICByZXQgPSBBcnJheS5mcm9tKFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIChpdGVtLCBpKSA9PiByZW5kZXJJdGVtKGl0ZW0sIGksIHZvaWQgMCwgY2FjaGVkICYmIGNhY2hlZFtpXSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgcmV0W2ldID0gcmVuZGVySXRlbShzb3VyY2Vba2V5XSwga2V5LCBpLCBjYWNoZWQgJiYgY2FjaGVkW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0ID0gW107XG4gIH1cbiAgaWYgKGNhY2hlKSB7XG4gICAgY2FjaGVbaW5kZXhdID0gcmV0O1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNsb3RzKHNsb3RzLCBkeW5hbWljU2xvdHMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkeW5hbWljU2xvdHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzbG90ID0gZHluYW1pY1Nsb3RzW2ldO1xuICAgIGlmIChpc0FycmF5KHNsb3QpKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNsb3QubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc2xvdHNbc2xvdFtqXS5uYW1lXSA9IHNsb3Rbal0uZm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzbG90KSB7XG4gICAgICBzbG90c1tzbG90Lm5hbWVdID0gc2xvdC5rZXkgPyAoLi4uYXJncykgPT4ge1xuICAgICAgICBjb25zdCByZXMgPSBzbG90LmZuKC4uLmFyZ3MpO1xuICAgICAgICBpZiAocmVzKSByZXMua2V5ID0gc2xvdC5rZXk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9IDogc2xvdC5mbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNsb3RzO1xufVxuXG5mdW5jdGlvbiByZW5kZXJTbG90KHNsb3RzLCBuYW1lLCBwcm9wcyA9IHt9LCBmYWxsYmFjaywgbm9TbG90dGVkKSB7XG4gIGlmIChjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UuY2UgfHwgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnBhcmVudCAmJiBpc0FzeW5jV3JhcHBlcihjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UucGFyZW50KSAmJiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UucGFyZW50LmNlKSB7XG4gICAgaWYgKG5hbWUgIT09IFwiZGVmYXVsdFwiKSBwcm9wcy5uYW1lID0gbmFtZTtcbiAgICByZXR1cm4gb3BlbkJsb2NrKCksIGNyZWF0ZUJsb2NrKFxuICAgICAgRnJhZ21lbnQsXG4gICAgICBudWxsLFxuICAgICAgW2NyZWF0ZVZOb2RlKFwic2xvdFwiLCBwcm9wcywgZmFsbGJhY2sgJiYgZmFsbGJhY2soKSldLFxuICAgICAgNjRcbiAgICApO1xuICB9XG4gIGxldCBzbG90ID0gc2xvdHNbbmFtZV07XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHNsb3QgJiYgc2xvdC5sZW5ndGggPiAxKSB7XG4gICAgd2FybiQxKFxuICAgICAgYFNTUi1vcHRpbWl6ZWQgc2xvdCBmdW5jdGlvbiBkZXRlY3RlZCBpbiBhIG5vbi1TU1Itb3B0aW1pemVkIHJlbmRlciBmdW5jdGlvbi4gWW91IG5lZWQgdG8gbWFyayB0aGlzIGNvbXBvbmVudCB3aXRoICRkeW5hbWljLXNsb3RzIGluIHRoZSBwYXJlbnQgdGVtcGxhdGUuYFxuICAgICk7XG4gICAgc2xvdCA9ICgpID0+IFtdO1xuICB9XG4gIGlmIChzbG90ICYmIHNsb3QuX2MpIHtcbiAgICBzbG90Ll9kID0gZmFsc2U7XG4gIH1cbiAgb3BlbkJsb2NrKCk7XG4gIGNvbnN0IHZhbGlkU2xvdENvbnRlbnQgPSBzbG90ICYmIGVuc3VyZVZhbGlkVk5vZGUoc2xvdChwcm9wcykpO1xuICBjb25zdCBzbG90S2V5ID0gcHJvcHMua2V5IHx8IC8vIHNsb3QgY29udGVudCBhcnJheSBvZiBhIGR5bmFtaWMgY29uZGl0aW9uYWwgc2xvdCBtYXkgaGF2ZSBhIGJyYW5jaFxuICAvLyBrZXkgYXR0YWNoZWQgaW4gdGhlIGBjcmVhdGVTbG90c2AgaGVscGVyLCByZXNwZWN0IHRoYXRcbiAgdmFsaWRTbG90Q29udGVudCAmJiB2YWxpZFNsb3RDb250ZW50LmtleTtcbiAgY29uc3QgcmVuZGVyZWQgPSBjcmVhdGVCbG9jayhcbiAgICBGcmFnbWVudCxcbiAgICB7XG4gICAgICBrZXk6IChzbG90S2V5ICYmICFpc1N5bWJvbChzbG90S2V5KSA/IHNsb3RLZXkgOiBgXyR7bmFtZX1gKSArIC8vICM3MjU2IGZvcmNlIGRpZmZlcmVudGlhdGUgZmFsbGJhY2sgY29udGVudCBmcm9tIGFjdHVhbCBjb250ZW50XG4gICAgICAoIXZhbGlkU2xvdENvbnRlbnQgJiYgZmFsbGJhY2sgPyBcIl9mYlwiIDogXCJcIilcbiAgICB9LFxuICAgIHZhbGlkU2xvdENvbnRlbnQgfHwgKGZhbGxiYWNrID8gZmFsbGJhY2soKSA6IFtdKSxcbiAgICB2YWxpZFNsb3RDb250ZW50ICYmIHNsb3RzLl8gPT09IDEgPyA2NCA6IC0yXG4gICk7XG4gIGlmICghbm9TbG90dGVkICYmIHJlbmRlcmVkLnNjb3BlSWQpIHtcbiAgICByZW5kZXJlZC5zbG90U2NvcGVJZHMgPSBbcmVuZGVyZWQuc2NvcGVJZCArIFwiLXNcIl07XG4gIH1cbiAgaWYgKHNsb3QgJiYgc2xvdC5fYykge1xuICAgIHNsb3QuX2QgPSB0cnVlO1xuICB9XG4gIHJldHVybiByZW5kZXJlZDtcbn1cbmZ1bmN0aW9uIGVuc3VyZVZhbGlkVk5vZGUodm5vZGVzKSB7XG4gIHJldHVybiB2bm9kZXMuc29tZSgoY2hpbGQpID0+IHtcbiAgICBpZiAoIWlzVk5vZGUoY2hpbGQpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gQ29tbWVudCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChjaGlsZC50eXBlID09PSBGcmFnbWVudCAmJiAhZW5zdXJlVmFsaWRWTm9kZShjaGlsZC5jaGlsZHJlbikpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pID8gdm5vZGVzIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gdG9IYW5kbGVycyhvYmosIHByZXNlcnZlQ2FzZUlmTmVjZXNzYXJ5KSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNPYmplY3Qob2JqKSkge1xuICAgIHdhcm4kMShgdi1vbiB3aXRoIG5vIGFyZ3VtZW50IGV4cGVjdHMgYW4gb2JqZWN0IHZhbHVlLmApO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgcmV0W3ByZXNlcnZlQ2FzZUlmTmVjZXNzYXJ5ICYmIC9bQS1aXS8udGVzdChrZXkpID8gYG9uOiR7a2V5fWAgOiB0b0hhbmRsZXJLZXkoa2V5KV0gPSBvYmpba2V5XTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5jb25zdCBnZXRQdWJsaWNJbnN0YW5jZSA9IChpKSA9PiB7XG4gIGlmICghaSkgcmV0dXJuIG51bGw7XG4gIGlmIChpc1N0YXRlZnVsQ29tcG9uZW50KGkpKSByZXR1cm4gZ2V0Q29tcG9uZW50UHVibGljSW5zdGFuY2UoaSk7XG4gIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShpLnBhcmVudCk7XG59O1xuY29uc3QgcHVibGljUHJvcGVydGllc01hcCA9IChcbiAgLy8gTW92ZSBQVVJFIG1hcmtlciB0byBuZXcgbGluZSB0byB3b3JrYXJvdW5kIGNvbXBpbGVyIGRpc2NhcmRpbmcgaXRcbiAgLy8gZHVlIHRvIHR5cGUgYW5ub3RhdGlvblxuICAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgJDogKGkpID0+IGksXG4gICAgJGVsOiAoaSkgPT4gaS52bm9kZS5lbCxcbiAgICAkZGF0YTogKGkpID0+IGkuZGF0YSxcbiAgICAkcHJvcHM6IChpKSA9PiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGkucHJvcHMpIDogaS5wcm9wcyxcbiAgICAkYXR0cnM6IChpKSA9PiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGkuYXR0cnMpIDogaS5hdHRycyxcbiAgICAkc2xvdHM6IChpKSA9PiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGkuc2xvdHMpIDogaS5zbG90cyxcbiAgICAkcmVmczogKGkpID0+ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkoaS5yZWZzKSA6IGkucmVmcyxcbiAgICAkcGFyZW50OiAoaSkgPT4gZ2V0UHVibGljSW5zdGFuY2UoaS5wYXJlbnQpLFxuICAgICRyb290OiAoaSkgPT4gZ2V0UHVibGljSW5zdGFuY2UoaS5yb290KSxcbiAgICAkaG9zdDogKGkpID0+IGkuY2UsXG4gICAgJGVtaXQ6IChpKSA9PiBpLmVtaXQsXG4gICAgJG9wdGlvbnM6IChpKSA9PiBfX1ZVRV9PUFRJT05TX0FQSV9fID8gcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaSkgOiBpLnR5cGUsXG4gICAgJGZvcmNlVXBkYXRlOiAoaSkgPT4gaS5mIHx8IChpLmYgPSAoKSA9PiB7XG4gICAgICBxdWV1ZUpvYihpLnVwZGF0ZSk7XG4gICAgfSksXG4gICAgJG5leHRUaWNrOiAoaSkgPT4gaS5uIHx8IChpLm4gPSBuZXh0VGljay5iaW5kKGkucHJveHkpKSxcbiAgICAkd2F0Y2g6IChpKSA9PiBfX1ZVRV9PUFRJT05TX0FQSV9fID8gaW5zdGFuY2VXYXRjaC5iaW5kKGkpIDogTk9PUFxuICB9KVxuKTtcbmNvbnN0IGlzUmVzZXJ2ZWRQcmVmaXggPSAoa2V5KSA9PiBrZXkgPT09IFwiX1wiIHx8IGtleSA9PT0gXCIkXCI7XG5jb25zdCBoYXNTZXR1cEJpbmRpbmcgPSAoc3RhdGUsIGtleSkgPT4gc3RhdGUgIT09IEVNUFRZX09CSiAmJiAhc3RhdGUuX19pc1NjcmlwdFNldHVwICYmIGhhc093bihzdGF0ZSwga2V5KTtcbmNvbnN0IFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyA9IHtcbiAgZ2V0KHsgXzogaW5zdGFuY2UgfSwga2V5KSB7XG4gICAgaWYgKGtleSA9PT0gXCJfX3Zfc2tpcFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgeyBjdHgsIHNldHVwU3RhdGUsIGRhdGEsIHByb3BzLCBhY2Nlc3NDYWNoZSwgdHlwZSwgYXBwQ29udGV4dCB9ID0gaW5zdGFuY2U7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYga2V5ID09PSBcIl9faXNWdWVcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBub3JtYWxpemVkUHJvcHM7XG4gICAgaWYgKGtleVswXSAhPT0gXCIkXCIpIHtcbiAgICAgIGNvbnN0IG4gPSBhY2Nlc3NDYWNoZVtrZXldO1xuICAgICAgaWYgKG4gIT09IHZvaWQgMCkge1xuICAgICAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgICBjYXNlIDEgLyogU0VUVVAgKi86XG4gICAgICAgICAgICByZXR1cm4gc2V0dXBTdGF0ZVtrZXldO1xuICAgICAgICAgIGNhc2UgMiAvKiBEQVRBICovOlxuICAgICAgICAgICAgcmV0dXJuIGRhdGFba2V5XTtcbiAgICAgICAgICBjYXNlIDQgLyogQ09OVEVYVCAqLzpcbiAgICAgICAgICAgIHJldHVybiBjdHhba2V5XTtcbiAgICAgICAgICBjYXNlIDMgLyogUFJPUFMgKi86XG4gICAgICAgICAgICByZXR1cm4gcHJvcHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChoYXNTZXR1cEJpbmRpbmcoc2V0dXBTdGF0ZSwga2V5KSkge1xuICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMSAvKiBTRVRVUCAqLztcbiAgICAgICAgcmV0dXJuIHNldHVwU3RhdGVba2V5XTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihkYXRhLCBrZXkpKSB7XG4gICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAyIC8qIERBVEEgKi87XG4gICAgICAgIHJldHVybiBkYXRhW2tleV07XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAvLyBvbmx5IGNhY2hlIG90aGVyIHByb3BlcnRpZXMgd2hlbiBpbnN0YW5jZSBoYXMgZGVjbGFyZWQgKHRodXMgc3RhYmxlKVxuICAgICAgICAvLyBwcm9wc1xuICAgICAgICAobm9ybWFsaXplZFByb3BzID0gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdKSAmJiBoYXNPd24obm9ybWFsaXplZFByb3BzLCBrZXkpXG4gICAgICApIHtcbiAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDMgLyogUFJPUFMgKi87XG4gICAgICAgIHJldHVybiBwcm9wc1trZXldO1xuICAgICAgfSBlbHNlIGlmIChjdHggIT09IEVNUFRZX09CSiAmJiBoYXNPd24oY3R4LCBrZXkpKSB7XG4gICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSA0IC8qIENPTlRFWFQgKi87XG4gICAgICAgIHJldHVybiBjdHhba2V5XTtcbiAgICAgIH0gZWxzZSBpZiAoIV9fVlVFX09QVElPTlNfQVBJX18gfHwgc2hvdWxkQ2FjaGVBY2Nlc3MpIHtcbiAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDAgLyogT1RIRVIgKi87XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHB1YmxpY0dldHRlciA9IHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XTtcbiAgICBsZXQgY3NzTW9kdWxlLCBnbG9iYWxQcm9wZXJ0aWVzO1xuICAgIGlmIChwdWJsaWNHZXR0ZXIpIHtcbiAgICAgIGlmIChrZXkgPT09IFwiJGF0dHJzXCIpIHtcbiAgICAgICAgdHJhY2soaW5zdGFuY2UuYXR0cnMsIFwiZ2V0XCIsIFwiXCIpO1xuICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XG4gICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYga2V5ID09PSBcIiRzbG90c1wiKSB7XG4gICAgICAgIHRyYWNrKGluc3RhbmNlLCBcImdldFwiLCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHB1YmxpY0dldHRlcihpbnN0YW5jZSk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIC8vIGNzcyBtb2R1bGUgKGluamVjdGVkIGJ5IHZ1ZS1sb2FkZXIpXG4gICAgICAoY3NzTW9kdWxlID0gdHlwZS5fX2Nzc01vZHVsZXMpICYmIChjc3NNb2R1bGUgPSBjc3NNb2R1bGVba2V5XSlcbiAgICApIHtcbiAgICAgIHJldHVybiBjc3NNb2R1bGU7XG4gICAgfSBlbHNlIGlmIChjdHggIT09IEVNUFRZX09CSiAmJiBoYXNPd24oY3R4LCBrZXkpKSB7XG4gICAgICBhY2Nlc3NDYWNoZVtrZXldID0gNCAvKiBDT05URVhUICovO1xuICAgICAgcmV0dXJuIGN0eFtrZXldO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAvLyBnbG9iYWwgcHJvcGVydGllc1xuICAgICAgZ2xvYmFsUHJvcGVydGllcyA9IGFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMsIGhhc093bihnbG9iYWxQcm9wZXJ0aWVzLCBrZXkpXG4gICAgKSB7XG4gICAgICB7XG4gICAgICAgIHJldHVybiBnbG9iYWxQcm9wZXJ0aWVzW2tleV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSAmJiAoIWlzU3RyaW5nKGtleSkgfHwgLy8gIzEwOTEgYXZvaWQgaW50ZXJuYWwgaXNSZWYvaXNWTm9kZSBjaGVja3Mgb24gY29tcG9uZW50IGluc3RhbmNlIGxlYWRpbmdcbiAgICAvLyB0byBpbmZpbml0ZSB3YXJuaW5nIGxvb3BcbiAgICBrZXkuaW5kZXhPZihcIl9fdlwiKSAhPT0gMCkpIHtcbiAgICAgIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaXNSZXNlcnZlZFByZWZpeChrZXlbMF0pICYmIGhhc093bihkYXRhLCBrZXkpKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIGtleVxuICAgICAgICAgICl9IG11c3QgYmUgYWNjZXNzZWQgdmlhICRkYXRhIGJlY2F1c2UgaXQgc3RhcnRzIHdpdGggYSByZXNlcnZlZCBjaGFyYWN0ZXIgKFwiJFwiIG9yIFwiX1wiKSBhbmQgaXMgbm90IHByb3hpZWQgb24gdGhlIHJlbmRlciBjb250ZXh0LmBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5zdGFuY2UgPT09IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSkge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYFByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoa2V5KX0gd2FzIGFjY2Vzc2VkIGR1cmluZyByZW5kZXIgYnV0IGlzIG5vdCBkZWZpbmVkIG9uIGluc3RhbmNlLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHNldCh7IF86IGluc3RhbmNlIH0sIGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCB7IGRhdGEsIHNldHVwU3RhdGUsIGN0eCB9ID0gaW5zdGFuY2U7XG4gICAgaWYgKGhhc1NldHVwQmluZGluZyhzZXR1cFN0YXRlLCBrZXkpKSB7XG4gICAgICBzZXR1cFN0YXRlW2tleV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzZXR1cFN0YXRlLl9faXNTY3JpcHRTZXR1cCAmJiBoYXNPd24oc2V0dXBTdGF0ZSwga2V5KSkge1xuICAgICAgd2FybiQxKGBDYW5ub3QgbXV0YXRlIDxzY3JpcHQgc2V0dXA+IGJpbmRpbmcgXCIke2tleX1cIiBmcm9tIE9wdGlvbnMgQVBJLmApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoZGF0YSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihkYXRhLCBrZXkpKSB7XG4gICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoaGFzT3duKGluc3RhbmNlLnByb3BzLCBrZXkpKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShgQXR0ZW1wdGluZyB0byBtdXRhdGUgcHJvcCBcIiR7a2V5fVwiLiBQcm9wcyBhcmUgcmVhZG9ubHkuYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChrZXlbMF0gPT09IFwiJFwiICYmIGtleS5zbGljZSgxKSBpbiBpbnN0YW5jZSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuJDEoXG4gICAgICAgIGBBdHRlbXB0aW5nIHRvIG11dGF0ZSBwdWJsaWMgcHJvcGVydHkgXCIke2tleX1cIi4gUHJvcGVydGllcyBzdGFydGluZyB3aXRoICQgYXJlIHJlc2VydmVkIGFuZCByZWFkb25seS5gXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBrZXkgaW4gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBoYXMoe1xuICAgIF86IHsgZGF0YSwgc2V0dXBTdGF0ZSwgYWNjZXNzQ2FjaGUsIGN0eCwgYXBwQ29udGV4dCwgcHJvcHNPcHRpb25zIH1cbiAgfSwga2V5KSB7XG4gICAgbGV0IG5vcm1hbGl6ZWRQcm9wcztcbiAgICByZXR1cm4gISFhY2Nlc3NDYWNoZVtrZXldIHx8IGRhdGEgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oZGF0YSwga2V5KSB8fCBoYXNTZXR1cEJpbmRpbmcoc2V0dXBTdGF0ZSwga2V5KSB8fCAobm9ybWFsaXplZFByb3BzID0gcHJvcHNPcHRpb25zWzBdKSAmJiBoYXNPd24obm9ybWFsaXplZFByb3BzLCBrZXkpIHx8IGhhc093bihjdHgsIGtleSkgfHwgaGFzT3duKHB1YmxpY1Byb3BlcnRpZXNNYXAsIGtleSkgfHwgaGFzT3duKGFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMsIGtleSk7XG4gIH0sXG4gIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgaWYgKGRlc2NyaXB0b3IuZ2V0ICE9IG51bGwpIHtcbiAgICAgIHRhcmdldC5fLmFjY2Vzc0NhY2hlW2tleV0gPSAwO1xuICAgIH0gZWxzZSBpZiAoaGFzT3duKGRlc2NyaXB0b3IsIFwidmFsdWVcIikpIHtcbiAgICAgIHRoaXMuc2V0KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yLnZhbHVlLCBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpO1xuICB9XG59O1xuaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdHJ1ZSkge1xuICBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMub3duS2V5cyA9ICh0YXJnZXQpID0+IHtcbiAgICB3YXJuJDEoXG4gICAgICBgQXZvaWQgYXBwIGxvZ2ljIHRoYXQgcmVsaWVzIG9uIGVudW1lcmF0aW5nIGtleXMgb24gYSBjb21wb25lbnQgaW5zdGFuY2UuIFRoZSBrZXlzIHdpbGwgYmUgZW1wdHkgaW4gcHJvZHVjdGlvbiBtb2RlIHRvIGF2b2lkIHBlcmZvcm1hbmNlIG92ZXJoZWFkLmBcbiAgICApO1xuICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcbiAgfTtcbn1cbmNvbnN0IFJ1bnRpbWVDb21waWxlZFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBleHRlbmQoe30sIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycywge1xuICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAoa2V5ID09PSBTeW1ib2wudW5zY29wYWJsZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5nZXQodGFyZ2V0LCBrZXksIHRhcmdldCk7XG4gIH0sXG4gIGhhcyhfLCBrZXkpIHtcbiAgICBjb25zdCBoYXMgPSBrZXlbMF0gIT09IFwiX1wiICYmICFpc0dsb2JhbGx5QWxsb3dlZChrZXkpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFoYXMgJiYgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLmhhcyhfLCBrZXkpKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIGtleVxuICAgICAgICApfSBzaG91bGQgbm90IHN0YXJ0IHdpdGggXyB3aGljaCBpcyBhIHJlc2VydmVkIHByZWZpeCBmb3IgVnVlIGludGVybmFscy5gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gaGFzO1xuICB9XG59KTtcbmZ1bmN0aW9uIGNyZWF0ZURldlJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcbiAgY29uc3QgdGFyZ2V0ID0ge307XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGBfYCwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQ6ICgpID0+IGluc3RhbmNlXG4gIH0pO1xuICBPYmplY3Qua2V5cyhwdWJsaWNQcm9wZXJ0aWVzTWFwKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiAoKSA9PiBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV0oaW5zdGFuY2UpLFxuICAgICAgLy8gaW50ZXJjZXB0ZWQgYnkgdGhlIHByb3h5IHNvIG5vIG5lZWQgZm9yIGltcGxlbWVudGF0aW9uLFxuICAgICAgLy8gYnV0IG5lZWRlZCB0byBwcmV2ZW50IHNldCBlcnJvcnNcbiAgICAgIHNldDogTk9PUFxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIGV4cG9zZVByb3BzT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKSB7XG4gIGNvbnN0IHtcbiAgICBjdHgsXG4gICAgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXVxuICB9ID0gaW5zdGFuY2U7XG4gIGlmIChwcm9wc09wdGlvbnMpIHtcbiAgICBPYmplY3Qua2V5cyhwcm9wc09wdGlvbnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiBpbnN0YW5jZS5wcm9wc1trZXldLFxuICAgICAgICBzZXQ6IE5PT1BcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBleHBvc2VTZXR1cFN0YXRlT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKSB7XG4gIGNvbnN0IHsgY3R4LCBzZXR1cFN0YXRlIH0gPSBpbnN0YW5jZTtcbiAgT2JqZWN0LmtleXModG9SYXcoc2V0dXBTdGF0ZSkpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmICghc2V0dXBTdGF0ZS5fX2lzU2NyaXB0U2V0dXApIHtcbiAgICAgIGlmIChpc1Jlc2VydmVkUHJlZml4KGtleVswXSkpIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGBzZXR1cCgpIHJldHVybiBwcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAga2V5XG4gICAgICAgICAgKX0gc2hvdWxkIG5vdCBzdGFydCB3aXRoIFwiJFwiIG9yIFwiX1wiIHdoaWNoIGFyZSByZXNlcnZlZCBwcmVmaXhlcyBmb3IgVnVlIGludGVybmFscy5gXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gc2V0dXBTdGF0ZVtrZXldLFxuICAgICAgICBzZXQ6IE5PT1BcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmNvbnN0IHdhcm5SdW50aW1lVXNhZ2UgPSAobWV0aG9kKSA9PiB3YXJuJDEoXG4gIGAke21ldGhvZH0oKSBpcyBhIGNvbXBpbGVyLWhpbnQgaGVscGVyIHRoYXQgaXMgb25seSB1c2FibGUgaW5zaWRlIDxzY3JpcHQgc2V0dXA+IG9mIGEgc2luZ2xlIGZpbGUgY29tcG9uZW50LiBJdHMgYXJndW1lbnRzIHNob3VsZCBiZSBjb21waWxlZCBhd2F5IGFuZCBwYXNzaW5nIGl0IGF0IHJ1bnRpbWUgaGFzIG5vIGVmZmVjdC5gXG4pO1xuZnVuY3Rpb24gZGVmaW5lUHJvcHMoKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lUHJvcHNgKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGRlZmluZUVtaXRzKCkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZUVtaXRzYCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBkZWZpbmVFeHBvc2UoZXhwb3NlZCkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZUV4cG9zZWApO1xuICB9XG59XG5mdW5jdGlvbiBkZWZpbmVPcHRpb25zKG9wdGlvbnMpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVPcHRpb25zYCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZmluZVNsb3RzKCkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZVNsb3RzYCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBkZWZpbmVNb2RlbCgpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKFwiZGVmaW5lTW9kZWxcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIHdpdGhEZWZhdWx0cyhwcm9wcywgZGVmYXVsdHMpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKGB3aXRoRGVmYXVsdHNgKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHVzZVNsb3RzKCkge1xuICByZXR1cm4gZ2V0Q29udGV4dCgpLnNsb3RzO1xufVxuZnVuY3Rpb24gdXNlQXR0cnMoKSB7XG4gIHJldHVybiBnZXRDb250ZXh0KCkuYXR0cnM7XG59XG5mdW5jdGlvbiBnZXRDb250ZXh0KCkge1xuICBjb25zdCBpID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpKSB7XG4gICAgd2FybiQxKGB1c2VDb250ZXh0KCkgY2FsbGVkIHdpdGhvdXQgYWN0aXZlIGluc3RhbmNlLmApO1xuICB9XG4gIHJldHVybiBpLnNldHVwQ29udGV4dCB8fCAoaS5zZXR1cENvbnRleHQgPSBjcmVhdGVTZXR1cENvbnRleHQoaSkpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHNPckVtaXRzKHByb3BzKSB7XG4gIHJldHVybiBpc0FycmF5KHByb3BzKSA/IHByb3BzLnJlZHVjZShcbiAgICAobm9ybWFsaXplZCwgcCkgPT4gKG5vcm1hbGl6ZWRbcF0gPSBudWxsLCBub3JtYWxpemVkKSxcbiAgICB7fVxuICApIDogcHJvcHM7XG59XG5mdW5jdGlvbiBtZXJnZURlZmF1bHRzKHJhdywgZGVmYXVsdHMpIHtcbiAgY29uc3QgcHJvcHMgPSBub3JtYWxpemVQcm9wc09yRW1pdHMocmF3KTtcbiAgZm9yIChjb25zdCBrZXkgaW4gZGVmYXVsdHMpIHtcbiAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCJfX3NraXBcIikpIGNvbnRpbnVlO1xuICAgIGxldCBvcHQgPSBwcm9wc1trZXldO1xuICAgIGlmIChvcHQpIHtcbiAgICAgIGlmIChpc0FycmF5KG9wdCkgfHwgaXNGdW5jdGlvbihvcHQpKSB7XG4gICAgICAgIG9wdCA9IHByb3BzW2tleV0gPSB7IHR5cGU6IG9wdCwgZGVmYXVsdDogZGVmYXVsdHNba2V5XSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0LmRlZmF1bHQgPSBkZWZhdWx0c1trZXldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0ID09PSBudWxsKSB7XG4gICAgICBvcHQgPSBwcm9wc1trZXldID0geyBkZWZhdWx0OiBkZWZhdWx0c1trZXldIH07XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuJDEoYHByb3BzIGRlZmF1bHQga2V5IFwiJHtrZXl9XCIgaGFzIG5vIGNvcnJlc3BvbmRpbmcgZGVjbGFyYXRpb24uYCk7XG4gICAgfVxuICAgIGlmIChvcHQgJiYgZGVmYXVsdHNbYF9fc2tpcF8ke2tleX1gXSkge1xuICAgICAgb3B0LnNraXBGYWN0b3J5ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3BzO1xufVxuZnVuY3Rpb24gbWVyZ2VNb2RlbHMoYSwgYikge1xuICBpZiAoIWEgfHwgIWIpIHJldHVybiBhIHx8IGI7XG4gIGlmIChpc0FycmF5KGEpICYmIGlzQXJyYXkoYikpIHJldHVybiBhLmNvbmNhdChiKTtcbiAgcmV0dXJuIGV4dGVuZCh7fSwgbm9ybWFsaXplUHJvcHNPckVtaXRzKGEpLCBub3JtYWxpemVQcm9wc09yRW1pdHMoYikpO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJvcHNSZXN0UHJveHkocHJvcHMsIGV4Y2x1ZGVkS2V5cykge1xuICBjb25zdCByZXQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoIWV4Y2x1ZGVkS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmV0LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiBwcm9wc1trZXldXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHdpdGhBc3luY0NvbnRleHQoZ2V0QXdhaXRhYmxlKSB7XG4gIGNvbnN0IGN0eCA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhY3R4KSB7XG4gICAgd2FybiQxKFxuICAgICAgYHdpdGhBc3luY0NvbnRleHQgY2FsbGVkIHdpdGhvdXQgYWN0aXZlIGN1cnJlbnQgaW5zdGFuY2UuIFRoaXMgaXMgbGlrZWx5IGEgYnVnLmBcbiAgICApO1xuICB9XG4gIGxldCBhd2FpdGFibGUgPSBnZXRBd2FpdGFibGUoKTtcbiAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKGlzUHJvbWlzZShhd2FpdGFibGUpKSB7XG4gICAgYXdhaXRhYmxlID0gYXdhaXRhYmxlLmNhdGNoKChlKSA9PiB7XG4gICAgICBzZXRDdXJyZW50SW5zdGFuY2UoY3R4KTtcbiAgICAgIHRocm93IGU7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIFthd2FpdGFibGUsICgpID0+IHNldEN1cnJlbnRJbnN0YW5jZShjdHgpXTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRHVwbGljYXRlQ2hlY2tlcigpIHtcbiAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuICh0eXBlLCBrZXkpID0+IHtcbiAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgd2FybiQxKGAke3R5cGV9IHByb3BlcnR5IFwiJHtrZXl9XCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluICR7Y2FjaGVba2V5XX0uYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhY2hlW2tleV0gPSB0eXBlO1xuICAgIH1cbiAgfTtcbn1cbmxldCBzaG91bGRDYWNoZUFjY2VzcyA9IHRydWU7XG5mdW5jdGlvbiBhcHBseU9wdGlvbnMoaW5zdGFuY2UpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHJlc29sdmVNZXJnZWRPcHRpb25zKGluc3RhbmNlKTtcbiAgY29uc3QgcHVibGljVGhpcyA9IGluc3RhbmNlLnByb3h5O1xuICBjb25zdCBjdHggPSBpbnN0YW5jZS5jdHg7XG4gIHNob3VsZENhY2hlQWNjZXNzID0gZmFsc2U7XG4gIGlmIChvcHRpb25zLmJlZm9yZUNyZWF0ZSkge1xuICAgIGNhbGxIb29rKG9wdGlvbnMuYmVmb3JlQ3JlYXRlLCBpbnN0YW5jZSwgXCJiY1wiKTtcbiAgfVxuICBjb25zdCB7XG4gICAgLy8gc3RhdGVcbiAgICBkYXRhOiBkYXRhT3B0aW9ucyxcbiAgICBjb21wdXRlZDogY29tcHV0ZWRPcHRpb25zLFxuICAgIG1ldGhvZHMsXG4gICAgd2F0Y2g6IHdhdGNoT3B0aW9ucyxcbiAgICBwcm92aWRlOiBwcm92aWRlT3B0aW9ucyxcbiAgICBpbmplY3Q6IGluamVjdE9wdGlvbnMsXG4gICAgLy8gbGlmZWN5Y2xlXG4gICAgY3JlYXRlZCxcbiAgICBiZWZvcmVNb3VudCxcbiAgICBtb3VudGVkLFxuICAgIGJlZm9yZVVwZGF0ZSxcbiAgICB1cGRhdGVkLFxuICAgIGFjdGl2YXRlZCxcbiAgICBkZWFjdGl2YXRlZCxcbiAgICBiZWZvcmVEZXN0cm95LFxuICAgIGJlZm9yZVVubW91bnQsXG4gICAgZGVzdHJveWVkLFxuICAgIHVubW91bnRlZCxcbiAgICByZW5kZXIsXG4gICAgcmVuZGVyVHJhY2tlZCxcbiAgICByZW5kZXJUcmlnZ2VyZWQsXG4gICAgZXJyb3JDYXB0dXJlZCxcbiAgICBzZXJ2ZXJQcmVmZXRjaCxcbiAgICAvLyBwdWJsaWMgQVBJXG4gICAgZXhwb3NlLFxuICAgIGluaGVyaXRBdHRycyxcbiAgICAvLyBhc3NldHNcbiAgICBjb21wb25lbnRzLFxuICAgIGRpcmVjdGl2ZXMsXG4gICAgZmlsdGVyc1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGNyZWF0ZUR1cGxpY2F0ZUNoZWNrZXIoKSA6IG51bGw7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY29uc3QgW3Byb3BzT3B0aW9uc10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XG4gICAgaWYgKHByb3BzT3B0aW9ucykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHNPcHRpb25zKSB7XG4gICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIlByb3BzXCIgLyogUFJPUFMgKi8sIGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChpbmplY3RPcHRpb25zKSB7XG4gICAgcmVzb2x2ZUluamVjdGlvbnMoaW5qZWN0T3B0aW9ucywgY3R4LCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMpO1xuICB9XG4gIGlmIChtZXRob2RzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbWV0aG9kcykge1xuICAgICAgY29uc3QgbWV0aG9kSGFuZGxlciA9IG1ldGhvZHNba2V5XTtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKG1ldGhvZEhhbmRsZXIpKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogbWV0aG9kSGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4W2tleV0gPSBtZXRob2RIYW5kbGVyLmJpbmQocHVibGljVGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJNZXRob2RzXCIgLyogTUVUSE9EUyAqLywga2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBgTWV0aG9kIFwiJHtrZXl9XCIgaGFzIHR5cGUgXCIke3R5cGVvZiBtZXRob2RIYW5kbGVyfVwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChkYXRhT3B0aW9ucykge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc0Z1bmN0aW9uKGRhdGFPcHRpb25zKSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgVGhlIGRhdGEgb3B0aW9uIG11c3QgYmUgYSBmdW5jdGlvbi4gUGxhaW4gb2JqZWN0IHVzYWdlIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGRhdGFPcHRpb25zLmNhbGwocHVibGljVGhpcywgcHVibGljVGhpcyk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNQcm9taXNlKGRhdGEpKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBkYXRhKCkgcmV0dXJuZWQgYSBQcm9taXNlIC0gbm90ZSBkYXRhKCkgY2Fubm90IGJlIGFzeW5jOyBJZiB5b3UgaW50ZW5kIHRvIHBlcmZvcm0gZGF0YSBmZXRjaGluZyBiZWZvcmUgY29tcG9uZW50IHJlbmRlcnMsIHVzZSBhc3luYyBzZXR1cCgpICsgPFN1c3BlbnNlPi5gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShgZGF0YSgpIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LmApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZS5kYXRhID0gcmVhY3RpdmUoZGF0YSk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiRGF0YVwiIC8qIERBVEEgKi8sIGtleSk7XG4gICAgICAgICAgaWYgKCFpc1Jlc2VydmVkUHJlZml4KGtleVswXSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIGdldDogKCkgPT4gZGF0YVtrZXldLFxuICAgICAgICAgICAgICBzZXQ6IE5PT1BcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBzaG91bGRDYWNoZUFjY2VzcyA9IHRydWU7XG4gIGlmIChjb21wdXRlZE9wdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjb21wdXRlZE9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IG9wdCA9IGNvbXB1dGVkT3B0aW9uc1trZXldO1xuICAgICAgY29uc3QgZ2V0ID0gaXNGdW5jdGlvbihvcHQpID8gb3B0LmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcykgOiBpc0Z1bmN0aW9uKG9wdC5nZXQpID8gb3B0LmdldC5iaW5kKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpIDogTk9PUDtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGdldCA9PT0gTk9PUCkge1xuICAgICAgICB3YXJuJDEoYENvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgaGFzIG5vIGdldHRlci5gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNldCA9ICFpc0Z1bmN0aW9uKG9wdCkgJiYgaXNGdW5jdGlvbihvcHQuc2V0KSA/IG9wdC5zZXQuYmluZChwdWJsaWNUaGlzKSA6ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyAoKSA9PiB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBgV3JpdGUgb3BlcmF0aW9uIGZhaWxlZDogY29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBpcyByZWFkb25seS5gXG4gICAgICAgICk7XG4gICAgICB9IDogTk9PUDtcbiAgICAgIGNvbnN0IGMgPSBjb21wdXRlZCh7XG4gICAgICAgIGdldCxcbiAgICAgICAgc2V0XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gYy52YWx1ZSxcbiAgICAgICAgc2V0OiAodikgPT4gYy52YWx1ZSA9IHZcbiAgICAgIH0pO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiQ29tcHV0ZWRcIiAvKiBDT01QVVRFRCAqLywga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHdhdGNoT3B0aW9ucykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHdhdGNoT3B0aW9ucykge1xuICAgICAgY3JlYXRlV2F0Y2hlcih3YXRjaE9wdGlvbnNba2V5XSwgY3R4LCBwdWJsaWNUaGlzLCBrZXkpO1xuICAgIH1cbiAgfVxuICBpZiAocHJvdmlkZU9wdGlvbnMpIHtcbiAgICBjb25zdCBwcm92aWRlcyA9IGlzRnVuY3Rpb24ocHJvdmlkZU9wdGlvbnMpID8gcHJvdmlkZU9wdGlvbnMuY2FsbChwdWJsaWNUaGlzKSA6IHByb3ZpZGVPcHRpb25zO1xuICAgIFJlZmxlY3Qub3duS2V5cyhwcm92aWRlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBwcm92aWRlKGtleSwgcHJvdmlkZXNba2V5XSk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKGNyZWF0ZWQpIHtcbiAgICBjYWxsSG9vayhjcmVhdGVkLCBpbnN0YW5jZSwgXCJjXCIpO1xuICB9XG4gIGZ1bmN0aW9uIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhyZWdpc3RlciwgaG9vaykge1xuICAgIGlmIChpc0FycmF5KGhvb2spKSB7XG4gICAgICBob29rLmZvckVhY2goKF9ob29rKSA9PiByZWdpc3RlcihfaG9vay5iaW5kKHB1YmxpY1RoaXMpKSk7XG4gICAgfSBlbHNlIGlmIChob29rKSB7XG4gICAgICByZWdpc3Rlcihob29rLmJpbmQocHVibGljVGhpcykpO1xuICAgIH1cbiAgfVxuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVNb3VudCwgYmVmb3JlTW91bnQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25Nb3VudGVkLCBtb3VudGVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQmVmb3JlVXBkYXRlLCBiZWZvcmVVcGRhdGUpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25VcGRhdGVkLCB1cGRhdGVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQWN0aXZhdGVkLCBhY3RpdmF0ZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25EZWFjdGl2YXRlZCwgZGVhY3RpdmF0ZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25FcnJvckNhcHR1cmVkLCBlcnJvckNhcHR1cmVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uUmVuZGVyVHJhY2tlZCwgcmVuZGVyVHJhY2tlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblJlbmRlclRyaWdnZXJlZCwgcmVuZGVyVHJpZ2dlcmVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQmVmb3JlVW5tb3VudCwgYmVmb3JlVW5tb3VudCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblVubW91bnRlZCwgdW5tb3VudGVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uU2VydmVyUHJlZmV0Y2gsIHNlcnZlclByZWZldGNoKTtcbiAgaWYgKGlzQXJyYXkoZXhwb3NlKSkge1xuICAgIGlmIChleHBvc2UubGVuZ3RoKSB7XG4gICAgICBjb25zdCBleHBvc2VkID0gaW5zdGFuY2UuZXhwb3NlZCB8fCAoaW5zdGFuY2UuZXhwb3NlZCA9IHt9KTtcbiAgICAgIGV4cG9zZS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9zZWQsIGtleSwge1xuICAgICAgICAgIGdldDogKCkgPT4gcHVibGljVGhpc1trZXldLFxuICAgICAgICAgIHNldDogKHZhbCkgPT4gcHVibGljVGhpc1trZXldID0gdmFsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghaW5zdGFuY2UuZXhwb3NlZCkge1xuICAgICAgaW5zdGFuY2UuZXhwb3NlZCA9IHt9O1xuICAgIH1cbiAgfVxuICBpZiAocmVuZGVyICYmIGluc3RhbmNlLnJlbmRlciA9PT0gTk9PUCkge1xuICAgIGluc3RhbmNlLnJlbmRlciA9IHJlbmRlcjtcbiAgfVxuICBpZiAoaW5oZXJpdEF0dHJzICE9IG51bGwpIHtcbiAgICBpbnN0YW5jZS5pbmhlcml0QXR0cnMgPSBpbmhlcml0QXR0cnM7XG4gIH1cbiAgaWYgKGNvbXBvbmVudHMpIGluc3RhbmNlLmNvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICBpZiAoZGlyZWN0aXZlcykgaW5zdGFuY2UuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XG4gIGlmIChzZXJ2ZXJQcmVmZXRjaCkge1xuICAgIG1hcmtBc3luY0JvdW5kYXJ5KGluc3RhbmNlKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdGlvbnMoaW5qZWN0T3B0aW9ucywgY3R4LCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMgPSBOT09QKSB7XG4gIGlmIChpc0FycmF5KGluamVjdE9wdGlvbnMpKSB7XG4gICAgaW5qZWN0T3B0aW9ucyA9IG5vcm1hbGl6ZUluamVjdChpbmplY3RPcHRpb25zKTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBpbmplY3RPcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0ID0gaW5qZWN0T3B0aW9uc1trZXldO1xuICAgIGxldCBpbmplY3RlZDtcbiAgICBpZiAoaXNPYmplY3Qob3B0KSkge1xuICAgICAgaWYgKFwiZGVmYXVsdFwiIGluIG9wdCkge1xuICAgICAgICBpbmplY3RlZCA9IGluamVjdChcbiAgICAgICAgICBvcHQuZnJvbSB8fCBrZXksXG4gICAgICAgICAgb3B0LmRlZmF1bHQsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5qZWN0ZWQgPSBpbmplY3Qob3B0LmZyb20gfHwga2V5KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW5qZWN0ZWQgPSBpbmplY3Qob3B0KTtcbiAgICB9XG4gICAgaWYgKGlzUmVmKGluamVjdGVkKSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiBpbmplY3RlZC52YWx1ZSxcbiAgICAgICAgc2V0OiAodikgPT4gaW5qZWN0ZWQudmFsdWUgPSB2XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4W2tleV0gPSBpbmplY3RlZDtcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkluamVjdFwiIC8qIElOSkVDVCAqLywga2V5KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNhbGxIb29rKGhvb2ssIGluc3RhbmNlLCB0eXBlKSB7XG4gIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgIGlzQXJyYXkoaG9vaykgPyBob29rLm1hcCgoaCkgPT4gaC5iaW5kKGluc3RhbmNlLnByb3h5KSkgOiBob29rLmJpbmQoaW5zdGFuY2UucHJveHkpLFxuICAgIGluc3RhbmNlLFxuICAgIHR5cGVcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIocmF3LCBjdHgsIHB1YmxpY1RoaXMsIGtleSkge1xuICBsZXQgZ2V0dGVyID0ga2V5LmluY2x1ZGVzKFwiLlwiKSA/IGNyZWF0ZVBhdGhHZXR0ZXIocHVibGljVGhpcywga2V5KSA6ICgpID0+IHB1YmxpY1RoaXNba2V5XTtcbiAgaWYgKGlzU3RyaW5nKHJhdykpIHtcbiAgICBjb25zdCBoYW5kbGVyID0gY3R4W3Jhd107XG4gICAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICAgIHtcbiAgICAgICAgd2F0Y2goZ2V0dGVyLCBoYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4kMShgSW52YWxpZCB3YXRjaCBoYW5kbGVyIHNwZWNpZmllZCBieSBrZXkgXCIke3Jhd31cImAsIGhhbmRsZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHJhdykpIHtcbiAgICB7XG4gICAgICB3YXRjaChnZXR0ZXIsIHJhdy5iaW5kKHB1YmxpY1RoaXMpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QocmF3KSkge1xuICAgIGlmIChpc0FycmF5KHJhdykpIHtcbiAgICAgIHJhdy5mb3JFYWNoKChyKSA9PiBjcmVhdGVXYXRjaGVyKHIsIGN0eCwgcHVibGljVGhpcywga2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBpc0Z1bmN0aW9uKHJhdy5oYW5kbGVyKSA/IHJhdy5oYW5kbGVyLmJpbmQocHVibGljVGhpcykgOiBjdHhbcmF3LmhhbmRsZXJdO1xuICAgICAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICAgICAgd2F0Y2goZ2V0dGVyLCBoYW5kbGVyLCByYXcpO1xuICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIHdhcm4kMShgSW52YWxpZCB3YXRjaCBoYW5kbGVyIHNwZWNpZmllZCBieSBrZXkgXCIke3Jhdy5oYW5kbGVyfVwiYCwgaGFuZGxlcik7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuJDEoYEludmFsaWQgd2F0Y2ggb3B0aW9uOiBcIiR7a2V5fVwiYCwgcmF3KTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaW5zdGFuY2UpIHtcbiAgY29uc3QgYmFzZSA9IGluc3RhbmNlLnR5cGU7XG4gIGNvbnN0IHsgbWl4aW5zLCBleHRlbmRzOiBleHRlbmRzT3B0aW9ucyB9ID0gYmFzZTtcbiAgY29uc3Qge1xuICAgIG1peGluczogZ2xvYmFsTWl4aW5zLFxuICAgIG9wdGlvbnNDYWNoZTogY2FjaGUsXG4gICAgY29uZmlnOiB7IG9wdGlvbk1lcmdlU3RyYXRlZ2llcyB9XG4gIH0gPSBpbnN0YW5jZS5hcHBDb250ZXh0O1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoYmFzZSk7XG4gIGxldCByZXNvbHZlZDtcbiAgaWYgKGNhY2hlZCkge1xuICAgIHJlc29sdmVkID0gY2FjaGVkO1xuICB9IGVsc2UgaWYgKCFnbG9iYWxNaXhpbnMubGVuZ3RoICYmICFtaXhpbnMgJiYgIWV4dGVuZHNPcHRpb25zKSB7XG4gICAge1xuICAgICAgcmVzb2x2ZWQgPSBiYXNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXNvbHZlZCA9IHt9O1xuICAgIGlmIChnbG9iYWxNaXhpbnMubGVuZ3RoKSB7XG4gICAgICBnbG9iYWxNaXhpbnMuZm9yRWFjaChcbiAgICAgICAgKG0pID0+IG1lcmdlT3B0aW9ucyhyZXNvbHZlZCwgbSwgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzLCB0cnVlKVxuICAgICAgKTtcbiAgICB9XG4gICAgbWVyZ2VPcHRpb25zKHJlc29sdmVkLCBiYXNlLCBvcHRpb25NZXJnZVN0cmF0ZWdpZXMpO1xuICB9XG4gIGlmIChpc09iamVjdChiYXNlKSkge1xuICAgIGNhY2hlLnNldChiYXNlLCByZXNvbHZlZCk7XG4gIH1cbiAgcmV0dXJuIHJlc29sdmVkO1xufVxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKHRvLCBmcm9tLCBzdHJhdHMsIGFzTWl4aW4gPSBmYWxzZSkge1xuICBjb25zdCB7IG1peGlucywgZXh0ZW5kczogZXh0ZW5kc09wdGlvbnMgfSA9IGZyb207XG4gIGlmIChleHRlbmRzT3B0aW9ucykge1xuICAgIG1lcmdlT3B0aW9ucyh0bywgZXh0ZW5kc09wdGlvbnMsIHN0cmF0cywgdHJ1ZSk7XG4gIH1cbiAgaWYgKG1peGlucykge1xuICAgIG1peGlucy5mb3JFYWNoKFxuICAgICAgKG0pID0+IG1lcmdlT3B0aW9ucyh0bywgbSwgc3RyYXRzLCB0cnVlKVxuICAgICk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gZnJvbSkge1xuICAgIGlmIChhc01peGluICYmIGtleSA9PT0gXCJleHBvc2VcIikge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuJDEoXG4gICAgICAgIGBcImV4cG9zZVwiIG9wdGlvbiBpcyBpZ25vcmVkIHdoZW4gZGVjbGFyZWQgaW4gbWl4aW5zIG9yIGV4dGVuZHMuIEl0IHNob3VsZCBvbmx5IGJlIGRlY2xhcmVkIGluIHRoZSBiYXNlIGNvbXBvbmVudCBpdHNlbGYuYFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RyYXQgPSBpbnRlcm5hbE9wdGlvbk1lcmdlU3RyYXRzW2tleV0gfHwgc3RyYXRzICYmIHN0cmF0c1trZXldO1xuICAgICAgdG9ba2V5XSA9IHN0cmF0ID8gc3RyYXQodG9ba2V5XSwgZnJvbVtrZXldKSA6IGZyb21ba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvO1xufVxuY29uc3QgaW50ZXJuYWxPcHRpb25NZXJnZVN0cmF0cyA9IHtcbiAgZGF0YTogbWVyZ2VEYXRhRm4sXG4gIHByb3BzOiBtZXJnZUVtaXRzT3JQcm9wc09wdGlvbnMsXG4gIGVtaXRzOiBtZXJnZUVtaXRzT3JQcm9wc09wdGlvbnMsXG4gIC8vIG9iamVjdHNcbiAgbWV0aG9kczogbWVyZ2VPYmplY3RPcHRpb25zLFxuICBjb21wdXRlZDogbWVyZ2VPYmplY3RPcHRpb25zLFxuICAvLyBsaWZlY3ljbGVcbiAgYmVmb3JlQ3JlYXRlOiBtZXJnZUFzQXJyYXksXG4gIGNyZWF0ZWQ6IG1lcmdlQXNBcnJheSxcbiAgYmVmb3JlTW91bnQ6IG1lcmdlQXNBcnJheSxcbiAgbW91bnRlZDogbWVyZ2VBc0FycmF5LFxuICBiZWZvcmVVcGRhdGU6IG1lcmdlQXNBcnJheSxcbiAgdXBkYXRlZDogbWVyZ2VBc0FycmF5LFxuICBiZWZvcmVEZXN0cm95OiBtZXJnZUFzQXJyYXksXG4gIGJlZm9yZVVubW91bnQ6IG1lcmdlQXNBcnJheSxcbiAgZGVzdHJveWVkOiBtZXJnZUFzQXJyYXksXG4gIHVubW91bnRlZDogbWVyZ2VBc0FycmF5LFxuICBhY3RpdmF0ZWQ6IG1lcmdlQXNBcnJheSxcbiAgZGVhY3RpdmF0ZWQ6IG1lcmdlQXNBcnJheSxcbiAgZXJyb3JDYXB0dXJlZDogbWVyZ2VBc0FycmF5LFxuICBzZXJ2ZXJQcmVmZXRjaDogbWVyZ2VBc0FycmF5LFxuICAvLyBhc3NldHNcbiAgY29tcG9uZW50czogbWVyZ2VPYmplY3RPcHRpb25zLFxuICBkaXJlY3RpdmVzOiBtZXJnZU9iamVjdE9wdGlvbnMsXG4gIC8vIHdhdGNoXG4gIHdhdGNoOiBtZXJnZVdhdGNoT3B0aW9ucyxcbiAgLy8gcHJvdmlkZSAvIGluamVjdFxuICBwcm92aWRlOiBtZXJnZURhdGFGbixcbiAgaW5qZWN0OiBtZXJnZUluamVjdFxufTtcbmZ1bmN0aW9uIG1lcmdlRGF0YUZuKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkge1xuICAgIHJldHVybiB0bztcbiAgfVxuICBpZiAoIXRvKSB7XG4gICAgcmV0dXJuIGZyb207XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbigpIHtcbiAgICByZXR1cm4gKGV4dGVuZCkoXG4gICAgICBpc0Z1bmN0aW9uKHRvKSA/IHRvLmNhbGwodGhpcywgdGhpcykgOiB0byxcbiAgICAgIGlzRnVuY3Rpb24oZnJvbSkgPyBmcm9tLmNhbGwodGhpcywgdGhpcykgOiBmcm9tXG4gICAgKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlSW5qZWN0KHRvLCBmcm9tKSB7XG4gIHJldHVybiBtZXJnZU9iamVjdE9wdGlvbnMobm9ybWFsaXplSW5qZWN0KHRvKSwgbm9ybWFsaXplSW5qZWN0KGZyb20pKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUluamVjdChyYXcpIHtcbiAgaWYgKGlzQXJyYXkocmF3KSkge1xuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXNbcmF3W2ldXSA9IHJhd1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICByZXR1cm4gcmF3O1xufVxuZnVuY3Rpb24gbWVyZ2VBc0FycmF5KHRvLCBmcm9tKSB7XG4gIHJldHVybiB0byA/IFsuLi5uZXcgU2V0KFtdLmNvbmNhdCh0bywgZnJvbSkpXSA6IGZyb207XG59XG5mdW5jdGlvbiBtZXJnZU9iamVjdE9wdGlvbnModG8sIGZyb20pIHtcbiAgcmV0dXJuIHRvID8gZXh0ZW5kKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB0bywgZnJvbSkgOiBmcm9tO1xufVxuZnVuY3Rpb24gbWVyZ2VFbWl0c09yUHJvcHNPcHRpb25zKHRvLCBmcm9tKSB7XG4gIGlmICh0bykge1xuICAgIGlmIChpc0FycmF5KHRvKSAmJiBpc0FycmF5KGZyb20pKSB7XG4gICAgICByZXR1cm4gWy4uLi8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFsuLi50bywgLi4uZnJvbV0pXTtcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuZChcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgbm9ybWFsaXplUHJvcHNPckVtaXRzKHRvKSxcbiAgICAgIG5vcm1hbGl6ZVByb3BzT3JFbWl0cyhmcm9tICE9IG51bGwgPyBmcm9tIDoge30pXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnJvbTtcbiAgfVxufVxuZnVuY3Rpb24gbWVyZ2VXYXRjaE9wdGlvbnModG8sIGZyb20pIHtcbiAgaWYgKCF0bykgcmV0dXJuIGZyb207XG4gIGlmICghZnJvbSkgcmV0dXJuIHRvO1xuICBjb25zdCBtZXJnZWQgPSBleHRlbmQoLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHRvKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gZnJvbSkge1xuICAgIG1lcmdlZFtrZXldID0gbWVyZ2VBc0FycmF5KHRvW2tleV0sIGZyb21ba2V5XSk7XG4gIH1cbiAgcmV0dXJuIG1lcmdlZDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXBwQ29udGV4dCgpIHtcbiAgcmV0dXJuIHtcbiAgICBhcHA6IG51bGwsXG4gICAgY29uZmlnOiB7XG4gICAgICBpc05hdGl2ZVRhZzogTk8sXG4gICAgICBwZXJmb3JtYW5jZTogZmFsc2UsXG4gICAgICBnbG9iYWxQcm9wZXJ0aWVzOiB7fSxcbiAgICAgIG9wdGlvbk1lcmdlU3RyYXRlZ2llczoge30sXG4gICAgICBlcnJvckhhbmRsZXI6IHZvaWQgMCxcbiAgICAgIHdhcm5IYW5kbGVyOiB2b2lkIDAsXG4gICAgICBjb21waWxlck9wdGlvbnM6IHt9XG4gICAgfSxcbiAgICBtaXhpbnM6IFtdLFxuICAgIGNvbXBvbmVudHM6IHt9LFxuICAgIGRpcmVjdGl2ZXM6IHt9LFxuICAgIHByb3ZpZGVzOiAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICBvcHRpb25zQ2FjaGU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLFxuICAgIHByb3BzQ2FjaGU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLFxuICAgIGVtaXRzQ2FjaGU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpXG4gIH07XG59XG5sZXQgdWlkJDEgPSAwO1xuZnVuY3Rpb24gY3JlYXRlQXBwQVBJKHJlbmRlciwgaHlkcmF0ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQXBwKHJvb3RDb21wb25lbnQsIHJvb3RQcm9wcyA9IG51bGwpIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24ocm9vdENvbXBvbmVudCkpIHtcbiAgICAgIHJvb3RDb21wb25lbnQgPSBleHRlbmQoe30sIHJvb3RDb21wb25lbnQpO1xuICAgIH1cbiAgICBpZiAocm9vdFByb3BzICE9IG51bGwgJiYgIWlzT2JqZWN0KHJvb3RQcm9wcykpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKGByb290IHByb3BzIHBhc3NlZCB0byBhcHAubW91bnQoKSBtdXN0IGJlIGFuIG9iamVjdC5gKTtcbiAgICAgIHJvb3RQcm9wcyA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVBcHBDb250ZXh0KCk7XG4gICAgY29uc3QgaW5zdGFsbGVkUGx1Z2lucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICAgIGNvbnN0IHBsdWdpbkNsZWFudXBGbnMgPSBbXTtcbiAgICBsZXQgaXNNb3VudGVkID0gZmFsc2U7XG4gICAgY29uc3QgYXBwID0gY29udGV4dC5hcHAgPSB7XG4gICAgICBfdWlkOiB1aWQkMSsrLFxuICAgICAgX2NvbXBvbmVudDogcm9vdENvbXBvbmVudCxcbiAgICAgIF9wcm9wczogcm9vdFByb3BzLFxuICAgICAgX2NvbnRhaW5lcjogbnVsbCxcbiAgICAgIF9jb250ZXh0OiBjb250ZXh0LFxuICAgICAgX2luc3RhbmNlOiBudWxsLFxuICAgICAgdmVyc2lvbixcbiAgICAgIGdldCBjb25maWcoKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmNvbmZpZztcbiAgICAgIH0sXG4gICAgICBzZXQgY29uZmlnKHYpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgYXBwLmNvbmZpZyBjYW5ub3QgYmUgcmVwbGFjZWQuIE1vZGlmeSBpbmRpdmlkdWFsIG9wdGlvbnMgaW5zdGVhZC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZShwbHVnaW4sIC4uLm9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaGFzKHBsdWdpbikpIHtcbiAgICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShgUGx1Z2luIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCB0byB0YXJnZXQgYXBwLmApO1xuICAgICAgICB9IGVsc2UgaWYgKHBsdWdpbiAmJiBpc0Z1bmN0aW9uKHBsdWdpbi5pbnN0YWxsKSkge1xuICAgICAgICAgIGluc3RhbGxlZFBsdWdpbnMuYWRkKHBsdWdpbik7XG4gICAgICAgICAgcGx1Z2luLmluc3RhbGwoYXBwLCAuLi5vcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHBsdWdpbikpIHtcbiAgICAgICAgICBpbnN0YWxsZWRQbHVnaW5zLmFkZChwbHVnaW4pO1xuICAgICAgICAgIHBsdWdpbihhcHAsIC4uLm9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgQSBwbHVnaW4gbXVzdCBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3Qgd2l0aCBhbiBcImluc3RhbGxcIiBmdW5jdGlvbi5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwO1xuICAgICAgfSxcbiAgICAgIG1peGluKG1peGluKSB7XG4gICAgICAgIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fKSB7XG4gICAgICAgICAgaWYgKCFjb250ZXh0Lm1peGlucy5pbmNsdWRlcyhtaXhpbikpIHtcbiAgICAgICAgICAgIGNvbnRleHQubWl4aW5zLnB1c2gobWl4aW4pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgICBcIk1peGluIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCB0byB0YXJnZXQgYXBwXCIgKyAobWl4aW4ubmFtZSA/IGA6ICR7bWl4aW4ubmFtZX1gIDogXCJcIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuJDEoXCJNaXhpbnMgYXJlIG9ubHkgYXZhaWxhYmxlIGluIGJ1aWxkcyBzdXBwb3J0aW5nIE9wdGlvbnMgQVBJXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgICB9LFxuICAgICAgY29tcG9uZW50KG5hbWUsIGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lLCBjb250ZXh0LmNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5jb21wb25lbnRzW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXSkge1xuICAgICAgICAgIHdhcm4kMShgQ29tcG9uZW50IFwiJHtuYW1lfVwiIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCBpbiB0YXJnZXQgYXBwLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXSA9IGNvbXBvbmVudDtcbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgIH0sXG4gICAgICBkaXJlY3RpdmUobmFtZSwgZGlyZWN0aXZlKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgdmFsaWRhdGVEaXJlY3RpdmVOYW1lKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGlyZWN0aXZlKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV0pIHtcbiAgICAgICAgICB3YXJuJDEoYERpcmVjdGl2ZSBcIiR7bmFtZX1cIiBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgaW4gdGFyZ2V0IGFwcC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV0gPSBkaXJlY3RpdmU7XG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgICB9LFxuICAgICAgbW91bnQocm9vdENvbnRhaW5lciwgaXNIeWRyYXRlLCBuYW1lc3BhY2UpIHtcbiAgICAgICAgaWYgKCFpc01vdW50ZWQpIHtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiByb290Q29udGFpbmVyLl9fdnVlX2FwcF9fKSB7XG4gICAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAgIGBUaGVyZSBpcyBhbHJlYWR5IGFuIGFwcCBpbnN0YW5jZSBtb3VudGVkIG9uIHRoZSBob3N0IGNvbnRhaW5lci5cbiBJZiB5b3Ugd2FudCB0byBtb3VudCBhbm90aGVyIGFwcCBvbiB0aGUgc2FtZSBob3N0IGNvbnRhaW5lciwgeW91IG5lZWQgdG8gdW5tb3VudCB0aGUgcHJldmlvdXMgYXBwIGJ5IGNhbGxpbmcgXFxgYXBwLnVubW91bnQoKVxcYCBmaXJzdC5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB2bm9kZSA9IGFwcC5fY2VWTm9kZSB8fCBjcmVhdGVWTm9kZShyb290Q29tcG9uZW50LCByb290UHJvcHMpO1xuICAgICAgICAgIHZub2RlLmFwcENvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgIGlmIChuYW1lc3BhY2UgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IFwic3ZnXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChuYW1lc3BhY2UgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBuYW1lc3BhY2UgPSB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICBjb250ZXh0LnJlbG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgY2xvbmVkID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgICAgICAgICAgIGNsb25lZC5lbCA9IG51bGw7XG4gICAgICAgICAgICAgIHJlbmRlcihjbG9uZWQsIHJvb3RDb250YWluZXIsIG5hbWVzcGFjZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNIeWRyYXRlICYmIGh5ZHJhdGUpIHtcbiAgICAgICAgICAgIGh5ZHJhdGUodm5vZGUsIHJvb3RDb250YWluZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXIodm5vZGUsIHJvb3RDb250YWluZXIsIG5hbWVzcGFjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzTW91bnRlZCA9IHRydWU7XG4gICAgICAgICAgYXBwLl9jb250YWluZXIgPSByb290Q29udGFpbmVyO1xuICAgICAgICAgIHJvb3RDb250YWluZXIuX192dWVfYXBwX18gPSBhcHA7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgICBhcHAuX2luc3RhbmNlID0gdm5vZGUuY29tcG9uZW50O1xuICAgICAgICAgICAgZGV2dG9vbHNJbml0QXBwKGFwcCwgdmVyc2lvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnRQdWJsaWNJbnN0YW5jZSh2bm9kZS5jb21wb25lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgQXBwIGhhcyBhbHJlYWR5IGJlZW4gbW91bnRlZC5cbklmIHlvdSB3YW50IHRvIHJlbW91bnQgdGhlIHNhbWUgYXBwLCBtb3ZlIHlvdXIgYXBwIGNyZWF0aW9uIGxvZ2ljIGludG8gYSBmYWN0b3J5IGZ1bmN0aW9uIGFuZCBjcmVhdGUgZnJlc2ggYXBwIGluc3RhbmNlcyBmb3IgZWFjaCBtb3VudCAtIGUuZy4gXFxgY29uc3QgY3JlYXRlTXlBcHAgPSAoKSA9PiBjcmVhdGVBcHAoQXBwKVxcYGBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25Vbm1vdW50KGNsZWFudXBGbikge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB0eXBlb2YgY2xlYW51cEZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgRXhwZWN0ZWQgZnVuY3Rpb24gYXMgZmlyc3QgYXJndW1lbnQgdG8gYXBwLm9uVW5tb3VudCgpLCBidXQgZ290ICR7dHlwZW9mIGNsZWFudXBGbn1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBwbHVnaW5DbGVhbnVwRm5zLnB1c2goY2xlYW51cEZuKTtcbiAgICAgIH0sXG4gICAgICB1bm1vdW50KCkge1xuICAgICAgICBpZiAoaXNNb3VudGVkKSB7XG4gICAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoXG4gICAgICAgICAgICBwbHVnaW5DbGVhbnVwRm5zLFxuICAgICAgICAgICAgYXBwLl9pbnN0YW5jZSxcbiAgICAgICAgICAgIDE2XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZW5kZXIobnVsbCwgYXBwLl9jb250YWluZXIpO1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgICAgYXBwLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICBkZXZ0b29sc1VubW91bnRBcHAoYXBwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVsZXRlIGFwcC5fY29udGFpbmVyLl9fdnVlX2FwcF9fO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuJDEoYENhbm5vdCB1bm1vdW50IGFuIGFwcCB0aGF0IGlzIG5vdCBtb3VudGVkLmApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJvdmlkZShrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGtleSBpbiBjb250ZXh0LnByb3ZpZGVzKSB7XG4gICAgICAgICAgaWYgKGhhc093bihjb250ZXh0LnByb3ZpZGVzLCBrZXkpKSB7XG4gICAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAgIGBBcHAgYWxyZWFkeSBwcm92aWRlcyBwcm9wZXJ0eSB3aXRoIGtleSBcIiR7U3RyaW5nKGtleSl9XCIuIEl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gd2l0aCB0aGUgbmV3IHZhbHVlLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgICAgYEFwcCBhbHJlYWR5IHByb3ZpZGVzIHByb3BlcnR5IHdpdGgga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBpbmhlcml0ZWQgZnJvbSBpdHMgcGFyZW50IGVsZW1lbnQuIEl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gd2l0aCB0aGUgbmV3IHZhbHVlLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQucHJvdmlkZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gYXBwO1xuICAgICAgfSxcbiAgICAgIHJ1bldpdGhDb250ZXh0KGZuKSB7XG4gICAgICAgIGNvbnN0IGxhc3RBcHAgPSBjdXJyZW50QXBwO1xuICAgICAgICBjdXJyZW50QXBwID0gYXBwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGN1cnJlbnRBcHAgPSBsYXN0QXBwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gYXBwO1xuICB9O1xufVxubGV0IGN1cnJlbnRBcHAgPSBudWxsO1xuXG5mdW5jdGlvbiBwcm92aWRlKGtleSwgdmFsdWUpIHtcbiAgaWYgKCFjdXJyZW50SW5zdGFuY2UpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybiQxKGBwcm92aWRlKCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgc2V0dXAoKS5gKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IHByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnByb3ZpZGVzO1xuICAgIGNvbnN0IHBhcmVudFByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnBhcmVudCAmJiBjdXJyZW50SW5zdGFuY2UucGFyZW50LnByb3ZpZGVzO1xuICAgIGlmIChwYXJlbnRQcm92aWRlcyA9PT0gcHJvdmlkZXMpIHtcbiAgICAgIHByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnByb3ZpZGVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRQcm92aWRlcyk7XG4gICAgfVxuICAgIHByb3ZpZGVzW2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gaW5qZWN0KGtleSwgZGVmYXVsdFZhbHVlLCB0cmVhdERlZmF1bHRBc0ZhY3RvcnkgPSBmYWxzZSkge1xuICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG4gIGlmIChpbnN0YW5jZSB8fCBjdXJyZW50QXBwKSB7XG4gICAgbGV0IHByb3ZpZGVzID0gY3VycmVudEFwcCA/IGN1cnJlbnRBcHAuX2NvbnRleHQucHJvdmlkZXMgOiBpbnN0YW5jZSA/IGluc3RhbmNlLnBhcmVudCA9PSBudWxsIHx8IGluc3RhbmNlLmNlID8gaW5zdGFuY2Uudm5vZGUuYXBwQ29udGV4dCAmJiBpbnN0YW5jZS52bm9kZS5hcHBDb250ZXh0LnByb3ZpZGVzIDogaW5zdGFuY2UucGFyZW50LnByb3ZpZGVzIDogdm9pZCAwO1xuICAgIGlmIChwcm92aWRlcyAmJiBrZXkgaW4gcHJvdmlkZXMpIHtcbiAgICAgIHJldHVybiBwcm92aWRlc1trZXldO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB0cmVhdERlZmF1bHRBc0ZhY3RvcnkgJiYgaXNGdW5jdGlvbihkZWZhdWx0VmFsdWUpID8gZGVmYXVsdFZhbHVlLmNhbGwoaW5zdGFuY2UgJiYgaW5zdGFuY2UucHJveHkpIDogZGVmYXVsdFZhbHVlO1xuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybiQxKGBpbmplY3Rpb24gXCIke1N0cmluZyhrZXkpfVwiIG5vdCBmb3VuZC5gKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4kMShgaW5qZWN0KCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgc2V0dXAoKSBvciBmdW5jdGlvbmFsIGNvbXBvbmVudHMuYCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhc0luamVjdGlvbkNvbnRleHQoKSB7XG4gIHJldHVybiAhIShjdXJyZW50SW5zdGFuY2UgfHwgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIHx8IGN1cnJlbnRBcHApO1xufVxuXG5jb25zdCBpbnRlcm5hbE9iamVjdFByb3RvID0ge307XG5jb25zdCBjcmVhdGVJbnRlcm5hbE9iamVjdCA9ICgpID0+IE9iamVjdC5jcmVhdGUoaW50ZXJuYWxPYmplY3RQcm90byk7XG5jb25zdCBpc0ludGVybmFsT2JqZWN0ID0gKG9iaikgPT4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT09IGludGVybmFsT2JqZWN0UHJvdG87XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIGlzU3RhdGVmdWwsIGlzU1NSID0gZmFsc2UpIHtcbiAgY29uc3QgcHJvcHMgPSB7fTtcbiAgY29uc3QgYXR0cnMgPSBjcmVhdGVJbnRlcm5hbE9iamVjdCgpO1xuICBpbnN0YW5jZS5wcm9wc0RlZmF1bHRzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycyk7XG4gIGZvciAoY29uc3Qga2V5IGluIGluc3RhbmNlLnByb3BzT3B0aW9uc1swXSkge1xuICAgIGlmICghKGtleSBpbiBwcm9wcykpIHtcbiAgICAgIHByb3BzW2tleV0gPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgdmFsaWRhdGVQcm9wcyhyYXdQcm9wcyB8fCB7fSwgcHJvcHMsIGluc3RhbmNlKTtcbiAgfVxuICBpZiAoaXNTdGF0ZWZ1bCkge1xuICAgIGluc3RhbmNlLnByb3BzID0gaXNTU1IgPyBwcm9wcyA6IHNoYWxsb3dSZWFjdGl2ZShwcm9wcyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFpbnN0YW5jZS50eXBlLnByb3BzKSB7XG4gICAgICBpbnN0YW5jZS5wcm9wcyA9IGF0dHJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZS5wcm9wcyA9IHByb3BzO1xuICAgIH1cbiAgfVxuICBpbnN0YW5jZS5hdHRycyA9IGF0dHJzO1xufVxuZnVuY3Rpb24gaXNJbkhtckNvbnRleHQoaW5zdGFuY2UpIHtcbiAgd2hpbGUgKGluc3RhbmNlKSB7XG4gICAgaWYgKGluc3RhbmNlLnR5cGUuX19obXJJZCkgcmV0dXJuIHRydWU7XG4gICAgaW5zdGFuY2UgPSBpbnN0YW5jZS5wYXJlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZVByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcmF3UHJldlByb3BzLCBvcHRpbWl6ZWQpIHtcbiAgY29uc3Qge1xuICAgIHByb3BzLFxuICAgIGF0dHJzLFxuICAgIHZub2RlOiB7IHBhdGNoRmxhZyB9XG4gIH0gPSBpbnN0YW5jZTtcbiAgY29uc3QgcmF3Q3VycmVudFByb3BzID0gdG9SYXcocHJvcHMpO1xuICBjb25zdCBbb3B0aW9uc10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XG4gIGxldCBoYXNBdHRyc0NoYW5nZWQgPSBmYWxzZTtcbiAgaWYgKFxuICAgIC8vIGFsd2F5cyBmb3JjZSBmdWxsIGRpZmYgaW4gZGV2XG4gICAgLy8gLSAjMTk0MiBpZiBobXIgaXMgZW5hYmxlZCB3aXRoIHNmYyBjb21wb25lbnRcbiAgICAvLyAtIHZpdGUjODcyIG5vbi1zZmMgY29tcG9uZW50IHVzZWQgYnkgc2ZjIGNvbXBvbmVudFxuICAgICEoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0luSG1yQ29udGV4dChpbnN0YW5jZSkpICYmIChvcHRpbWl6ZWQgfHwgcGF0Y2hGbGFnID4gMCkgJiYgIShwYXRjaEZsYWcgJiAxNilcbiAgKSB7XG4gICAgaWYgKHBhdGNoRmxhZyAmIDgpIHtcbiAgICAgIGNvbnN0IHByb3BzVG9VcGRhdGUgPSBpbnN0YW5jZS52bm9kZS5keW5hbWljUHJvcHM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGtleSA9IHByb3BzVG9VcGRhdGVbaV07XG4gICAgICAgIGlmIChpc0VtaXRMaXN0ZW5lcihpbnN0YW5jZS5lbWl0c09wdGlvbnMsIGtleSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHJhd1Byb3BzW2tleV07XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKGhhc093bihhdHRycywga2V5KSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBhdHRyc1trZXldKSB7XG4gICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2FtZWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICAgICAgICAgIHByb3BzW2NhbWVsaXplZEtleV0gPSByZXNvbHZlUHJvcFZhbHVlKFxuICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICByYXdDdXJyZW50UHJvcHMsXG4gICAgICAgICAgICAgIGNhbWVsaXplZEtleSxcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBhdHRyc1trZXldKSB7XG4gICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKSkge1xuICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IGtlYmFiS2V5O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHJhd0N1cnJlbnRQcm9wcykge1xuICAgICAgaWYgKCFyYXdQcm9wcyB8fCAvLyBmb3IgY2FtZWxDYXNlXG4gICAgICAhaGFzT3duKHJhd1Byb3BzLCBrZXkpICYmIC8vIGl0J3MgcG9zc2libGUgdGhlIG9yaWdpbmFsIHByb3BzIHdhcyBwYXNzZWQgaW4gYXMga2ViYWItY2FzZVxuICAgICAgLy8gYW5kIGNvbnZlcnRlZCB0byBjYW1lbENhc2UgKCM5NTUpXG4gICAgICAoKGtlYmFiS2V5ID0gaHlwaGVuYXRlKGtleSkpID09PSBrZXkgfHwgIWhhc093bihyYXdQcm9wcywga2ViYWJLZXkpKSkge1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgIGlmIChyYXdQcmV2UHJvcHMgJiYgLy8gZm9yIGNhbWVsQ2FzZVxuICAgICAgICAgIChyYXdQcmV2UHJvcHNba2V5XSAhPT0gdm9pZCAwIHx8IC8vIGZvciBrZWJhYi1jYXNlXG4gICAgICAgICAgcmF3UHJldlByb3BzW2tlYmFiS2V5XSAhPT0gdm9pZCAwKSkge1xuICAgICAgICAgICAgcHJvcHNba2V5XSA9IHJlc29sdmVQcm9wVmFsdWUoXG4gICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgIHJhd0N1cnJlbnRQcm9wcyxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgcHJvcHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXR0cnMgIT09IHJhd0N1cnJlbnRQcm9wcykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgaWYgKCFyYXdQcm9wcyB8fCAhaGFzT3duKHJhd1Byb3BzLCBrZXkpICYmIHRydWUpIHtcbiAgICAgICAgICBkZWxldGUgYXR0cnNba2V5XTtcbiAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChoYXNBdHRyc0NoYW5nZWQpIHtcbiAgICB0cmlnZ2VyKGluc3RhbmNlLmF0dHJzLCBcInNldFwiLCBcIlwiKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHZhbGlkYXRlUHJvcHMocmF3UHJvcHMgfHwge30sIHByb3BzLCBpbnN0YW5jZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycykge1xuICBjb25zdCBbb3B0aW9ucywgbmVlZENhc3RLZXlzXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcbiAgbGV0IGhhc0F0dHJzQ2hhbmdlZCA9IGZhbHNlO1xuICBsZXQgcmF3Q2FzdFZhbHVlcztcbiAgaWYgKHJhd1Byb3BzKSB7XG4gICAgZm9yIChsZXQga2V5IGluIHJhd1Byb3BzKSB7XG4gICAgICBpZiAoaXNSZXNlcnZlZFByb3Aoa2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gcmF3UHJvcHNba2V5XTtcbiAgICAgIGxldCBjYW1lbEtleTtcbiAgICAgIGlmIChvcHRpb25zICYmIGhhc093bihvcHRpb25zLCBjYW1lbEtleSA9IGNhbWVsaXplKGtleSkpKSB7XG4gICAgICAgIGlmICghbmVlZENhc3RLZXlzIHx8ICFuZWVkQ2FzdEtleXMuaW5jbHVkZXMoY2FtZWxLZXkpKSB7XG4gICAgICAgICAgcHJvcHNbY2FtZWxLZXldID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKHJhd0Nhc3RWYWx1ZXMgfHwgKHJhd0Nhc3RWYWx1ZXMgPSB7fSkpW2NhbWVsS2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFpc0VtaXRMaXN0ZW5lcihpbnN0YW5jZS5lbWl0c09wdGlvbnMsIGtleSkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIGF0dHJzKSB8fCB2YWx1ZSAhPT0gYXR0cnNba2V5XSkge1xuICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChuZWVkQ2FzdEtleXMpIHtcbiAgICBjb25zdCByYXdDdXJyZW50UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XG4gICAgY29uc3QgY2FzdFZhbHVlcyA9IHJhd0Nhc3RWYWx1ZXMgfHwgRU1QVFlfT0JKO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmVlZENhc3RLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBuZWVkQ2FzdEtleXNbaV07XG4gICAgICBwcm9wc1trZXldID0gcmVzb2x2ZVByb3BWYWx1ZShcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgcmF3Q3VycmVudFByb3BzLFxuICAgICAgICBrZXksXG4gICAgICAgIGNhc3RWYWx1ZXNba2V5XSxcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICFoYXNPd24oY2FzdFZhbHVlcywga2V5KVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhc0F0dHJzQ2hhbmdlZDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcHJvcHMsIGtleSwgdmFsdWUsIGluc3RhbmNlLCBpc0Fic2VudCkge1xuICBjb25zdCBvcHQgPSBvcHRpb25zW2tleV07XG4gIGlmIChvcHQgIT0gbnVsbCkge1xuICAgIGNvbnN0IGhhc0RlZmF1bHQgPSBoYXNPd24ob3B0LCBcImRlZmF1bHRcIik7XG4gICAgaWYgKGhhc0RlZmF1bHQgJiYgdmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gb3B0LmRlZmF1bHQ7XG4gICAgICBpZiAob3B0LnR5cGUgIT09IEZ1bmN0aW9uICYmICFvcHQuc2tpcEZhY3RvcnkgJiYgaXNGdW5jdGlvbihkZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHNEZWZhdWx0cyB9ID0gaW5zdGFuY2U7XG4gICAgICAgIGlmIChrZXkgaW4gcHJvcHNEZWZhdWx0cykge1xuICAgICAgICAgIHZhbHVlID0gcHJvcHNEZWZhdWx0c1trZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHJlc2V0ID0gc2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcbiAgICAgICAgICB2YWx1ZSA9IHByb3BzRGVmYXVsdHNba2V5XSA9IGRlZmF1bHRWYWx1ZS5jYWxsKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHByb3BzXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXNldCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpbnN0YW5jZS5jZSkge1xuICAgICAgICBpbnN0YW5jZS5jZS5fc2V0UHJvcChrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdFswIC8qIHNob3VsZENhc3QgKi9dKSB7XG4gICAgICBpZiAoaXNBYnNlbnQgJiYgIWhhc0RlZmF1bHQpIHtcbiAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAob3B0WzEgLyogc2hvdWxkQ2FzdFRydWUgKi9dICYmICh2YWx1ZSA9PT0gXCJcIiB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpKSB7XG4gICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3QgbWl4aW5Qcm9wc0NhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBub3JtYWxpemVQcm9wc09wdGlvbnMoY29tcCwgYXBwQ29udGV4dCwgYXNNaXhpbiA9IGZhbHNlKSB7XG4gIGNvbnN0IGNhY2hlID0gX19WVUVfT1BUSU9OU19BUElfXyAmJiBhc01peGluID8gbWl4aW5Qcm9wc0NhY2hlIDogYXBwQ29udGV4dC5wcm9wc0NhY2hlO1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoY29tcCk7XG4gIGlmIChjYWNoZWQpIHtcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG4gIGNvbnN0IHJhdyA9IGNvbXAucHJvcHM7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSB7fTtcbiAgY29uc3QgbmVlZENhc3RLZXlzID0gW107XG4gIGxldCBoYXNFeHRlbmRzID0gZmFsc2U7XG4gIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XG4gICAgY29uc3QgZXh0ZW5kUHJvcHMgPSAocmF3MikgPT4ge1xuICAgICAgaGFzRXh0ZW5kcyA9IHRydWU7XG4gICAgICBjb25zdCBbcHJvcHMsIGtleXNdID0gbm9ybWFsaXplUHJvcHNPcHRpb25zKHJhdzIsIGFwcENvbnRleHQsIHRydWUpO1xuICAgICAgZXh0ZW5kKG5vcm1hbGl6ZWQsIHByb3BzKTtcbiAgICAgIGlmIChrZXlzKSBuZWVkQ2FzdEtleXMucHVzaCguLi5rZXlzKTtcbiAgICB9O1xuICAgIGlmICghYXNNaXhpbiAmJiBhcHBDb250ZXh0Lm1peGlucy5sZW5ndGgpIHtcbiAgICAgIGFwcENvbnRleHQubWl4aW5zLmZvckVhY2goZXh0ZW5kUHJvcHMpO1xuICAgIH1cbiAgICBpZiAoY29tcC5leHRlbmRzKSB7XG4gICAgICBleHRlbmRQcm9wcyhjb21wLmV4dGVuZHMpO1xuICAgIH1cbiAgICBpZiAoY29tcC5taXhpbnMpIHtcbiAgICAgIGNvbXAubWl4aW5zLmZvckVhY2goZXh0ZW5kUHJvcHMpO1xuICAgIH1cbiAgfVxuICBpZiAoIXJhdyAmJiAhaGFzRXh0ZW5kcykge1xuICAgIGlmIChpc09iamVjdChjb21wKSkge1xuICAgICAgY2FjaGUuc2V0KGNvbXAsIEVNUFRZX0FSUik7XG4gICAgfVxuICAgIHJldHVybiBFTVBUWV9BUlI7XG4gIH1cbiAgaWYgKGlzQXJyYXkocmF3KSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNTdHJpbmcocmF3W2ldKSkge1xuICAgICAgICB3YXJuJDEoYHByb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC5gLCByYXdbaV0pO1xuICAgICAgfVxuICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGNhbWVsaXplKHJhd1tpXSk7XG4gICAgICBpZiAodmFsaWRhdGVQcm9wTmFtZShub3JtYWxpemVkS2V5KSkge1xuICAgICAgICBub3JtYWxpemVkW25vcm1hbGl6ZWRLZXldID0gRU1QVFlfT0JKO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChyYXcpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNPYmplY3QocmF3KSkge1xuICAgICAgd2FybiQxKGBpbnZhbGlkIHByb3BzIG9wdGlvbnNgLCByYXcpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiByYXcpIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgaWYgKHZhbGlkYXRlUHJvcE5hbWUobm9ybWFsaXplZEtleSkpIHtcbiAgICAgICAgY29uc3Qgb3B0ID0gcmF3W2tleV07XG4gICAgICAgIGNvbnN0IHByb3AgPSBub3JtYWxpemVkW25vcm1hbGl6ZWRLZXldID0gaXNBcnJheShvcHQpIHx8IGlzRnVuY3Rpb24ob3B0KSA/IHsgdHlwZTogb3B0IH0gOiBleHRlbmQoe30sIG9wdCk7XG4gICAgICAgIGNvbnN0IHByb3BUeXBlID0gcHJvcC50eXBlO1xuICAgICAgICBsZXQgc2hvdWxkQ2FzdCA9IGZhbHNlO1xuICAgICAgICBsZXQgc2hvdWxkQ2FzdFRydWUgPSB0cnVlO1xuICAgICAgICBpZiAoaXNBcnJheShwcm9wVHlwZSkpIHtcbiAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcHJvcFR5cGUubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gcHJvcFR5cGVbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgdHlwZU5hbWUgPSBpc0Z1bmN0aW9uKHR5cGUpICYmIHR5cGUubmFtZTtcbiAgICAgICAgICAgIGlmICh0eXBlTmFtZSA9PT0gXCJCb29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgc2hvdWxkQ2FzdCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlTmFtZSA9PT0gXCJTdHJpbmdcIikge1xuICAgICAgICAgICAgICBzaG91bGRDYXN0VHJ1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaG91bGRDYXN0ID0gaXNGdW5jdGlvbihwcm9wVHlwZSkgJiYgcHJvcFR5cGUubmFtZSA9PT0gXCJCb29sZWFuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcHJvcFswIC8qIHNob3VsZENhc3QgKi9dID0gc2hvdWxkQ2FzdDtcbiAgICAgICAgcHJvcFsxIC8qIHNob3VsZENhc3RUcnVlICovXSA9IHNob3VsZENhc3RUcnVlO1xuICAgICAgICBpZiAoc2hvdWxkQ2FzdCB8fCBoYXNPd24ocHJvcCwgXCJkZWZhdWx0XCIpKSB7XG4gICAgICAgICAgbmVlZENhc3RLZXlzLnB1c2gobm9ybWFsaXplZEtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzID0gW25vcm1hbGl6ZWQsIG5lZWRDYXN0S2V5c107XG4gIGlmIChpc09iamVjdChjb21wKSkge1xuICAgIGNhY2hlLnNldChjb21wLCByZXMpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BOYW1lKGtleSkge1xuICBpZiAoa2V5WzBdICE9PSBcIiRcIiAmJiAhaXNSZXNlcnZlZFByb3Aoa2V5KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuJDEoYEludmFsaWQgcHJvcCBuYW1lOiBcIiR7a2V5fVwiIGlzIGEgcmVzZXJ2ZWQgcHJvcGVydHkuYCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0VHlwZShjdG9yKSB7XG4gIGlmIChjdG9yID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFwibnVsbFwiO1xuICB9XG4gIGlmICh0eXBlb2YgY3RvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGN0b3IubmFtZSB8fCBcIlwiO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjdG9yID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29uc3QgbmFtZSA9IGN0b3IuY29uc3RydWN0b3IgJiYgY3Rvci5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIHJldHVybiBuYW1lIHx8IFwiXCI7XG4gIH1cbiAgcmV0dXJuIFwiXCI7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BzKHJhd1Byb3BzLCBwcm9wcywgaW5zdGFuY2UpIHtcbiAgY29uc3QgcmVzb2x2ZWRWYWx1ZXMgPSB0b1Jhdyhwcm9wcyk7XG4gIGNvbnN0IG9wdGlvbnMgPSBpbnN0YW5jZS5wcm9wc09wdGlvbnNbMF07XG4gIGNvbnN0IGNhbWVsaXplUHJvcHNLZXkgPSBPYmplY3Qua2V5cyhyYXdQcm9wcykubWFwKChrZXkpID0+IGNhbWVsaXplKGtleSkpO1xuICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgbGV0IG9wdCA9IG9wdGlvbnNba2V5XTtcbiAgICBpZiAob3B0ID09IG51bGwpIGNvbnRpbnVlO1xuICAgIHZhbGlkYXRlUHJvcChcbiAgICAgIGtleSxcbiAgICAgIHJlc29sdmVkVmFsdWVzW2tleV0sXG4gICAgICBvcHQsXG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KHJlc29sdmVkVmFsdWVzKSA6IHJlc29sdmVkVmFsdWVzLFxuICAgICAgIWNhbWVsaXplUHJvcHNLZXkuaW5jbHVkZXMoa2V5KVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcChuYW1lLCB2YWx1ZSwgcHJvcCwgcHJvcHMsIGlzQWJzZW50KSB7XG4gIGNvbnN0IHsgdHlwZSwgcmVxdWlyZWQsIHZhbGlkYXRvciwgc2tpcENoZWNrIH0gPSBwcm9wO1xuICBpZiAocmVxdWlyZWQgJiYgaXNBYnNlbnQpIHtcbiAgICB3YXJuJDEoJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcmVxdWlyZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGUgIT0gbnVsbCAmJiB0eXBlICE9PSB0cnVlICYmICFza2lwQ2hlY2spIHtcbiAgICBsZXQgaXNWYWxpZCA9IGZhbHNlO1xuICAgIGNvbnN0IHR5cGVzID0gaXNBcnJheSh0eXBlKSA/IHR5cGUgOiBbdHlwZV07XG4gICAgY29uc3QgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoICYmICFpc1ZhbGlkOyBpKyspIHtcbiAgICAgIGNvbnN0IHsgdmFsaWQsIGV4cGVjdGVkVHlwZSB9ID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZXNbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGV4cGVjdGVkVHlwZSB8fCBcIlwiKTtcbiAgICAgIGlzVmFsaWQgPSB2YWxpZDtcbiAgICB9XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICB3YXJuJDEoZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGlmICh2YWxpZGF0b3IgJiYgIXZhbGlkYXRvcih2YWx1ZSwgcHJvcHMpKSB7XG4gICAgd2FybiQxKCdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyk7XG4gIH1cbn1cbmNvbnN0IGlzU2ltcGxlVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBcIlN0cmluZyxOdW1iZXIsQm9vbGVhbixGdW5jdGlvbixTeW1ib2wsQmlnSW50XCJcbik7XG5mdW5jdGlvbiBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlKSB7XG4gIGxldCB2YWxpZDtcbiAgY29uc3QgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gXCJudWxsXCIpIHtcbiAgICB2YWxpZCA9IHZhbHVlID09PSBudWxsO1xuICB9IGVsc2UgaWYgKGlzU2ltcGxlVHlwZShleHBlY3RlZFR5cGUpKSB7XG4gICAgY29uc3QgdCA9IHR5cGVvZiB2YWx1ZTtcbiAgICB2YWxpZCA9IHQgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICghdmFsaWQgJiYgdCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gXCJPYmplY3RcIikge1xuICAgIHZhbGlkID0gaXNPYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gXCJBcnJheVwiKSB7XG4gICAgdmFsaWQgPSBpc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSB7XG4gIGlmIChleHBlY3RlZFR5cGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBgUHJvcCB0eXBlIFtdIGZvciBwcm9wIFwiJHtuYW1lfVwiIHdvbid0IG1hdGNoIGFueXRoaW5nLiBEaWQgeW91IG1lYW4gdG8gdXNlIHR5cGUgQXJyYXkgaW5zdGVhZD9gO1xuICB9XG4gIGxldCBtZXNzYWdlID0gYEludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCIke25hbWV9XCIuIEV4cGVjdGVkICR7ZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbihcIiB8IFwiKX1gO1xuICBjb25zdCBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGVzWzBdO1xuICBjb25zdCByZWNlaXZlZFR5cGUgPSB0b1Jhd1R5cGUodmFsdWUpO1xuICBjb25zdCBleHBlY3RlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgZXhwZWN0ZWRUeXBlKTtcbiAgY29uc3QgcmVjZWl2ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIHJlY2VpdmVkVHlwZSk7XG4gIGlmIChleHBlY3RlZFR5cGVzLmxlbmd0aCA9PT0gMSAmJiBpc0V4cGxpY2FibGUoZXhwZWN0ZWRUeXBlKSAmJiAhaXNCb29sZWFuKGV4cGVjdGVkVHlwZSwgcmVjZWl2ZWRUeXBlKSkge1xuICAgIG1lc3NhZ2UgKz0gYCB3aXRoIHZhbHVlICR7ZXhwZWN0ZWRWYWx1ZX1gO1xuICB9XG4gIG1lc3NhZ2UgKz0gYCwgZ290ICR7cmVjZWl2ZWRUeXBlfSBgO1xuICBpZiAoaXNFeHBsaWNhYmxlKHJlY2VpdmVkVHlwZSkpIHtcbiAgICBtZXNzYWdlICs9IGB3aXRoIHZhbHVlICR7cmVjZWl2ZWRWYWx1ZX0uYDtcbiAgfVxuICByZXR1cm4gbWVzc2FnZTtcbn1cbmZ1bmN0aW9uIHN0eWxlVmFsdWUodmFsdWUsIHR5cGUpIHtcbiAgaWYgKHR5cGUgPT09IFwiU3RyaW5nXCIpIHtcbiAgICByZXR1cm4gYFwiJHt2YWx1ZX1cImA7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJOdW1iZXJcIikge1xuICAgIHJldHVybiBgJHtOdW1iZXIodmFsdWUpfWA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGAke3ZhbHVlfWA7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzRXhwbGljYWJsZSh0eXBlKSB7XG4gIGNvbnN0IGV4cGxpY2l0VHlwZXMgPSBbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJib29sZWFuXCJdO1xuICByZXR1cm4gZXhwbGljaXRUeXBlcy5zb21lKChlbGVtKSA9PiB0eXBlLnRvTG93ZXJDYXNlKCkgPT09IGVsZW0pO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGFyZ3Muc29tZSgoZWxlbSkgPT4gZWxlbS50b0xvd2VyQ2FzZSgpID09PSBcImJvb2xlYW5cIik7XG59XG5cbmNvbnN0IGlzSW50ZXJuYWxLZXkgPSAoa2V5KSA9PiBrZXlbMF0gPT09IFwiX1wiIHx8IGtleSA9PT0gXCIkc3RhYmxlXCI7XG5jb25zdCBub3JtYWxpemVTbG90VmFsdWUgPSAodmFsdWUpID0+IGlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKG5vcm1hbGl6ZVZOb2RlKSA6IFtub3JtYWxpemVWTm9kZSh2YWx1ZSldO1xuY29uc3Qgbm9ybWFsaXplU2xvdCA9IChrZXksIHJhd1Nsb3QsIGN0eCkgPT4ge1xuICBpZiAocmF3U2xvdC5fbikge1xuICAgIHJldHVybiByYXdTbG90O1xuICB9XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSB3aXRoQ3R4KCguLi5hcmdzKSA9PiB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY3VycmVudEluc3RhbmNlICYmICEoY3R4ID09PSBudWxsICYmIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSkgJiYgIShjdHggJiYgY3R4LnJvb3QgIT09IGN1cnJlbnRJbnN0YW5jZS5yb290KSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgU2xvdCBcIiR7a2V5fVwiIGludm9rZWQgb3V0c2lkZSBvZiB0aGUgcmVuZGVyIGZ1bmN0aW9uOiB0aGlzIHdpbGwgbm90IHRyYWNrIGRlcGVuZGVuY2llcyB1c2VkIGluIHRoZSBzbG90LiBJbnZva2UgdGhlIHNsb3QgZnVuY3Rpb24gaW5zaWRlIHRoZSByZW5kZXIgZnVuY3Rpb24gaW5zdGVhZC5gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplU2xvdFZhbHVlKHJhd1Nsb3QoLi4uYXJncykpO1xuICB9LCBjdHgpO1xuICBub3JtYWxpemVkLl9jID0gZmFsc2U7XG4gIHJldHVybiBub3JtYWxpemVkO1xufTtcbmNvbnN0IG5vcm1hbGl6ZU9iamVjdFNsb3RzID0gKHJhd1Nsb3RzLCBzbG90cywgaW5zdGFuY2UpID0+IHtcbiAgY29uc3QgY3R4ID0gcmF3U2xvdHMuX2N0eDtcbiAgZm9yIChjb25zdCBrZXkgaW4gcmF3U2xvdHMpIHtcbiAgICBpZiAoaXNJbnRlcm5hbEtleShrZXkpKSBjb250aW51ZTtcbiAgICBjb25zdCB2YWx1ZSA9IHJhd1Nsb3RzW2tleV07XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICBzbG90c1trZXldID0gbm9ybWFsaXplU2xvdChrZXksIHZhbHVlLCBjdHgpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdHJ1ZSkge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYE5vbi1mdW5jdGlvbiB2YWx1ZSBlbmNvdW50ZXJlZCBmb3Igc2xvdCBcIiR7a2V5fVwiLiBQcmVmZXIgZnVuY3Rpb24gc2xvdHMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplU2xvdFZhbHVlKHZhbHVlKTtcbiAgICAgIHNsb3RzW2tleV0gPSAoKSA9PiBub3JtYWxpemVkO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IG5vcm1hbGl6ZVZOb2RlU2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuKSA9PiB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc0tlZXBBbGl2ZShpbnN0YW5jZS52bm9kZSkgJiYgdHJ1ZSkge1xuICAgIHdhcm4kMShcbiAgICAgIGBOb24tZnVuY3Rpb24gdmFsdWUgZW5jb3VudGVyZWQgZm9yIGRlZmF1bHQgc2xvdC4gUHJlZmVyIGZ1bmN0aW9uIHNsb3RzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuYFxuICAgICk7XG4gIH1cbiAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVNsb3RWYWx1ZShjaGlsZHJlbik7XG4gIGluc3RhbmNlLnNsb3RzLmRlZmF1bHQgPSAoKSA9PiBub3JtYWxpemVkO1xufTtcbmNvbnN0IGFzc2lnblNsb3RzID0gKHNsb3RzLCBjaGlsZHJlbiwgb3B0aW1pemVkKSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IGluIGNoaWxkcmVuKSB7XG4gICAgaWYgKG9wdGltaXplZCB8fCAhaXNJbnRlcm5hbEtleShrZXkpKSB7XG4gICAgICBzbG90c1trZXldID0gY2hpbGRyZW5ba2V5XTtcbiAgICB9XG4gIH1cbn07XG5jb25zdCBpbml0U2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpID0+IHtcbiAgY29uc3Qgc2xvdHMgPSBpbnN0YW5jZS5zbG90cyA9IGNyZWF0ZUludGVybmFsT2JqZWN0KCk7XG4gIGlmIChpbnN0YW5jZS52bm9kZS5zaGFwZUZsYWcgJiAzMikge1xuICAgIGNvbnN0IHR5cGUgPSBjaGlsZHJlbi5fO1xuICAgIGlmICh0eXBlKSB7XG4gICAgICBhc3NpZ25TbG90cyhzbG90cywgY2hpbGRyZW4sIG9wdGltaXplZCk7XG4gICAgICBpZiAob3B0aW1pemVkKSB7XG4gICAgICAgIGRlZihzbG90cywgXCJfXCIsIHR5cGUsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub3JtYWxpemVPYmplY3RTbG90cyhjaGlsZHJlbiwgc2xvdHMpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjaGlsZHJlbikge1xuICAgIG5vcm1hbGl6ZVZOb2RlU2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcbiAgfVxufTtcbmNvbnN0IHVwZGF0ZVNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbiwgb3B0aW1pemVkKSA9PiB7XG4gIGNvbnN0IHsgdm5vZGUsIHNsb3RzIH0gPSBpbnN0YW5jZTtcbiAgbGV0IG5lZWREZWxldGlvbkNoZWNrID0gdHJ1ZTtcbiAgbGV0IGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCA9IEVNUFRZX09CSjtcbiAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDMyKSB7XG4gICAgY29uc3QgdHlwZSA9IGNoaWxkcmVuLl87XG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSG1yVXBkYXRpbmcpIHtcbiAgICAgICAgYXNzaWduU2xvdHMoc2xvdHMsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpO1xuICAgICAgICB0cmlnZ2VyKGluc3RhbmNlLCBcInNldFwiLCBcIiRzbG90c1wiKTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW1pemVkICYmIHR5cGUgPT09IDEpIHtcbiAgICAgICAgbmVlZERlbGV0aW9uQ2hlY2sgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2lnblNsb3RzKHNsb3RzLCBjaGlsZHJlbiwgb3B0aW1pemVkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmVlZERlbGV0aW9uQ2hlY2sgPSAhY2hpbGRyZW4uJHN0YWJsZTtcbiAgICAgIG5vcm1hbGl6ZU9iamVjdFNsb3RzKGNoaWxkcmVuLCBzbG90cyk7XG4gICAgfVxuICAgIGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuKSB7XG4gICAgbm9ybWFsaXplVk5vZGVTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4pO1xuICAgIGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCA9IHsgZGVmYXVsdDogMSB9O1xuICB9XG4gIGlmIChuZWVkRGVsZXRpb25DaGVjaykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNsb3RzKSB7XG4gICAgICBpZiAoIWlzSW50ZXJuYWxLZXkoa2V5KSAmJiBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXRba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSBzbG90c1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubGV0IHN1cHBvcnRlZDtcbmxldCBwZXJmO1xuZnVuY3Rpb24gc3RhcnRNZWFzdXJlKGluc3RhbmNlLCB0eXBlKSB7XG4gIGlmIChpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5wZXJmb3JtYW5jZSAmJiBpc1N1cHBvcnRlZCgpKSB7XG4gICAgcGVyZi5tYXJrKGB2dWUtJHt0eXBlfS0ke2luc3RhbmNlLnVpZH1gKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICBkZXZ0b29sc1BlcmZTdGFydChpbnN0YW5jZSwgdHlwZSwgaXNTdXBwb3J0ZWQoKSA/IHBlcmYubm93KCkgOiBEYXRlLm5vdygpKTtcbiAgfVxufVxuZnVuY3Rpb24gZW5kTWVhc3VyZShpbnN0YW5jZSwgdHlwZSkge1xuICBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcucGVyZm9ybWFuY2UgJiYgaXNTdXBwb3J0ZWQoKSkge1xuICAgIGNvbnN0IHN0YXJ0VGFnID0gYHZ1ZS0ke3R5cGV9LSR7aW5zdGFuY2UudWlkfWA7XG4gICAgY29uc3QgZW5kVGFnID0gc3RhcnRUYWcgKyBgOmVuZGA7XG4gICAgcGVyZi5tYXJrKGVuZFRhZyk7XG4gICAgcGVyZi5tZWFzdXJlKFxuICAgICAgYDwke2Zvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIGluc3RhbmNlLnR5cGUpfT4gJHt0eXBlfWAsXG4gICAgICBzdGFydFRhZyxcbiAgICAgIGVuZFRhZ1xuICAgICk7XG4gICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICBkZXZ0b29sc1BlcmZFbmQoaW5zdGFuY2UsIHR5cGUsIGlzU3VwcG9ydGVkKCkgPyBwZXJmLm5vdygpIDogRGF0ZS5ub3coKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzU3VwcG9ydGVkKCkge1xuICBpZiAoc3VwcG9ydGVkICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gc3VwcG9ydGVkO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5wZXJmb3JtYW5jZSkge1xuICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgcGVyZiA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgfSBlbHNlIHtcbiAgICBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gc3VwcG9ydGVkO1xufVxuXG5mdW5jdGlvbiBpbml0RmVhdHVyZUZsYWdzKCkge1xuICBjb25zdCBuZWVkV2FybiA9IFtdO1xuICBpZiAodHlwZW9mIF9fVlVFX09QVElPTlNfQVBJX18gIT09IFwiYm9vbGVhblwiKSB7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBuZWVkV2Fybi5wdXNoKGBfX1ZVRV9PUFRJT05TX0FQSV9fYCk7XG4gICAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX09QVElPTlNfQVBJX18gPSB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgX19WVUVfUFJPRF9ERVZUT09MU19fICE9PSBcImJvb2xlYW5cIikge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbmVlZFdhcm4ucHVzaChgX19WVUVfUFJPRF9ERVZUT09MU19fYCk7XG4gICAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX1BST0RfREVWVE9PTFNfXyA9IGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fICE9PSBcImJvb2xlYW5cIikge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbmVlZFdhcm4ucHVzaChgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fYCk7XG4gICAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXyA9IGZhbHNlO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG5lZWRXYXJuLmxlbmd0aCkge1xuICAgIGNvbnN0IG11bHRpID0gbmVlZFdhcm4ubGVuZ3RoID4gMTtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBgRmVhdHVyZSBmbGFnJHttdWx0aSA/IGBzYCA6IGBgfSAke25lZWRXYXJuLmpvaW4oXCIsIFwiKX0gJHttdWx0aSA/IGBhcmVgIDogYGlzYH0gbm90IGV4cGxpY2l0bHkgZGVmaW5lZC4gWW91IGFyZSBydW5uaW5nIHRoZSBlc20tYnVuZGxlciBidWlsZCBvZiBWdWUsIHdoaWNoIGV4cGVjdHMgdGhlc2UgY29tcGlsZS10aW1lIGZlYXR1cmUgZmxhZ3MgdG8gYmUgZ2xvYmFsbHkgaW5qZWN0ZWQgdmlhIHRoZSBidW5kbGVyIGNvbmZpZyBpbiBvcmRlciB0byBnZXQgYmV0dGVyIHRyZWUtc2hha2luZyBpbiB0aGUgcHJvZHVjdGlvbiBidW5kbGUuXG5cbkZvciBtb3JlIGRldGFpbHMsIHNlZSBodHRwczovL2xpbmsudnVlanMub3JnL2ZlYXR1cmUtZmxhZ3MuYFxuICAgICk7XG4gIH1cbn1cblxuY29uc3QgcXVldWVQb3N0UmVuZGVyRWZmZWN0ID0gcXVldWVFZmZlY3RXaXRoU3VzcGVuc2UgO1xuZnVuY3Rpb24gY3JlYXRlUmVuZGVyZXIob3B0aW9ucykge1xuICByZXR1cm4gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIob3B0aW9ucykge1xuICByZXR1cm4gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMsIGNyZWF0ZUh5ZHJhdGlvbkZ1bmN0aW9ucyk7XG59XG5mdW5jdGlvbiBiYXNlQ3JlYXRlUmVuZGVyZXIob3B0aW9ucywgY3JlYXRlSHlkcmF0aW9uRm5zKSB7XG4gIHtcbiAgICBpbml0RmVhdHVyZUZsYWdzKCk7XG4gIH1cbiAgY29uc3QgdGFyZ2V0ID0gZ2V0R2xvYmFsVGhpcygpO1xuICB0YXJnZXQuX19WVUVfXyA9IHRydWU7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgIHNldERldnRvb2xzSG9vayQxKHRhcmdldC5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fLCB0YXJnZXQpO1xuICB9XG4gIGNvbnN0IHtcbiAgICBpbnNlcnQ6IGhvc3RJbnNlcnQsXG4gICAgcmVtb3ZlOiBob3N0UmVtb3ZlLFxuICAgIHBhdGNoUHJvcDogaG9zdFBhdGNoUHJvcCxcbiAgICBjcmVhdGVFbGVtZW50OiBob3N0Q3JlYXRlRWxlbWVudCxcbiAgICBjcmVhdGVUZXh0OiBob3N0Q3JlYXRlVGV4dCxcbiAgICBjcmVhdGVDb21tZW50OiBob3N0Q3JlYXRlQ29tbWVudCxcbiAgICBzZXRUZXh0OiBob3N0U2V0VGV4dCxcbiAgICBzZXRFbGVtZW50VGV4dDogaG9zdFNldEVsZW1lbnRUZXh0LFxuICAgIHBhcmVudE5vZGU6IGhvc3RQYXJlbnROb2RlLFxuICAgIG5leHRTaWJsaW5nOiBob3N0TmV4dFNpYmxpbmcsXG4gICAgc2V0U2NvcGVJZDogaG9zdFNldFNjb3BlSWQgPSBOT09QLFxuICAgIGluc2VydFN0YXRpY0NvbnRlbnQ6IGhvc3RJbnNlcnRTdGF0aWNDb250ZW50XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBwYXRjaCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yID0gbnVsbCwgcGFyZW50Q29tcG9uZW50ID0gbnVsbCwgcGFyZW50U3VzcGVuc2UgPSBudWxsLCBuYW1lc3BhY2UgPSB2b2lkIDAsIHNsb3RTY29wZUlkcyA9IG51bGwsIG9wdGltaXplZCA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNIbXJVcGRhdGluZyA/IGZhbHNlIDogISFuMi5keW5hbWljQ2hpbGRyZW4pID0+IHtcbiAgICBpZiAobjEgPT09IG4yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuMSAmJiAhaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcbiAgICAgIGFuY2hvciA9IGdldE5leHRIb3N0Tm9kZShuMSk7XG4gICAgICB1bm1vdW50KG4xLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgIG4xID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG4yLnBhdGNoRmxhZyA9PT0gLTIpIHtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgbjIuZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeyB0eXBlLCByZWYsIHNoYXBlRmxhZyB9ID0gbjI7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFRleHQ6XG4gICAgICAgIHByb2Nlc3NUZXh0KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ29tbWVudDpcbiAgICAgICAgcHJvY2Vzc0NvbW1lbnROb2RlKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGljOlxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgICAgIG1vdW50U3RhdGljTm9kZShuMiwgY29udGFpbmVyLCBhbmNob3IsIG5hbWVzcGFjZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHBhdGNoU3RhdGljTm9kZShuMSwgbjIsIGNvbnRhaW5lciwgbmFtZXNwYWNlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgIHByb2Nlc3NGcmFnbWVudChcbiAgICAgICAgICBuMSxcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxKSB7XG4gICAgICAgICAgcHJvY2Vzc0VsZW1lbnQoXG4gICAgICAgICAgICBuMSxcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDYpIHtcbiAgICAgICAgICBwcm9jZXNzQ29tcG9uZW50KFxuICAgICAgICAgICAgbjEsXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiA2NCkge1xuICAgICAgICAgIHR5cGUucHJvY2VzcyhcbiAgICAgICAgICAgIG4xLFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgICAgIGludGVybmFsc1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICAgICAgdHlwZS5wcm9jZXNzKFxuICAgICAgICAgICAgbjEsXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICAgICAgaW50ZXJuYWxzXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybiQxKFwiSW52YWxpZCBWTm9kZSB0eXBlOlwiLCB0eXBlLCBgKCR7dHlwZW9mIHR5cGV9KWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyZWYgIT0gbnVsbCAmJiBwYXJlbnRDb21wb25lbnQpIHtcbiAgICAgIHNldFJlZihyZWYsIG4xICYmIG4xLnJlZiwgcGFyZW50U3VzcGVuc2UsIG4yIHx8IG4xLCAhbjIpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcHJvY2Vzc1RleHQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcikgPT4ge1xuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBob3N0SW5zZXJ0KFxuICAgICAgICBuMi5lbCA9IGhvc3RDcmVhdGVUZXh0KG4yLmNoaWxkcmVuKSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3JcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVsID0gbjIuZWwgPSBuMS5lbDtcbiAgICAgIGlmIChuMi5jaGlsZHJlbiAhPT0gbjEuY2hpbGRyZW4pIHtcbiAgICAgICAgaG9zdFNldFRleHQoZWwsIG4yLmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NDb21tZW50Tm9kZSA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKSA9PiB7XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIGhvc3RJbnNlcnQoXG4gICAgICAgIG4yLmVsID0gaG9zdENyZWF0ZUNvbW1lbnQobjIuY2hpbGRyZW4gfHwgXCJcIiksXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBuMi5lbCA9IG4xLmVsO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbW91bnRTdGF0aWNOb2RlID0gKG4yLCBjb250YWluZXIsIGFuY2hvciwgbmFtZXNwYWNlKSA9PiB7XG4gICAgW24yLmVsLCBuMi5hbmNob3JdID0gaG9zdEluc2VydFN0YXRpY0NvbnRlbnQoXG4gICAgICBuMi5jaGlsZHJlbixcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIGFuY2hvcixcbiAgICAgIG5hbWVzcGFjZSxcbiAgICAgIG4yLmVsLFxuICAgICAgbjIuYW5jaG9yXG4gICAgKTtcbiAgfTtcbiAgY29uc3QgcGF0Y2hTdGF0aWNOb2RlID0gKG4xLCBuMiwgY29udGFpbmVyLCBuYW1lc3BhY2UpID0+IHtcbiAgICBpZiAobjIuY2hpbGRyZW4gIT09IG4xLmNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBhbmNob3IgPSBob3N0TmV4dFNpYmxpbmcobjEuYW5jaG9yKTtcbiAgICAgIHJlbW92ZVN0YXRpY05vZGUobjEpO1xuICAgICAgW24yLmVsLCBuMi5hbmNob3JdID0gaG9zdEluc2VydFN0YXRpY0NvbnRlbnQoXG4gICAgICAgIG4yLmNoaWxkcmVuLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgbmFtZXNwYWNlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBuMi5lbCA9IG4xLmVsO1xuICAgICAgbjIuYW5jaG9yID0gbjEuYW5jaG9yO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbW92ZVN0YXRpY05vZGUgPSAoeyBlbCwgYW5jaG9yIH0sIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpID0+IHtcbiAgICBsZXQgbmV4dDtcbiAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGFuY2hvcikge1xuICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhlbCk7XG4gICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIG5leHRTaWJsaW5nKTtcbiAgICAgIGVsID0gbmV4dDtcbiAgICB9XG4gICAgaG9zdEluc2VydChhbmNob3IsIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpO1xuICB9O1xuICBjb25zdCByZW1vdmVTdGF0aWNOb2RlID0gKHsgZWwsIGFuY2hvciB9KSA9PiB7XG4gICAgbGV0IG5leHQ7XG4gICAgd2hpbGUgKGVsICYmIGVsICE9PSBhbmNob3IpIHtcbiAgICAgIG5leHQgPSBob3N0TmV4dFNpYmxpbmcoZWwpO1xuICAgICAgaG9zdFJlbW92ZShlbCk7XG4gICAgICBlbCA9IG5leHQ7XG4gICAgfVxuICAgIGhvc3RSZW1vdmUoYW5jaG9yKTtcbiAgfTtcbiAgY29uc3QgcHJvY2Vzc0VsZW1lbnQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGlmIChuMi50eXBlID09PSBcInN2Z1wiKSB7XG4gICAgICBuYW1lc3BhY2UgPSBcInN2Z1wiO1xuICAgIH0gZWxzZSBpZiAobjIudHlwZSA9PT0gXCJtYXRoXCIpIHtcbiAgICAgIG5hbWVzcGFjZSA9IFwibWF0aG1sXCI7XG4gICAgfVxuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBtb3VudEVsZW1lbnQoXG4gICAgICAgIG4yLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0Y2hFbGVtZW50KFxuICAgICAgICBuMSxcbiAgICAgICAgbjIsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3VudEVsZW1lbnQgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgbGV0IGVsO1xuICAgIGxldCB2bm9kZUhvb2s7XG4gICAgY29uc3QgeyBwcm9wcywgc2hhcGVGbGFnLCB0cmFuc2l0aW9uLCBkaXJzIH0gPSB2bm9kZTtcbiAgICBlbCA9IHZub2RlLmVsID0gaG9zdENyZWF0ZUVsZW1lbnQoXG4gICAgICB2bm9kZS50eXBlLFxuICAgICAgbmFtZXNwYWNlLFxuICAgICAgcHJvcHMgJiYgcHJvcHMuaXMsXG4gICAgICBwcm9wc1xuICAgICk7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDgpIHtcbiAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChlbCwgdm5vZGUuY2hpbGRyZW4pO1xuICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgIG1vdW50Q2hpbGRyZW4oXG4gICAgICAgIHZub2RlLmNoaWxkcmVuLFxuICAgICAgICBlbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgcmVzb2x2ZUNoaWxkcmVuTmFtZXNwYWNlKHZub2RlLCBuYW1lc3BhY2UpLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGRpcnMpIHtcbiAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJjcmVhdGVkXCIpO1xuICAgIH1cbiAgICBzZXRTY29wZUlkKGVsLCB2bm9kZSwgdm5vZGUuc2NvcGVJZCwgc2xvdFNjb3BlSWRzLCBwYXJlbnRDb21wb25lbnQpO1xuICAgIGlmIChwcm9wcykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gXCJ2YWx1ZVwiICYmICFpc1Jlc2VydmVkUHJvcChrZXkpKSB7XG4gICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBudWxsLCBwcm9wc1trZXldLCBuYW1lc3BhY2UsIHBhcmVudENvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChcInZhbHVlXCIgaW4gcHJvcHMpIHtcbiAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgXCJ2YWx1ZVwiLCBudWxsLCBwcm9wcy52YWx1ZSwgbmFtZXNwYWNlKTtcbiAgICAgIH1cbiAgICAgIGlmICh2bm9kZUhvb2sgPSBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpIHtcbiAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgZGVmKGVsLCBcIl9fdm5vZGVcIiwgdm5vZGUsIHRydWUpO1xuICAgICAgZGVmKGVsLCBcIl9fdnVlUGFyZW50Q29tcG9uZW50XCIsIHBhcmVudENvbXBvbmVudCwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChkaXJzKSB7XG4gICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwiYmVmb3JlTW91bnRcIik7XG4gICAgfVxuICAgIGNvbnN0IG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzID0gbmVlZFRyYW5zaXRpb24ocGFyZW50U3VzcGVuc2UsIHRyYW5zaXRpb24pO1xuICAgIGlmIChuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcykge1xuICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XG4gICAgfVxuICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSB8fCBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyB8fCBkaXJzKSB7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICB2bm9kZUhvb2sgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzICYmIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xuICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJtb3VudGVkXCIpO1xuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2V0U2NvcGVJZCA9IChlbCwgdm5vZGUsIHNjb3BlSWQsIHNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50KSA9PiB7XG4gICAgaWYgKHNjb3BlSWQpIHtcbiAgICAgIGhvc3RTZXRTY29wZUlkKGVsLCBzY29wZUlkKTtcbiAgICB9XG4gICAgaWYgKHNsb3RTY29wZUlkcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbG90U2NvcGVJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaG9zdFNldFNjb3BlSWQoZWwsIHNsb3RTY29wZUlkc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJlbnRDb21wb25lbnQpIHtcbiAgICAgIGxldCBzdWJUcmVlID0gcGFyZW50Q29tcG9uZW50LnN1YlRyZWU7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzdWJUcmVlLnBhdGNoRmxhZyA+IDAgJiYgc3ViVHJlZS5wYXRjaEZsYWcgJiAyMDQ4KSB7XG4gICAgICAgIHN1YlRyZWUgPSBmaWx0ZXJTaW5nbGVSb290KHN1YlRyZWUuY2hpbGRyZW4pIHx8IHN1YlRyZWU7XG4gICAgICB9XG4gICAgICBpZiAodm5vZGUgPT09IHN1YlRyZWUgfHwgaXNTdXNwZW5zZShzdWJUcmVlLnR5cGUpICYmIChzdWJUcmVlLnNzQ29udGVudCA9PT0gdm5vZGUgfHwgc3ViVHJlZS5zc0ZhbGxiYWNrID09PSB2bm9kZSkpIHtcbiAgICAgICAgY29uc3QgcGFyZW50Vk5vZGUgPSBwYXJlbnRDb21wb25lbnQudm5vZGU7XG4gICAgICAgIHNldFNjb3BlSWQoXG4gICAgICAgICAgZWwsXG4gICAgICAgICAgcGFyZW50Vk5vZGUsXG4gICAgICAgICAgcGFyZW50Vk5vZGUuc2NvcGVJZCxcbiAgICAgICAgICBwYXJlbnRWTm9kZS5zbG90U2NvcGVJZHMsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LnBhcmVudFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgbW91bnRDaGlsZHJlbiA9IChjaGlsZHJlbiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHN0YXJ0ID0gMCkgPT4ge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoY2hpbGRyZW5baV0pIDogbm9ybWFsaXplVk5vZGUoY2hpbGRyZW5baV0pO1xuICAgICAgcGF0Y2goXG4gICAgICAgIG51bGwsXG4gICAgICAgIGNoaWxkLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdGNoRWxlbWVudCA9IChuMSwgbjIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCBlbCA9IG4yLmVsID0gbjEuZWw7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBlbC5fX3Zub2RlID0gbjI7XG4gICAgfVxuICAgIGxldCB7IHBhdGNoRmxhZywgZHluYW1pY0NoaWxkcmVuLCBkaXJzIH0gPSBuMjtcbiAgICBwYXRjaEZsYWcgfD0gbjEucGF0Y2hGbGFnICYgMTY7XG4gICAgY29uc3Qgb2xkUHJvcHMgPSBuMS5wcm9wcyB8fCBFTVBUWV9PQko7XG4gICAgY29uc3QgbmV3UHJvcHMgPSBuMi5wcm9wcyB8fCBFTVBUWV9PQko7XG4gICAgbGV0IHZub2RlSG9vaztcbiAgICBwYXJlbnRDb21wb25lbnQgJiYgdG9nZ2xlUmVjdXJzZShwYXJlbnRDb21wb25lbnQsIGZhbHNlKTtcbiAgICBpZiAodm5vZGVIb29rID0gbmV3UHJvcHMub25Wbm9kZUJlZm9yZVVwZGF0ZSkge1xuICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCBuMiwgbjEpO1xuICAgIH1cbiAgICBpZiAoZGlycykge1xuICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayhuMiwgbjEsIHBhcmVudENvbXBvbmVudCwgXCJiZWZvcmVVcGRhdGVcIik7XG4gICAgfVxuICAgIHBhcmVudENvbXBvbmVudCAmJiB0b2dnbGVSZWN1cnNlKHBhcmVudENvbXBvbmVudCwgdHJ1ZSk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNIbXJVcGRhdGluZykge1xuICAgICAgcGF0Y2hGbGFnID0gMDtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG9sZFByb3BzLmlubmVySFRNTCAmJiBuZXdQcm9wcy5pbm5lckhUTUwgPT0gbnVsbCB8fCBvbGRQcm9wcy50ZXh0Q29udGVudCAmJiBuZXdQcm9wcy50ZXh0Q29udGVudCA9PSBudWxsKSB7XG4gICAgICBob3N0U2V0RWxlbWVudFRleHQoZWwsIFwiXCIpO1xuICAgIH1cbiAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4oXG4gICAgICAgIG4xLmR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICBlbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgcmVzb2x2ZUNoaWxkcmVuTmFtZXNwYWNlKG4yLCBuYW1lc3BhY2UpLFxuICAgICAgICBzbG90U2NvcGVJZHNcbiAgICAgICk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghb3B0aW1pemVkKSB7XG4gICAgICBwYXRjaENoaWxkcmVuKFxuICAgICAgICBuMSxcbiAgICAgICAgbjIsXG4gICAgICAgIGVsLFxuICAgICAgICBudWxsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICByZXNvbHZlQ2hpbGRyZW5OYW1lc3BhY2UobjIsIG5hbWVzcGFjZSksXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChwYXRjaEZsYWcgPiAwKSB7XG4gICAgICBpZiAocGF0Y2hGbGFnICYgMTYpIHtcbiAgICAgICAgcGF0Y2hQcm9wcyhlbCwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIG5hbWVzcGFjZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocGF0Y2hGbGFnICYgMikge1xuICAgICAgICAgIGlmIChvbGRQcm9wcy5jbGFzcyAhPT0gbmV3UHJvcHMuY2xhc3MpIHtcbiAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIFwiY2xhc3NcIiwgbnVsbCwgbmV3UHJvcHMuY2xhc3MsIG5hbWVzcGFjZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiA0KSB7XG4gICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgXCJzdHlsZVwiLCBvbGRQcm9wcy5zdHlsZSwgbmV3UHJvcHMuc3R5bGUsIG5hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDgpIHtcbiAgICAgICAgICBjb25zdCBwcm9wc1RvVXBkYXRlID0gbjIuZHluYW1pY1Byb3BzO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNUb1VwZGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gcHJvcHNUb1VwZGF0ZVtpXTtcbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSBvbGRQcm9wc1trZXldO1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5ld1Byb3BzW2tleV07XG4gICAgICAgICAgICBpZiAobmV4dCAhPT0gcHJldiB8fCBrZXkgPT09IFwidmFsdWVcIikge1xuICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIHByZXYsIG5leHQsIG5hbWVzcGFjZSwgcGFyZW50Q29tcG9uZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXRjaEZsYWcgJiAxKSB7XG4gICAgICAgIGlmIChuMS5jaGlsZHJlbiAhPT0gbjIuY2hpbGRyZW4pIHtcbiAgICAgICAgICBob3N0U2V0RWxlbWVudFRleHQoZWwsIG4yLmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIW9wdGltaXplZCAmJiBkeW5hbWljQ2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgcGF0Y2hQcm9wcyhlbCwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIG5hbWVzcGFjZSk7XG4gICAgfVxuICAgIGlmICgodm5vZGVIb29rID0gbmV3UHJvcHMub25Wbm9kZVVwZGF0ZWQpIHx8IGRpcnMpIHtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIG4yLCBuMSk7XG4gICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayhuMiwgbjEsIHBhcmVudENvbXBvbmVudCwgXCJ1cGRhdGVkXCIpO1xuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF0Y2hCbG9ja0NoaWxkcmVuID0gKG9sZENoaWxkcmVuLCBuZXdDaGlsZHJlbiwgZmFsbGJhY2tDb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgb2xkVk5vZGUgPSBvbGRDaGlsZHJlbltpXTtcbiAgICAgIGNvbnN0IG5ld1ZOb2RlID0gbmV3Q2hpbGRyZW5baV07XG4gICAgICBjb25zdCBjb250YWluZXIgPSAoXG4gICAgICAgIC8vIG9sZFZOb2RlIG1heSBiZSBhbiBlcnJvcmVkIGFzeW5jIHNldHVwKCkgY29tcG9uZW50IGluc2lkZSBTdXNwZW5zZVxuICAgICAgICAvLyB3aGljaCB3aWxsIG5vdCBoYXZlIGEgbW91bnRlZCBlbGVtZW50XG4gICAgICAgIG9sZFZOb2RlLmVsICYmIC8vIC0gSW4gdGhlIGNhc2Ugb2YgYSBGcmFnbWVudCwgd2UgbmVlZCB0byBwcm92aWRlIHRoZSBhY3R1YWwgcGFyZW50XG4gICAgICAgIC8vIG9mIHRoZSBGcmFnbWVudCBpdHNlbGYgc28gaXQgY2FuIG1vdmUgaXRzIGNoaWxkcmVuLlxuICAgICAgICAob2xkVk5vZGUudHlwZSA9PT0gRnJhZ21lbnQgfHwgLy8gLSBJbiB0aGUgY2FzZSBvZiBkaWZmZXJlbnQgbm9kZXMsIHRoZXJlIGlzIGdvaW5nIHRvIGJlIGEgcmVwbGFjZW1lbnRcbiAgICAgICAgLy8gd2hpY2ggYWxzbyByZXF1aXJlcyB0aGUgY29ycmVjdCBwYXJlbnQgY29udGFpbmVyXG4gICAgICAgICFpc1NhbWVWTm9kZVR5cGUob2xkVk5vZGUsIG5ld1ZOb2RlKSB8fCAvLyAtIEluIHRoZSBjYXNlIG9mIGEgY29tcG9uZW50LCBpdCBjb3VsZCBjb250YWluIGFueXRoaW5nLlxuICAgICAgICBvbGRWTm9kZS5zaGFwZUZsYWcgJiAoNiB8IDY0IHwgMTI4KSkgPyBob3N0UGFyZW50Tm9kZShvbGRWTm9kZS5lbCkgOiAoXG4gICAgICAgICAgLy8gSW4gb3RoZXIgY2FzZXMsIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIG5vdCBhY3R1YWxseSB1c2VkIHNvIHdlXG4gICAgICAgICAgLy8ganVzdCBwYXNzIHRoZSBibG9jayBlbGVtZW50IGhlcmUgdG8gYXZvaWQgYSBET00gcGFyZW50Tm9kZSBjYWxsLlxuICAgICAgICAgIGZhbGxiYWNrQ29udGFpbmVyXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBwYXRjaChcbiAgICAgICAgb2xkVk5vZGUsXG4gICAgICAgIG5ld1ZOb2RlLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF0Y2hQcm9wcyA9IChlbCwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIG5hbWVzcGFjZSkgPT4ge1xuICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMpIHtcbiAgICAgIGlmIChvbGRQcm9wcyAhPT0gRU1QVFlfT0JKKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9sZFByb3BzKSB7XG4gICAgICAgICAgaWYgKCFpc1Jlc2VydmVkUHJvcChrZXkpICYmICEoa2V5IGluIG5ld1Byb3BzKSkge1xuICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChcbiAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgb2xkUHJvcHNba2V5XSxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXdQcm9wcykge1xuICAgICAgICBpZiAoaXNSZXNlcnZlZFByb3Aoa2V5KSkgY29udGludWU7XG4gICAgICAgIGNvbnN0IG5leHQgPSBuZXdQcm9wc1trZXldO1xuICAgICAgICBjb25zdCBwcmV2ID0gb2xkUHJvcHNba2V5XTtcbiAgICAgICAgaWYgKG5leHQgIT09IHByZXYgJiYga2V5ICE9PSBcInZhbHVlXCIpIHtcbiAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIHByZXYsIG5leHQsIG5hbWVzcGFjZSwgcGFyZW50Q29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKFwidmFsdWVcIiBpbiBuZXdQcm9wcykge1xuICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBcInZhbHVlXCIsIG9sZFByb3BzLnZhbHVlLCBuZXdQcm9wcy52YWx1ZSwgbmFtZXNwYWNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NGcmFnbWVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgZnJhZ21lbnRTdGFydEFuY2hvciA9IG4yLmVsID0gbjEgPyBuMS5lbCA6IGhvc3RDcmVhdGVUZXh0KFwiXCIpO1xuICAgIGNvbnN0IGZyYWdtZW50RW5kQW5jaG9yID0gbjIuYW5jaG9yID0gbjEgPyBuMS5hbmNob3IgOiBob3N0Q3JlYXRlVGV4dChcIlwiKTtcbiAgICBsZXQgeyBwYXRjaEZsYWcsIGR5bmFtaWNDaGlsZHJlbiwgc2xvdFNjb3BlSWRzOiBmcmFnbWVudFNsb3RTY29wZUlkcyB9ID0gbjI7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgLy8gIzU1MjMgZGV2IHJvb3QgZnJhZ21lbnQgbWF5IGluaGVyaXQgZGlyZWN0aXZlc1xuICAgIChpc0htclVwZGF0aW5nIHx8IHBhdGNoRmxhZyAmIDIwNDgpKSB7XG4gICAgICBwYXRjaEZsYWcgPSAwO1xuICAgICAgb3B0aW1pemVkID0gZmFsc2U7XG4gICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZnJhZ21lbnRTbG90U2NvcGVJZHMpIHtcbiAgICAgIHNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkcyA/IHNsb3RTY29wZUlkcy5jb25jYXQoZnJhZ21lbnRTbG90U2NvcGVJZHMpIDogZnJhZ21lbnRTbG90U2NvcGVJZHM7XG4gICAgfVxuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBob3N0SW5zZXJ0KGZyYWdtZW50U3RhcnRBbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIGhvc3RJbnNlcnQoZnJhZ21lbnRFbmRBbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIG1vdW50Q2hpbGRyZW4oXG4gICAgICAgIC8vICMxMDAwN1xuICAgICAgICAvLyBzdWNoIGZyYWdtZW50IGxpa2UgYDw+PC8+YCB3aWxsIGJlIGNvbXBpbGVkIGludG9cbiAgICAgICAgLy8gYSBmcmFnbWVudCB3aGljaCBkb2Vzbid0IGhhdmUgYSBjaGlsZHJlbi5cbiAgICAgICAgLy8gSW4gdGhpcyBjYXNlIGZhbGxiYWNrIHRvIGFuIGVtcHR5IGFycmF5XG4gICAgICAgIG4yLmNoaWxkcmVuIHx8IFtdLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGZyYWdtZW50RW5kQW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGF0Y2hGbGFnID4gMCAmJiBwYXRjaEZsYWcgJiA2NCAmJiBkeW5hbWljQ2hpbGRyZW4gJiYgLy8gIzI3MTUgdGhlIHByZXZpb3VzIGZyYWdtZW50IGNvdWxkJ3ZlIGJlZW4gYSBCQUlMZWQgb25lIGFzIGEgcmVzdWx0XG4gICAgICAvLyBvZiByZW5kZXJTbG90KCkgd2l0aCBubyB2YWxpZCBjaGlsZHJlblxuICAgICAgbjEuZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihcbiAgICAgICAgICBuMS5keW5hbWljQ2hpbGRyZW4sXG4gICAgICAgICAgZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkc1xuICAgICAgICApO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAvLyAjMjA4MCBpZiB0aGUgc3RhYmxlIGZyYWdtZW50IGhhcyBhIGtleSwgaXQncyBhIDx0ZW1wbGF0ZSB2LWZvcj4gdGhhdCBtYXlcbiAgICAgICAgICAvLyAgZ2V0IG1vdmVkIGFyb3VuZC4gTWFrZSBzdXJlIGFsbCByb290IGxldmVsIHZub2RlcyBpbmhlcml0IGVsLlxuICAgICAgICAgIC8vICMyMTM0IG9yIGlmIGl0J3MgYSBjb21wb25lbnQgcm9vdCwgaXQgbWF5IGFsc28gZ2V0IG1vdmVkIGFyb3VuZFxuICAgICAgICAgIC8vIGFzIHRoZSBjb21wb25lbnQgaXMgYmVpbmcgbW92ZWQuXG4gICAgICAgICAgbjIua2V5ICE9IG51bGwgfHwgcGFyZW50Q29tcG9uZW50ICYmIG4yID09PSBwYXJlbnRDb21wb25lbnQuc3ViVHJlZVxuICAgICAgICApIHtcbiAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKFxuICAgICAgICAgICAgbjEsXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgIC8qIHNoYWxsb3cgKi9cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRjaENoaWxkcmVuKFxuICAgICAgICAgIG4xLFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBmcmFnbWVudEVuZEFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NDb21wb25lbnQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIG4yLnNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkcztcbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgaWYgKG4yLnNoYXBlRmxhZyAmIDUxMikge1xuICAgICAgICBwYXJlbnRDb21wb25lbnQuY3R4LmFjdGl2YXRlKFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW91bnRDb21wb25lbnQoXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVDb21wb25lbnQobjEsIG4yLCBvcHRpbWl6ZWQpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbW91bnRDb21wb25lbnQgPSAoaW5pdGlhbFZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IChpbml0aWFsVk5vZGUuY29tcG9uZW50ID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2UoXG4gICAgICBpbml0aWFsVk5vZGUsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBwYXJlbnRTdXNwZW5zZVxuICAgICkpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGluc3RhbmNlLnR5cGUuX19obXJJZCkge1xuICAgICAgcmVnaXN0ZXJITVIoaW5zdGFuY2UpO1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KGluaXRpYWxWTm9kZSk7XG4gICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBtb3VudGApO1xuICAgIH1cbiAgICBpZiAoaXNLZWVwQWxpdmUoaW5pdGlhbFZOb2RlKSkge1xuICAgICAgaW5zdGFuY2UuY3R4LnJlbmRlcmVyID0gaW50ZXJuYWxzO1xuICAgIH1cbiAgICB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBpbml0YCk7XG4gICAgICB9XG4gICAgICBzZXR1cENvbXBvbmVudChpbnN0YW5jZSwgZmFsc2UsIG9wdGltaXplZCk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgaW5pdGApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0htclVwZGF0aW5nKSBpbml0aWFsVk5vZGUuZWwgPSBudWxsO1xuICAgIGlmIChpbnN0YW5jZS5hc3luY0RlcCkge1xuICAgICAgcGFyZW50U3VzcGVuc2UgJiYgcGFyZW50U3VzcGVuc2UucmVnaXN0ZXJEZXAoaW5zdGFuY2UsIHNldHVwUmVuZGVyRWZmZWN0LCBvcHRpbWl6ZWQpO1xuICAgICAgaWYgKCFpbml0aWFsVk5vZGUuZWwpIHtcbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSBpbnN0YW5jZS5zdWJUcmVlID0gY3JlYXRlVk5vZGUoQ29tbWVudCk7XG4gICAgICAgIHByb2Nlc3NDb21tZW50Tm9kZShudWxsLCBwbGFjZWhvbGRlciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXR1cFJlbmRlckVmZmVjdChcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgIGluaXRpYWxWTm9kZSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XG4gICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgbW91bnRgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHVwZGF0ZUNvbXBvbmVudCA9IChuMSwgbjIsIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gbjIuY29tcG9uZW50ID0gbjEuY29tcG9uZW50O1xuICAgIGlmIChzaG91bGRVcGRhdGVDb21wb25lbnQobjEsIG4yLCBvcHRpbWl6ZWQpKSB7XG4gICAgICBpZiAoaW5zdGFuY2UuYXN5bmNEZXAgJiYgIWluc3RhbmNlLmFzeW5jUmVzb2x2ZWQpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQobjIpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbjIsIG9wdGltaXplZCk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0YW5jZS5uZXh0ID0gbjI7XG4gICAgICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuMi5lbCA9IG4xLmVsO1xuICAgICAgaW5zdGFuY2Uudm5vZGUgPSBuMjtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHNldHVwUmVuZGVyRWZmZWN0ID0gKGluc3RhbmNlLCBpbml0aWFsVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCBjb21wb25lbnRVcGRhdGVGbiA9ICgpID0+IHtcbiAgICAgIGlmICghaW5zdGFuY2UuaXNNb3VudGVkKSB7XG4gICAgICAgIGxldCB2bm9kZUhvb2s7XG4gICAgICAgIGNvbnN0IHsgZWwsIHByb3BzIH0gPSBpbml0aWFsVk5vZGU7XG4gICAgICAgIGNvbnN0IHsgYm0sIG0sIHBhcmVudCwgcm9vdCwgdHlwZSB9ID0gaW5zdGFuY2U7XG4gICAgICAgIGNvbnN0IGlzQXN5bmNXcmFwcGVyVk5vZGUgPSBpc0FzeW5jV3JhcHBlcihpbml0aWFsVk5vZGUpO1xuICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCBmYWxzZSk7XG4gICAgICAgIGlmIChibSkge1xuICAgICAgICAgIGludm9rZUFycmF5Rm5zKGJtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQXN5bmNXcmFwcGVyVk5vZGUgJiYgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVNb3VudCkpIHtcbiAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIGluaXRpYWxWTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgdHJ1ZSk7XG4gICAgICAgIGlmIChlbCAmJiBoeWRyYXRlTm9kZSkge1xuICAgICAgICAgIGNvbnN0IGh5ZHJhdGVTdWJUcmVlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnN0YW5jZS5zdWJUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSk7XG4gICAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBoeWRyYXRlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoeWRyYXRlTm9kZShcbiAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgIGluc3RhbmNlLnN1YlRyZWUsXG4gICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBoeWRyYXRlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoaXNBc3luY1dyYXBwZXJWTm9kZSAmJiB0eXBlLl9fYXN5bmNIeWRyYXRlKSB7XG4gICAgICAgICAgICB0eXBlLl9fYXN5bmNIeWRyYXRlKFxuICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgIGh5ZHJhdGVTdWJUcmVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoeWRyYXRlU3ViVHJlZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocm9vdC5jZSkge1xuICAgICAgICAgICAgcm9vdC5jZS5faW5qZWN0Q2hpbGRTdHlsZSh0eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzdWJUcmVlID0gaW5zdGFuY2Uuc3ViVHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpO1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXRjaChcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBzdWJUcmVlLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbml0aWFsVk5vZGUuZWwgPSBzdWJUcmVlLmVsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KG0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQXN5bmNXcmFwcGVyVk5vZGUgJiYgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSkge1xuICAgICAgICAgIGNvbnN0IHNjb3BlZEluaXRpYWxWTm9kZSA9IGluaXRpYWxWTm9kZTtcbiAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoXG4gICAgICAgICAgICAoKSA9PiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIHNjb3BlZEluaXRpYWxWTm9kZSksXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaXRpYWxWTm9kZS5zaGFwZUZsYWcgJiAyNTYgfHwgcGFyZW50ICYmIGlzQXN5bmNXcmFwcGVyKHBhcmVudC52bm9kZSkgJiYgcGFyZW50LnZub2RlLnNoYXBlRmxhZyAmIDI1Nikge1xuICAgICAgICAgIGluc3RhbmNlLmEgJiYgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGluc3RhbmNlLmEsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpbml0aWFsVk5vZGUgPSBjb250YWluZXIgPSBhbmNob3IgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHsgbmV4dCwgYnUsIHUsIHBhcmVudCwgdm5vZGUgfSA9IGluc3RhbmNlO1xuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qgbm9uSHlkcmF0ZWRBc3luY1Jvb3QgPSBsb2NhdGVOb25IeWRyYXRlZEFzeW5jUm9vdChpbnN0YW5jZSk7XG4gICAgICAgICAgaWYgKG5vbkh5ZHJhdGVkQXN5bmNSb290KSB7XG4gICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICBuZXh0LmVsID0gdm5vZGUuZWw7XG4gICAgICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbmV4dCwgb3B0aW1pemVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vbkh5ZHJhdGVkQXN5bmNSb290LmFzeW5jRGVwLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoIWluc3RhbmNlLmlzVW5tb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50VXBkYXRlRm4oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBvcmlnaW5OZXh0ID0gbmV4dDtcbiAgICAgICAgbGV0IHZub2RlSG9vaztcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQobmV4dCB8fCBpbnN0YW5jZS52bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgZmFsc2UpO1xuICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgIG5leHQuZWwgPSB2bm9kZS5lbDtcbiAgICAgICAgICB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIoaW5zdGFuY2UsIG5leHQsIG9wdGltaXplZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCA9IHZub2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidSkge1xuICAgICAgICAgIGludm9rZUFycmF5Rm5zKGJ1KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodm5vZGVIb29rID0gbmV4dC5wcm9wcyAmJiBuZXh0LnByb3BzLm9uVm5vZGVCZWZvcmVVcGRhdGUpIHtcbiAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIG5leHQsIHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCB0cnVlKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0VHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2VHJlZSA9IGluc3RhbmNlLnN1YlRyZWU7XG4gICAgICAgIGluc3RhbmNlLnN1YlRyZWUgPSBuZXh0VHJlZTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICB9XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIHByZXZUcmVlLFxuICAgICAgICAgIG5leHRUcmVlLFxuICAgICAgICAgIC8vIHBhcmVudCBtYXkgaGF2ZSBjaGFuZ2VkIGlmIGl0J3MgaW4gYSB0ZWxlcG9ydFxuICAgICAgICAgIGhvc3RQYXJlbnROb2RlKHByZXZUcmVlLmVsKSxcbiAgICAgICAgICAvLyBhbmNob3IgbWF5IGhhdmUgY2hhbmdlZCBpZiBpdCdzIGluIGEgZnJhZ21lbnRcbiAgICAgICAgICBnZXROZXh0SG9zdE5vZGUocHJldlRyZWUpLFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZVxuICAgICAgICApO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICB9XG4gICAgICAgIG5leHQuZWwgPSBuZXh0VHJlZS5lbDtcbiAgICAgICAgaWYgKG9yaWdpbk5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIG5leHRUcmVlLmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodSkge1xuICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCh1LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZub2RlSG9vayA9IG5leHQucHJvcHMgJiYgbmV4dC5wcm9wcy5vblZub2RlVXBkYXRlZCkge1xuICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChcbiAgICAgICAgICAgICgpID0+IGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgbmV4dCwgdm5vZGUpLFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2VcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZChpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBpbnN0YW5jZS5zY29wZS5vbigpO1xuICAgIGNvbnN0IGVmZmVjdCA9IGluc3RhbmNlLmVmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChjb21wb25lbnRVcGRhdGVGbik7XG4gICAgaW5zdGFuY2Uuc2NvcGUub2ZmKCk7XG4gICAgY29uc3QgdXBkYXRlID0gaW5zdGFuY2UudXBkYXRlID0gZWZmZWN0LnJ1bi5iaW5kKGVmZmVjdCk7XG4gICAgY29uc3Qgam9iID0gaW5zdGFuY2Uuam9iID0gZWZmZWN0LnJ1bklmRGlydHkuYmluZChlZmZlY3QpO1xuICAgIGpvYi5pID0gaW5zdGFuY2U7XG4gICAgam9iLmlkID0gaW5zdGFuY2UudWlkO1xuICAgIGVmZmVjdC5zY2hlZHVsZXIgPSAoKSA9PiBxdWV1ZUpvYihqb2IpO1xuICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBlZmZlY3Qub25UcmFjayA9IGluc3RhbmNlLnJ0YyA/IChlKSA9PiBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5ydGMsIGUpIDogdm9pZCAwO1xuICAgICAgZWZmZWN0Lm9uVHJpZ2dlciA9IGluc3RhbmNlLnJ0ZyA/IChlKSA9PiBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5ydGcsIGUpIDogdm9pZCAwO1xuICAgIH1cbiAgICB1cGRhdGUoKTtcbiAgfTtcbiAgY29uc3QgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyID0gKGluc3RhbmNlLCBuZXh0Vk5vZGUsIG9wdGltaXplZCkgPT4ge1xuICAgIG5leHRWTm9kZS5jb21wb25lbnQgPSBpbnN0YW5jZTtcbiAgICBjb25zdCBwcmV2UHJvcHMgPSBpbnN0YW5jZS52bm9kZS5wcm9wcztcbiAgICBpbnN0YW5jZS52bm9kZSA9IG5leHRWTm9kZTtcbiAgICBpbnN0YW5jZS5uZXh0ID0gbnVsbDtcbiAgICB1cGRhdGVQcm9wcyhpbnN0YW5jZSwgbmV4dFZOb2RlLnByb3BzLCBwcmV2UHJvcHMsIG9wdGltaXplZCk7XG4gICAgdXBkYXRlU2xvdHMoaW5zdGFuY2UsIG5leHRWTm9kZS5jaGlsZHJlbiwgb3B0aW1pemVkKTtcbiAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgZmx1c2hQcmVGbHVzaENicyhpbnN0YW5jZSk7XG4gICAgcmVzZXRUcmFja2luZygpO1xuICB9O1xuICBjb25zdCBwYXRjaENoaWxkcmVuID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IGMxID0gbjEgJiYgbjEuY2hpbGRyZW47XG4gICAgY29uc3QgcHJldlNoYXBlRmxhZyA9IG4xID8gbjEuc2hhcGVGbGFnIDogMDtcbiAgICBjb25zdCBjMiA9IG4yLmNoaWxkcmVuO1xuICAgIGNvbnN0IHsgcGF0Y2hGbGFnLCBzaGFwZUZsYWcgfSA9IG4yO1xuICAgIGlmIChwYXRjaEZsYWcgPiAwKSB7XG4gICAgICBpZiAocGF0Y2hGbGFnICYgMTI4KSB7XG4gICAgICAgIHBhdGNoS2V5ZWRDaGlsZHJlbihcbiAgICAgICAgICBjMSxcbiAgICAgICAgICBjMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHBhdGNoRmxhZyAmIDI1Nikge1xuICAgICAgICBwYXRjaFVua2V5ZWRDaGlsZHJlbihcbiAgICAgICAgICBjMSxcbiAgICAgICAgICBjMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaGFwZUZsYWcgJiA4KSB7XG4gICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgIHVubW91bnRDaGlsZHJlbihjMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9XG4gICAgICBpZiAoYzIgIT09IGMxKSB7XG4gICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsIGMyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByZXZTaGFwZUZsYWcgJiAxNikge1xuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgICAgICBwYXRjaEtleWVkQ2hpbGRyZW4oXG4gICAgICAgICAgICBjMSxcbiAgICAgICAgICAgIGMyLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVubW91bnRDaGlsZHJlbihjMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcmV2U2hhcGVGbGFnICYgOCkge1xuICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsIFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgICAgIG1vdW50Q2hpbGRyZW4oXG4gICAgICAgICAgICBjMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF0Y2hVbmtleWVkQ2hpbGRyZW4gPSAoYzEsIGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGMxID0gYzEgfHwgRU1QVFlfQVJSO1xuICAgIGMyID0gYzIgfHwgRU1QVFlfQVJSO1xuICAgIGNvbnN0IG9sZExlbmd0aCA9IGMxLmxlbmd0aDtcbiAgICBjb25zdCBuZXdMZW5ndGggPSBjMi5sZW5ndGg7XG4gICAgY29uc3QgY29tbW9uTGVuZ3RoID0gTWF0aC5taW4ob2xkTGVuZ3RoLCBuZXdMZW5ndGgpO1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb21tb25MZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbmV4dENoaWxkID0gYzJbaV0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjMltpXSkgOiBub3JtYWxpemVWTm9kZShjMltpXSk7XG4gICAgICBwYXRjaChcbiAgICAgICAgYzFbaV0sXG4gICAgICAgIG5leHRDaGlsZCxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBudWxsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAob2xkTGVuZ3RoID4gbmV3TGVuZ3RoKSB7XG4gICAgICB1bm1vdW50Q2hpbGRyZW4oXG4gICAgICAgIGMxLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICB0cnVlLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgY29tbW9uTGVuZ3RoXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb3VudENoaWxkcmVuKFxuICAgICAgICBjMixcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgIGNvbW1vbkxlbmd0aFxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdGNoS2V5ZWRDaGlsZHJlbiA9IChjMSwgYzIsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IGwyID0gYzIubGVuZ3RoO1xuICAgIGxldCBlMSA9IGMxLmxlbmd0aCAtIDE7XG4gICAgbGV0IGUyID0gbDIgLSAxO1xuICAgIHdoaWxlIChpIDw9IGUxICYmIGkgPD0gZTIpIHtcbiAgICAgIGNvbnN0IG4xID0gYzFbaV07XG4gICAgICBjb25zdCBuMiA9IGMyW2ldID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pO1xuICAgICAgaWYgKGlzU2FtZVZOb2RlVHlwZShuMSwgbjIpKSB7XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG4xLFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICAgIHdoaWxlIChpIDw9IGUxICYmIGkgPD0gZTIpIHtcbiAgICAgIGNvbnN0IG4xID0gYzFbZTFdO1xuICAgICAgY29uc3QgbjIgPSBjMltlMl0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjMltlMl0pIDogbm9ybWFsaXplVk5vZGUoYzJbZTJdKTtcbiAgICAgIGlmIChpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSkge1xuICAgICAgICBwYXRjaChcbiAgICAgICAgICBuMSxcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZTEtLTtcbiAgICAgIGUyLS07XG4gICAgfVxuICAgIGlmIChpID4gZTEpIHtcbiAgICAgIGlmIChpIDw9IGUyKSB7XG4gICAgICAgIGNvbnN0IG5leHRQb3MgPSBlMiArIDE7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHRQb3MgPCBsMiA/IGMyW25leHRQb3NdLmVsIDogcGFyZW50QW5jaG9yO1xuICAgICAgICB3aGlsZSAoaSA8PSBlMikge1xuICAgICAgICAgIHBhdGNoKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIGMyW2ldID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaSA+IGUyKSB7XG4gICAgICB3aGlsZSAoaSA8PSBlMSkge1xuICAgICAgICB1bm1vdW50KGMxW2ldLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzMSA9IGk7XG4gICAgICBjb25zdCBzMiA9IGk7XG4gICAgICBjb25zdCBrZXlUb05ld0luZGV4TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGZvciAoaSA9IHMyOyBpIDw9IGUyOyBpKyspIHtcbiAgICAgICAgY29uc3QgbmV4dENoaWxkID0gYzJbaV0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjMltpXSkgOiBub3JtYWxpemVWTm9kZShjMltpXSk7XG4gICAgICAgIGlmIChuZXh0Q2hpbGQua2V5ICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBrZXlUb05ld0luZGV4TWFwLmhhcyhuZXh0Q2hpbGQua2V5KSkge1xuICAgICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgICBgRHVwbGljYXRlIGtleXMgZm91bmQgZHVyaW5nIHVwZGF0ZTpgLFxuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShuZXh0Q2hpbGQua2V5KSxcbiAgICAgICAgICAgICAgYE1ha2Ugc3VyZSBrZXlzIGFyZSB1bmlxdWUuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAga2V5VG9OZXdJbmRleE1hcC5zZXQobmV4dENoaWxkLmtleSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBqO1xuICAgICAgbGV0IHBhdGNoZWQgPSAwO1xuICAgICAgY29uc3QgdG9CZVBhdGNoZWQgPSBlMiAtIHMyICsgMTtcbiAgICAgIGxldCBtb3ZlZCA9IGZhbHNlO1xuICAgICAgbGV0IG1heE5ld0luZGV4U29GYXIgPSAwO1xuICAgICAgY29uc3QgbmV3SW5kZXhUb09sZEluZGV4TWFwID0gbmV3IEFycmF5KHRvQmVQYXRjaGVkKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0b0JlUGF0Y2hlZDsgaSsrKSBuZXdJbmRleFRvT2xkSW5kZXhNYXBbaV0gPSAwO1xuICAgICAgZm9yIChpID0gczE7IGkgPD0gZTE7IGkrKykge1xuICAgICAgICBjb25zdCBwcmV2Q2hpbGQgPSBjMVtpXTtcbiAgICAgICAgaWYgKHBhdGNoZWQgPj0gdG9CZVBhdGNoZWQpIHtcbiAgICAgICAgICB1bm1vdW50KHByZXZDaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld0luZGV4O1xuICAgICAgICBpZiAocHJldkNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3SW5kZXggPSBrZXlUb05ld0luZGV4TWFwLmdldChwcmV2Q2hpbGQua2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGogPSBzMjsgaiA8PSBlMjsgaisrKSB7XG4gICAgICAgICAgICBpZiAobmV3SW5kZXhUb09sZEluZGV4TWFwW2ogLSBzMl0gPT09IDAgJiYgaXNTYW1lVk5vZGVUeXBlKHByZXZDaGlsZCwgYzJbal0pKSB7XG4gICAgICAgICAgICAgIG5ld0luZGV4ID0gajtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdJbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdW5tb3VudChwcmV2Q2hpbGQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0luZGV4VG9PbGRJbmRleE1hcFtuZXdJbmRleCAtIHMyXSA9IGkgKyAxO1xuICAgICAgICAgIGlmIChuZXdJbmRleCA+PSBtYXhOZXdJbmRleFNvRmFyKSB7XG4gICAgICAgICAgICBtYXhOZXdJbmRleFNvRmFyID0gbmV3SW5kZXg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBwcmV2Q2hpbGQsXG4gICAgICAgICAgICBjMltuZXdJbmRleF0sXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIHBhdGNoZWQrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2UgPSBtb3ZlZCA/IGdldFNlcXVlbmNlKG5ld0luZGV4VG9PbGRJbmRleE1hcCkgOiBFTVBUWV9BUlI7XG4gICAgICBqID0gaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2UubGVuZ3RoIC0gMTtcbiAgICAgIGZvciAoaSA9IHRvQmVQYXRjaGVkIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gczIgKyBpO1xuICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSBjMltuZXh0SW5kZXhdO1xuICAgICAgICBjb25zdCBhbmNob3IgPSBuZXh0SW5kZXggKyAxIDwgbDIgPyBjMltuZXh0SW5kZXggKyAxXS5lbCA6IHBhcmVudEFuY2hvcjtcbiAgICAgICAgaWYgKG5ld0luZGV4VG9PbGRJbmRleE1hcFtpXSA9PT0gMCkge1xuICAgICAgICAgIHBhdGNoKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIG5leHRDaGlsZCxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChtb3ZlZCkge1xuICAgICAgICAgIGlmIChqIDwgMCB8fCBpICE9PSBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZVtqXSkge1xuICAgICAgICAgICAgbW92ZShuZXh0Q2hpbGQsIGNvbnRhaW5lciwgYW5jaG9yLCAyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgai0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgbW92ZSA9ICh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlLCBwYXJlbnRTdXNwZW5zZSA9IG51bGwpID0+IHtcbiAgICBjb25zdCB7IGVsLCB0eXBlLCB0cmFuc2l0aW9uLCBjaGlsZHJlbiwgc2hhcGVGbGFnIH0gPSB2bm9kZTtcbiAgICBpZiAoc2hhcGVGbGFnICYgNikge1xuICAgICAgbW92ZSh2bm9kZS5jb21wb25lbnQuc3ViVHJlZSwgY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgdm5vZGUuc3VzcGVuc2UubW92ZShjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2hhcGVGbGFnICYgNjQpIHtcbiAgICAgIHR5cGUubW92ZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIGludGVybmFscyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBGcmFnbWVudCkge1xuICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBtb3ZlKGNoaWxkcmVuW2ldLCBjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUpO1xuICAgICAgfVxuICAgICAgaG9zdEluc2VydCh2bm9kZS5hbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFN0YXRpYykge1xuICAgICAgbW92ZVN0YXRpY05vZGUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmVlZFRyYW5zaXRpb24yID0gbW92ZVR5cGUgIT09IDIgJiYgc2hhcGVGbGFnICYgMSAmJiB0cmFuc2l0aW9uO1xuICAgIGlmIChuZWVkVHJhbnNpdGlvbjIpIHtcbiAgICAgIGlmIChtb3ZlVHlwZSA9PT0gMCkge1xuICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcbiAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4gdHJhbnNpdGlvbi5lbnRlcihlbCksIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgbGVhdmUsIGRlbGF5TGVhdmUsIGFmdGVyTGVhdmUgfSA9IHRyYW5zaXRpb247XG4gICAgICAgIGNvbnN0IHJlbW92ZTIgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKHZub2RlLmN0eC5pc1VubW91bnRlZCkge1xuICAgICAgICAgICAgaG9zdFJlbW92ZShlbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBlcmZvcm1MZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgICBsZWF2ZShlbCwgKCkgPT4ge1xuICAgICAgICAgICAgcmVtb3ZlMigpO1xuICAgICAgICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChkZWxheUxlYXZlKSB7XG4gICAgICAgICAgZGVsYXlMZWF2ZShlbCwgcmVtb3ZlMiwgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZXJmb3JtTGVhdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgfVxuICB9O1xuICBjb25zdCB1bm1vdW50ID0gKHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSA9IGZhbHNlLCBvcHRpbWl6ZWQgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIHJlZixcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZHluYW1pY0NoaWxkcmVuLFxuICAgICAgc2hhcGVGbGFnLFxuICAgICAgcGF0Y2hGbGFnLFxuICAgICAgZGlycyxcbiAgICAgIGNhY2hlSW5kZXhcbiAgICB9ID0gdm5vZGU7XG4gICAgaWYgKHBhdGNoRmxhZyA9PT0gLTIpIHtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAocmVmICE9IG51bGwpIHtcbiAgICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICAgIHNldFJlZihyZWYsIG51bGwsIHBhcmVudFN1c3BlbnNlLCB2bm9kZSwgdHJ1ZSk7XG4gICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgfVxuICAgIGlmIChjYWNoZUluZGV4ICE9IG51bGwpIHtcbiAgICAgIHBhcmVudENvbXBvbmVudC5yZW5kZXJDYWNoZVtjYWNoZUluZGV4XSA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDI1Nikge1xuICAgICAgcGFyZW50Q29tcG9uZW50LmN0eC5kZWFjdGl2YXRlKHZub2RlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2hvdWxkSW52b2tlRGlycyA9IHNoYXBlRmxhZyAmIDEgJiYgZGlycztcbiAgICBjb25zdCBzaG91bGRJbnZva2VWbm9kZUhvb2sgPSAhaXNBc3luY1dyYXBwZXIodm5vZGUpO1xuICAgIGxldCB2bm9kZUhvb2s7XG4gICAgaWYgKHNob3VsZEludm9rZVZub2RlSG9vayAmJiAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZUJlZm9yZVVubW91bnQpKSB7XG4gICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDYpIHtcbiAgICAgIHVubW91bnRDb21wb25lbnQodm5vZGUuY29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICAgIHZub2RlLnN1c3BlbnNlLnVubW91bnQocGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZEludm9rZURpcnMpIHtcbiAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcImJlZm9yZVVubW91bnRcIik7XG4gICAgICB9XG4gICAgICBpZiAoc2hhcGVGbGFnICYgNjQpIHtcbiAgICAgICAgdm5vZGUudHlwZS5yZW1vdmUoXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGludGVybmFscyxcbiAgICAgICAgICBkb1JlbW92ZVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChkeW5hbWljQ2hpbGRyZW4gJiYgLy8gIzUxNTRcbiAgICAgIC8vIHdoZW4gdi1vbmNlIGlzIHVzZWQgaW5zaWRlIGEgYmxvY2ssIHNldEJsb2NrVHJhY2tpbmcoLTEpIG1hcmtzIHRoZVxuICAgICAgLy8gcGFyZW50IGJsb2NrIHdpdGggaGFzT25jZTogdHJ1ZVxuICAgICAgLy8gc28gdGhhdCBpdCBkb2Vzbid0IHRha2UgdGhlIGZhc3QgcGF0aCBkdXJpbmcgdW5tb3VudCAtIG90aGVyd2lzZVxuICAgICAgLy8gY29tcG9uZW50cyBuZXN0ZWQgaW4gdi1vbmNlIGFyZSBuZXZlciB1bm1vdW50ZWQuXG4gICAgICAhZHluYW1pY0NoaWxkcmVuLmhhc09uY2UgJiYgLy8gIzExNTM6IGZhc3QgcGF0aCBzaG91bGQgbm90IGJlIHRha2VuIGZvciBub24tc3RhYmxlICh2LWZvcikgZnJhZ21lbnRzXG4gICAgICAodHlwZSAhPT0gRnJhZ21lbnQgfHwgcGF0Y2hGbGFnID4gMCAmJiBwYXRjaEZsYWcgJiA2NCkpIHtcbiAgICAgICAgdW5tb3VudENoaWxkcmVuKFxuICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBGcmFnbWVudCAmJiBwYXRjaEZsYWcgJiAoMTI4IHwgMjU2KSB8fCAhb3B0aW1pemVkICYmIHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgIHVubW91bnRDaGlsZHJlbihjaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9XG4gICAgICBpZiAoZG9SZW1vdmUpIHtcbiAgICAgICAgcmVtb3ZlKHZub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNob3VsZEludm9rZVZub2RlSG9vayAmJiAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZVVubW91bnRlZCkgfHwgc2hvdWxkSW52b2tlRGlycykge1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgdm5vZGVIb29rICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgICBzaG91bGRJbnZva2VEaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJ1bm1vdW50ZWRcIik7XG4gICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZW1vdmUgPSAodm5vZGUpID0+IHtcbiAgICBjb25zdCB7IHR5cGUsIGVsLCBhbmNob3IsIHRyYW5zaXRpb24gfSA9IHZub2RlO1xuICAgIGlmICh0eXBlID09PSBGcmFnbWVudCkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdm5vZGUucGF0Y2hGbGFnID4gMCAmJiB2bm9kZS5wYXRjaEZsYWcgJiAyMDQ4ICYmIHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkKSB7XG4gICAgICAgIHZub2RlLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IENvbW1lbnQpIHtcbiAgICAgICAgICAgIGhvc3RSZW1vdmUoY2hpbGQuZWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmUoY2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmVGcmFnbWVudChlbCwgYW5jaG9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFN0YXRpYykge1xuICAgICAgcmVtb3ZlU3RhdGljTm9kZSh2bm9kZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBlcmZvcm1SZW1vdmUgPSAoKSA9PiB7XG4gICAgICBob3N0UmVtb3ZlKGVsKTtcbiAgICAgIGlmICh0cmFuc2l0aW9uICYmICF0cmFuc2l0aW9uLnBlcnNpc3RlZCAmJiB0cmFuc2l0aW9uLmFmdGVyTGVhdmUpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5hZnRlckxlYXZlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMSAmJiB0cmFuc2l0aW9uICYmICF0cmFuc2l0aW9uLnBlcnNpc3RlZCkge1xuICAgICAgY29uc3QgeyBsZWF2ZSwgZGVsYXlMZWF2ZSB9ID0gdHJhbnNpdGlvbjtcbiAgICAgIGNvbnN0IHBlcmZvcm1MZWF2ZSA9ICgpID0+IGxlYXZlKGVsLCBwZXJmb3JtUmVtb3ZlKTtcbiAgICAgIGlmIChkZWxheUxlYXZlKSB7XG4gICAgICAgIGRlbGF5TGVhdmUodm5vZGUuZWwsIHBlcmZvcm1SZW1vdmUsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZXJmb3JtTGVhdmUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVyZm9ybVJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVtb3ZlRnJhZ21lbnQgPSAoY3VyLCBlbmQpID0+IHtcbiAgICBsZXQgbmV4dDtcbiAgICB3aGlsZSAoY3VyICE9PSBlbmQpIHtcbiAgICAgIG5leHQgPSBob3N0TmV4dFNpYmxpbmcoY3VyKTtcbiAgICAgIGhvc3RSZW1vdmUoY3VyKTtcbiAgICAgIGN1ciA9IG5leHQ7XG4gICAgfVxuICAgIGhvc3RSZW1vdmUoZW5kKTtcbiAgfTtcbiAgY29uc3QgdW5tb3VudENvbXBvbmVudCA9IChpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKSA9PiB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaW5zdGFuY2UudHlwZS5fX2htcklkKSB7XG4gICAgICB1bnJlZ2lzdGVySE1SKGluc3RhbmNlKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYnVtLFxuICAgICAgc2NvcGUsXG4gICAgICBqb2IsXG4gICAgICBzdWJUcmVlLFxuICAgICAgdW0sXG4gICAgICBtLFxuICAgICAgYSxcbiAgICAgIHBhcmVudCxcbiAgICAgIHNsb3RzOiB7IF9fOiBzbG90Q2FjaGVLZXlzIH1cbiAgICB9ID0gaW5zdGFuY2U7XG4gICAgaW52YWxpZGF0ZU1vdW50KG0pO1xuICAgIGludmFsaWRhdGVNb3VudChhKTtcbiAgICBpZiAoYnVtKSB7XG4gICAgICBpbnZva2VBcnJheUZucyhidW0pO1xuICAgIH1cbiAgICBpZiAocGFyZW50ICYmIGlzQXJyYXkoc2xvdENhY2hlS2V5cykpIHtcbiAgICAgIHNsb3RDYWNoZUtleXMuZm9yRWFjaCgodikgPT4ge1xuICAgICAgICBwYXJlbnQucmVuZGVyQ2FjaGVbdl0gPSB2b2lkIDA7XG4gICAgICB9KTtcbiAgICB9XG4gICAgc2NvcGUuc3RvcCgpO1xuICAgIGlmIChqb2IpIHtcbiAgICAgIGpvYi5mbGFncyB8PSA4O1xuICAgICAgdW5tb3VudChzdWJUcmVlLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcbiAgICB9XG4gICAgaWYgKHVtKSB7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QodW0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICB9XG4gICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgIGluc3RhbmNlLmlzVW5tb3VudGVkID0gdHJ1ZTtcbiAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgaWYgKHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggJiYgIXBhcmVudFN1c3BlbnNlLmlzVW5tb3VudGVkICYmIGluc3RhbmNlLmFzeW5jRGVwICYmICFpbnN0YW5jZS5hc3luY1Jlc29sdmVkICYmIGluc3RhbmNlLnN1c3BlbnNlSWQgPT09IHBhcmVudFN1c3BlbnNlLnBlbmRpbmdJZCkge1xuICAgICAgcGFyZW50U3VzcGVuc2UuZGVwcy0tO1xuICAgICAgaWYgKHBhcmVudFN1c3BlbnNlLmRlcHMgPT09IDApIHtcbiAgICAgICAgcGFyZW50U3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZChpbnN0YW5jZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCB1bm1vdW50Q2hpbGRyZW4gPSAoY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlID0gZmFsc2UsIG9wdGltaXplZCA9IGZhbHNlLCBzdGFydCA9IDApID0+IHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdW5tb3VudChjaGlsZHJlbltpXSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUsIG9wdGltaXplZCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBnZXROZXh0SG9zdE5vZGUgPSAodm5vZGUpID0+IHtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNikge1xuICAgICAgcmV0dXJuIGdldE5leHRIb3N0Tm9kZSh2bm9kZS5jb21wb25lbnQuc3ViVHJlZSk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgIHJldHVybiB2bm9kZS5zdXNwZW5zZS5uZXh0KCk7XG4gICAgfVxuICAgIGNvbnN0IGVsID0gaG9zdE5leHRTaWJsaW5nKHZub2RlLmFuY2hvciB8fCB2bm9kZS5lbCk7XG4gICAgY29uc3QgdGVsZXBvcnRFbmQgPSBlbCAmJiBlbFtUZWxlcG9ydEVuZEtleV07XG4gICAgcmV0dXJuIHRlbGVwb3J0RW5kID8gaG9zdE5leHRTaWJsaW5nKHRlbGVwb3J0RW5kKSA6IGVsO1xuICB9O1xuICBsZXQgaXNGbHVzaGluZyA9IGZhbHNlO1xuICBjb25zdCByZW5kZXIgPSAodm5vZGUsIGNvbnRhaW5lciwgbmFtZXNwYWNlKSA9PiB7XG4gICAgaWYgKHZub2RlID09IG51bGwpIHtcbiAgICAgIGlmIChjb250YWluZXIuX3Zub2RlKSB7XG4gICAgICAgIHVubW91bnQoY29udGFpbmVyLl92bm9kZSwgbnVsbCwgbnVsbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGNoKFxuICAgICAgICBjb250YWluZXIuX3Zub2RlIHx8IG51bGwsXG4gICAgICAgIHZub2RlLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG5hbWVzcGFjZVxuICAgICAgKTtcbiAgICB9XG4gICAgY29udGFpbmVyLl92bm9kZSA9IHZub2RlO1xuICAgIGlmICghaXNGbHVzaGluZykge1xuICAgICAgaXNGbHVzaGluZyA9IHRydWU7XG4gICAgICBmbHVzaFByZUZsdXNoQ2JzKCk7XG4gICAgICBmbHVzaFBvc3RGbHVzaENicygpO1xuICAgICAgaXNGbHVzaGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHA6IHBhdGNoLFxuICAgIHVtOiB1bm1vdW50LFxuICAgIG06IG1vdmUsXG4gICAgcjogcmVtb3ZlLFxuICAgIG10OiBtb3VudENvbXBvbmVudCxcbiAgICBtYzogbW91bnRDaGlsZHJlbixcbiAgICBwYzogcGF0Y2hDaGlsZHJlbixcbiAgICBwYmM6IHBhdGNoQmxvY2tDaGlsZHJlbixcbiAgICBuOiBnZXROZXh0SG9zdE5vZGUsXG4gICAgbzogb3B0aW9uc1xuICB9O1xuICBsZXQgaHlkcmF0ZTtcbiAgbGV0IGh5ZHJhdGVOb2RlO1xuICBpZiAoY3JlYXRlSHlkcmF0aW9uRm5zKSB7XG4gICAgW2h5ZHJhdGUsIGh5ZHJhdGVOb2RlXSA9IGNyZWF0ZUh5ZHJhdGlvbkZucyhcbiAgICAgIGludGVybmFsc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZW5kZXIsXG4gICAgaHlkcmF0ZSxcbiAgICBjcmVhdGVBcHA6IGNyZWF0ZUFwcEFQSShyZW5kZXIsIGh5ZHJhdGUpXG4gIH07XG59XG5mdW5jdGlvbiByZXNvbHZlQ2hpbGRyZW5OYW1lc3BhY2UoeyB0eXBlLCBwcm9wcyB9LCBjdXJyZW50TmFtZXNwYWNlKSB7XG4gIHJldHVybiBjdXJyZW50TmFtZXNwYWNlID09PSBcInN2Z1wiICYmIHR5cGUgPT09IFwiZm9yZWlnbk9iamVjdFwiIHx8IGN1cnJlbnROYW1lc3BhY2UgPT09IFwibWF0aG1sXCIgJiYgdHlwZSA9PT0gXCJhbm5vdGF0aW9uLXhtbFwiICYmIHByb3BzICYmIHByb3BzLmVuY29kaW5nICYmIHByb3BzLmVuY29kaW5nLmluY2x1ZGVzKFwiaHRtbFwiKSA/IHZvaWQgMCA6IGN1cnJlbnROYW1lc3BhY2U7XG59XG5mdW5jdGlvbiB0b2dnbGVSZWN1cnNlKHsgZWZmZWN0LCBqb2IgfSwgYWxsb3dlZCkge1xuICBpZiAoYWxsb3dlZCkge1xuICAgIGVmZmVjdC5mbGFncyB8PSAzMjtcbiAgICBqb2IuZmxhZ3MgfD0gNDtcbiAgfSBlbHNlIHtcbiAgICBlZmZlY3QuZmxhZ3MgJj0gLTMzO1xuICAgIGpvYi5mbGFncyAmPSAtNTtcbiAgfVxufVxuZnVuY3Rpb24gbmVlZFRyYW5zaXRpb24ocGFyZW50U3VzcGVuc2UsIHRyYW5zaXRpb24pIHtcbiAgcmV0dXJuICghcGFyZW50U3VzcGVuc2UgfHwgcGFyZW50U3VzcGVuc2UgJiYgIXBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpICYmIHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkO1xufVxuZnVuY3Rpb24gdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHNoYWxsb3cgPSBmYWxzZSkge1xuICBjb25zdCBjaDEgPSBuMS5jaGlsZHJlbjtcbiAgY29uc3QgY2gyID0gbjIuY2hpbGRyZW47XG4gIGlmIChpc0FycmF5KGNoMSkgJiYgaXNBcnJheShjaDIpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaDEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGMxID0gY2gxW2ldO1xuICAgICAgbGV0IGMyID0gY2gyW2ldO1xuICAgICAgaWYgKGMyLnNoYXBlRmxhZyAmIDEgJiYgIWMyLmR5bmFtaWNDaGlsZHJlbikge1xuICAgICAgICBpZiAoYzIucGF0Y2hGbGFnIDw9IDAgfHwgYzIucGF0Y2hGbGFnID09PSAzMikge1xuICAgICAgICAgIGMyID0gY2gyW2ldID0gY2xvbmVJZk1vdW50ZWQoY2gyW2ldKTtcbiAgICAgICAgICBjMi5lbCA9IGMxLmVsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2hhbGxvdyAmJiBjMi5wYXRjaEZsYWcgIT09IC0yKVxuICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4oYzEsIGMyKTtcbiAgICAgIH1cbiAgICAgIGlmIChjMi50eXBlID09PSBUZXh0KSB7XG4gICAgICAgIGMyLmVsID0gYzEuZWw7XG4gICAgICB9XG4gICAgICBpZiAoYzIudHlwZSA9PT0gQ29tbWVudCAmJiAhYzIuZWwpIHtcbiAgICAgICAgYzIuZWwgPSBjMS5lbDtcbiAgICAgIH1cbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIGMyLmVsICYmIChjMi5lbC5fX3Zub2RlID0gYzIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0U2VxdWVuY2UoYXJyKSB7XG4gIGNvbnN0IHAgPSBhcnIuc2xpY2UoKTtcbiAgY29uc3QgcmVzdWx0ID0gWzBdO1xuICBsZXQgaSwgaiwgdSwgdiwgYztcbiAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgYXJySSA9IGFycltpXTtcbiAgICBpZiAoYXJySSAhPT0gMCkge1xuICAgICAgaiA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoYXJyW2pdIDwgYXJySSkge1xuICAgICAgICBwW2ldID0gajtcbiAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdSA9IDA7XG4gICAgICB2ID0gcmVzdWx0Lmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAodSA8IHYpIHtcbiAgICAgICAgYyA9IHUgKyB2ID4+IDE7XG4gICAgICAgIGlmIChhcnJbcmVzdWx0W2NdXSA8IGFyckkpIHtcbiAgICAgICAgICB1ID0gYyArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdiA9IGM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhcnJJIDwgYXJyW3Jlc3VsdFt1XV0pIHtcbiAgICAgICAgaWYgKHUgPiAwKSB7XG4gICAgICAgICAgcFtpXSA9IHJlc3VsdFt1IC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W3VdID0gaTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdSA9IHJlc3VsdC5sZW5ndGg7XG4gIHYgPSByZXN1bHRbdSAtIDFdO1xuICB3aGlsZSAodS0tID4gMCkge1xuICAgIHJlc3VsdFt1XSA9IHY7XG4gICAgdiA9IHBbdl07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGxvY2F0ZU5vbkh5ZHJhdGVkQXN5bmNSb290KGluc3RhbmNlKSB7XG4gIGNvbnN0IHN1YkNvbXBvbmVudCA9IGluc3RhbmNlLnN1YlRyZWUuY29tcG9uZW50O1xuICBpZiAoc3ViQ29tcG9uZW50KSB7XG4gICAgaWYgKHN1YkNvbXBvbmVudC5hc3luY0RlcCAmJiAhc3ViQ29tcG9uZW50LmFzeW5jUmVzb2x2ZWQpIHtcbiAgICAgIHJldHVybiBzdWJDb21wb25lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsb2NhdGVOb25IeWRyYXRlZEFzeW5jUm9vdChzdWJDb21wb25lbnQpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaW52YWxpZGF0ZU1vdW50KGhvb2tzKSB7XG4gIGlmIChob29rcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspXG4gICAgICBob29rc1tpXS5mbGFncyB8PSA4O1xuICB9XG59XG5cbmNvbnN0IHNzckNvbnRleHRLZXkgPSBTeW1ib2wuZm9yKFwidi1zY3hcIik7XG5jb25zdCB1c2VTU1JDb250ZXh0ID0gKCkgPT4ge1xuICB7XG4gICAgY29uc3QgY3R4ID0gaW5qZWN0KHNzckNvbnRleHRLZXkpO1xuICAgIGlmICghY3R4KSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShcbiAgICAgICAgYFNlcnZlciByZW5kZXJpbmcgY29udGV4dCBub3QgcHJvdmlkZWQuIE1ha2Ugc3VyZSB0byBvbmx5IGNhbGwgdXNlU1NSQ29udGV4dCgpIGNvbmRpdGlvbmFsbHkgaW4gdGhlIHNlcnZlciBidWlsZC5gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gY3R4O1xuICB9XG59O1xuXG5mdW5jdGlvbiB3YXRjaEVmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRvV2F0Y2goZWZmZWN0LCBudWxsLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHdhdGNoUG9zdEVmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRvV2F0Y2goXG4gICAgZWZmZWN0LFxuICAgIG51bGwsXG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGV4dGVuZCh7fSwgb3B0aW9ucywgeyBmbHVzaDogXCJwb3N0XCIgfSkgOiB7IGZsdXNoOiBcInBvc3RcIiB9XG4gICk7XG59XG5mdW5jdGlvbiB3YXRjaFN5bmNFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XG4gIHJldHVybiBkb1dhdGNoKFxuICAgIGVmZmVjdCxcbiAgICBudWxsLFxuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBleHRlbmQoe30sIG9wdGlvbnMsIHsgZmx1c2g6IFwic3luY1wiIH0pIDogeyBmbHVzaDogXCJzeW5jXCIgfVxuICApO1xufVxuZnVuY3Rpb24gd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucykge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNGdW5jdGlvbihjYikpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgXFxgd2F0Y2goZm4sIG9wdGlvbnM/KVxcYCBzaWduYXR1cmUgaGFzIGJlZW4gbW92ZWQgdG8gYSBzZXBhcmF0ZSBBUEkuIFVzZSBcXGB3YXRjaEVmZmVjdChmbiwgb3B0aW9ucz8pXFxgIGluc3RlYWQuIFxcYHdhdGNoXFxgIG5vdyBvbmx5IHN1cHBvcnRzIFxcYHdhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnM/KSBzaWduYXR1cmUuYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGRvV2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBkb1dhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMgPSBFTVBUWV9PQkopIHtcbiAgY29uc3QgeyBpbW1lZGlhdGUsIGRlZXAsIGZsdXNoLCBvbmNlIH0gPSBvcHRpb25zO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhY2IpIHtcbiAgICBpZiAoaW1tZWRpYXRlICE9PSB2b2lkIDApIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYHdhdGNoKCkgXCJpbW1lZGlhdGVcIiBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyB0aGUgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZGVlcCAhPT0gdm9pZCAwKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGB3YXRjaCgpIFwiZGVlcFwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSB3YXRjaChzb3VyY2UsIGNhbGxiYWNrLCBvcHRpb25zPykgc2lnbmF0dXJlLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChvbmNlICE9PSB2b2lkIDApIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYHdhdGNoKCkgXCJvbmNlXCIgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgdGhlIHdhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgYmFzZVdhdGNoT3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSBiYXNlV2F0Y2hPcHRpb25zLm9uV2FybiA9IHdhcm4kMTtcbiAgY29uc3QgcnVuc0ltbWVkaWF0ZWx5ID0gY2IgJiYgaW1tZWRpYXRlIHx8ICFjYiAmJiBmbHVzaCAhPT0gXCJwb3N0XCI7XG4gIGxldCBzc3JDbGVhbnVwO1xuICBpZiAoaXNJblNTUkNvbXBvbmVudFNldHVwKSB7XG4gICAgaWYgKGZsdXNoID09PSBcInN5bmNcIikge1xuICAgICAgY29uc3QgY3R4ID0gdXNlU1NSQ29udGV4dCgpO1xuICAgICAgc3NyQ2xlYW51cCA9IGN0eC5fX3dhdGNoZXJIYW5kbGVzIHx8IChjdHguX193YXRjaGVySGFuZGxlcyA9IFtdKTtcbiAgICB9IGVsc2UgaWYgKCFydW5zSW1tZWRpYXRlbHkpIHtcbiAgICAgIGNvbnN0IHdhdGNoU3RvcEhhbmRsZSA9ICgpID0+IHtcbiAgICAgIH07XG4gICAgICB3YXRjaFN0b3BIYW5kbGUuc3RvcCA9IE5PT1A7XG4gICAgICB3YXRjaFN0b3BIYW5kbGUucmVzdW1lID0gTk9PUDtcbiAgICAgIHdhdGNoU3RvcEhhbmRsZS5wYXVzZSA9IE5PT1A7XG4gICAgICByZXR1cm4gd2F0Y2hTdG9wSGFuZGxlO1xuICAgIH1cbiAgfVxuICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgYmFzZVdhdGNoT3B0aW9ucy5jYWxsID0gKGZuLCB0eXBlLCBhcmdzKSA9PiBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpO1xuICBsZXQgaXNQcmUgPSBmYWxzZTtcbiAgaWYgKGZsdXNoID09PSBcInBvc3RcIikge1xuICAgIGJhc2VXYXRjaE9wdGlvbnMuc2NoZWR1bGVyID0gKGpvYikgPT4ge1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGpvYiwgaW5zdGFuY2UgJiYgaW5zdGFuY2Uuc3VzcGVuc2UpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoZmx1c2ggIT09IFwic3luY1wiKSB7XG4gICAgaXNQcmUgPSB0cnVlO1xuICAgIGJhc2VXYXRjaE9wdGlvbnMuc2NoZWR1bGVyID0gKGpvYiwgaXNGaXJzdFJ1bikgPT4ge1xuICAgICAgaWYgKGlzRmlyc3RSdW4pIHtcbiAgICAgICAgam9iKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUpvYihqb2IpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgYmFzZVdhdGNoT3B0aW9ucy5hdWdtZW50Sm9iID0gKGpvYikgPT4ge1xuICAgIGlmIChjYikge1xuICAgICAgam9iLmZsYWdzIHw9IDQ7XG4gICAgfVxuICAgIGlmIChpc1ByZSkge1xuICAgICAgam9iLmZsYWdzIHw9IDI7XG4gICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgam9iLmlkID0gaW5zdGFuY2UudWlkO1xuICAgICAgICBqb2IuaSA9IGluc3RhbmNlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3Qgd2F0Y2hIYW5kbGUgPSB3YXRjaCQxKHNvdXJjZSwgY2IsIGJhc2VXYXRjaE9wdGlvbnMpO1xuICBpZiAoaXNJblNTUkNvbXBvbmVudFNldHVwKSB7XG4gICAgaWYgKHNzckNsZWFudXApIHtcbiAgICAgIHNzckNsZWFudXAucHVzaCh3YXRjaEhhbmRsZSk7XG4gICAgfSBlbHNlIGlmIChydW5zSW1tZWRpYXRlbHkpIHtcbiAgICAgIHdhdGNoSGFuZGxlKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB3YXRjaEhhbmRsZTtcbn1cbmZ1bmN0aW9uIGluc3RhbmNlV2F0Y2goc291cmNlLCB2YWx1ZSwgb3B0aW9ucykge1xuICBjb25zdCBwdWJsaWNUaGlzID0gdGhpcy5wcm94eTtcbiAgY29uc3QgZ2V0dGVyID0gaXNTdHJpbmcoc291cmNlKSA/IHNvdXJjZS5pbmNsdWRlcyhcIi5cIikgPyBjcmVhdGVQYXRoR2V0dGVyKHB1YmxpY1RoaXMsIHNvdXJjZSkgOiAoKSA9PiBwdWJsaWNUaGlzW3NvdXJjZV0gOiBzb3VyY2UuYmluZChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKTtcbiAgbGV0IGNiO1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBjYiA9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGNiID0gdmFsdWUuaGFuZGxlcjtcbiAgICBvcHRpb25zID0gdmFsdWU7XG4gIH1cbiAgY29uc3QgcmVzZXQgPSBzZXRDdXJyZW50SW5zdGFuY2UodGhpcyk7XG4gIGNvbnN0IHJlcyA9IGRvV2F0Y2goZ2V0dGVyLCBjYi5iaW5kKHB1YmxpY1RoaXMpLCBvcHRpb25zKTtcbiAgcmVzZXQoKTtcbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhdGhHZXR0ZXIoY3R4LCBwYXRoKSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gcGF0aC5zcGxpdChcIi5cIik7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGV0IGN1ciA9IGN0eDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aCAmJiBjdXI7IGkrKykge1xuICAgICAgY3VyID0gY3VyW3NlZ21lbnRzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlTW9kZWwocHJvcHMsIG5hbWUsIG9wdGlvbnMgPSBFTVBUWV9PQkopIHtcbiAgY29uc3QgaSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaSkge1xuICAgIHdhcm4kMShgdXNlTW9kZWwoKSBjYWxsZWQgd2l0aG91dCBhY3RpdmUgaW5zdGFuY2UuYCk7XG4gICAgcmV0dXJuIHJlZigpO1xuICB9XG4gIGNvbnN0IGNhbWVsaXplZE5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWkucHJvcHNPcHRpb25zWzBdW2NhbWVsaXplZE5hbWVdKSB7XG4gICAgd2FybiQxKGB1c2VNb2RlbCgpIGNhbGxlZCB3aXRoIHByb3AgXCIke25hbWV9XCIgd2hpY2ggaXMgbm90IGRlY2xhcmVkLmApO1xuICAgIHJldHVybiByZWYoKTtcbiAgfVxuICBjb25zdCBoeXBoZW5hdGVkTmFtZSA9IGh5cGhlbmF0ZShuYW1lKTtcbiAgY29uc3QgbW9kaWZpZXJzID0gZ2V0TW9kZWxNb2RpZmllcnMocHJvcHMsIGNhbWVsaXplZE5hbWUpO1xuICBjb25zdCByZXMgPSBjdXN0b21SZWYoKHRyYWNrLCB0cmlnZ2VyKSA9PiB7XG4gICAgbGV0IGxvY2FsVmFsdWU7XG4gICAgbGV0IHByZXZTZXRWYWx1ZSA9IEVNUFRZX09CSjtcbiAgICBsZXQgcHJldkVtaXR0ZWRWYWx1ZTtcbiAgICB3YXRjaFN5bmNFZmZlY3QoKCkgPT4ge1xuICAgICAgY29uc3QgcHJvcFZhbHVlID0gcHJvcHNbY2FtZWxpemVkTmFtZV07XG4gICAgICBpZiAoaGFzQ2hhbmdlZChsb2NhbFZhbHVlLCBwcm9wVmFsdWUpKSB7XG4gICAgICAgIGxvY2FsVmFsdWUgPSBwcm9wVmFsdWU7XG4gICAgICAgIHRyaWdnZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0KCkge1xuICAgICAgICB0cmFjaygpO1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5nZXQgPyBvcHRpb25zLmdldChsb2NhbFZhbHVlKSA6IGxvY2FsVmFsdWU7XG4gICAgICB9LFxuICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGVtaXR0ZWRWYWx1ZSA9IG9wdGlvbnMuc2V0ID8gb3B0aW9ucy5zZXQodmFsdWUpIDogdmFsdWU7XG4gICAgICAgIGlmICghaGFzQ2hhbmdlZChlbWl0dGVkVmFsdWUsIGxvY2FsVmFsdWUpICYmICEocHJldlNldFZhbHVlICE9PSBFTVBUWV9PQkogJiYgaGFzQ2hhbmdlZCh2YWx1ZSwgcHJldlNldFZhbHVlKSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmF3UHJvcHMgPSBpLnZub2RlLnByb3BzO1xuICAgICAgICBpZiAoIShyYXdQcm9wcyAmJiAvLyBjaGVjayBpZiBwYXJlbnQgaGFzIHBhc3NlZCB2LW1vZGVsXG4gICAgICAgIChuYW1lIGluIHJhd1Byb3BzIHx8IGNhbWVsaXplZE5hbWUgaW4gcmF3UHJvcHMgfHwgaHlwaGVuYXRlZE5hbWUgaW4gcmF3UHJvcHMpICYmIChgb25VcGRhdGU6JHtuYW1lfWAgaW4gcmF3UHJvcHMgfHwgYG9uVXBkYXRlOiR7Y2FtZWxpemVkTmFtZX1gIGluIHJhd1Byb3BzIHx8IGBvblVwZGF0ZToke2h5cGhlbmF0ZWROYW1lfWAgaW4gcmF3UHJvcHMpKSkge1xuICAgICAgICAgIGxvY2FsVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0cmlnZ2VyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaS5lbWl0KGB1cGRhdGU6JHtuYW1lfWAsIGVtaXR0ZWRWYWx1ZSk7XG4gICAgICAgIGlmIChoYXNDaGFuZ2VkKHZhbHVlLCBlbWl0dGVkVmFsdWUpICYmIGhhc0NoYW5nZWQodmFsdWUsIHByZXZTZXRWYWx1ZSkgJiYgIWhhc0NoYW5nZWQoZW1pdHRlZFZhbHVlLCBwcmV2RW1pdHRlZFZhbHVlKSkge1xuICAgICAgICAgIHRyaWdnZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2U2V0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcHJldkVtaXR0ZWRWYWx1ZSA9IGVtaXR0ZWRWYWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgcmVzW1N5bWJvbC5pdGVyYXRvcl0gPSAoKSA9PiB7XG4gICAgbGV0IGkyID0gMDtcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dCgpIHtcbiAgICAgICAgaWYgKGkyIDwgMikge1xuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBpMisrID8gbW9kaWZpZXJzIHx8IEVNUFRZX09CSiA6IHJlcywgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICByZXR1cm4gcmVzO1xufVxuY29uc3QgZ2V0TW9kZWxNb2RpZmllcnMgPSAocHJvcHMsIG1vZGVsTmFtZSkgPT4ge1xuICByZXR1cm4gbW9kZWxOYW1lID09PSBcIm1vZGVsVmFsdWVcIiB8fCBtb2RlbE5hbWUgPT09IFwibW9kZWwtdmFsdWVcIiA/IHByb3BzLm1vZGVsTW9kaWZpZXJzIDogcHJvcHNbYCR7bW9kZWxOYW1lfU1vZGlmaWVyc2BdIHx8IHByb3BzW2Ake2NhbWVsaXplKG1vZGVsTmFtZSl9TW9kaWZpZXJzYF0gfHwgcHJvcHNbYCR7aHlwaGVuYXRlKG1vZGVsTmFtZSl9TW9kaWZpZXJzYF07XG59O1xuXG5mdW5jdGlvbiBlbWl0KGluc3RhbmNlLCBldmVudCwgLi4ucmF3QXJncykge1xuICBpZiAoaW5zdGFuY2UuaXNVbm1vdW50ZWQpIHJldHVybjtcbiAgY29uc3QgcHJvcHMgPSBpbnN0YW5jZS52bm9kZS5wcm9wcyB8fCBFTVBUWV9PQko7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY29uc3Qge1xuICAgICAgZW1pdHNPcHRpb25zLFxuICAgICAgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXVxuICAgIH0gPSBpbnN0YW5jZTtcbiAgICBpZiAoZW1pdHNPcHRpb25zKSB7XG4gICAgICBpZiAoIShldmVudCBpbiBlbWl0c09wdGlvbnMpICYmIHRydWUpIHtcbiAgICAgICAgaWYgKCFwcm9wc09wdGlvbnMgfHwgISh0b0hhbmRsZXJLZXkoY2FtZWxpemUoZXZlbnQpKSBpbiBwcm9wc09wdGlvbnMpKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYENvbXBvbmVudCBlbWl0dGVkIGV2ZW50IFwiJHtldmVudH1cIiBidXQgaXQgaXMgbmVpdGhlciBkZWNsYXJlZCBpbiB0aGUgZW1pdHMgb3B0aW9uIG5vciBhcyBhbiBcIiR7dG9IYW5kbGVyS2V5KGNhbWVsaXplKGV2ZW50KSl9XCIgcHJvcC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gZW1pdHNPcHRpb25zW2V2ZW50XTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsaWRhdG9yKSkge1xuICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSB2YWxpZGF0b3IoLi4ucmF3QXJncyk7XG4gICAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIGV2ZW50IGFyZ3VtZW50czogZXZlbnQgdmFsaWRhdGlvbiBmYWlsZWQgZm9yIGV2ZW50IFwiJHtldmVudH1cIi5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBsZXQgYXJncyA9IHJhd0FyZ3M7XG4gIGNvbnN0IGlzTW9kZWxMaXN0ZW5lciA9IGV2ZW50LnN0YXJ0c1dpdGgoXCJ1cGRhdGU6XCIpO1xuICBjb25zdCBtb2RpZmllcnMgPSBpc01vZGVsTGlzdGVuZXIgJiYgZ2V0TW9kZWxNb2RpZmllcnMocHJvcHMsIGV2ZW50LnNsaWNlKDcpKTtcbiAgaWYgKG1vZGlmaWVycykge1xuICAgIGlmIChtb2RpZmllcnMudHJpbSkge1xuICAgICAgYXJncyA9IHJhd0FyZ3MubWFwKChhKSA9PiBpc1N0cmluZyhhKSA/IGEudHJpbSgpIDogYSk7XG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMubnVtYmVyKSB7XG4gICAgICBhcmdzID0gcmF3QXJncy5tYXAobG9vc2VUb051bWJlcik7XG4gICAgfVxuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgIGRldnRvb2xzQ29tcG9uZW50RW1pdChpbnN0YW5jZSwgZXZlbnQsIGFyZ3MpO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY29uc3QgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgcHJvcHNbdG9IYW5kbGVyS2V5KGxvd2VyQ2FzZUV2ZW50KV0pIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYEV2ZW50IFwiJHtsb3dlckNhc2VFdmVudH1cIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCAke2Zvcm1hdENvbXBvbmVudE5hbWUoXG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgaW5zdGFuY2UudHlwZVxuICAgICAgICApfSBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXCIke2V2ZW50fVwiLiBOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSB2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXCIke2h5cGhlbmF0ZShcbiAgICAgICAgICBldmVudFxuICAgICAgICApfVwiIGluc3RlYWQgb2YgXCIke2V2ZW50fVwiLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGxldCBoYW5kbGVyTmFtZTtcbiAgbGV0IGhhbmRsZXIgPSBwcm9wc1toYW5kbGVyTmFtZSA9IHRvSGFuZGxlcktleShldmVudCldIHx8IC8vIGFsc28gdHJ5IGNhbWVsQ2FzZSBldmVudCBoYW5kbGVyICgjMjI0OSlcbiAgcHJvcHNbaGFuZGxlck5hbWUgPSB0b0hhbmRsZXJLZXkoY2FtZWxpemUoZXZlbnQpKV07XG4gIGlmICghaGFuZGxlciAmJiBpc01vZGVsTGlzdGVuZXIpIHtcbiAgICBoYW5kbGVyID0gcHJvcHNbaGFuZGxlck5hbWUgPSB0b0hhbmRsZXJLZXkoaHlwaGVuYXRlKGV2ZW50KSldO1xuICB9XG4gIGlmIChoYW5kbGVyKSB7XG4gICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoXG4gICAgICBoYW5kbGVyLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICA2LFxuICAgICAgYXJnc1xuICAgICk7XG4gIH1cbiAgY29uc3Qgb25jZUhhbmRsZXIgPSBwcm9wc1toYW5kbGVyTmFtZSArIGBPbmNlYF07XG4gIGlmIChvbmNlSGFuZGxlcikge1xuICAgIGlmICghaW5zdGFuY2UuZW1pdHRlZCkge1xuICAgICAgaW5zdGFuY2UuZW1pdHRlZCA9IHt9O1xuICAgIH0gZWxzZSBpZiAoaW5zdGFuY2UuZW1pdHRlZFtoYW5kbGVyTmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW5zdGFuY2UuZW1pdHRlZFtoYW5kbGVyTmFtZV0gPSB0cnVlO1xuICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgICAgb25jZUhhbmRsZXIsXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDYsXG4gICAgICBhcmdzXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplRW1pdHNPcHRpb25zKGNvbXAsIGFwcENvbnRleHQsIGFzTWl4aW4gPSBmYWxzZSkge1xuICBjb25zdCBjYWNoZSA9IGFwcENvbnRleHQuZW1pdHNDYWNoZTtcbiAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGNvbXApO1xuICBpZiAoY2FjaGVkICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG4gIGNvbnN0IHJhdyA9IGNvbXAuZW1pdHM7XG4gIGxldCBub3JtYWxpemVkID0ge307XG4gIGxldCBoYXNFeHRlbmRzID0gZmFsc2U7XG4gIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XG4gICAgY29uc3QgZXh0ZW5kRW1pdHMgPSAocmF3MikgPT4ge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZEZyb21FeHRlbmQgPSBub3JtYWxpemVFbWl0c09wdGlvbnMocmF3MiwgYXBwQ29udGV4dCwgdHJ1ZSk7XG4gICAgICBpZiAobm9ybWFsaXplZEZyb21FeHRlbmQpIHtcbiAgICAgICAgaGFzRXh0ZW5kcyA9IHRydWU7XG4gICAgICAgIGV4dGVuZChub3JtYWxpemVkLCBub3JtYWxpemVkRnJvbUV4dGVuZCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoIWFzTWl4aW4gJiYgYXBwQ29udGV4dC5taXhpbnMubGVuZ3RoKSB7XG4gICAgICBhcHBDb250ZXh0Lm1peGlucy5mb3JFYWNoKGV4dGVuZEVtaXRzKTtcbiAgICB9XG4gICAgaWYgKGNvbXAuZXh0ZW5kcykge1xuICAgICAgZXh0ZW5kRW1pdHMoY29tcC5leHRlbmRzKTtcbiAgICB9XG4gICAgaWYgKGNvbXAubWl4aW5zKSB7XG4gICAgICBjb21wLm1peGlucy5mb3JFYWNoKGV4dGVuZEVtaXRzKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFyYXcgJiYgIWhhc0V4dGVuZHMpIHtcbiAgICBpZiAoaXNPYmplY3QoY29tcCkpIHtcbiAgICAgIGNhY2hlLnNldChjb21wLCBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGlzQXJyYXkocmF3KSkge1xuICAgIHJhdy5mb3JFYWNoKChrZXkpID0+IG5vcm1hbGl6ZWRba2V5XSA9IG51bGwpO1xuICB9IGVsc2Uge1xuICAgIGV4dGVuZChub3JtYWxpemVkLCByYXcpO1xuICB9XG4gIGlmIChpc09iamVjdChjb21wKSkge1xuICAgIGNhY2hlLnNldChjb21wLCBub3JtYWxpemVkKTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cbmZ1bmN0aW9uIGlzRW1pdExpc3RlbmVyKG9wdGlvbnMsIGtleSkge1xuICBpZiAoIW9wdGlvbnMgfHwgIWlzT24oa2V5KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBrZXkgPSBrZXkuc2xpY2UoMikucmVwbGFjZSgvT25jZSQvLCBcIlwiKTtcbiAgcmV0dXJuIGhhc093bihvcHRpb25zLCBrZXlbMF0udG9Mb3dlckNhc2UoKSArIGtleS5zbGljZSgxKSkgfHwgaGFzT3duKG9wdGlvbnMsIGh5cGhlbmF0ZShrZXkpKSB8fCBoYXNPd24ob3B0aW9ucywga2V5KTtcbn1cblxubGV0IGFjY2Vzc2VkQXR0cnMgPSBmYWxzZTtcbmZ1bmN0aW9uIG1hcmtBdHRyc0FjY2Vzc2VkKCkge1xuICBhY2Nlc3NlZEF0dHJzID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpIHtcbiAgY29uc3Qge1xuICAgIHR5cGU6IENvbXBvbmVudCxcbiAgICB2bm9kZSxcbiAgICBwcm94eSxcbiAgICB3aXRoUHJveHksXG4gICAgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXSxcbiAgICBzbG90cyxcbiAgICBhdHRycyxcbiAgICBlbWl0LFxuICAgIHJlbmRlcixcbiAgICByZW5kZXJDYWNoZSxcbiAgICBwcm9wcyxcbiAgICBkYXRhLFxuICAgIHNldHVwU3RhdGUsXG4gICAgY3R4LFxuICAgIGluaGVyaXRBdHRyc1xuICB9ID0gaW5zdGFuY2U7XG4gIGNvbnN0IHByZXYgPSBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoaW5zdGFuY2UpO1xuICBsZXQgcmVzdWx0O1xuICBsZXQgZmFsbHRocm91Z2hBdHRycztcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBhY2Nlc3NlZEF0dHJzID0gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNCkge1xuICAgICAgY29uc3QgcHJveHlUb1VzZSA9IHdpdGhQcm94eSB8fCBwcm94eTtcbiAgICAgIGNvbnN0IHRoaXNQcm94eSA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2V0dXBTdGF0ZS5fX2lzU2NyaXB0U2V0dXAgPyBuZXcgUHJveHkocHJveHlUb1VzZSwge1xuICAgICAgICBnZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYFByb3BlcnR5ICcke1N0cmluZyhcbiAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICApfScgd2FzIGFjY2Vzc2VkIHZpYSAndGhpcycuIEF2b2lkIHVzaW5nICd0aGlzJyBpbiB0ZW1wbGF0ZXMuYFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcik7XG4gICAgICAgIH1cbiAgICAgIH0pIDogcHJveHlUb1VzZTtcbiAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVZOb2RlKFxuICAgICAgICByZW5kZXIuY2FsbChcbiAgICAgICAgICB0aGlzUHJveHksXG4gICAgICAgICAgcHJveHlUb1VzZSxcbiAgICAgICAgICByZW5kZXJDYWNoZSxcbiAgICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KHByb3BzKSA6IHByb3BzLFxuICAgICAgICAgIHNldHVwU3RhdGUsXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBjdHhcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBhdHRycztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVuZGVyMiA9IENvbXBvbmVudDtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGF0dHJzID09PSBwcm9wcykge1xuICAgICAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gbm9ybWFsaXplVk5vZGUoXG4gICAgICAgIHJlbmRlcjIubGVuZ3RoID4gMSA/IHJlbmRlcjIoXG4gICAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShwcm9wcykgOiBwcm9wcyxcbiAgICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8ge1xuICAgICAgICAgICAgZ2V0IGF0dHJzKCkge1xuICAgICAgICAgICAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xuICAgICAgICAgICAgICByZXR1cm4gc2hhbGxvd1JlYWRvbmx5KGF0dHJzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzbG90cyxcbiAgICAgICAgICAgIGVtaXRcbiAgICAgICAgICB9IDogeyBhdHRycywgc2xvdHMsIGVtaXQgfVxuICAgICAgICApIDogcmVuZGVyMihcbiAgICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KHByb3BzKSA6IHByb3BzLFxuICAgICAgICAgIG51bGxcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBDb21wb25lbnQucHJvcHMgPyBhdHRycyA6IGdldEZ1bmN0aW9uYWxGYWxsdGhyb3VnaChhdHRycyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBibG9ja1N0YWNrLmxlbmd0aCA9IDA7XG4gICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgMSk7XG4gICAgcmVzdWx0ID0gY3JlYXRlVk5vZGUoQ29tbWVudCk7XG4gIH1cbiAgbGV0IHJvb3QgPSByZXN1bHQ7XG4gIGxldCBzZXRSb290ID0gdm9pZCAwO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiByZXN1bHQucGF0Y2hGbGFnID4gMCAmJiByZXN1bHQucGF0Y2hGbGFnICYgMjA0OCkge1xuICAgIFtyb290LCBzZXRSb290XSA9IGdldENoaWxkUm9vdChyZXN1bHQpO1xuICB9XG4gIGlmIChmYWxsdGhyb3VnaEF0dHJzICYmIGluaGVyaXRBdHRycyAhPT0gZmFsc2UpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZmFsbHRocm91Z2hBdHRycyk7XG4gICAgY29uc3QgeyBzaGFwZUZsYWcgfSA9IHJvb3Q7XG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICBpZiAoc2hhcGVGbGFnICYgKDEgfCA2KSkge1xuICAgICAgICBpZiAocHJvcHNPcHRpb25zICYmIGtleXMuc29tZShpc01vZGVsTGlzdGVuZXIpKSB7XG4gICAgICAgICAgZmFsbHRocm91Z2hBdHRycyA9IGZpbHRlck1vZGVsTGlzdGVuZXJzKFxuICAgICAgICAgICAgZmFsbHRocm91Z2hBdHRycyxcbiAgICAgICAgICAgIHByb3BzT3B0aW9uc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcm9vdCA9IGNsb25lVk5vZGUocm9vdCwgZmFsbHRocm91Z2hBdHRycywgZmFsc2UsIHRydWUpO1xuICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFhY2Nlc3NlZEF0dHJzICYmIHJvb3QudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICBjb25zdCBhbGxBdHRycyA9IE9iamVjdC5rZXlzKGF0dHJzKTtcbiAgICAgICAgY29uc3QgZXZlbnRBdHRycyA9IFtdO1xuICAgICAgICBjb25zdCBleHRyYUF0dHJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gYWxsQXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gYWxsQXR0cnNbaV07XG4gICAgICAgICAgaWYgKGlzT24oa2V5KSkge1xuICAgICAgICAgICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSkge1xuICAgICAgICAgICAgICBldmVudEF0dHJzLnB1c2goa2V5WzJdLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHRyYUF0dHJzLnB1c2goa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dHJhQXR0cnMubGVuZ3RoKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYEV4dHJhbmVvdXMgbm9uLXByb3BzIGF0dHJpYnV0ZXMgKCR7ZXh0cmFBdHRycy5qb2luKFwiLCBcIil9KSB3ZXJlIHBhc3NlZCB0byBjb21wb25lbnQgYnV0IGNvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGluaGVyaXRlZCBiZWNhdXNlIGNvbXBvbmVudCByZW5kZXJzIGZyYWdtZW50IG9yIHRleHQgb3IgdGVsZXBvcnQgcm9vdCBub2Rlcy5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnRBdHRycy5sZW5ndGgpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgRXh0cmFuZW91cyBub24tZW1pdHMgZXZlbnQgbGlzdGVuZXJzICgke2V2ZW50QXR0cnMuam9pbihcIiwgXCIpfSkgd2VyZSBwYXNzZWQgdG8gY29tcG9uZW50IGJ1dCBjb3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBpbmhlcml0ZWQgYmVjYXVzZSBjb21wb25lbnQgcmVuZGVycyBmcmFnbWVudCBvciB0ZXh0IHJvb3Qgbm9kZXMuIElmIHRoZSBsaXN0ZW5lciBpcyBpbnRlbmRlZCB0byBiZSBhIGNvbXBvbmVudCBjdXN0b20gZXZlbnQgbGlzdGVuZXIgb25seSwgZGVjbGFyZSBpdCB1c2luZyB0aGUgXCJlbWl0c1wiIG9wdGlvbi5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodm5vZGUuZGlycykge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc0VsZW1lbnRSb290KHJvb3QpKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBSdW50aW1lIGRpcmVjdGl2ZSB1c2VkIG9uIGNvbXBvbmVudCB3aXRoIG5vbi1lbGVtZW50IHJvb3Qgbm9kZS4gVGhlIGRpcmVjdGl2ZXMgd2lsbCBub3QgZnVuY3Rpb24gYXMgaW50ZW5kZWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcm9vdCA9IGNsb25lVk5vZGUocm9vdCwgbnVsbCwgZmFsc2UsIHRydWUpO1xuICAgIHJvb3QuZGlycyA9IHJvb3QuZGlycyA/IHJvb3QuZGlycy5jb25jYXQodm5vZGUuZGlycykgOiB2bm9kZS5kaXJzO1xuICB9XG4gIGlmICh2bm9kZS50cmFuc2l0aW9uKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzRWxlbWVudFJvb3Qocm9vdCkpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYENvbXBvbmVudCBpbnNpZGUgPFRyYW5zaXRpb24+IHJlbmRlcnMgbm9uLWVsZW1lbnQgcm9vdCBub2RlIHRoYXQgY2Fubm90IGJlIGFuaW1hdGVkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHNldFRyYW5zaXRpb25Ib29rcyhyb290LCB2bm9kZS50cmFuc2l0aW9uKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzZXRSb290KSB7XG4gICAgc2V0Um9vdChyb290KTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSByb290O1xuICB9XG4gIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShwcmV2KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGdldENoaWxkUm9vdCA9ICh2bm9kZSkgPT4ge1xuICBjb25zdCByYXdDaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICBjb25zdCBkeW5hbWljQ2hpbGRyZW4gPSB2bm9kZS5keW5hbWljQ2hpbGRyZW47XG4gIGNvbnN0IGNoaWxkUm9vdCA9IGZpbHRlclNpbmdsZVJvb3QocmF3Q2hpbGRyZW4sIGZhbHNlKTtcbiAgaWYgKCFjaGlsZFJvb3QpIHtcbiAgICByZXR1cm4gW3Zub2RlLCB2b2lkIDBdO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY2hpbGRSb290LnBhdGNoRmxhZyA+IDAgJiYgY2hpbGRSb290LnBhdGNoRmxhZyAmIDIwNDgpIHtcbiAgICByZXR1cm4gZ2V0Q2hpbGRSb290KGNoaWxkUm9vdCk7XG4gIH1cbiAgY29uc3QgaW5kZXggPSByYXdDaGlsZHJlbi5pbmRleE9mKGNoaWxkUm9vdCk7XG4gIGNvbnN0IGR5bmFtaWNJbmRleCA9IGR5bmFtaWNDaGlsZHJlbiA/IGR5bmFtaWNDaGlsZHJlbi5pbmRleE9mKGNoaWxkUm9vdCkgOiAtMTtcbiAgY29uc3Qgc2V0Um9vdCA9ICh1cGRhdGVkUm9vdCkgPT4ge1xuICAgIHJhd0NoaWxkcmVuW2luZGV4XSA9IHVwZGF0ZWRSb290O1xuICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgIGlmIChkeW5hbWljSW5kZXggPiAtMSkge1xuICAgICAgICBkeW5hbWljQ2hpbGRyZW5bZHluYW1pY0luZGV4XSA9IHVwZGF0ZWRSb290O1xuICAgICAgfSBlbHNlIGlmICh1cGRhdGVkUm9vdC5wYXRjaEZsYWcgPiAwKSB7XG4gICAgICAgIHZub2RlLmR5bmFtaWNDaGlsZHJlbiA9IFsuLi5keW5hbWljQ2hpbGRyZW4sIHVwZGF0ZWRSb290XTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBbbm9ybWFsaXplVk5vZGUoY2hpbGRSb290KSwgc2V0Um9vdF07XG59O1xuZnVuY3Rpb24gZmlsdGVyU2luZ2xlUm9vdChjaGlsZHJlbiwgcmVjdXJzZSA9IHRydWUpIHtcbiAgbGV0IHNpbmdsZVJvb3Q7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChpc1ZOb2RlKGNoaWxkKSkge1xuICAgICAgaWYgKGNoaWxkLnR5cGUgIT09IENvbW1lbnQgfHwgY2hpbGQuY2hpbGRyZW4gPT09IFwidi1pZlwiKSB7XG4gICAgICAgIGlmIChzaW5nbGVSb290KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNpbmdsZVJvb3QgPSBjaGlsZDtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiByZWN1cnNlICYmIHNpbmdsZVJvb3QucGF0Y2hGbGFnID4gMCAmJiBzaW5nbGVSb290LnBhdGNoRmxhZyAmIDIwNDgpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJTaW5nbGVSb290KHNpbmdsZVJvb3QuY2hpbGRyZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHJldHVybiBzaW5nbGVSb290O1xufVxuY29uc3QgZ2V0RnVuY3Rpb25hbEZhbGx0aHJvdWdoID0gKGF0dHJzKSA9PiB7XG4gIGxldCByZXM7XG4gIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XG4gICAgaWYgKGtleSA9PT0gXCJjbGFzc1wiIHx8IGtleSA9PT0gXCJzdHlsZVwiIHx8IGlzT24oa2V5KSkge1xuICAgICAgKHJlcyB8fCAocmVzID0ge30pKVtrZXldID0gYXR0cnNba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5jb25zdCBmaWx0ZXJNb2RlbExpc3RlbmVycyA9IChhdHRycywgcHJvcHMpID0+IHtcbiAgY29uc3QgcmVzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XG4gICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSB8fCAhKGtleS5zbGljZSg5KSBpbiBwcm9wcykpIHtcbiAgICAgIHJlc1trZXldID0gYXR0cnNba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5jb25zdCBpc0VsZW1lbnRSb290ID0gKHZub2RlKSA9PiB7XG4gIHJldHVybiB2bm9kZS5zaGFwZUZsYWcgJiAoNiB8IDEpIHx8IHZub2RlLnR5cGUgPT09IENvbW1lbnQ7XG59O1xuZnVuY3Rpb24gc2hvdWxkVXBkYXRlQ29tcG9uZW50KHByZXZWTm9kZSwgbmV4dFZOb2RlLCBvcHRpbWl6ZWQpIHtcbiAgY29uc3QgeyBwcm9wczogcHJldlByb3BzLCBjaGlsZHJlbjogcHJldkNoaWxkcmVuLCBjb21wb25lbnQgfSA9IHByZXZWTm9kZTtcbiAgY29uc3QgeyBwcm9wczogbmV4dFByb3BzLCBjaGlsZHJlbjogbmV4dENoaWxkcmVuLCBwYXRjaEZsYWcgfSA9IG5leHRWTm9kZTtcbiAgY29uc3QgZW1pdHMgPSBjb21wb25lbnQuZW1pdHNPcHRpb25zO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAocHJldkNoaWxkcmVuIHx8IG5leHRDaGlsZHJlbikgJiYgaXNIbXJVcGRhdGluZykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChuZXh0Vk5vZGUuZGlycyB8fCBuZXh0Vk5vZGUudHJhbnNpdGlvbikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChvcHRpbWl6ZWQgJiYgcGF0Y2hGbGFnID49IDApIHtcbiAgICBpZiAocGF0Y2hGbGFnICYgMTAyNCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChwYXRjaEZsYWcgJiAxNikge1xuICAgICAgaWYgKCFwcmV2UHJvcHMpIHtcbiAgICAgICAgcmV0dXJuICEhbmV4dFByb3BzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc1Byb3BzQ2hhbmdlZChwcmV2UHJvcHMsIG5leHRQcm9wcywgZW1pdHMpO1xuICAgIH0gZWxzZSBpZiAocGF0Y2hGbGFnICYgOCkge1xuICAgICAgY29uc3QgZHluYW1pY1Byb3BzID0gbmV4dFZOb2RlLmR5bmFtaWNQcm9wcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHluYW1pY1Byb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGR5bmFtaWNQcm9wc1tpXTtcbiAgICAgICAgaWYgKG5leHRQcm9wc1trZXldICE9PSBwcmV2UHJvcHNba2V5XSAmJiAhaXNFbWl0TGlzdGVuZXIoZW1pdHMsIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocHJldkNoaWxkcmVuIHx8IG5leHRDaGlsZHJlbikge1xuICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4gfHwgIW5leHRDaGlsZHJlbi4kc3RhYmxlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJldlByb3BzID09PSBuZXh0UHJvcHMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFwcmV2UHJvcHMpIHtcbiAgICAgIHJldHVybiAhIW5leHRQcm9wcztcbiAgICB9XG4gICAgaWYgKCFuZXh0UHJvcHMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0cyk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0c09wdGlvbnMpIHtcbiAgY29uc3QgbmV4dEtleXMgPSBPYmplY3Qua2V5cyhuZXh0UHJvcHMpO1xuICBpZiAobmV4dEtleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhwcmV2UHJvcHMpLmxlbmd0aCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBuZXh0S2V5c1tpXTtcbiAgICBpZiAobmV4dFByb3BzW2tleV0gIT09IHByZXZQcm9wc1trZXldICYmICFpc0VtaXRMaXN0ZW5lcihlbWl0c09wdGlvbnMsIGtleSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiB1cGRhdGVIT0NIb3N0RWwoeyB2bm9kZSwgcGFyZW50IH0sIGVsKSB7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBjb25zdCByb290ID0gcGFyZW50LnN1YlRyZWU7XG4gICAgaWYgKHJvb3Quc3VzcGVuc2UgJiYgcm9vdC5zdXNwZW5zZS5hY3RpdmVCcmFuY2ggPT09IHZub2RlKSB7XG4gICAgICByb290LmVsID0gdm5vZGUuZWw7XG4gICAgfVxuICAgIGlmIChyb290ID09PSB2bm9kZSkge1xuICAgICAgKHZub2RlID0gcGFyZW50LnZub2RlKS5lbCA9IGVsO1xuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGlzU3VzcGVuc2UgPSAodHlwZSkgPT4gdHlwZS5fX2lzU3VzcGVuc2U7XG5sZXQgc3VzcGVuc2VJZCA9IDA7XG5jb25zdCBTdXNwZW5zZUltcGwgPSB7XG4gIG5hbWU6IFwiU3VzcGVuc2VcIixcbiAgLy8gSW4gb3JkZXIgdG8gbWFrZSBTdXNwZW5zZSB0cmVlLXNoYWthYmxlLCB3ZSBuZWVkIHRvIGF2b2lkIGltcG9ydGluZyBpdFxuICAvLyBkaXJlY3RseSBpbiB0aGUgcmVuZGVyZXIuIFRoZSByZW5kZXJlciBjaGVja3MgZm9yIHRoZSBfX2lzU3VzcGVuc2UgZmxhZ1xuICAvLyBvbiBhIHZub2RlJ3MgdHlwZSBhbmQgY2FsbHMgdGhlIGBwcm9jZXNzYCBtZXRob2QsIHBhc3NpbmcgaW4gcmVuZGVyZXJcbiAgLy8gaW50ZXJuYWxzLlxuICBfX2lzU3VzcGVuc2U6IHRydWUsXG4gIHByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMpIHtcbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgbW91bnRTdXNwZW5zZShcbiAgICAgICAgbjIsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICByZW5kZXJlckludGVybmFsc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLmRlcHMgPiAwICYmICFuMS5zdXNwZW5zZS5pc0luRmFsbGJhY2spIHtcbiAgICAgICAgbjIuc3VzcGVuc2UgPSBuMS5zdXNwZW5zZTtcbiAgICAgICAgbjIuc3VzcGVuc2Uudm5vZGUgPSBuMjtcbiAgICAgICAgbjIuZWwgPSBuMS5lbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcGF0Y2hTdXNwZW5zZShcbiAgICAgICAgbjEsXG4gICAgICAgIG4yLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICByZW5kZXJlckludGVybmFsc1xuICAgICAgKTtcbiAgICB9XG4gIH0sXG4gIGh5ZHJhdGU6IGh5ZHJhdGVTdXNwZW5zZSxcbiAgbm9ybWFsaXplOiBub3JtYWxpemVTdXNwZW5zZUNoaWxkcmVuXG59O1xuY29uc3QgU3VzcGVuc2UgPSBTdXNwZW5zZUltcGwgO1xuZnVuY3Rpb24gdHJpZ2dlckV2ZW50KHZub2RlLCBuYW1lKSB7XG4gIGNvbnN0IGV2ZW50TGlzdGVuZXIgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wc1tuYW1lXTtcbiAgaWYgKGlzRnVuY3Rpb24oZXZlbnRMaXN0ZW5lcikpIHtcbiAgICBldmVudExpc3RlbmVyKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2Uodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscykge1xuICBjb25zdCB7XG4gICAgcDogcGF0Y2gsXG4gICAgbzogeyBjcmVhdGVFbGVtZW50IH1cbiAgfSA9IHJlbmRlcmVySW50ZXJuYWxzO1xuICBjb25zdCBoaWRkZW5Db250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBjb25zdCBzdXNwZW5zZSA9IHZub2RlLnN1c3BlbnNlID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShcbiAgICB2bm9kZSxcbiAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgY29udGFpbmVyLFxuICAgIGhpZGRlbkNvbnRhaW5lcixcbiAgICBhbmNob3IsXG4gICAgbmFtZXNwYWNlLFxuICAgIHNsb3RTY29wZUlkcyxcbiAgICBvcHRpbWl6ZWQsXG4gICAgcmVuZGVyZXJJbnRlcm5hbHNcbiAgKTtcbiAgcGF0Y2goXG4gICAgbnVsbCxcbiAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gdm5vZGUuc3NDb250ZW50LFxuICAgIGhpZGRlbkNvbnRhaW5lcixcbiAgICBudWxsLFxuICAgIHBhcmVudENvbXBvbmVudCxcbiAgICBzdXNwZW5zZSxcbiAgICBuYW1lc3BhY2UsXG4gICAgc2xvdFNjb3BlSWRzXG4gICk7XG4gIGlmIChzdXNwZW5zZS5kZXBzID4gMCkge1xuICAgIHRyaWdnZXJFdmVudCh2bm9kZSwgXCJvblBlbmRpbmdcIik7XG4gICAgdHJpZ2dlckV2ZW50KHZub2RlLCBcIm9uRmFsbGJhY2tcIik7XG4gICAgcGF0Y2goXG4gICAgICBudWxsLFxuICAgICAgdm5vZGUuc3NGYWxsYmFjayxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIGFuY2hvcixcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIG51bGwsXG4gICAgICAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxuICAgICAgbmFtZXNwYWNlLFxuICAgICAgc2xvdFNjb3BlSWRzXG4gICAgKTtcbiAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIHZub2RlLnNzRmFsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIHN1c3BlbnNlLnJlc29sdmUoZmFsc2UsIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBwYXRjaFN1c3BlbnNlKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgeyBwOiBwYXRjaCwgdW06IHVubW91bnQsIG86IHsgY3JlYXRlRWxlbWVudCB9IH0pIHtcbiAgY29uc3Qgc3VzcGVuc2UgPSBuMi5zdXNwZW5zZSA9IG4xLnN1c3BlbnNlO1xuICBzdXNwZW5zZS52bm9kZSA9IG4yO1xuICBuMi5lbCA9IG4xLmVsO1xuICBjb25zdCBuZXdCcmFuY2ggPSBuMi5zc0NvbnRlbnQ7XG4gIGNvbnN0IG5ld0ZhbGxiYWNrID0gbjIuc3NGYWxsYmFjaztcbiAgY29uc3QgeyBhY3RpdmVCcmFuY2gsIHBlbmRpbmdCcmFuY2gsIGlzSW5GYWxsYmFjaywgaXNIeWRyYXRpbmcgfSA9IHN1c3BlbnNlO1xuICBpZiAocGVuZGluZ0JyYW5jaCkge1xuICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBuZXdCcmFuY2g7XG4gICAgaWYgKGlzU2FtZVZOb2RlVHlwZShuZXdCcmFuY2gsIHBlbmRpbmdCcmFuY2gpKSB7XG4gICAgICBwYXRjaChcbiAgICAgICAgcGVuZGluZ0JyYW5jaCxcbiAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XG4gICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNJbkZhbGxiYWNrKSB7XG4gICAgICAgIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgICBwYXRjaChcbiAgICAgICAgICAgIGFjdGl2ZUJyYW5jaCxcbiAgICAgICAgICAgIG5ld0ZhbGxiYWNrLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3RmFsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1c3BlbnNlLnBlbmRpbmdJZCA9IHN1c3BlbnNlSWQrKztcbiAgICAgIGlmIChpc0h5ZHJhdGluZykge1xuICAgICAgICBzdXNwZW5zZS5pc0h5ZHJhdGluZyA9IGZhbHNlO1xuICAgICAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggPSBwZW5kaW5nQnJhbmNoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5tb3VudChwZW5kaW5nQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlKTtcbiAgICAgIH1cbiAgICAgIHN1c3BlbnNlLmRlcHMgPSAwO1xuICAgICAgc3VzcGVuc2UuZWZmZWN0cy5sZW5ndGggPSAwO1xuICAgICAgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGlmIChpc0luRmFsbGJhY2spIHtcbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgICAgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcbiAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBhY3RpdmVCcmFuY2gsXG4gICAgICAgICAgICBuZXdGYWxsYmFjayxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIG5ld0ZhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhY3RpdmVCcmFuY2ggJiYgaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgYWN0aXZlQnJhbmNoKSkge1xuICAgICAgICBwYXRjaChcbiAgICAgICAgICBhY3RpdmVCcmFuY2gsXG4gICAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIHN1c3BlbnNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRjaChcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIG5ld0JyYW5jaCxcbiAgICAgICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xuICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYWN0aXZlQnJhbmNoICYmIGlzU2FtZVZOb2RlVHlwZShuZXdCcmFuY2gsIGFjdGl2ZUJyYW5jaCkpIHtcbiAgICAgIHBhdGNoKFxuICAgICAgICBhY3RpdmVCcmFuY2gsXG4gICAgICAgIG5ld0JyYW5jaCxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIG5ld0JyYW5jaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXJFdmVudChuMiwgXCJvblBlbmRpbmdcIik7XG4gICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbmV3QnJhbmNoO1xuICAgICAgaWYgKG5ld0JyYW5jaC5zaGFwZUZsYWcgJiA1MTIpIHtcbiAgICAgICAgc3VzcGVuc2UucGVuZGluZ0lkID0gbmV3QnJhbmNoLmNvbXBvbmVudC5zdXNwZW5zZUlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VzcGVuc2UucGVuZGluZ0lkID0gc3VzcGVuc2VJZCsrO1xuICAgICAgfVxuICAgICAgcGF0Y2goXG4gICAgICAgIG51bGwsXG4gICAgICAgIG5ld0JyYW5jaCxcbiAgICAgICAgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLFxuICAgICAgICBudWxsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xuICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IHRpbWVvdXQsIHBlbmRpbmdJZCB9ID0gc3VzcGVuc2U7XG4gICAgICAgIGlmICh0aW1lb3V0ID4gMCkge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdJZCA9PT0gcGVuZGluZ0lkKSB7XG4gICAgICAgICAgICAgIHN1c3BlbnNlLmZhbGxiYWNrKG5ld0ZhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aW1lb3V0ID09PSAwKSB7XG4gICAgICAgICAgc3VzcGVuc2UuZmFsbGJhY2sobmV3RmFsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5sZXQgaGFzV2FybmVkID0gZmFsc2U7XG5mdW5jdGlvbiBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KHZub2RlLCBwYXJlbnRTdXNwZW5zZSwgcGFyZW50Q29tcG9uZW50LCBjb250YWluZXIsIGhpZGRlbkNvbnRhaW5lciwgYW5jaG9yLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgaXNIeWRyYXRpbmcgPSBmYWxzZSkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB0cnVlICYmICFoYXNXYXJuZWQpIHtcbiAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gXCJpbmZvXCIgOiBcImxvZ1wiXShcbiAgICAgIGA8U3VzcGVuc2U+IGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlIGFuZCBpdHMgQVBJIHdpbGwgbGlrZWx5IGNoYW5nZS5gXG4gICAgKTtcbiAgfVxuICBjb25zdCB7XG4gICAgcDogcGF0Y2gsXG4gICAgbTogbW92ZSxcbiAgICB1bTogdW5tb3VudCxcbiAgICBuOiBuZXh0LFxuICAgIG86IHsgcGFyZW50Tm9kZSwgcmVtb3ZlIH1cbiAgfSA9IHJlbmRlcmVySW50ZXJuYWxzO1xuICBsZXQgcGFyZW50U3VzcGVuc2VJZDtcbiAgY29uc3QgaXNTdXNwZW5zaWJsZSA9IGlzVk5vZGVTdXNwZW5zaWJsZSh2bm9kZSk7XG4gIGlmIChpc1N1c3BlbnNpYmxlKSB7XG4gICAgaWYgKHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgIHBhcmVudFN1c3BlbnNlSWQgPSBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nSWQ7XG4gICAgICBwYXJlbnRTdXNwZW5zZS5kZXBzKys7XG4gICAgfVxuICB9XG4gIGNvbnN0IHRpbWVvdXQgPSB2bm9kZS5wcm9wcyA/IHRvTnVtYmVyKHZub2RlLnByb3BzLnRpbWVvdXQpIDogdm9pZCAwO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGFzc2VydE51bWJlcih0aW1lb3V0LCBgU3VzcGVuc2UgdGltZW91dGApO1xuICB9XG4gIGNvbnN0IGluaXRpYWxBbmNob3IgPSBhbmNob3I7XG4gIGNvbnN0IHN1c3BlbnNlID0ge1xuICAgIHZub2RlLFxuICAgIHBhcmVudDogcGFyZW50U3VzcGVuc2UsXG4gICAgcGFyZW50Q29tcG9uZW50LFxuICAgIG5hbWVzcGFjZSxcbiAgICBjb250YWluZXIsXG4gICAgaGlkZGVuQ29udGFpbmVyLFxuICAgIGRlcHM6IDAsXG4gICAgcGVuZGluZ0lkOiBzdXNwZW5zZUlkKyssXG4gICAgdGltZW91dDogdHlwZW9mIHRpbWVvdXQgPT09IFwibnVtYmVyXCIgPyB0aW1lb3V0IDogLTEsXG4gICAgYWN0aXZlQnJhbmNoOiBudWxsLFxuICAgIHBlbmRpbmdCcmFuY2g6IG51bGwsXG4gICAgaXNJbkZhbGxiYWNrOiAhaXNIeWRyYXRpbmcsXG4gICAgaXNIeWRyYXRpbmcsXG4gICAgaXNVbm1vdW50ZWQ6IGZhbHNlLFxuICAgIGVmZmVjdHM6IFtdLFxuICAgIHJlc29sdmUocmVzdW1lID0gZmFsc2UsIHN5bmMgPSBmYWxzZSkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgaWYgKCFyZXN1bWUgJiYgIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgc3VzcGVuc2UucmVzb2x2ZSgpIGlzIGNhbGxlZCB3aXRob3V0IGEgcGVuZGluZyBicmFuY2guYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1c3BlbnNlLmlzVW5tb3VudGVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYHN1c3BlbnNlLnJlc29sdmUoKSBpcyBjYWxsZWQgb24gYW4gYWxyZWFkeSB1bm1vdW50ZWQgc3VzcGVuc2UgYm91bmRhcnkuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdm5vZGU6IHZub2RlMixcbiAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICBwZW5kaW5nQnJhbmNoLFxuICAgICAgICBwZW5kaW5nSWQsXG4gICAgICAgIGVmZmVjdHMsXG4gICAgICAgIHBhcmVudENvbXBvbmVudDogcGFyZW50Q29tcG9uZW50MixcbiAgICAgICAgY29udGFpbmVyOiBjb250YWluZXIyXG4gICAgICB9ID0gc3VzcGVuc2U7XG4gICAgICBsZXQgZGVsYXlFbnRlciA9IGZhbHNlO1xuICAgICAgaWYgKHN1c3BlbnNlLmlzSHlkcmF0aW5nKSB7XG4gICAgICAgIHN1c3BlbnNlLmlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCFyZXN1bWUpIHtcbiAgICAgICAgZGVsYXlFbnRlciA9IGFjdGl2ZUJyYW5jaCAmJiBwZW5kaW5nQnJhbmNoLnRyYW5zaXRpb24gJiYgcGVuZGluZ0JyYW5jaC50cmFuc2l0aW9uLm1vZGUgPT09IFwib3V0LWluXCI7XG4gICAgICAgIGlmIChkZWxheUVudGVyKSB7XG4gICAgICAgICAgYWN0aXZlQnJhbmNoLnRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChwZW5kaW5nSWQgPT09IHN1c3BlbnNlLnBlbmRpbmdJZCkge1xuICAgICAgICAgICAgICBtb3ZlKFxuICAgICAgICAgICAgICAgIHBlbmRpbmdCcmFuY2gsXG4gICAgICAgICAgICAgICAgY29udGFpbmVyMixcbiAgICAgICAgICAgICAgICBhbmNob3IgPT09IGluaXRpYWxBbmNob3IgPyBuZXh0KGFjdGl2ZUJyYW5jaCkgOiBhbmNob3IsXG4gICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBxdWV1ZVBvc3RGbHVzaENiKGVmZmVjdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGl2ZUJyYW5jaCkge1xuICAgICAgICAgIGlmIChwYXJlbnROb2RlKGFjdGl2ZUJyYW5jaC5lbCkgPT09IGNvbnRhaW5lcjIpIHtcbiAgICAgICAgICAgIGFuY2hvciA9IG5leHQoYWN0aXZlQnJhbmNoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdW5tb3VudChhY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudDIsIHN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlbGF5RW50ZXIpIHtcbiAgICAgICAgICBtb3ZlKHBlbmRpbmdCcmFuY2gsIGNvbnRhaW5lcjIsIGFuY2hvciwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgcGVuZGluZ0JyYW5jaCk7XG4gICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbnVsbDtcbiAgICAgIHN1c3BlbnNlLmlzSW5GYWxsYmFjayA9IGZhbHNlO1xuICAgICAgbGV0IHBhcmVudCA9IHN1c3BlbnNlLnBhcmVudDtcbiAgICAgIGxldCBoYXNVbnJlc29sdmVkQW5jZXN0b3IgPSBmYWxzZTtcbiAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudC5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICAgICAgcGFyZW50LmVmZmVjdHMucHVzaCguLi5lZmZlY3RzKTtcbiAgICAgICAgICBoYXNVbnJlc29sdmVkQW5jZXN0b3IgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoIWhhc1VucmVzb2x2ZWRBbmNlc3RvciAmJiAhZGVsYXlFbnRlcikge1xuICAgICAgICBxdWV1ZVBvc3RGbHVzaENiKGVmZmVjdHMpO1xuICAgICAgfVxuICAgICAgc3VzcGVuc2UuZWZmZWN0cyA9IFtdO1xuICAgICAgaWYgKGlzU3VzcGVuc2libGUpIHtcbiAgICAgICAgaWYgKHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggJiYgcGFyZW50U3VzcGVuc2VJZCA9PT0gcGFyZW50U3VzcGVuc2UucGVuZGluZ0lkKSB7XG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UuZGVwcy0tO1xuICAgICAgICAgIGlmIChwYXJlbnRTdXNwZW5zZS5kZXBzID09PSAwICYmICFzeW5jKSB7XG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cmlnZ2VyRXZlbnQodm5vZGUyLCBcIm9uUmVzb2x2ZVwiKTtcbiAgICB9LFxuICAgIGZhbGxiYWNrKGZhbGxiYWNrVk5vZGUpIHtcbiAgICAgIGlmICghc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IHZub2RlOiB2bm9kZTIsIGFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50OiBwYXJlbnRDb21wb25lbnQyLCBjb250YWluZXI6IGNvbnRhaW5lcjIsIG5hbWVzcGFjZTogbmFtZXNwYWNlMiB9ID0gc3VzcGVuc2U7XG4gICAgICB0cmlnZ2VyRXZlbnQodm5vZGUyLCBcIm9uRmFsbGJhY2tcIik7XG4gICAgICBjb25zdCBhbmNob3IyID0gbmV4dChhY3RpdmVCcmFuY2gpO1xuICAgICAgY29uc3QgbW91bnRGYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFzdXNwZW5zZS5pc0luRmFsbGJhY2spIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBmYWxsYmFja1ZOb2RlLFxuICAgICAgICAgIGNvbnRhaW5lcjIsXG4gICAgICAgICAgYW5jaG9yMixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcbiAgICAgICAgICBuYW1lc3BhY2UyLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBmYWxsYmFja1ZOb2RlKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBkZWxheUVudGVyID0gZmFsbGJhY2tWTm9kZS50cmFuc2l0aW9uICYmIGZhbGxiYWNrVk5vZGUudHJhbnNpdGlvbi5tb2RlID09PSBcIm91dC1pblwiO1xuICAgICAgaWYgKGRlbGF5RW50ZXIpIHtcbiAgICAgICAgYWN0aXZlQnJhbmNoLnRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSA9IG1vdW50RmFsbGJhY2s7XG4gICAgICB9XG4gICAgICBzdXNwZW5zZS5pc0luRmFsbGJhY2sgPSB0cnVlO1xuICAgICAgdW5tb3VudChcbiAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQyLFxuICAgICAgICBudWxsLFxuICAgICAgICAvLyBubyBzdXNwZW5zZSBzbyB1bm1vdW50IGhvb2tzIGZpcmUgbm93XG4gICAgICAgIHRydWVcbiAgICAgICAgLy8gc2hvdWxkUmVtb3ZlXG4gICAgICApO1xuICAgICAgaWYgKCFkZWxheUVudGVyKSB7XG4gICAgICAgIG1vdW50RmFsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdmUoY29udGFpbmVyMiwgYW5jaG9yMiwgdHlwZSkge1xuICAgICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoICYmIG1vdmUoc3VzcGVuc2UuYWN0aXZlQnJhbmNoLCBjb250YWluZXIyLCBhbmNob3IyLCB0eXBlKTtcbiAgICAgIHN1c3BlbnNlLmNvbnRhaW5lciA9IGNvbnRhaW5lcjI7XG4gICAgfSxcbiAgICBuZXh0KCkge1xuICAgICAgcmV0dXJuIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCAmJiBuZXh0KHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCk7XG4gICAgfSxcbiAgICByZWdpc3RlckRlcChpbnN0YW5jZSwgc2V0dXBSZW5kZXJFZmZlY3QsIG9wdGltaXplZDIpIHtcbiAgICAgIGNvbnN0IGlzSW5QZW5kaW5nU3VzcGVuc2UgPSAhIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2g7XG4gICAgICBpZiAoaXNJblBlbmRpbmdTdXNwZW5zZSkge1xuICAgICAgICBzdXNwZW5zZS5kZXBzKys7XG4gICAgICB9XG4gICAgICBjb25zdCBoeWRyYXRlZEVsID0gaW5zdGFuY2Uudm5vZGUuZWw7XG4gICAgICBpbnN0YW5jZS5hc3luY0RlcC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIDApO1xuICAgICAgfSkudGhlbigoYXN5bmNTZXR1cFJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAoaW5zdGFuY2UuaXNVbm1vdW50ZWQgfHwgc3VzcGVuc2UuaXNVbm1vdW50ZWQgfHwgc3VzcGVuc2UucGVuZGluZ0lkICE9PSBpbnN0YW5jZS5zdXNwZW5zZUlkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlLmFzeW5jUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IHZub2RlOiB2bm9kZTIgfSA9IGluc3RhbmNlO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dCh2bm9kZTIpO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBhc3luY1NldHVwUmVzdWx0LCBmYWxzZSk7XG4gICAgICAgIGlmIChoeWRyYXRlZEVsKSB7XG4gICAgICAgICAgdm5vZGUyLmVsID0gaHlkcmF0ZWRFbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9ICFoeWRyYXRlZEVsICYmIGluc3RhbmNlLnN1YlRyZWUuZWw7XG4gICAgICAgIHNldHVwUmVuZGVyRWZmZWN0KFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIHZub2RlMixcbiAgICAgICAgICAvLyBjb21wb25lbnQgbWF5IGhhdmUgYmVlbiBtb3ZlZCBiZWZvcmUgcmVzb2x2ZS5cbiAgICAgICAgICAvLyBpZiB0aGlzIGlzIG5vdCBhIGh5ZHJhdGlvbiwgaW5zdGFuY2Uuc3ViVHJlZSB3aWxsIGJlIHRoZSBjb21tZW50XG4gICAgICAgICAgLy8gcGxhY2Vob2xkZXIuXG4gICAgICAgICAgcGFyZW50Tm9kZShoeWRyYXRlZEVsIHx8IGluc3RhbmNlLnN1YlRyZWUuZWwpLFxuICAgICAgICAgIC8vIGFuY2hvciB3aWxsIG5vdCBiZSB1c2VkIGlmIHRoaXMgaXMgaHlkcmF0aW9uLCBzbyBvbmx5IG5lZWQgdG9cbiAgICAgICAgICAvLyBjb25zaWRlciB0aGUgY29tbWVudCBwbGFjZWhvbGRlciBjYXNlLlxuICAgICAgICAgIGh5ZHJhdGVkRWwgPyBudWxsIDogbmV4dChpbnN0YW5jZS5zdWJUcmVlKSxcbiAgICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgb3B0aW1pemVkMlxuICAgICAgICApO1xuICAgICAgICBpZiAocGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICByZW1vdmUocGxhY2Vob2xkZXIpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZUhPQ0hvc3RFbChpbnN0YW5jZSwgdm5vZGUyLmVsKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0luUGVuZGluZ1N1c3BlbnNlICYmIC0tc3VzcGVuc2UuZGVwcyA9PT0gMCkge1xuICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICB1bm1vdW50KHBhcmVudFN1c3BlbnNlMiwgZG9SZW1vdmUpIHtcbiAgICAgIHN1c3BlbnNlLmlzVW5tb3VudGVkID0gdHJ1ZTtcbiAgICAgIGlmIChzdXNwZW5zZS5hY3RpdmVCcmFuY2gpIHtcbiAgICAgICAgdW5tb3VudChcbiAgICAgICAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2gsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlMixcbiAgICAgICAgICBkb1JlbW92ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgICAgdW5tb3VudChcbiAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZTIsXG4gICAgICAgICAgZG9SZW1vdmVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBzdXNwZW5zZTtcbn1cbmZ1bmN0aW9uIGh5ZHJhdGVTdXNwZW5zZShub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGh5ZHJhdGVOb2RlKSB7XG4gIGNvbnN0IHN1c3BlbnNlID0gdm5vZGUuc3VzcGVuc2UgPSBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KFxuICAgIHZub2RlLFxuICAgIHBhcmVudFN1c3BlbnNlLFxuICAgIHBhcmVudENvbXBvbmVudCxcbiAgICBub2RlLnBhcmVudE5vZGUsXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgbnVsbCxcbiAgICBuYW1lc3BhY2UsXG4gICAgc2xvdFNjb3BlSWRzLFxuICAgIG9wdGltaXplZCxcbiAgICByZW5kZXJlckludGVybmFscyxcbiAgICB0cnVlXG4gICk7XG4gIGNvbnN0IHJlc3VsdCA9IGh5ZHJhdGVOb2RlKFxuICAgIG5vZGUsXG4gICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IHZub2RlLnNzQ29udGVudCxcbiAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgc3VzcGVuc2UsXG4gICAgc2xvdFNjb3BlSWRzLFxuICAgIG9wdGltaXplZFxuICApO1xuICBpZiAoc3VzcGVuc2UuZGVwcyA9PT0gMCkge1xuICAgIHN1c3BlbnNlLnJlc29sdmUoZmFsc2UsIHRydWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemVTdXNwZW5zZUNoaWxkcmVuKHZub2RlKSB7XG4gIGNvbnN0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiB9ID0gdm5vZGU7XG4gIGNvbnN0IGlzU2xvdENoaWxkcmVuID0gc2hhcGVGbGFnICYgMzI7XG4gIHZub2RlLnNzQ29udGVudCA9IG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChcbiAgICBpc1Nsb3RDaGlsZHJlbiA/IGNoaWxkcmVuLmRlZmF1bHQgOiBjaGlsZHJlblxuICApO1xuICB2bm9kZS5zc0ZhbGxiYWNrID0gaXNTbG90Q2hpbGRyZW4gPyBub3JtYWxpemVTdXNwZW5zZVNsb3QoY2hpbGRyZW4uZmFsbGJhY2spIDogY3JlYXRlVk5vZGUoQ29tbWVudCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVTdXNwZW5zZVNsb3Qocykge1xuICBsZXQgYmxvY2s7XG4gIGlmIChpc0Z1bmN0aW9uKHMpKSB7XG4gICAgY29uc3QgdHJhY2tCbG9jayA9IGlzQmxvY2tUcmVlRW5hYmxlZCAmJiBzLl9jO1xuICAgIGlmICh0cmFja0Jsb2NrKSB7XG4gICAgICBzLl9kID0gZmFsc2U7XG4gICAgICBvcGVuQmxvY2soKTtcbiAgICB9XG4gICAgcyA9IHMoKTtcbiAgICBpZiAodHJhY2tCbG9jaykge1xuICAgICAgcy5fZCA9IHRydWU7XG4gICAgICBibG9jayA9IGN1cnJlbnRCbG9jaztcbiAgICAgIGNsb3NlQmxvY2soKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQXJyYXkocykpIHtcbiAgICBjb25zdCBzaW5nbGVDaGlsZCA9IGZpbHRlclNpbmdsZVJvb3Qocyk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIXNpbmdsZUNoaWxkICYmIHMuZmlsdGVyKChjaGlsZCkgPT4gY2hpbGQgIT09IE5VTExfRFlOQU1JQ19DT01QT05FTlQpLmxlbmd0aCA+IDApIHtcbiAgICAgIHdhcm4kMShgPFN1c3BlbnNlPiBzbG90cyBleHBlY3QgYSBzaW5nbGUgcm9vdCBub2RlLmApO1xuICAgIH1cbiAgICBzID0gc2luZ2xlQ2hpbGQ7XG4gIH1cbiAgcyA9IG5vcm1hbGl6ZVZOb2RlKHMpO1xuICBpZiAoYmxvY2sgJiYgIXMuZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgcy5keW5hbWljQ2hpbGRyZW4gPSBibG9jay5maWx0ZXIoKGMpID0+IGMgIT09IHMpO1xuICB9XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24gcXVldWVFZmZlY3RXaXRoU3VzcGVuc2UoZm4sIHN1c3BlbnNlKSB7XG4gIGlmIChzdXNwZW5zZSAmJiBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XG4gICAgaWYgKGlzQXJyYXkoZm4pKSB7XG4gICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goLi4uZm4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goZm4pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBxdWV1ZVBvc3RGbHVzaENiKGZuKTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBicmFuY2gpIHtcbiAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoID0gYnJhbmNoO1xuICBjb25zdCB7IHZub2RlLCBwYXJlbnRDb21wb25lbnQgfSA9IHN1c3BlbnNlO1xuICBsZXQgZWwgPSBicmFuY2guZWw7XG4gIHdoaWxlICghZWwgJiYgYnJhbmNoLmNvbXBvbmVudCkge1xuICAgIGJyYW5jaCA9IGJyYW5jaC5jb21wb25lbnQuc3ViVHJlZTtcbiAgICBlbCA9IGJyYW5jaC5lbDtcbiAgfVxuICB2bm9kZS5lbCA9IGVsO1xuICBpZiAocGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC5zdWJUcmVlID09PSB2bm9kZSkge1xuICAgIHBhcmVudENvbXBvbmVudC52bm9kZS5lbCA9IGVsO1xuICAgIHVwZGF0ZUhPQ0hvc3RFbChwYXJlbnRDb21wb25lbnQsIGVsKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNWTm9kZVN1c3BlbnNpYmxlKHZub2RlKSB7XG4gIGNvbnN0IHN1c3BlbnNpYmxlID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMuc3VzcGVuc2libGU7XG4gIHJldHVybiBzdXNwZW5zaWJsZSAhPSBudWxsICYmIHN1c3BlbnNpYmxlICE9PSBmYWxzZTtcbn1cblxuY29uc3QgRnJhZ21lbnQgPSBTeW1ib2wuZm9yKFwidi1mZ3RcIik7XG5jb25zdCBUZXh0ID0gU3ltYm9sLmZvcihcInYtdHh0XCIpO1xuY29uc3QgQ29tbWVudCA9IFN5bWJvbC5mb3IoXCJ2LWNtdFwiKTtcbmNvbnN0IFN0YXRpYyA9IFN5bWJvbC5mb3IoXCJ2LXN0Y1wiKTtcbmNvbnN0IGJsb2NrU3RhY2sgPSBbXTtcbmxldCBjdXJyZW50QmxvY2sgPSBudWxsO1xuZnVuY3Rpb24gb3BlbkJsb2NrKGRpc2FibGVUcmFja2luZyA9IGZhbHNlKSB7XG4gIGJsb2NrU3RhY2sucHVzaChjdXJyZW50QmxvY2sgPSBkaXNhYmxlVHJhY2tpbmcgPyBudWxsIDogW10pO1xufVxuZnVuY3Rpb24gY2xvc2VCbG9jaygpIHtcbiAgYmxvY2tTdGFjay5wb3AoKTtcbiAgY3VycmVudEJsb2NrID0gYmxvY2tTdGFja1tibG9ja1N0YWNrLmxlbmd0aCAtIDFdIHx8IG51bGw7XG59XG5sZXQgaXNCbG9ja1RyZWVFbmFibGVkID0gMTtcbmZ1bmN0aW9uIHNldEJsb2NrVHJhY2tpbmcodmFsdWUsIGluVk9uY2UgPSBmYWxzZSkge1xuICBpc0Jsb2NrVHJlZUVuYWJsZWQgKz0gdmFsdWU7XG4gIGlmICh2YWx1ZSA8IDAgJiYgY3VycmVudEJsb2NrICYmIGluVk9uY2UpIHtcbiAgICBjdXJyZW50QmxvY2suaGFzT25jZSA9IHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldHVwQmxvY2sodm5vZGUpIHtcbiAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID0gaXNCbG9ja1RyZWVFbmFibGVkID4gMCA/IGN1cnJlbnRCbG9jayB8fCBFTVBUWV9BUlIgOiBudWxsO1xuICBjbG9zZUJsb2NrKCk7XG4gIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmIGN1cnJlbnRCbG9jaykge1xuICAgIGN1cnJlbnRCbG9jay5wdXNoKHZub2RlKTtcbiAgfVxuICByZXR1cm4gdm5vZGU7XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50QmxvY2sodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgc2hhcGVGbGFnKSB7XG4gIHJldHVybiBzZXR1cEJsb2NrKFxuICAgIGNyZWF0ZUJhc2VWTm9kZShcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgcGF0Y2hGbGFnLFxuICAgICAgZHluYW1pY1Byb3BzLFxuICAgICAgc2hhcGVGbGFnLFxuICAgICAgdHJ1ZVxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMpIHtcbiAgcmV0dXJuIHNldHVwQmxvY2soXG4gICAgY3JlYXRlVk5vZGUoXG4gICAgICB0eXBlLFxuICAgICAgcHJvcHMsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIHBhdGNoRmxhZyxcbiAgICAgIGR5bmFtaWNQcm9wcyxcbiAgICAgIHRydWVcbiAgICApXG4gICk7XG59XG5mdW5jdGlvbiBpc1ZOb2RlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA/IHZhbHVlLl9fdl9pc1ZOb2RlID09PSB0cnVlIDogZmFsc2U7XG59XG5mdW5jdGlvbiBpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG4yLnNoYXBlRmxhZyAmIDYgJiYgbjEuY29tcG9uZW50KSB7XG4gICAgY29uc3QgZGlydHlJbnN0YW5jZXMgPSBobXJEaXJ0eUNvbXBvbmVudHMuZ2V0KG4yLnR5cGUpO1xuICAgIGlmIChkaXJ0eUluc3RhbmNlcyAmJiBkaXJ0eUluc3RhbmNlcy5oYXMobjEuY29tcG9uZW50KSkge1xuICAgICAgbjEuc2hhcGVGbGFnICY9IC0yNTc7XG4gICAgICBuMi5zaGFwZUZsYWcgJj0gLTUxMztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG4xLnR5cGUgPT09IG4yLnR5cGUgJiYgbjEua2V5ID09PSBuMi5rZXk7XG59XG5sZXQgdm5vZGVBcmdzVHJhbnNmb3JtZXI7XG5mdW5jdGlvbiB0cmFuc2Zvcm1WTm9kZUFyZ3ModHJhbnNmb3JtZXIpIHtcbiAgdm5vZGVBcmdzVHJhbnNmb3JtZXIgPSB0cmFuc2Zvcm1lcjtcbn1cbmNvbnN0IGNyZWF0ZVZOb2RlV2l0aEFyZ3NUcmFuc2Zvcm0gPSAoLi4uYXJncykgPT4ge1xuICByZXR1cm4gX2NyZWF0ZVZOb2RlKFxuICAgIC4uLnZub2RlQXJnc1RyYW5zZm9ybWVyID8gdm5vZGVBcmdzVHJhbnNmb3JtZXIoYXJncywgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKSA6IGFyZ3NcbiAgKTtcbn07XG5jb25zdCBub3JtYWxpemVLZXkgPSAoeyBrZXkgfSkgPT4ga2V5ICE9IG51bGwgPyBrZXkgOiBudWxsO1xuY29uc3Qgbm9ybWFsaXplUmVmID0gKHtcbiAgcmVmLFxuICByZWZfa2V5LFxuICByZWZfZm9yXG59KSA9PiB7XG4gIGlmICh0eXBlb2YgcmVmID09PSBcIm51bWJlclwiKSB7XG4gICAgcmVmID0gXCJcIiArIHJlZjtcbiAgfVxuICByZXR1cm4gcmVmICE9IG51bGwgPyBpc1N0cmluZyhyZWYpIHx8IGlzUmVmKHJlZikgfHwgaXNGdW5jdGlvbihyZWYpID8geyBpOiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsIHI6IHJlZiwgazogcmVmX2tleSwgZjogISFyZWZfZm9yIH0gOiByZWYgOiBudWxsO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VWTm9kZSh0eXBlLCBwcm9wcyA9IG51bGwsIGNoaWxkcmVuID0gbnVsbCwgcGF0Y2hGbGFnID0gMCwgZHluYW1pY1Byb3BzID0gbnVsbCwgc2hhcGVGbGFnID0gdHlwZSA9PT0gRnJhZ21lbnQgPyAwIDogMSwgaXNCbG9ja05vZGUgPSBmYWxzZSwgbmVlZEZ1bGxDaGlsZHJlbk5vcm1hbGl6YXRpb24gPSBmYWxzZSkge1xuICBjb25zdCB2bm9kZSA9IHtcbiAgICBfX3ZfaXNWTm9kZTogdHJ1ZSxcbiAgICBfX3Zfc2tpcDogdHJ1ZSxcbiAgICB0eXBlLFxuICAgIHByb3BzLFxuICAgIGtleTogcHJvcHMgJiYgbm9ybWFsaXplS2V5KHByb3BzKSxcbiAgICByZWY6IHByb3BzICYmIG5vcm1hbGl6ZVJlZihwcm9wcyksXG4gICAgc2NvcGVJZDogY3VycmVudFNjb3BlSWQsXG4gICAgc2xvdFNjb3BlSWRzOiBudWxsLFxuICAgIGNoaWxkcmVuLFxuICAgIGNvbXBvbmVudDogbnVsbCxcbiAgICBzdXNwZW5zZTogbnVsbCxcbiAgICBzc0NvbnRlbnQ6IG51bGwsXG4gICAgc3NGYWxsYmFjazogbnVsbCxcbiAgICBkaXJzOiBudWxsLFxuICAgIHRyYW5zaXRpb246IG51bGwsXG4gICAgZWw6IG51bGwsXG4gICAgYW5jaG9yOiBudWxsLFxuICAgIHRhcmdldDogbnVsbCxcbiAgICB0YXJnZXRTdGFydDogbnVsbCxcbiAgICB0YXJnZXRBbmNob3I6IG51bGwsXG4gICAgc3RhdGljQ291bnQ6IDAsXG4gICAgc2hhcGVGbGFnLFxuICAgIHBhdGNoRmxhZyxcbiAgICBkeW5hbWljUHJvcHMsXG4gICAgZHluYW1pY0NoaWxkcmVuOiBudWxsLFxuICAgIGFwcENvbnRleHQ6IG51bGwsXG4gICAgY3R4OiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2VcbiAgfTtcbiAgaWYgKG5lZWRGdWxsQ2hpbGRyZW5Ob3JtYWxpemF0aW9uKSB7XG4gICAgbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuKTtcbiAgICBpZiAoc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICB0eXBlLm5vcm1hbGl6ZSh2bm9kZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGNoaWxkcmVuKSB7XG4gICAgdm5vZGUuc2hhcGVGbGFnIHw9IGlzU3RyaW5nKGNoaWxkcmVuKSA/IDggOiAxNjtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB2bm9kZS5rZXkgIT09IHZub2RlLmtleSkge1xuICAgIHdhcm4kMShgVk5vZGUgY3JlYXRlZCB3aXRoIGludmFsaWQga2V5IChOYU4pLiBWTm9kZSB0eXBlOmAsIHZub2RlLnR5cGUpO1xuICB9XG4gIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmIC8vIGF2b2lkIGEgYmxvY2sgbm9kZSBmcm9tIHRyYWNraW5nIGl0c2VsZlxuICAhaXNCbG9ja05vZGUgJiYgLy8gaGFzIGN1cnJlbnQgcGFyZW50IGJsb2NrXG4gIGN1cnJlbnRCbG9jayAmJiAvLyBwcmVzZW5jZSBvZiBhIHBhdGNoIGZsYWcgaW5kaWNhdGVzIHRoaXMgbm9kZSBuZWVkcyBwYXRjaGluZyBvbiB1cGRhdGVzLlxuICAvLyBjb21wb25lbnQgbm9kZXMgYWxzbyBzaG91bGQgYWx3YXlzIGJlIHBhdGNoZWQsIGJlY2F1c2UgZXZlbiBpZiB0aGVcbiAgLy8gY29tcG9uZW50IGRvZXNuJ3QgbmVlZCB0byB1cGRhdGUsIGl0IG5lZWRzIHRvIHBlcnNpc3QgdGhlIGluc3RhbmNlIG9uIHRvXG4gIC8vIHRoZSBuZXh0IHZub2RlIHNvIHRoYXQgaXQgY2FuIGJlIHByb3Blcmx5IHVubW91bnRlZCBsYXRlci5cbiAgKHZub2RlLnBhdGNoRmxhZyA+IDAgfHwgc2hhcGVGbGFnICYgNikgJiYgLy8gdGhlIEVWRU5UUyBmbGFnIGlzIG9ubHkgZm9yIGh5ZHJhdGlvbiBhbmQgaWYgaXQgaXMgdGhlIG9ubHkgZmxhZywgdGhlXG4gIC8vIHZub2RlIHNob3VsZCBub3QgYmUgY29uc2lkZXJlZCBkeW5hbWljIGR1ZSB0byBoYW5kbGVyIGNhY2hpbmcuXG4gIHZub2RlLnBhdGNoRmxhZyAhPT0gMzIpIHtcbiAgICBjdXJyZW50QmxvY2sucHVzaCh2bm9kZSk7XG4gIH1cbiAgcmV0dXJuIHZub2RlO1xufVxuY29uc3QgY3JlYXRlVk5vZGUgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gY3JlYXRlVk5vZGVXaXRoQXJnc1RyYW5zZm9ybSA6IF9jcmVhdGVWTm9kZTtcbmZ1bmN0aW9uIF9jcmVhdGVWTm9kZSh0eXBlLCBwcm9wcyA9IG51bGwsIGNoaWxkcmVuID0gbnVsbCwgcGF0Y2hGbGFnID0gMCwgZHluYW1pY1Byb3BzID0gbnVsbCwgaXNCbG9ja05vZGUgPSBmYWxzZSkge1xuICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICF0eXBlKSB7XG4gICAgICB3YXJuJDEoYEludmFsaWQgdm5vZGUgdHlwZSB3aGVuIGNyZWF0aW5nIHZub2RlOiAke3R5cGV9LmApO1xuICAgIH1cbiAgICB0eXBlID0gQ29tbWVudDtcbiAgfVxuICBpZiAoaXNWTm9kZSh0eXBlKSkge1xuICAgIGNvbnN0IGNsb25lZCA9IGNsb25lVk5vZGUoXG4gICAgICB0eXBlLFxuICAgICAgcHJvcHMsXG4gICAgICB0cnVlXG4gICAgICAvKiBtZXJnZVJlZjogdHJ1ZSAqL1xuICAgICk7XG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBub3JtYWxpemVDaGlsZHJlbihjbG9uZWQsIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgIWlzQmxvY2tOb2RlICYmIGN1cnJlbnRCbG9jaykge1xuICAgICAgaWYgKGNsb25lZC5zaGFwZUZsYWcgJiA2KSB7XG4gICAgICAgIGN1cnJlbnRCbG9ja1tjdXJyZW50QmxvY2suaW5kZXhPZih0eXBlKV0gPSBjbG9uZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50QmxvY2sucHVzaChjbG9uZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBjbG9uZWQucGF0Y2hGbGFnID0gLTI7XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxuICBpZiAoaXNDbGFzc0NvbXBvbmVudCh0eXBlKSkge1xuICAgIHR5cGUgPSB0eXBlLl9fdmNjT3B0cztcbiAgfVxuICBpZiAocHJvcHMpIHtcbiAgICBwcm9wcyA9IGd1YXJkUmVhY3RpdmVQcm9wcyhwcm9wcyk7XG4gICAgbGV0IHsgY2xhc3M6IGtsYXNzLCBzdHlsZSB9ID0gcHJvcHM7XG4gICAgaWYgKGtsYXNzICYmICFpc1N0cmluZyhrbGFzcykpIHtcbiAgICAgIHByb3BzLmNsYXNzID0gbm9ybWFsaXplQ2xhc3Moa2xhc3MpO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3Qoc3R5bGUpKSB7XG4gICAgICBpZiAoaXNQcm94eShzdHlsZSkgJiYgIWlzQXJyYXkoc3R5bGUpKSB7XG4gICAgICAgIHN0eWxlID0gZXh0ZW5kKHt9LCBzdHlsZSk7XG4gICAgICB9XG4gICAgICBwcm9wcy5zdHlsZSA9IG5vcm1hbGl6ZVN0eWxlKHN0eWxlKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc2hhcGVGbGFnID0gaXNTdHJpbmcodHlwZSkgPyAxIDogaXNTdXNwZW5zZSh0eXBlKSA/IDEyOCA6IGlzVGVsZXBvcnQodHlwZSkgPyA2NCA6IGlzT2JqZWN0KHR5cGUpID8gNCA6IGlzRnVuY3Rpb24odHlwZSkgPyAyIDogMDtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2hhcGVGbGFnICYgNCAmJiBpc1Byb3h5KHR5cGUpKSB7XG4gICAgdHlwZSA9IHRvUmF3KHR5cGUpO1xuICAgIHdhcm4kMShcbiAgICAgIGBWdWUgcmVjZWl2ZWQgYSBDb21wb25lbnQgdGhhdCB3YXMgbWFkZSBhIHJlYWN0aXZlIG9iamVjdC4gVGhpcyBjYW4gbGVhZCB0byB1bm5lY2Vzc2FyeSBwZXJmb3JtYW5jZSBvdmVyaGVhZCBhbmQgc2hvdWxkIGJlIGF2b2lkZWQgYnkgbWFya2luZyB0aGUgY29tcG9uZW50IHdpdGggXFxgbWFya1Jhd1xcYCBvciB1c2luZyBcXGBzaGFsbG93UmVmXFxgIGluc3RlYWQgb2YgXFxgcmVmXFxgLmAsXG4gICAgICBgXG5Db21wb25lbnQgdGhhdCB3YXMgbWFkZSByZWFjdGl2ZTogYCxcbiAgICAgIHR5cGVcbiAgICApO1xuICB9XG4gIHJldHVybiBjcmVhdGVCYXNlVk5vZGUoXG4gICAgdHlwZSxcbiAgICBwcm9wcyxcbiAgICBjaGlsZHJlbixcbiAgICBwYXRjaEZsYWcsXG4gICAgZHluYW1pY1Byb3BzLFxuICAgIHNoYXBlRmxhZyxcbiAgICBpc0Jsb2NrTm9kZSxcbiAgICB0cnVlXG4gICk7XG59XG5mdW5jdGlvbiBndWFyZFJlYWN0aXZlUHJvcHMocHJvcHMpIHtcbiAgaWYgKCFwcm9wcykgcmV0dXJuIG51bGw7XG4gIHJldHVybiBpc1Byb3h5KHByb3BzKSB8fCBpc0ludGVybmFsT2JqZWN0KHByb3BzKSA/IGV4dGVuZCh7fSwgcHJvcHMpIDogcHJvcHM7XG59XG5mdW5jdGlvbiBjbG9uZVZOb2RlKHZub2RlLCBleHRyYVByb3BzLCBtZXJnZVJlZiA9IGZhbHNlLCBjbG9uZVRyYW5zaXRpb24gPSBmYWxzZSkge1xuICBjb25zdCB7IHByb3BzLCByZWYsIHBhdGNoRmxhZywgY2hpbGRyZW4sIHRyYW5zaXRpb24gfSA9IHZub2RlO1xuICBjb25zdCBtZXJnZWRQcm9wcyA9IGV4dHJhUHJvcHMgPyBtZXJnZVByb3BzKHByb3BzIHx8IHt9LCBleHRyYVByb3BzKSA6IHByb3BzO1xuICBjb25zdCBjbG9uZWQgPSB7XG4gICAgX192X2lzVk5vZGU6IHRydWUsXG4gICAgX192X3NraXA6IHRydWUsXG4gICAgdHlwZTogdm5vZGUudHlwZSxcbiAgICBwcm9wczogbWVyZ2VkUHJvcHMsXG4gICAga2V5OiBtZXJnZWRQcm9wcyAmJiBub3JtYWxpemVLZXkobWVyZ2VkUHJvcHMpLFxuICAgIHJlZjogZXh0cmFQcm9wcyAmJiBleHRyYVByb3BzLnJlZiA/IChcbiAgICAgIC8vICMyMDc4IGluIHRoZSBjYXNlIG9mIDxjb21wb25lbnQgOmlzPVwidm5vZGVcIiByZWY9XCJleHRyYVwiLz5cbiAgICAgIC8vIGlmIHRoZSB2bm9kZSBpdHNlbGYgYWxyZWFkeSBoYXMgYSByZWYsIGNsb25lVk5vZGUgd2lsbCBuZWVkIHRvIG1lcmdlXG4gICAgICAvLyB0aGUgcmVmcyBzbyB0aGUgc2luZ2xlIHZub2RlIGNhbiBiZSBzZXQgb24gbXVsdGlwbGUgcmVmc1xuICAgICAgbWVyZ2VSZWYgJiYgcmVmID8gaXNBcnJheShyZWYpID8gcmVmLmNvbmNhdChub3JtYWxpemVSZWYoZXh0cmFQcm9wcykpIDogW3JlZiwgbm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpXSA6IG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKVxuICAgICkgOiByZWYsXG4gICAgc2NvcGVJZDogdm5vZGUuc2NvcGVJZCxcbiAgICBzbG90U2NvcGVJZHM6IHZub2RlLnNsb3RTY29wZUlkcyxcbiAgICBjaGlsZHJlbjogISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBwYXRjaEZsYWcgPT09IC0xICYmIGlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4ubWFwKGRlZXBDbG9uZVZOb2RlKSA6IGNoaWxkcmVuLFxuICAgIHRhcmdldDogdm5vZGUudGFyZ2V0LFxuICAgIHRhcmdldFN0YXJ0OiB2bm9kZS50YXJnZXRTdGFydCxcbiAgICB0YXJnZXRBbmNob3I6IHZub2RlLnRhcmdldEFuY2hvcixcbiAgICBzdGF0aWNDb3VudDogdm5vZGUuc3RhdGljQ291bnQsXG4gICAgc2hhcGVGbGFnOiB2bm9kZS5zaGFwZUZsYWcsXG4gICAgLy8gaWYgdGhlIHZub2RlIGlzIGNsb25lZCB3aXRoIGV4dHJhIHByb3BzLCB3ZSBjYW4gbm8gbG9uZ2VyIGFzc3VtZSBpdHNcbiAgICAvLyBleGlzdGluZyBwYXRjaCBmbGFnIHRvIGJlIHJlbGlhYmxlIGFuZCBuZWVkIHRvIGFkZCB0aGUgRlVMTF9QUk9QUyBmbGFnLlxuICAgIC8vIG5vdGU6IHByZXNlcnZlIGZsYWcgZm9yIGZyYWdtZW50cyBzaW5jZSB0aGV5IHVzZSB0aGUgZmxhZyBmb3IgY2hpbGRyZW5cbiAgICAvLyBmYXN0IHBhdGhzIG9ubHkuXG4gICAgcGF0Y2hGbGFnOiBleHRyYVByb3BzICYmIHZub2RlLnR5cGUgIT09IEZyYWdtZW50ID8gcGF0Y2hGbGFnID09PSAtMSA/IDE2IDogcGF0Y2hGbGFnIHwgMTYgOiBwYXRjaEZsYWcsXG4gICAgZHluYW1pY1Byb3BzOiB2bm9kZS5keW5hbWljUHJvcHMsXG4gICAgZHluYW1pY0NoaWxkcmVuOiB2bm9kZS5keW5hbWljQ2hpbGRyZW4sXG4gICAgYXBwQ29udGV4dDogdm5vZGUuYXBwQ29udGV4dCxcbiAgICBkaXJzOiB2bm9kZS5kaXJzLFxuICAgIHRyYW5zaXRpb24sXG4gICAgLy8gVGhlc2Ugc2hvdWxkIHRlY2huaWNhbGx5IG9ubHkgYmUgbm9uLW51bGwgb24gbW91bnRlZCBWTm9kZXMuIEhvd2V2ZXIsXG4gICAgLy8gdGhleSAqc2hvdWxkKiBiZSBjb3BpZWQgZm9yIGtlcHQtYWxpdmUgdm5vZGVzLiBTbyB3ZSBqdXN0IGFsd2F5cyBjb3B5XG4gICAgLy8gdGhlbSBzaW5jZSB0aGVtIGJlaW5nIG5vbi1udWxsIGR1cmluZyBhIG1vdW50IGRvZXNuJ3QgYWZmZWN0IHRoZSBsb2dpYyBhc1xuICAgIC8vIHRoZXkgd2lsbCBzaW1wbHkgYmUgb3ZlcndyaXR0ZW4uXG4gICAgY29tcG9uZW50OiB2bm9kZS5jb21wb25lbnQsXG4gICAgc3VzcGVuc2U6IHZub2RlLnN1c3BlbnNlLFxuICAgIHNzQ29udGVudDogdm5vZGUuc3NDb250ZW50ICYmIGNsb25lVk5vZGUodm5vZGUuc3NDb250ZW50KSxcbiAgICBzc0ZhbGxiYWNrOiB2bm9kZS5zc0ZhbGxiYWNrICYmIGNsb25lVk5vZGUodm5vZGUuc3NGYWxsYmFjayksXG4gICAgZWw6IHZub2RlLmVsLFxuICAgIGFuY2hvcjogdm5vZGUuYW5jaG9yLFxuICAgIGN0eDogdm5vZGUuY3R4LFxuICAgIGNlOiB2bm9kZS5jZVxuICB9O1xuICBpZiAodHJhbnNpdGlvbiAmJiBjbG9uZVRyYW5zaXRpb24pIHtcbiAgICBzZXRUcmFuc2l0aW9uSG9va3MoXG4gICAgICBjbG9uZWQsXG4gICAgICB0cmFuc2l0aW9uLmNsb25lKGNsb25lZClcbiAgICApO1xuICB9XG4gIHJldHVybiBjbG9uZWQ7XG59XG5mdW5jdGlvbiBkZWVwQ2xvbmVWTm9kZSh2bm9kZSkge1xuICBjb25zdCBjbG9uZWQgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgaWYgKGlzQXJyYXkodm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgY2xvbmVkLmNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW4ubWFwKGRlZXBDbG9uZVZOb2RlKTtcbiAgfVxuICByZXR1cm4gY2xvbmVkO1xufVxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlKHRleHQgPSBcIiBcIiwgZmxhZyA9IDApIHtcbiAgcmV0dXJuIGNyZWF0ZVZOb2RlKFRleHQsIG51bGwsIHRleHQsIGZsYWcpO1xufVxuZnVuY3Rpb24gY3JlYXRlU3RhdGljVk5vZGUoY29udGVudCwgbnVtYmVyT2ZOb2Rlcykge1xuICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKFN0YXRpYywgbnVsbCwgY29udGVudCk7XG4gIHZub2RlLnN0YXRpY0NvdW50ID0gbnVtYmVyT2ZOb2RlcztcbiAgcmV0dXJuIHZub2RlO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudFZOb2RlKHRleHQgPSBcIlwiLCBhc0Jsb2NrID0gZmFsc2UpIHtcbiAgcmV0dXJuIGFzQmxvY2sgPyAob3BlbkJsb2NrKCksIGNyZWF0ZUJsb2NrKENvbW1lbnQsIG51bGwsIHRleHQpKSA6IGNyZWF0ZVZOb2RlKENvbW1lbnQsIG51bGwsIHRleHQpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplVk5vZGUoY2hpbGQpIHtcbiAgaWYgKGNoaWxkID09IG51bGwgfHwgdHlwZW9mIGNoaWxkID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiBjcmVhdGVWTm9kZShDb21tZW50KTtcbiAgfSBlbHNlIGlmIChpc0FycmF5KGNoaWxkKSkge1xuICAgIHJldHVybiBjcmVhdGVWTm9kZShcbiAgICAgIEZyYWdtZW50LFxuICAgICAgbnVsbCxcbiAgICAgIC8vICMzNjY2LCBhdm9pZCByZWZlcmVuY2UgcG9sbHV0aW9uIHdoZW4gcmV1c2luZyB2bm9kZVxuICAgICAgY2hpbGQuc2xpY2UoKVxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNWTm9kZShjaGlsZCkpIHtcbiAgICByZXR1cm4gY2xvbmVJZk1vdW50ZWQoY2hpbGQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVWTm9kZShUZXh0LCBudWxsLCBTdHJpbmcoY2hpbGQpKTtcbiAgfVxufVxuZnVuY3Rpb24gY2xvbmVJZk1vdW50ZWQoY2hpbGQpIHtcbiAgcmV0dXJuIGNoaWxkLmVsID09PSBudWxsICYmIGNoaWxkLnBhdGNoRmxhZyAhPT0gLTEgfHwgY2hpbGQubWVtbyA/IGNoaWxkIDogY2xvbmVWTm9kZShjaGlsZCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4pIHtcbiAgbGV0IHR5cGUgPSAwO1xuICBjb25zdCB7IHNoYXBlRmxhZyB9ID0gdm5vZGU7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgdHlwZSA9IDE2O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJvYmplY3RcIikge1xuICAgIGlmIChzaGFwZUZsYWcgJiAoMSB8IDY0KSkge1xuICAgICAgY29uc3Qgc2xvdCA9IGNoaWxkcmVuLmRlZmF1bHQ7XG4gICAgICBpZiAoc2xvdCkge1xuICAgICAgICBzbG90Ll9jICYmIChzbG90Ll9kID0gZmFsc2UpO1xuICAgICAgICBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgc2xvdCgpKTtcbiAgICAgICAgc2xvdC5fYyAmJiAoc2xvdC5fZCA9IHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gMzI7XG4gICAgICBjb25zdCBzbG90RmxhZyA9IGNoaWxkcmVuLl87XG4gICAgICBpZiAoIXNsb3RGbGFnICYmICFpc0ludGVybmFsT2JqZWN0KGNoaWxkcmVuKSkge1xuICAgICAgICBjaGlsZHJlbi5fY3R4ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICAgICAgfSBlbHNlIGlmIChzbG90RmxhZyA9PT0gMyAmJiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5zbG90cy5fID09PSAxKSB7XG4gICAgICAgICAgY2hpbGRyZW4uXyA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hpbGRyZW4uXyA9IDI7XG4gICAgICAgICAgdm5vZGUucGF0Y2hGbGFnIHw9IDEwMjQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihjaGlsZHJlbikpIHtcbiAgICBjaGlsZHJlbiA9IHsgZGVmYXVsdDogY2hpbGRyZW4sIF9jdHg6IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSB9O1xuICAgIHR5cGUgPSAzMjtcbiAgfSBlbHNlIHtcbiAgICBjaGlsZHJlbiA9IFN0cmluZyhjaGlsZHJlbik7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDY0KSB7XG4gICAgICB0eXBlID0gMTY7XG4gICAgICBjaGlsZHJlbiA9IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZSA9IDg7XG4gICAgfVxuICB9XG4gIHZub2RlLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHZub2RlLnNoYXBlRmxhZyB8PSB0eXBlO1xufVxuZnVuY3Rpb24gbWVyZ2VQcm9wcyguLi5hcmdzKSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0b01lcmdlID0gYXJnc1tpXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0b01lcmdlKSB7XG4gICAgICBpZiAoa2V5ID09PSBcImNsYXNzXCIpIHtcbiAgICAgICAgaWYgKHJldC5jbGFzcyAhPT0gdG9NZXJnZS5jbGFzcykge1xuICAgICAgICAgIHJldC5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKFtyZXQuY2xhc3MsIHRvTWVyZ2UuY2xhc3NdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwic3R5bGVcIikge1xuICAgICAgICByZXQuc3R5bGUgPSBub3JtYWxpemVTdHlsZShbcmV0LnN0eWxlLCB0b01lcmdlLnN0eWxlXSk7XG4gICAgICB9IGVsc2UgaWYgKGlzT24oa2V5KSkge1xuICAgICAgICBjb25zdCBleGlzdGluZyA9IHJldFtrZXldO1xuICAgICAgICBjb25zdCBpbmNvbWluZyA9IHRvTWVyZ2Vba2V5XTtcbiAgICAgICAgaWYgKGluY29taW5nICYmIGV4aXN0aW5nICE9PSBpbmNvbWluZyAmJiAhKGlzQXJyYXkoZXhpc3RpbmcpICYmIGV4aXN0aW5nLmluY2x1ZGVzKGluY29taW5nKSkpIHtcbiAgICAgICAgICByZXRba2V5XSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBpbmNvbWluZykgOiBpbmNvbWluZztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgIT09IFwiXCIpIHtcbiAgICAgICAgcmV0W2tleV0gPSB0b01lcmdlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBpbnZva2VWTm9kZUhvb2soaG9vaywgaW5zdGFuY2UsIHZub2RlLCBwcmV2Vk5vZGUgPSBudWxsKSB7XG4gIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIGluc3RhbmNlLCA3LCBbXG4gICAgdm5vZGUsXG4gICAgcHJldlZOb2RlXG4gIF0pO1xufVxuXG5jb25zdCBlbXB0eUFwcENvbnRleHQgPSBjcmVhdGVBcHBDb250ZXh0KCk7XG5sZXQgdWlkID0gMDtcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlKHZub2RlLCBwYXJlbnQsIHN1c3BlbnNlKSB7XG4gIGNvbnN0IHR5cGUgPSB2bm9kZS50eXBlO1xuICBjb25zdCBhcHBDb250ZXh0ID0gKHBhcmVudCA/IHBhcmVudC5hcHBDb250ZXh0IDogdm5vZGUuYXBwQ29udGV4dCkgfHwgZW1wdHlBcHBDb250ZXh0O1xuICBjb25zdCBpbnN0YW5jZSA9IHtcbiAgICB1aWQ6IHVpZCsrLFxuICAgIHZub2RlLFxuICAgIHR5cGUsXG4gICAgcGFyZW50LFxuICAgIGFwcENvbnRleHQsXG4gICAgcm9vdDogbnVsbCxcbiAgICAvLyB0byBiZSBpbW1lZGlhdGVseSBzZXRcbiAgICBuZXh0OiBudWxsLFxuICAgIHN1YlRyZWU6IG51bGwsXG4gICAgLy8gd2lsbCBiZSBzZXQgc3luY2hyb25vdXNseSByaWdodCBhZnRlciBjcmVhdGlvblxuICAgIGVmZmVjdDogbnVsbCxcbiAgICB1cGRhdGU6IG51bGwsXG4gICAgLy8gd2lsbCBiZSBzZXQgc3luY2hyb25vdXNseSByaWdodCBhZnRlciBjcmVhdGlvblxuICAgIGpvYjogbnVsbCxcbiAgICBzY29wZTogbmV3IEVmZmVjdFNjb3BlKFxuICAgICAgdHJ1ZVxuICAgICAgLyogZGV0YWNoZWQgKi9cbiAgICApLFxuICAgIHJlbmRlcjogbnVsbCxcbiAgICBwcm94eTogbnVsbCxcbiAgICBleHBvc2VkOiBudWxsLFxuICAgIGV4cG9zZVByb3h5OiBudWxsLFxuICAgIHdpdGhQcm94eTogbnVsbCxcbiAgICBwcm92aWRlczogcGFyZW50ID8gcGFyZW50LnByb3ZpZGVzIDogT2JqZWN0LmNyZWF0ZShhcHBDb250ZXh0LnByb3ZpZGVzKSxcbiAgICBpZHM6IHBhcmVudCA/IHBhcmVudC5pZHMgOiBbXCJcIiwgMCwgMF0sXG4gICAgYWNjZXNzQ2FjaGU6IG51bGwsXG4gICAgcmVuZGVyQ2FjaGU6IFtdLFxuICAgIC8vIGxvY2FsIHJlc29sdmVkIGFzc2V0c1xuICAgIGNvbXBvbmVudHM6IG51bGwsXG4gICAgZGlyZWN0aXZlczogbnVsbCxcbiAgICAvLyByZXNvbHZlZCBwcm9wcyBhbmQgZW1pdHMgb3B0aW9uc1xuICAgIHByb3BzT3B0aW9uczogbm9ybWFsaXplUHJvcHNPcHRpb25zKHR5cGUsIGFwcENvbnRleHQpLFxuICAgIGVtaXRzT3B0aW9uczogbm9ybWFsaXplRW1pdHNPcHRpb25zKHR5cGUsIGFwcENvbnRleHQpLFxuICAgIC8vIGVtaXRcbiAgICBlbWl0OiBudWxsLFxuICAgIC8vIHRvIGJlIHNldCBpbW1lZGlhdGVseVxuICAgIGVtaXR0ZWQ6IG51bGwsXG4gICAgLy8gcHJvcHMgZGVmYXVsdCB2YWx1ZVxuICAgIHByb3BzRGVmYXVsdHM6IEVNUFRZX09CSixcbiAgICAvLyBpbmhlcml0QXR0cnNcbiAgICBpbmhlcml0QXR0cnM6IHR5cGUuaW5oZXJpdEF0dHJzLFxuICAgIC8vIHN0YXRlXG4gICAgY3R4OiBFTVBUWV9PQkosXG4gICAgZGF0YTogRU1QVFlfT0JKLFxuICAgIHByb3BzOiBFTVBUWV9PQkosXG4gICAgYXR0cnM6IEVNUFRZX09CSixcbiAgICBzbG90czogRU1QVFlfT0JKLFxuICAgIHJlZnM6IEVNUFRZX09CSixcbiAgICBzZXR1cFN0YXRlOiBFTVBUWV9PQkosXG4gICAgc2V0dXBDb250ZXh0OiBudWxsLFxuICAgIC8vIHN1c3BlbnNlIHJlbGF0ZWRcbiAgICBzdXNwZW5zZSxcbiAgICBzdXNwZW5zZUlkOiBzdXNwZW5zZSA/IHN1c3BlbnNlLnBlbmRpbmdJZCA6IDAsXG4gICAgYXN5bmNEZXA6IG51bGwsXG4gICAgYXN5bmNSZXNvbHZlZDogZmFsc2UsXG4gICAgLy8gbGlmZWN5Y2xlIGhvb2tzXG4gICAgLy8gbm90IHVzaW5nIGVudW1zIGhlcmUgYmVjYXVzZSBpdCByZXN1bHRzIGluIGNvbXB1dGVkIHByb3BlcnRpZXNcbiAgICBpc01vdW50ZWQ6IGZhbHNlLFxuICAgIGlzVW5tb3VudGVkOiBmYWxzZSxcbiAgICBpc0RlYWN0aXZhdGVkOiBmYWxzZSxcbiAgICBiYzogbnVsbCxcbiAgICBjOiBudWxsLFxuICAgIGJtOiBudWxsLFxuICAgIG06IG51bGwsXG4gICAgYnU6IG51bGwsXG4gICAgdTogbnVsbCxcbiAgICB1bTogbnVsbCxcbiAgICBidW06IG51bGwsXG4gICAgZGE6IG51bGwsXG4gICAgYTogbnVsbCxcbiAgICBydGc6IG51bGwsXG4gICAgcnRjOiBudWxsLFxuICAgIGVjOiBudWxsLFxuICAgIHNwOiBudWxsXG4gIH07XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgaW5zdGFuY2UuY3R4ID0gY3JlYXRlRGV2UmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XG4gIH0gZWxzZSB7XG4gICAgaW5zdGFuY2UuY3R4ID0geyBfOiBpbnN0YW5jZSB9O1xuICB9XG4gIGluc3RhbmNlLnJvb3QgPSBwYXJlbnQgPyBwYXJlbnQucm9vdCA6IGluc3RhbmNlO1xuICBpbnN0YW5jZS5lbWl0ID0gZW1pdC5iaW5kKG51bGwsIGluc3RhbmNlKTtcbiAgaWYgKHZub2RlLmNlKSB7XG4gICAgdm5vZGUuY2UoaW5zdGFuY2UpO1xuICB9XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmxldCBjdXJyZW50SW5zdGFuY2UgPSBudWxsO1xuY29uc3QgZ2V0Q3VycmVudEluc3RhbmNlID0gKCkgPT4gY3VycmVudEluc3RhbmNlIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbmxldCBpbnRlcm5hbFNldEN1cnJlbnRJbnN0YW5jZTtcbmxldCBzZXRJblNTUlNldHVwU3RhdGU7XG57XG4gIGNvbnN0IGcgPSBnZXRHbG9iYWxUaGlzKCk7XG4gIGNvbnN0IHJlZ2lzdGVyR2xvYmFsU2V0dGVyID0gKGtleSwgc2V0dGVyKSA9PiB7XG4gICAgbGV0IHNldHRlcnM7XG4gICAgaWYgKCEoc2V0dGVycyA9IGdba2V5XSkpIHNldHRlcnMgPSBnW2tleV0gPSBbXTtcbiAgICBzZXR0ZXJzLnB1c2goc2V0dGVyKTtcbiAgICByZXR1cm4gKHYpID0+IHtcbiAgICAgIGlmIChzZXR0ZXJzLmxlbmd0aCA+IDEpIHNldHRlcnMuZm9yRWFjaCgoc2V0KSA9PiBzZXQodikpO1xuICAgICAgZWxzZSBzZXR0ZXJzWzBdKHYpO1xuICAgIH07XG4gIH07XG4gIGludGVybmFsU2V0Q3VycmVudEluc3RhbmNlID0gcmVnaXN0ZXJHbG9iYWxTZXR0ZXIoXG4gICAgYF9fVlVFX0lOU1RBTkNFX1NFVFRFUlNfX2AsXG4gICAgKHYpID0+IGN1cnJlbnRJbnN0YW5jZSA9IHZcbiAgKTtcbiAgc2V0SW5TU1JTZXR1cFN0YXRlID0gcmVnaXN0ZXJHbG9iYWxTZXR0ZXIoXG4gICAgYF9fVlVFX1NTUl9TRVRURVJTX19gLFxuICAgICh2KSA9PiBpc0luU1NSQ29tcG9uZW50U2V0dXAgPSB2XG4gICk7XG59XG5jb25zdCBzZXRDdXJyZW50SW5zdGFuY2UgPSAoaW5zdGFuY2UpID0+IHtcbiAgY29uc3QgcHJldiA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgaW50ZXJuYWxTZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xuICBpbnN0YW5jZS5zY29wZS5vbigpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGluc3RhbmNlLnNjb3BlLm9mZigpO1xuICAgIGludGVybmFsU2V0Q3VycmVudEluc3RhbmNlKHByZXYpO1xuICB9O1xufTtcbmNvbnN0IHVuc2V0Q3VycmVudEluc3RhbmNlID0gKCkgPT4ge1xuICBjdXJyZW50SW5zdGFuY2UgJiYgY3VycmVudEluc3RhbmNlLnNjb3BlLm9mZigpO1xuICBpbnRlcm5hbFNldEN1cnJlbnRJbnN0YW5jZShudWxsKTtcbn07XG5jb25zdCBpc0J1aWx0SW5UYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcInNsb3QsY29tcG9uZW50XCIpO1xuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUsIHsgaXNOYXRpdmVUYWcgfSkge1xuICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGlzTmF0aXZlVGFnKG5hbWUpKSB7XG4gICAgd2FybiQxKFxuICAgICAgXCJEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50IGlkOiBcIiArIG5hbWVcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBpc1N0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlKSB7XG4gIHJldHVybiBpbnN0YW5jZS52bm9kZS5zaGFwZUZsYWcgJiA0O1xufVxubGV0IGlzSW5TU1JDb21wb25lbnRTZXR1cCA9IGZhbHNlO1xuZnVuY3Rpb24gc2V0dXBDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSID0gZmFsc2UsIG9wdGltaXplZCA9IGZhbHNlKSB7XG4gIGlzU1NSICYmIHNldEluU1NSU2V0dXBTdGF0ZShpc1NTUik7XG4gIGNvbnN0IHsgcHJvcHMsIGNoaWxkcmVuIH0gPSBpbnN0YW5jZS52bm9kZTtcbiAgY29uc3QgaXNTdGF0ZWZ1bCA9IGlzU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UpO1xuICBpbml0UHJvcHMoaW5zdGFuY2UsIHByb3BzLCBpc1N0YXRlZnVsLCBpc1NTUik7XG4gIGluaXRTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4sIG9wdGltaXplZCB8fCBpc1NTUik7XG4gIGNvbnN0IHNldHVwUmVzdWx0ID0gaXNTdGF0ZWZ1bCA/IHNldHVwU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSKSA6IHZvaWQgMDtcbiAgaXNTU1IgJiYgc2V0SW5TU1JTZXR1cFN0YXRlKGZhbHNlKTtcbiAgcmV0dXJuIHNldHVwUmVzdWx0O1xufVxuZnVuY3Rpb24gc2V0dXBTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSwgaXNTU1IpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGlmIChDb21wb25lbnQubmFtZSkge1xuICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKENvbXBvbmVudC5uYW1lLCBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZyk7XG4gICAgfVxuICAgIGlmIChDb21wb25lbnQuY29tcG9uZW50cykge1xuICAgICAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhDb21wb25lbnQuY29tcG9uZW50cyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lc1tpXSwgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoQ29tcG9uZW50LmRpcmVjdGl2ZXMpIHtcbiAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoQ29tcG9uZW50LmRpcmVjdGl2ZXMpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoQ29tcG9uZW50LmNvbXBpbGVyT3B0aW9ucyAmJiBpc1J1bnRpbWVPbmx5KCkpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYFwiY29tcGlsZXJPcHRpb25zXCIgaXMgb25seSBzdXBwb3J0ZWQgd2hlbiB1c2luZyBhIGJ1aWxkIG9mIFZ1ZSB0aGF0IGluY2x1ZGVzIHRoZSBydW50aW1lIGNvbXBpbGVyLiBTaW5jZSB5b3UgYXJlIHVzaW5nIGEgcnVudGltZS1vbmx5IGJ1aWxkLCB0aGUgb3B0aW9ucyBzaG91bGQgYmUgcGFzc2VkIHZpYSB5b3VyIGJ1aWxkIHRvb2wgY29uZmlnIGluc3RlYWQuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaW5zdGFuY2UuYWNjZXNzQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaW5zdGFuY2UucHJveHkgPSBuZXcgUHJveHkoaW5zdGFuY2UuY3R4LCBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGV4cG9zZVByb3BzT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcbiAgfVxuICBjb25zdCB7IHNldHVwIH0gPSBDb21wb25lbnQ7XG4gIGlmIChzZXR1cCkge1xuICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICBjb25zdCBzZXR1cENvbnRleHQgPSBpbnN0YW5jZS5zZXR1cENvbnRleHQgPSBzZXR1cC5sZW5ndGggPiAxID8gY3JlYXRlU2V0dXBDb250ZXh0KGluc3RhbmNlKSA6IG51bGw7XG4gICAgY29uc3QgcmVzZXQgPSBzZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgIGNvbnN0IHNldHVwUmVzdWx0ID0gY2FsbFdpdGhFcnJvckhhbmRsaW5nKFxuICAgICAgc2V0dXAsXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDAsXG4gICAgICBbXG4gICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkoaW5zdGFuY2UucHJvcHMpIDogaW5zdGFuY2UucHJvcHMsXG4gICAgICAgIHNldHVwQ29udGV4dFxuICAgICAgXVxuICAgICk7XG4gICAgY29uc3QgaXNBc3luY1NldHVwID0gaXNQcm9taXNlKHNldHVwUmVzdWx0KTtcbiAgICByZXNldFRyYWNraW5nKCk7XG4gICAgcmVzZXQoKTtcbiAgICBpZiAoKGlzQXN5bmNTZXR1cCB8fCBpbnN0YW5jZS5zcCkgJiYgIWlzQXN5bmNXcmFwcGVyKGluc3RhbmNlKSkge1xuICAgICAgbWFya0FzeW5jQm91bmRhcnkoaW5zdGFuY2UpO1xuICAgIH1cbiAgICBpZiAoaXNBc3luY1NldHVwKSB7XG4gICAgICBzZXR1cFJlc3VsdC50aGVuKHVuc2V0Q3VycmVudEluc3RhbmNlLCB1bnNldEN1cnJlbnRJbnN0YW5jZSk7XG4gICAgICBpZiAoaXNTU1IpIHtcbiAgICAgICAgcmV0dXJuIHNldHVwUmVzdWx0LnRoZW4oKHJlc29sdmVkUmVzdWx0KSA9PiB7XG4gICAgICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHJlc29sdmVkUmVzdWx0LCBpc1NTUik7XG4gICAgICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgaW5zdGFuY2UsIDApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3RhbmNlLmFzeW5jRGVwID0gc2V0dXBSZXN1bHQ7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpbnN0YW5jZS5zdXNwZW5zZSkge1xuICAgICAgICAgIGNvbnN0IG5hbWUgPSAoX2EgPSBDb21wb25lbnQubmFtZSkgIT0gbnVsbCA/IF9hIDogXCJBbm9ueW1vdXNcIjtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgQ29tcG9uZW50IDwke25hbWV9Pjogc2V0dXAgZnVuY3Rpb24gcmV0dXJuZWQgYSBwcm9taXNlLCBidXQgbm8gPFN1c3BlbnNlPiBib3VuZGFyeSB3YXMgZm91bmQgaW4gdGhlIHBhcmVudCBjb21wb25lbnQgdHJlZS4gQSBjb21wb25lbnQgd2l0aCBhc3luYyBzZXR1cCgpIG11c3QgYmUgbmVzdGVkIGluIGEgPFN1c3BlbnNlPiBpbiBvcmRlciB0byBiZSByZW5kZXJlZC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgc2V0dXBSZXN1bHQsIGlzU1NSKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHNldHVwUmVzdWx0LCBpc1NTUikge1xuICBpZiAoaXNGdW5jdGlvbihzZXR1cFJlc3VsdCkpIHtcbiAgICBpZiAoaW5zdGFuY2UudHlwZS5fX3NzcklubGluZVJlbmRlcikge1xuICAgICAgaW5zdGFuY2Uuc3NyUmVuZGVyID0gc2V0dXBSZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlLnJlbmRlciA9IHNldHVwUmVzdWx0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChzZXR1cFJlc3VsdCkpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc1ZOb2RlKHNldHVwUmVzdWx0KSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgc2V0dXAoKSBzaG91bGQgbm90IHJldHVybiBWTm9kZXMgZGlyZWN0bHkgLSByZXR1cm4gYSByZW5kZXIgZnVuY3Rpb24gaW5zdGVhZC5gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGluc3RhbmNlLmRldnRvb2xzUmF3U2V0dXBTdGF0ZSA9IHNldHVwUmVzdWx0O1xuICAgIH1cbiAgICBpbnN0YW5jZS5zZXR1cFN0YXRlID0gcHJveHlSZWZzKHNldHVwUmVzdWx0KTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgZXhwb3NlU2V0dXBTdGF0ZU9uUmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2V0dXBSZXN1bHQgIT09IHZvaWQgMCkge1xuICAgIHdhcm4kMShcbiAgICAgIGBzZXR1cCgpIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LiBSZWNlaXZlZDogJHtzZXR1cFJlc3VsdCA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIHNldHVwUmVzdWx0fWBcbiAgICApO1xuICB9XG4gIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUik7XG59XG5sZXQgY29tcGlsZTtcbmxldCBpbnN0YWxsV2l0aFByb3h5O1xuZnVuY3Rpb24gcmVnaXN0ZXJSdW50aW1lQ29tcGlsZXIoX2NvbXBpbGUpIHtcbiAgY29tcGlsZSA9IF9jb21waWxlO1xuICBpbnN0YWxsV2l0aFByb3h5ID0gKGkpID0+IHtcbiAgICBpZiAoaS5yZW5kZXIuX3JjKSB7XG4gICAgICBpLndpdGhQcm94eSA9IG5ldyBQcm94eShpLmN0eCwgUnVudGltZUNvbXBpbGVkUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzKTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBpc1J1bnRpbWVPbmx5ID0gKCkgPT4gIWNvbXBpbGU7XG5mdW5jdGlvbiBmaW5pc2hDb21wb25lbnRTZXR1cChpbnN0YW5jZSwgaXNTU1IsIHNraXBPcHRpb25zKSB7XG4gIGNvbnN0IENvbXBvbmVudCA9IGluc3RhbmNlLnR5cGU7XG4gIGlmICghaW5zdGFuY2UucmVuZGVyKSB7XG4gICAgaWYgKCFpc1NTUiAmJiBjb21waWxlICYmICFDb21wb25lbnQucmVuZGVyKSB7XG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IENvbXBvbmVudC50ZW1wbGF0ZSB8fCBfX1ZVRV9PUFRJT05TX0FQSV9fICYmIHJlc29sdmVNZXJnZWRPcHRpb25zKGluc3RhbmNlKS50ZW1wbGF0ZTtcbiAgICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYGNvbXBpbGVgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGlzQ3VzdG9tRWxlbWVudCwgY29tcGlsZXJPcHRpb25zIH0gPSBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZztcbiAgICAgICAgY29uc3QgeyBkZWxpbWl0ZXJzLCBjb21waWxlck9wdGlvbnM6IGNvbXBvbmVudENvbXBpbGVyT3B0aW9ucyB9ID0gQ29tcG9uZW50O1xuICAgICAgICBjb25zdCBmaW5hbENvbXBpbGVyT3B0aW9ucyA9IGV4dGVuZChcbiAgICAgICAgICBleHRlbmQoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlzQ3VzdG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgZGVsaW1pdGVyc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBpbGVyT3B0aW9uc1xuICAgICAgICAgICksXG4gICAgICAgICAgY29tcG9uZW50Q29tcGlsZXJPcHRpb25zXG4gICAgICAgICk7XG4gICAgICAgIENvbXBvbmVudC5yZW5kZXIgPSBjb21waWxlKHRlbXBsYXRlLCBmaW5hbENvbXBpbGVyT3B0aW9ucyk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGNvbXBpbGVgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpbnN0YW5jZS5yZW5kZXIgPSBDb21wb25lbnQucmVuZGVyIHx8IE5PT1A7XG4gICAgaWYgKGluc3RhbGxXaXRoUHJveHkpIHtcbiAgICAgIGluc3RhbGxXaXRoUHJveHkoaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiB0cnVlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBzZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICB0cnkge1xuICAgICAgYXBwbHlPcHRpb25zKGluc3RhbmNlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgcmVzZXRUcmFja2luZygpO1xuICAgICAgcmVzZXQoKTtcbiAgICB9XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIUNvbXBvbmVudC5yZW5kZXIgJiYgaW5zdGFuY2UucmVuZGVyID09PSBOT09QICYmICFpc1NTUikge1xuICAgIGlmICghY29tcGlsZSAmJiBDb21wb25lbnQudGVtcGxhdGUpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYENvbXBvbmVudCBwcm92aWRlZCB0ZW1wbGF0ZSBvcHRpb24gYnV0IHJ1bnRpbWUgY29tcGlsYXRpb24gaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJ1aWxkIG9mIFZ1ZS5gICsgKGAgQ29uZmlndXJlIHlvdXIgYnVuZGxlciB0byBhbGlhcyBcInZ1ZVwiIHRvIFwidnVlL2Rpc3QvdnVlLmVzbS1idW5kbGVyLmpzXCIuYCApXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuJDEoYENvbXBvbmVudCBpcyBtaXNzaW5nIHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbjogYCwgQ29tcG9uZW50KTtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IGF0dHJzUHJveHlIYW5kbGVycyA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyB7XG4gIGdldCh0YXJnZXQsIGtleSkge1xuICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XG4gICAgdHJhY2sodGFyZ2V0LCBcImdldFwiLCBcIlwiKTtcbiAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gIH0sXG4gIHNldCgpIHtcbiAgICB3YXJuJDEoYHNldHVwQ29udGV4dC5hdHRycyBpcyByZWFkb25seS5gKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIGRlbGV0ZVByb3BlcnR5KCkge1xuICAgIHdhcm4kMShgc2V0dXBDb250ZXh0LmF0dHJzIGlzIHJlYWRvbmx5LmApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSA6IHtcbiAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgdHJhY2sodGFyZ2V0LCBcImdldFwiLCBcIlwiKTtcbiAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gIH1cbn07XG5mdW5jdGlvbiBnZXRTbG90c1Byb3h5KGluc3RhbmNlKSB7XG4gIHJldHVybiBuZXcgUHJveHkoaW5zdGFuY2Uuc2xvdHMsIHtcbiAgICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHRyYWNrKGluc3RhbmNlLCBcImdldFwiLCBcIiRzbG90c1wiKTtcbiAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlU2V0dXBDb250ZXh0KGluc3RhbmNlKSB7XG4gIGNvbnN0IGV4cG9zZSA9IChleHBvc2VkKSA9PiB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGlmIChpbnN0YW5jZS5leHBvc2VkKSB7XG4gICAgICAgIHdhcm4kMShgZXhwb3NlKCkgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IG9uY2UgcGVyIHNldHVwKCkuYCk7XG4gICAgICB9XG4gICAgICBpZiAoZXhwb3NlZCAhPSBudWxsKSB7XG4gICAgICAgIGxldCBleHBvc2VkVHlwZSA9IHR5cGVvZiBleHBvc2VkO1xuICAgICAgICBpZiAoZXhwb3NlZFR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShleHBvc2VkKSkge1xuICAgICAgICAgICAgZXhwb3NlZFR5cGUgPSBcImFycmF5XCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1JlZihleHBvc2VkKSkge1xuICAgICAgICAgICAgZXhwb3NlZFR5cGUgPSBcInJlZlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwb3NlZFR5cGUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgZXhwb3NlKCkgc2hvdWxkIGJlIHBhc3NlZCBhIHBsYWluIG9iamVjdCwgcmVjZWl2ZWQgJHtleHBvc2VkVHlwZX0uYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaW5zdGFuY2UuZXhwb3NlZCA9IGV4cG9zZWQgfHwge307XG4gIH07XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgbGV0IGF0dHJzUHJveHk7XG4gICAgbGV0IHNsb3RzUHJveHk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgZ2V0IGF0dHJzKCkge1xuICAgICAgICByZXR1cm4gYXR0cnNQcm94eSB8fCAoYXR0cnNQcm94eSA9IG5ldyBQcm94eShpbnN0YW5jZS5hdHRycywgYXR0cnNQcm94eUhhbmRsZXJzKSk7XG4gICAgICB9LFxuICAgICAgZ2V0IHNsb3RzKCkge1xuICAgICAgICByZXR1cm4gc2xvdHNQcm94eSB8fCAoc2xvdHNQcm94eSA9IGdldFNsb3RzUHJveHkoaW5zdGFuY2UpKTtcbiAgICAgIH0sXG4gICAgICBnZXQgZW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIChldmVudCwgLi4uYXJncykgPT4gaW5zdGFuY2UuZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgICB9LFxuICAgICAgZXhwb3NlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGF0dHJzOiBuZXcgUHJveHkoaW5zdGFuY2UuYXR0cnMsIGF0dHJzUHJveHlIYW5kbGVycyksXG4gICAgICBzbG90czogaW5zdGFuY2Uuc2xvdHMsXG4gICAgICBlbWl0OiBpbnN0YW5jZS5lbWl0LFxuICAgICAgZXhwb3NlXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50UHVibGljSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgaWYgKGluc3RhbmNlLmV4cG9zZWQpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuZXhwb3NlUHJveHkgfHwgKGluc3RhbmNlLmV4cG9zZVByb3h5ID0gbmV3IFByb3h5KHByb3h5UmVmcyhtYXJrUmF3KGluc3RhbmNlLmV4cG9zZWQpKSwge1xuICAgICAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSBpbiBwdWJsaWNQcm9wZXJ0aWVzTWFwKSB7XG4gICAgICAgICAgcmV0dXJuIHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XShpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBoYXModGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSBpbiB0YXJnZXQgfHwga2V5IGluIHB1YmxpY1Byb3BlcnRpZXNNYXA7XG4gICAgICB9XG4gICAgfSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpbnN0YW5jZS5wcm94eTtcbiAgfVxufVxuY29uc3QgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbmNvbnN0IGNsYXNzaWZ5ID0gKHN0cikgPT4gc3RyLnJlcGxhY2UoY2xhc3NpZnlSRSwgKGMpID0+IGMudG9VcHBlckNhc2UoKSkucmVwbGFjZSgvWy1fXS9nLCBcIlwiKTtcbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50LCBpbmNsdWRlSW5mZXJyZWQgPSB0cnVlKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKENvbXBvbmVudCkgPyBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgOiBDb21wb25lbnQubmFtZSB8fCBpbmNsdWRlSW5mZXJyZWQgJiYgQ29tcG9uZW50Ll9fbmFtZTtcbn1cbmZ1bmN0aW9uIGZvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIENvbXBvbmVudCwgaXNSb290ID0gZmFsc2UpIHtcbiAgbGV0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCk7XG4gIGlmICghbmFtZSAmJiBDb21wb25lbnQuX19maWxlKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBDb21wb25lbnQuX19maWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLlxcdyskLyk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBuYW1lID0gbWF0Y2hbMV07XG4gICAgfVxuICB9XG4gIGlmICghbmFtZSAmJiBpbnN0YW5jZSAmJiBpbnN0YW5jZS5wYXJlbnQpIHtcbiAgICBjb25zdCBpbmZlckZyb21SZWdpc3RyeSA9IChyZWdpc3RyeSkgPT4ge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVnaXN0cnkpIHtcbiAgICAgICAgaWYgKHJlZ2lzdHJ5W2tleV0gPT09IENvbXBvbmVudCkge1xuICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIG5hbWUgPSBpbmZlckZyb21SZWdpc3RyeShcbiAgICAgIGluc3RhbmNlLmNvbXBvbmVudHMgfHwgaW5zdGFuY2UucGFyZW50LnR5cGUuY29tcG9uZW50c1xuICAgICkgfHwgaW5mZXJGcm9tUmVnaXN0cnkoaW5zdGFuY2UuYXBwQ29udGV4dC5jb21wb25lbnRzKTtcbiAgfVxuICByZXR1cm4gbmFtZSA/IGNsYXNzaWZ5KG5hbWUpIDogaXNSb290ID8gYEFwcGAgOiBgQW5vbnltb3VzYDtcbn1cbmZ1bmN0aW9uIGlzQ2xhc3NDb21wb25lbnQodmFsdWUpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24odmFsdWUpICYmIFwiX192Y2NPcHRzXCIgaW4gdmFsdWU7XG59XG5cbmNvbnN0IGNvbXB1dGVkID0gKGdldHRlck9yT3B0aW9ucywgZGVidWdPcHRpb25zKSA9PiB7XG4gIGNvbnN0IGMgPSBjb21wdXRlZCQxKGdldHRlck9yT3B0aW9ucywgZGVidWdPcHRpb25zLCBpc0luU1NSQ29tcG9uZW50U2V0dXApO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IGkgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICBpZiAoaSAmJiBpLmFwcENvbnRleHQuY29uZmlnLndhcm5SZWN1cnNpdmVDb21wdXRlZCkge1xuICAgICAgYy5fd2FyblJlY3Vyc2l2ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBjO1xufTtcblxuZnVuY3Rpb24gaCh0eXBlLCBwcm9wc09yQ2hpbGRyZW4sIGNoaWxkcmVuKSB7XG4gIGNvbnN0IGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICBpZiAobCA9PT0gMikge1xuICAgIGlmIChpc09iamVjdChwcm9wc09yQ2hpbGRyZW4pICYmICFpc0FycmF5KHByb3BzT3JDaGlsZHJlbikpIHtcbiAgICAgIGlmIChpc1ZOb2RlKHByb3BzT3JDaGlsZHJlbikpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIG51bGwsIFtwcm9wc09yQ2hpbGRyZW5dKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wc09yQ2hpbGRyZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgbnVsbCwgcHJvcHNPckNoaWxkcmVuKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGwgPiAzKSB7XG4gICAgICBjaGlsZHJlbiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgfSBlbHNlIGlmIChsID09PSAzICYmIGlzVk5vZGUoY2hpbGRyZW4pKSB7XG4gICAgICBjaGlsZHJlbiA9IFtjaGlsZHJlbl07XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wc09yQ2hpbGRyZW4sIGNoaWxkcmVuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q3VzdG9tRm9ybWF0dGVyKCkge1xuICBpZiAoISEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB2dWVTdHlsZSA9IHsgc3R5bGU6IFwiY29sb3I6IzNiYTc3NlwiIH07XG4gIGNvbnN0IG51bWJlclN0eWxlID0geyBzdHlsZTogXCJjb2xvcjojMTY3N2ZmXCIgfTtcbiAgY29uc3Qgc3RyaW5nU3R5bGUgPSB7IHN0eWxlOiBcImNvbG9yOiNmNTIyMmRcIiB9O1xuICBjb25zdCBrZXl3b3JkU3R5bGUgPSB7IHN0eWxlOiBcImNvbG9yOiNlYjJmOTZcIiB9O1xuICBjb25zdCBmb3JtYXR0ZXIgPSB7XG4gICAgX192dWVfY3VzdG9tX2Zvcm1hdHRlcjogdHJ1ZSxcbiAgICBoZWFkZXIob2JqKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAob2JqLl9faXNWdWUpIHtcbiAgICAgICAgcmV0dXJuIFtcImRpdlwiLCB2dWVTdHlsZSwgYFZ1ZUluc3RhbmNlYF07XG4gICAgICB9IGVsc2UgaWYgKGlzUmVmKG9iaikpIHtcbiAgICAgICAgcGF1c2VUcmFja2luZygpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG9iai52YWx1ZTtcbiAgICAgICAgcmVzZXRUcmFja2luZygpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge30sXG4gICAgICAgICAgW1wic3BhblwiLCB2dWVTdHlsZSwgZ2VuUmVmRmxhZyhvYmopXSxcbiAgICAgICAgICBcIjxcIixcbiAgICAgICAgICBmb3JtYXRWYWx1ZSh2YWx1ZSksXG4gICAgICAgICAgYD5gXG4gICAgICAgIF07XG4gICAgICB9IGVsc2UgaWYgKGlzUmVhY3RpdmUob2JqKSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge30sXG4gICAgICAgICAgW1wic3BhblwiLCB2dWVTdHlsZSwgaXNTaGFsbG93KG9iaikgPyBcIlNoYWxsb3dSZWFjdGl2ZVwiIDogXCJSZWFjdGl2ZVwiXSxcbiAgICAgICAgICBcIjxcIixcbiAgICAgICAgICBmb3JtYXRWYWx1ZShvYmopLFxuICAgICAgICAgIGA+JHtpc1JlYWRvbmx5KG9iaikgPyBgIChyZWFkb25seSlgIDogYGB9YFxuICAgICAgICBdO1xuICAgICAgfSBlbHNlIGlmIChpc1JlYWRvbmx5KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIFtcInNwYW5cIiwgdnVlU3R5bGUsIGlzU2hhbGxvdyhvYmopID8gXCJTaGFsbG93UmVhZG9ubHlcIiA6IFwiUmVhZG9ubHlcIl0sXG4gICAgICAgICAgXCI8XCIsXG4gICAgICAgICAgZm9ybWF0VmFsdWUob2JqKSxcbiAgICAgICAgICBcIj5cIlxuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBoYXNCb2R5KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19pc1Z1ZTtcbiAgICB9LFxuICAgIGJvZHkob2JqKSB7XG4gICAgICBpZiAob2JqICYmIG9iai5fX2lzVnVlKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7fSxcbiAgICAgICAgICAuLi5mb3JtYXRJbnN0YW5jZShvYmouJClcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGZvcm1hdEluc3RhbmNlKGluc3RhbmNlKSB7XG4gICAgY29uc3QgYmxvY2tzID0gW107XG4gICAgaWYgKGluc3RhbmNlLnR5cGUucHJvcHMgJiYgaW5zdGFuY2UucHJvcHMpIHtcbiAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soXCJwcm9wc1wiLCB0b1JhdyhpbnN0YW5jZS5wcm9wcykpKTtcbiAgICB9XG4gICAgaWYgKGluc3RhbmNlLnNldHVwU3RhdGUgIT09IEVNUFRZX09CSikge1xuICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jayhcInNldHVwXCIsIGluc3RhbmNlLnNldHVwU3RhdGUpKTtcbiAgICB9XG4gICAgaWYgKGluc3RhbmNlLmRhdGEgIT09IEVNUFRZX09CSikge1xuICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jayhcImRhdGFcIiwgdG9SYXcoaW5zdGFuY2UuZGF0YSkpKTtcbiAgICB9XG4gICAgY29uc3QgY29tcHV0ZWQgPSBleHRyYWN0S2V5cyhpbnN0YW5jZSwgXCJjb21wdXRlZFwiKTtcbiAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soXCJjb21wdXRlZFwiLCBjb21wdXRlZCkpO1xuICAgIH1cbiAgICBjb25zdCBpbmplY3RlZCA9IGV4dHJhY3RLZXlzKGluc3RhbmNlLCBcImluamVjdFwiKTtcbiAgICBpZiAoaW5qZWN0ZWQpIHtcbiAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soXCJpbmplY3RlZFwiLCBpbmplY3RlZCkpO1xuICAgIH1cbiAgICBibG9ja3MucHVzaChbXG4gICAgICBcImRpdlwiLFxuICAgICAge30sXG4gICAgICBbXG4gICAgICAgIFwic3BhblwiLFxuICAgICAgICB7XG4gICAgICAgICAgc3R5bGU6IGtleXdvcmRTdHlsZS5zdHlsZSArIFwiO29wYWNpdHk6MC42NlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiJCAoaW50ZXJuYWwpOiBcIlxuICAgICAgXSxcbiAgICAgIFtcIm9iamVjdFwiLCB7IG9iamVjdDogaW5zdGFuY2UgfV1cbiAgICBdKTtcbiAgICByZXR1cm4gYmxvY2tzO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlQmxvY2sodHlwZSwgdGFyZ2V0KSB7XG4gICAgdGFyZ2V0ID0gZXh0ZW5kKHt9LCB0YXJnZXQpO1xuICAgIGlmICghT2JqZWN0LmtleXModGFyZ2V0KS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIHt9XTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7IHN0eWxlOiBcImxpbmUtaGVpZ2h0OjEuMjVlbTttYXJnaW4tYm90dG9tOjAuNmVtXCIgfSxcbiAgICAgIFtcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIHN0eWxlOiBcImNvbG9yOiM0NzY1ODJcIlxuICAgICAgICB9LFxuICAgICAgICB0eXBlXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7XG4gICAgICAgICAgc3R5bGU6IFwicGFkZGluZy1sZWZ0OjEuMjVlbVwiXG4gICAgICAgIH0sXG4gICAgICAgIC4uLk9iamVjdC5rZXlzKHRhcmdldCkubWFwKChrZXkpID0+IHtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgW1wic3BhblwiLCBrZXl3b3JkU3R5bGUsIGtleSArIFwiOiBcIl0sXG4gICAgICAgICAgICBmb3JtYXRWYWx1ZSh0YXJnZXRba2V5XSwgZmFsc2UpXG4gICAgICAgICAgXTtcbiAgICAgICAgfSlcbiAgICAgIF1cbiAgICBdO1xuICB9XG4gIGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHYsIGFzUmF3ID0gdHJ1ZSkge1xuICAgIGlmICh0eXBlb2YgdiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIFtcInNwYW5cIiwgbnVtYmVyU3R5bGUsIHZdO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIHN0cmluZ1N0eWxlLCBKU09OLnN0cmluZ2lmeSh2KV07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIGtleXdvcmRTdHlsZSwgdl07XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2KSkge1xuICAgICAgcmV0dXJuIFtcIm9iamVjdFwiLCB7IG9iamVjdDogYXNSYXcgPyB0b1Jhdyh2KSA6IHYgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIHN0cmluZ1N0eWxlLCBTdHJpbmcodildO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBleHRyYWN0S2V5cyhpbnN0YW5jZSwgdHlwZSkge1xuICAgIGNvbnN0IENvbXAgPSBpbnN0YW5jZS50eXBlO1xuICAgIGlmIChpc0Z1bmN0aW9uKENvbXApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGV4dHJhY3RlZCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGluc3RhbmNlLmN0eCkge1xuICAgICAgaWYgKGlzS2V5T2ZUeXBlKENvbXAsIGtleSwgdHlwZSkpIHtcbiAgICAgICAgZXh0cmFjdGVkW2tleV0gPSBpbnN0YW5jZS5jdHhba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4dHJhY3RlZDtcbiAgfVxuICBmdW5jdGlvbiBpc0tleU9mVHlwZShDb21wLCBrZXksIHR5cGUpIHtcbiAgICBjb25zdCBvcHRzID0gQ29tcFt0eXBlXTtcbiAgICBpZiAoaXNBcnJheShvcHRzKSAmJiBvcHRzLmluY2x1ZGVzKGtleSkgfHwgaXNPYmplY3Qob3B0cykgJiYga2V5IGluIG9wdHMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoQ29tcC5leHRlbmRzICYmIGlzS2V5T2ZUeXBlKENvbXAuZXh0ZW5kcywga2V5LCB0eXBlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChDb21wLm1peGlucyAmJiBDb21wLm1peGlucy5zb21lKChtKSA9PiBpc0tleU9mVHlwZShtLCBrZXksIHR5cGUpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdlblJlZkZsYWcodikge1xuICAgIGlmIChpc1NoYWxsb3codikpIHtcbiAgICAgIHJldHVybiBgU2hhbGxvd1JlZmA7XG4gICAgfVxuICAgIGlmICh2LmVmZmVjdCkge1xuICAgICAgcmV0dXJuIGBDb21wdXRlZFJlZmA7XG4gICAgfVxuICAgIHJldHVybiBgUmVmYDtcbiAgfVxuICBpZiAod2luZG93LmRldnRvb2xzRm9ybWF0dGVycykge1xuICAgIHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMucHVzaChmb3JtYXR0ZXIpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMgPSBbZm9ybWF0dGVyXTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3aXRoTWVtbyhtZW1vLCByZW5kZXIsIGNhY2hlLCBpbmRleCkge1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZVtpbmRleF07XG4gIGlmIChjYWNoZWQgJiYgaXNNZW1vU2FtZShjYWNoZWQsIG1lbW8pKSB7XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfVxuICBjb25zdCByZXQgPSByZW5kZXIoKTtcbiAgcmV0Lm1lbW8gPSBtZW1vLnNsaWNlKCk7XG4gIHJldC5jYWNoZUluZGV4ID0gaW5kZXg7XG4gIHJldHVybiBjYWNoZVtpbmRleF0gPSByZXQ7XG59XG5mdW5jdGlvbiBpc01lbW9TYW1lKGNhY2hlZCwgbWVtbykge1xuICBjb25zdCBwcmV2ID0gY2FjaGVkLm1lbW87XG4gIGlmIChwcmV2Lmxlbmd0aCAhPSBtZW1vLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXYubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaGFzQ2hhbmdlZChwcmV2W2ldLCBtZW1vW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiBjdXJyZW50QmxvY2spIHtcbiAgICBjdXJyZW50QmxvY2sucHVzaChjYWNoZWQpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5jb25zdCB2ZXJzaW9uID0gXCIzLjUuMTZcIjtcbmNvbnN0IHdhcm4gPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gd2FybiQxIDogTk9PUDtcbmNvbnN0IEVycm9yVHlwZVN0cmluZ3MgPSBFcnJvclR5cGVTdHJpbmdzJDEgO1xuY29uc3QgZGV2dG9vbHMgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IHRydWUgPyBkZXZ0b29scyQxIDogdm9pZCAwO1xuY29uc3Qgc2V0RGV2dG9vbHNIb29rID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCB0cnVlID8gc2V0RGV2dG9vbHNIb29rJDEgOiBOT09QO1xuY29uc3QgX3NzclV0aWxzID0ge1xuICBjcmVhdGVDb21wb25lbnRJbnN0YW5jZSxcbiAgc2V0dXBDb21wb25lbnQsXG4gIHJlbmRlckNvbXBvbmVudFJvb3QsXG4gIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSxcbiAgaXNWTm9kZTogaXNWTm9kZSxcbiAgbm9ybWFsaXplVk5vZGUsXG4gIGdldENvbXBvbmVudFB1YmxpY0luc3RhbmNlLFxuICBlbnN1cmVWYWxpZFZOb2RlLFxuICBwdXNoV2FybmluZ0NvbnRleHQsXG4gIHBvcFdhcm5pbmdDb250ZXh0XG59O1xuY29uc3Qgc3NyVXRpbHMgPSBfc3NyVXRpbHMgO1xuY29uc3QgcmVzb2x2ZUZpbHRlciA9IG51bGw7XG5jb25zdCBjb21wYXRVdGlscyA9IG51bGw7XG5jb25zdCBEZXByZWNhdGlvblR5cGVzID0gbnVsbDtcblxuZXhwb3J0IHsgQmFzZVRyYW5zaXRpb24sIEJhc2VUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLCBDb21tZW50LCBEZXByZWNhdGlvblR5cGVzLCBFcnJvckNvZGVzLCBFcnJvclR5cGVTdHJpbmdzLCBGcmFnbWVudCwgS2VlcEFsaXZlLCBTdGF0aWMsIFN1c3BlbnNlLCBUZWxlcG9ydCwgVGV4dCwgYXNzZXJ0TnVtYmVyLCBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZywgY2FsbFdpdGhFcnJvckhhbmRsaW5nLCBjbG9uZVZOb2RlLCBjb21wYXRVdGlscywgY29tcHV0ZWQsIGNyZWF0ZUJsb2NrLCBjcmVhdGVDb21tZW50Vk5vZGUsIGNyZWF0ZUVsZW1lbnRCbG9jaywgY3JlYXRlQmFzZVZOb2RlIGFzIGNyZWF0ZUVsZW1lbnRWTm9kZSwgY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIsIGNyZWF0ZVByb3BzUmVzdFByb3h5LCBjcmVhdGVSZW5kZXJlciwgY3JlYXRlU2xvdHMsIGNyZWF0ZVN0YXRpY1ZOb2RlLCBjcmVhdGVUZXh0Vk5vZGUsIGNyZWF0ZVZOb2RlLCBkZWZpbmVBc3luY0NvbXBvbmVudCwgZGVmaW5lQ29tcG9uZW50LCBkZWZpbmVFbWl0cywgZGVmaW5lRXhwb3NlLCBkZWZpbmVNb2RlbCwgZGVmaW5lT3B0aW9ucywgZGVmaW5lUHJvcHMsIGRlZmluZVNsb3RzLCBkZXZ0b29scywgZ2V0Q3VycmVudEluc3RhbmNlLCBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4sIGd1YXJkUmVhY3RpdmVQcm9wcywgaCwgaGFuZGxlRXJyb3IsIGhhc0luamVjdGlvbkNvbnRleHQsIGh5ZHJhdGVPbklkbGUsIGh5ZHJhdGVPbkludGVyYWN0aW9uLCBoeWRyYXRlT25NZWRpYVF1ZXJ5LCBoeWRyYXRlT25WaXNpYmxlLCBpbml0Q3VzdG9tRm9ybWF0dGVyLCBpbmplY3QsIGlzTWVtb1NhbWUsIGlzUnVudGltZU9ubHksIGlzVk5vZGUsIG1lcmdlRGVmYXVsdHMsIG1lcmdlTW9kZWxzLCBtZXJnZVByb3BzLCBuZXh0VGljaywgb25BY3RpdmF0ZWQsIG9uQmVmb3JlTW91bnQsIG9uQmVmb3JlVW5tb3VudCwgb25CZWZvcmVVcGRhdGUsIG9uRGVhY3RpdmF0ZWQsIG9uRXJyb3JDYXB0dXJlZCwgb25Nb3VudGVkLCBvblJlbmRlclRyYWNrZWQsIG9uUmVuZGVyVHJpZ2dlcmVkLCBvblNlcnZlclByZWZldGNoLCBvblVubW91bnRlZCwgb25VcGRhdGVkLCBvcGVuQmxvY2ssIHBvcFNjb3BlSWQsIHByb3ZpZGUsIHB1c2hTY29wZUlkLCBxdWV1ZVBvc3RGbHVzaENiLCByZWdpc3RlclJ1bnRpbWVDb21waWxlciwgcmVuZGVyTGlzdCwgcmVuZGVyU2xvdCwgcmVzb2x2ZUNvbXBvbmVudCwgcmVzb2x2ZURpcmVjdGl2ZSwgcmVzb2x2ZUR5bmFtaWNDb21wb25lbnQsIHJlc29sdmVGaWx0ZXIsIHJlc29sdmVUcmFuc2l0aW9uSG9va3MsIHNldEJsb2NrVHJhY2tpbmcsIHNldERldnRvb2xzSG9vaywgc2V0VHJhbnNpdGlvbkhvb2tzLCBzc3JDb250ZXh0S2V5LCBzc3JVdGlscywgdG9IYW5kbGVycywgdHJhbnNmb3JtVk5vZGVBcmdzLCB1c2VBdHRycywgdXNlSWQsIHVzZU1vZGVsLCB1c2VTU1JDb250ZXh0LCB1c2VTbG90cywgdXNlVGVtcGxhdGVSZWYsIHVzZVRyYW5zaXRpb25TdGF0ZSwgdmVyc2lvbiwgd2Fybiwgd2F0Y2gsIHdhdGNoRWZmZWN0LCB3YXRjaFBvc3RFZmZlY3QsIHdhdGNoU3luY0VmZmVjdCwgd2l0aEFzeW5jQ29udGV4dCwgd2l0aEN0eCwgd2l0aERlZmF1bHRzLCB3aXRoRGlyZWN0aXZlcywgd2l0aE1lbW8sIHdpdGhTY29wZUlkIH07XG4iLCIvKipcbiogQHZ1ZS9yZWFjdGl2aXR5IHYzLjUuMTZcbiogKGMpIDIwMTgtcHJlc2VudCBZdXhpIChFdmFuKSBZb3UgYW5kIFZ1ZSBjb250cmlidXRvcnNcbiogQGxpY2Vuc2UgTUlUXG4qKi9cbmltcG9ydCB7IGV4dGVuZCwgaGFzQ2hhbmdlZCwgaXNBcnJheSwgaXNJbnRlZ2VyS2V5LCBpc1N5bWJvbCwgaXNNYXAsIGhhc093biwgbWFrZU1hcCwgaXNPYmplY3QsIGNhcGl0YWxpemUsIHRvUmF3VHlwZSwgZGVmLCBpc0Z1bmN0aW9uLCBFTVBUWV9PQkosIGlzU2V0LCBpc1BsYWluT2JqZWN0LCByZW1vdmUsIE5PT1AgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmZ1bmN0aW9uIHdhcm4obXNnLCAuLi5hcmdzKSB7XG4gIGNvbnNvbGUud2FybihgW1Z1ZSB3YXJuXSAke21zZ31gLCAuLi5hcmdzKTtcbn1cblxubGV0IGFjdGl2ZUVmZmVjdFNjb3BlO1xuY2xhc3MgRWZmZWN0U2NvcGUge1xuICBjb25zdHJ1Y3RvcihkZXRhY2hlZCA9IGZhbHNlKSB7XG4gICAgdGhpcy5kZXRhY2hlZCA9IGRldGFjaGVkO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsIHRyYWNrIGBvbmAgY2FsbHMsIGFsbG93IGBvbmAgY2FsbCBtdWx0aXBsZSB0aW1lc1xuICAgICAqL1xuICAgIHRoaXMuX29uID0gMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmVmZmVjdHMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmNsZWFudXBzID0gW107XG4gICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLnBhcmVudCA9IGFjdGl2ZUVmZmVjdFNjb3BlO1xuICAgIGlmICghZGV0YWNoZWQgJiYgYWN0aXZlRWZmZWN0U2NvcGUpIHtcbiAgICAgIHRoaXMuaW5kZXggPSAoYWN0aXZlRWZmZWN0U2NvcGUuc2NvcGVzIHx8IChhY3RpdmVFZmZlY3RTY29wZS5zY29wZXMgPSBbXSkpLnB1c2goXG4gICAgICAgIHRoaXNcbiAgICAgICkgLSAxO1xuICAgIH1cbiAgfVxuICBnZXQgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gIH1cbiAgcGF1c2UoKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5faXNQYXVzZWQgPSB0cnVlO1xuICAgICAgbGV0IGksIGw7XG4gICAgICBpZiAodGhpcy5zY29wZXMpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuc2NvcGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHRoaXMuc2NvcGVzW2ldLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmVmZmVjdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZWZmZWN0c1tpXS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVzdW1lcyB0aGUgZWZmZWN0IHNjb3BlLCBpbmNsdWRpbmcgYWxsIGNoaWxkIHNjb3BlcyBhbmQgZWZmZWN0cy5cbiAgICovXG4gIHJlc3VtZSgpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICBpZiAodGhpcy5faXNQYXVzZWQpIHtcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGksIGw7XG4gICAgICAgIGlmICh0aGlzLnNjb3Blcykge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLnNjb3Blcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuc2NvcGVzW2ldLnJlc3VtZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5lZmZlY3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHRoaXMuZWZmZWN0c1tpXS5yZXN1bWUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBydW4oZm4pIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICBjb25zdCBjdXJyZW50RWZmZWN0U2NvcGUgPSBhY3RpdmVFZmZlY3RTY29wZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IGN1cnJlbnRFZmZlY3RTY29wZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oYGNhbm5vdCBydW4gYW4gaW5hY3RpdmUgZWZmZWN0IHNjb3BlLmApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gbm9uLWRldGFjaGVkIHNjb3Blc1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG9uKCkge1xuICAgIGlmICgrK3RoaXMuX29uID09PSAxKSB7XG4gICAgICB0aGlzLnByZXZTY29wZSA9IGFjdGl2ZUVmZmVjdFNjb3BlO1xuICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gbm9uLWRldGFjaGVkIHNjb3Blc1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG9mZigpIHtcbiAgICBpZiAodGhpcy5fb24gPiAwICYmIC0tdGhpcy5fb24gPT09IDApIHtcbiAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcy5wcmV2U2NvcGU7XG4gICAgICB0aGlzLnByZXZTY29wZSA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgc3RvcChmcm9tUGFyZW50KSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgICBsZXQgaSwgbDtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmVmZmVjdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZWZmZWN0c1tpXS5zdG9wKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmVmZmVjdHMubGVuZ3RoID0gMDtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNsZWFudXBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmNsZWFudXBzW2ldKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNsZWFudXBzLmxlbmd0aCA9IDA7XG4gICAgICBpZiAodGhpcy5zY29wZXMpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuc2NvcGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHRoaXMuc2NvcGVzW2ldLnN0b3AodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY29wZXMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5kZXRhY2hlZCAmJiB0aGlzLnBhcmVudCAmJiAhZnJvbVBhcmVudCkge1xuICAgICAgICBjb25zdCBsYXN0ID0gdGhpcy5wYXJlbnQuc2NvcGVzLnBvcCgpO1xuICAgICAgICBpZiAobGFzdCAmJiBsYXN0ICE9PSB0aGlzKSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnQuc2NvcGVzW3RoaXMuaW5kZXhdID0gbGFzdDtcbiAgICAgICAgICBsYXN0LmluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5wYXJlbnQgPSB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBlZmZlY3RTY29wZShkZXRhY2hlZCkge1xuICByZXR1cm4gbmV3IEVmZmVjdFNjb3BlKGRldGFjaGVkKTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRTY29wZSgpIHtcbiAgcmV0dXJuIGFjdGl2ZUVmZmVjdFNjb3BlO1xufVxuZnVuY3Rpb24gb25TY29wZURpc3Bvc2UoZm4sIGZhaWxTaWxlbnRseSA9IGZhbHNlKSB7XG4gIGlmIChhY3RpdmVFZmZlY3RTY29wZSkge1xuICAgIGFjdGl2ZUVmZmVjdFNjb3BlLmNsZWFudXBzLnB1c2goZm4pO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWZhaWxTaWxlbnRseSkge1xuICAgIHdhcm4oXG4gICAgICBgb25TY29wZURpc3Bvc2UoKSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgZWZmZWN0IHNjb3BlIHRvIGJlIGFzc29jaWF0ZWQgd2l0aC5gXG4gICAgKTtcbiAgfVxufVxuXG5sZXQgYWN0aXZlU3ViO1xuY29uc3QgRWZmZWN0RmxhZ3MgPSB7XG4gIFwiQUNUSVZFXCI6IDEsXG4gIFwiMVwiOiBcIkFDVElWRVwiLFxuICBcIlJVTk5JTkdcIjogMixcbiAgXCIyXCI6IFwiUlVOTklOR1wiLFxuICBcIlRSQUNLSU5HXCI6IDQsXG4gIFwiNFwiOiBcIlRSQUNLSU5HXCIsXG4gIFwiTk9USUZJRURcIjogOCxcbiAgXCI4XCI6IFwiTk9USUZJRURcIixcbiAgXCJESVJUWVwiOiAxNixcbiAgXCIxNlwiOiBcIkRJUlRZXCIsXG4gIFwiQUxMT1dfUkVDVVJTRVwiOiAzMixcbiAgXCIzMlwiOiBcIkFMTE9XX1JFQ1VSU0VcIixcbiAgXCJQQVVTRURcIjogNjQsXG4gIFwiNjRcIjogXCJQQVVTRURcIixcbiAgXCJFVkFMVUFURURcIjogMTI4LFxuICBcIjEyOFwiOiBcIkVWQUxVQVRFRFwiXG59O1xuY29uc3QgcGF1c2VkUXVldWVFZmZlY3RzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG5jbGFzcyBSZWFjdGl2ZUVmZmVjdCB7XG4gIGNvbnN0cnVjdG9yKGZuKSB7XG4gICAgdGhpcy5mbiA9IGZuO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZGVwcyA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmRlcHNUYWlsID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZmxhZ3MgPSAxIHwgNDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLm5leHQgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5jbGVhbnVwID0gdm9pZCAwO1xuICAgIHRoaXMuc2NoZWR1bGVyID0gdm9pZCAwO1xuICAgIGlmIChhY3RpdmVFZmZlY3RTY29wZSAmJiBhY3RpdmVFZmZlY3RTY29wZS5hY3RpdmUpIHtcbiAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlLmVmZmVjdHMucHVzaCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgcGF1c2UoKSB7XG4gICAgdGhpcy5mbGFncyB8PSA2NDtcbiAgfVxuICByZXN1bWUoKSB7XG4gICAgaWYgKHRoaXMuZmxhZ3MgJiA2NCkge1xuICAgICAgdGhpcy5mbGFncyAmPSAtNjU7XG4gICAgICBpZiAocGF1c2VkUXVldWVFZmZlY3RzLmhhcyh0aGlzKSkge1xuICAgICAgICBwYXVzZWRRdWV1ZUVmZmVjdHMuZGVsZXRlKHRoaXMpO1xuICAgICAgICB0aGlzLnRyaWdnZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbm90aWZ5KCkge1xuICAgIGlmICh0aGlzLmZsYWdzICYgMiAmJiAhKHRoaXMuZmxhZ3MgJiAzMikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEodGhpcy5mbGFncyAmIDgpKSB7XG4gICAgICBiYXRjaCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgcnVuKCkge1xuICAgIGlmICghKHRoaXMuZmxhZ3MgJiAxKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZm4oKTtcbiAgICB9XG4gICAgdGhpcy5mbGFncyB8PSAyO1xuICAgIGNsZWFudXBFZmZlY3QodGhpcyk7XG4gICAgcHJlcGFyZURlcHModGhpcyk7XG4gICAgY29uc3QgcHJldkVmZmVjdCA9IGFjdGl2ZVN1YjtcbiAgICBjb25zdCBwcmV2U2hvdWxkVHJhY2sgPSBzaG91bGRUcmFjaztcbiAgICBhY3RpdmVTdWIgPSB0aGlzO1xuICAgIHNob3VsZFRyYWNrID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuZm4oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgYWN0aXZlU3ViICE9PSB0aGlzKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJBY3RpdmUgZWZmZWN0IHdhcyBub3QgcmVzdG9yZWQgY29ycmVjdGx5IC0gdGhpcyBpcyBsaWtlbHkgYSBWdWUgaW50ZXJuYWwgYnVnLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjbGVhbnVwRGVwcyh0aGlzKTtcbiAgICAgIGFjdGl2ZVN1YiA9IHByZXZFZmZlY3Q7XG4gICAgICBzaG91bGRUcmFjayA9IHByZXZTaG91bGRUcmFjaztcbiAgICAgIHRoaXMuZmxhZ3MgJj0gLTM7XG4gICAgfVxuICB9XG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuZmxhZ3MgJiAxKSB7XG4gICAgICBmb3IgKGxldCBsaW5rID0gdGhpcy5kZXBzOyBsaW5rOyBsaW5rID0gbGluay5uZXh0RGVwKSB7XG4gICAgICAgIHJlbW92ZVN1YihsaW5rKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVwcyA9IHRoaXMuZGVwc1RhaWwgPSB2b2lkIDA7XG4gICAgICBjbGVhbnVwRWZmZWN0KHRoaXMpO1xuICAgICAgdGhpcy5vblN0b3AgJiYgdGhpcy5vblN0b3AoKTtcbiAgICAgIHRoaXMuZmxhZ3MgJj0gLTI7XG4gICAgfVxuICB9XG4gIHRyaWdnZXIoKSB7XG4gICAgaWYgKHRoaXMuZmxhZ3MgJiA2NCkge1xuICAgICAgcGF1c2VkUXVldWVFZmZlY3RzLmFkZCh0aGlzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2NoZWR1bGVyKSB7XG4gICAgICB0aGlzLnNjaGVkdWxlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJ1bklmRGlydHkoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcnVuSWZEaXJ0eSgpIHtcbiAgICBpZiAoaXNEaXJ0eSh0aGlzKSkge1xuICAgICAgdGhpcy5ydW4oKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGRpcnR5KCkge1xuICAgIHJldHVybiBpc0RpcnR5KHRoaXMpO1xuICB9XG59XG5sZXQgYmF0Y2hEZXB0aCA9IDA7XG5sZXQgYmF0Y2hlZFN1YjtcbmxldCBiYXRjaGVkQ29tcHV0ZWQ7XG5mdW5jdGlvbiBiYXRjaChzdWIsIGlzQ29tcHV0ZWQgPSBmYWxzZSkge1xuICBzdWIuZmxhZ3MgfD0gODtcbiAgaWYgKGlzQ29tcHV0ZWQpIHtcbiAgICBzdWIubmV4dCA9IGJhdGNoZWRDb21wdXRlZDtcbiAgICBiYXRjaGVkQ29tcHV0ZWQgPSBzdWI7XG4gICAgcmV0dXJuO1xuICB9XG4gIHN1Yi5uZXh0ID0gYmF0Y2hlZFN1YjtcbiAgYmF0Y2hlZFN1YiA9IHN1Yjtcbn1cbmZ1bmN0aW9uIHN0YXJ0QmF0Y2goKSB7XG4gIGJhdGNoRGVwdGgrKztcbn1cbmZ1bmN0aW9uIGVuZEJhdGNoKCkge1xuICBpZiAoLS1iYXRjaERlcHRoID4gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoYmF0Y2hlZENvbXB1dGVkKSB7XG4gICAgbGV0IGUgPSBiYXRjaGVkQ29tcHV0ZWQ7XG4gICAgYmF0Y2hlZENvbXB1dGVkID0gdm9pZCAwO1xuICAgIHdoaWxlIChlKSB7XG4gICAgICBjb25zdCBuZXh0ID0gZS5uZXh0O1xuICAgICAgZS5uZXh0ID0gdm9pZCAwO1xuICAgICAgZS5mbGFncyAmPSAtOTtcbiAgICAgIGUgPSBuZXh0O1xuICAgIH1cbiAgfVxuICBsZXQgZXJyb3I7XG4gIHdoaWxlIChiYXRjaGVkU3ViKSB7XG4gICAgbGV0IGUgPSBiYXRjaGVkU3ViO1xuICAgIGJhdGNoZWRTdWIgPSB2b2lkIDA7XG4gICAgd2hpbGUgKGUpIHtcbiAgICAgIGNvbnN0IG5leHQgPSBlLm5leHQ7XG4gICAgICBlLm5leHQgPSB2b2lkIDA7XG4gICAgICBlLmZsYWdzICY9IC05O1xuICAgICAgaWYgKGUuZmxhZ3MgJiAxKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgO1xuICAgICAgICAgIGUudHJpZ2dlcigpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSBlcnJvciA9IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZSA9IG5leHQ7XG4gICAgfVxuICB9XG4gIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG59XG5mdW5jdGlvbiBwcmVwYXJlRGVwcyhzdWIpIHtcbiAgZm9yIChsZXQgbGluayA9IHN1Yi5kZXBzOyBsaW5rOyBsaW5rID0gbGluay5uZXh0RGVwKSB7XG4gICAgbGluay52ZXJzaW9uID0gLTE7XG4gICAgbGluay5wcmV2QWN0aXZlTGluayA9IGxpbmsuZGVwLmFjdGl2ZUxpbms7XG4gICAgbGluay5kZXAuYWN0aXZlTGluayA9IGxpbms7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsZWFudXBEZXBzKHN1Yikge1xuICBsZXQgaGVhZDtcbiAgbGV0IHRhaWwgPSBzdWIuZGVwc1RhaWw7XG4gIGxldCBsaW5rID0gdGFpbDtcbiAgd2hpbGUgKGxpbmspIHtcbiAgICBjb25zdCBwcmV2ID0gbGluay5wcmV2RGVwO1xuICAgIGlmIChsaW5rLnZlcnNpb24gPT09IC0xKSB7XG4gICAgICBpZiAobGluayA9PT0gdGFpbCkgdGFpbCA9IHByZXY7XG4gICAgICByZW1vdmVTdWIobGluayk7XG4gICAgICByZW1vdmVEZXAobGluayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWQgPSBsaW5rO1xuICAgIH1cbiAgICBsaW5rLmRlcC5hY3RpdmVMaW5rID0gbGluay5wcmV2QWN0aXZlTGluaztcbiAgICBsaW5rLnByZXZBY3RpdmVMaW5rID0gdm9pZCAwO1xuICAgIGxpbmsgPSBwcmV2O1xuICB9XG4gIHN1Yi5kZXBzID0gaGVhZDtcbiAgc3ViLmRlcHNUYWlsID0gdGFpbDtcbn1cbmZ1bmN0aW9uIGlzRGlydHkoc3ViKSB7XG4gIGZvciAobGV0IGxpbmsgPSBzdWIuZGVwczsgbGluazsgbGluayA9IGxpbmsubmV4dERlcCkge1xuICAgIGlmIChsaW5rLmRlcC52ZXJzaW9uICE9PSBsaW5rLnZlcnNpb24gfHwgbGluay5kZXAuY29tcHV0ZWQgJiYgKHJlZnJlc2hDb21wdXRlZChsaW5rLmRlcC5jb21wdXRlZCkgfHwgbGluay5kZXAudmVyc2lvbiAhPT0gbGluay52ZXJzaW9uKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChzdWIuX2RpcnR5KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcmVmcmVzaENvbXB1dGVkKGNvbXB1dGVkKSB7XG4gIGlmIChjb21wdXRlZC5mbGFncyAmIDQgJiYgIShjb21wdXRlZC5mbGFncyAmIDE2KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb21wdXRlZC5mbGFncyAmPSAtMTc7XG4gIGlmIChjb21wdXRlZC5nbG9iYWxWZXJzaW9uID09PSBnbG9iYWxWZXJzaW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbXB1dGVkLmdsb2JhbFZlcnNpb24gPSBnbG9iYWxWZXJzaW9uO1xuICBpZiAoIWNvbXB1dGVkLmlzU1NSICYmIGNvbXB1dGVkLmZsYWdzICYgMTI4ICYmICghY29tcHV0ZWQuZGVwcyAmJiAhY29tcHV0ZWQuX2RpcnR5IHx8ICFpc0RpcnR5KGNvbXB1dGVkKSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29tcHV0ZWQuZmxhZ3MgfD0gMjtcbiAgY29uc3QgZGVwID0gY29tcHV0ZWQuZGVwO1xuICBjb25zdCBwcmV2U3ViID0gYWN0aXZlU3ViO1xuICBjb25zdCBwcmV2U2hvdWxkVHJhY2sgPSBzaG91bGRUcmFjaztcbiAgYWN0aXZlU3ViID0gY29tcHV0ZWQ7XG4gIHNob3VsZFRyYWNrID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICBwcmVwYXJlRGVwcyhjb21wdXRlZCk7XG4gICAgY29uc3QgdmFsdWUgPSBjb21wdXRlZC5mbihjb21wdXRlZC5fdmFsdWUpO1xuICAgIGlmIChkZXAudmVyc2lvbiA9PT0gMCB8fCBoYXNDaGFuZ2VkKHZhbHVlLCBjb21wdXRlZC5fdmFsdWUpKSB7XG4gICAgICBjb21wdXRlZC5mbGFncyB8PSAxMjg7XG4gICAgICBjb21wdXRlZC5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgIGRlcC52ZXJzaW9uKys7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZXAudmVyc2lvbisrO1xuICAgIHRocm93IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICBhY3RpdmVTdWIgPSBwcmV2U3ViO1xuICAgIHNob3VsZFRyYWNrID0gcHJldlNob3VsZFRyYWNrO1xuICAgIGNsZWFudXBEZXBzKGNvbXB1dGVkKTtcbiAgICBjb21wdXRlZC5mbGFncyAmPSAtMztcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlU3ViKGxpbmssIHNvZnQgPSBmYWxzZSkge1xuICBjb25zdCB7IGRlcCwgcHJldlN1YiwgbmV4dFN1YiB9ID0gbGluaztcbiAgaWYgKHByZXZTdWIpIHtcbiAgICBwcmV2U3ViLm5leHRTdWIgPSBuZXh0U3ViO1xuICAgIGxpbmsucHJldlN1YiA9IHZvaWQgMDtcbiAgfVxuICBpZiAobmV4dFN1Yikge1xuICAgIG5leHRTdWIucHJldlN1YiA9IHByZXZTdWI7XG4gICAgbGluay5uZXh0U3ViID0gdm9pZCAwO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGRlcC5zdWJzSGVhZCA9PT0gbGluaykge1xuICAgIGRlcC5zdWJzSGVhZCA9IG5leHRTdWI7XG4gIH1cbiAgaWYgKGRlcC5zdWJzID09PSBsaW5rKSB7XG4gICAgZGVwLnN1YnMgPSBwcmV2U3ViO1xuICAgIGlmICghcHJldlN1YiAmJiBkZXAuY29tcHV0ZWQpIHtcbiAgICAgIGRlcC5jb21wdXRlZC5mbGFncyAmPSAtNTtcbiAgICAgIGZvciAobGV0IGwgPSBkZXAuY29tcHV0ZWQuZGVwczsgbDsgbCA9IGwubmV4dERlcCkge1xuICAgICAgICByZW1vdmVTdWIobCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghc29mdCAmJiAhLS1kZXAuc2MgJiYgZGVwLm1hcCkge1xuICAgIGRlcC5tYXAuZGVsZXRlKGRlcC5rZXkpO1xuICB9XG59XG5mdW5jdGlvbiByZW1vdmVEZXAobGluaykge1xuICBjb25zdCB7IHByZXZEZXAsIG5leHREZXAgfSA9IGxpbms7XG4gIGlmIChwcmV2RGVwKSB7XG4gICAgcHJldkRlcC5uZXh0RGVwID0gbmV4dERlcDtcbiAgICBsaW5rLnByZXZEZXAgPSB2b2lkIDA7XG4gIH1cbiAgaWYgKG5leHREZXApIHtcbiAgICBuZXh0RGVwLnByZXZEZXAgPSBwcmV2RGVwO1xuICAgIGxpbmsubmV4dERlcCA9IHZvaWQgMDtcbiAgfVxufVxuZnVuY3Rpb24gZWZmZWN0KGZuLCBvcHRpb25zKSB7XG4gIGlmIChmbi5lZmZlY3QgaW5zdGFuY2VvZiBSZWFjdGl2ZUVmZmVjdCkge1xuICAgIGZuID0gZm4uZWZmZWN0LmZuO1xuICB9XG4gIGNvbnN0IGUgPSBuZXcgUmVhY3RpdmVFZmZlY3QoZm4pO1xuICBpZiAob3B0aW9ucykge1xuICAgIGV4dGVuZChlLCBvcHRpb25zKTtcbiAgfVxuICB0cnkge1xuICAgIGUucnVuKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGUuc3RvcCgpO1xuICAgIHRocm93IGVycjtcbiAgfVxuICBjb25zdCBydW5uZXIgPSBlLnJ1bi5iaW5kKGUpO1xuICBydW5uZXIuZWZmZWN0ID0gZTtcbiAgcmV0dXJuIHJ1bm5lcjtcbn1cbmZ1bmN0aW9uIHN0b3AocnVubmVyKSB7XG4gIHJ1bm5lci5lZmZlY3Quc3RvcCgpO1xufVxubGV0IHNob3VsZFRyYWNrID0gdHJ1ZTtcbmNvbnN0IHRyYWNrU3RhY2sgPSBbXTtcbmZ1bmN0aW9uIHBhdXNlVHJhY2tpbmcoKSB7XG4gIHRyYWNrU3RhY2sucHVzaChzaG91bGRUcmFjayk7XG4gIHNob3VsZFRyYWNrID0gZmFsc2U7XG59XG5mdW5jdGlvbiBlbmFibGVUcmFja2luZygpIHtcbiAgdHJhY2tTdGFjay5wdXNoKHNob3VsZFRyYWNrKTtcbiAgc2hvdWxkVHJhY2sgPSB0cnVlO1xufVxuZnVuY3Rpb24gcmVzZXRUcmFja2luZygpIHtcbiAgY29uc3QgbGFzdCA9IHRyYWNrU3RhY2sucG9wKCk7XG4gIHNob3VsZFRyYWNrID0gbGFzdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IGxhc3Q7XG59XG5mdW5jdGlvbiBvbkVmZmVjdENsZWFudXAoZm4sIGZhaWxTaWxlbnRseSA9IGZhbHNlKSB7XG4gIGlmIChhY3RpdmVTdWIgaW5zdGFuY2VvZiBSZWFjdGl2ZUVmZmVjdCkge1xuICAgIGFjdGl2ZVN1Yi5jbGVhbnVwID0gZm47XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhZmFpbFNpbGVudGx5KSB7XG4gICAgd2FybihcbiAgICAgIGBvbkVmZmVjdENsZWFudXAoKSB3YXMgY2FsbGVkIHdoZW4gdGhlcmUgd2FzIG5vIGFjdGl2ZSBlZmZlY3QgdG8gYXNzb2NpYXRlIHdpdGguYFxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsZWFudXBFZmZlY3QoZSkge1xuICBjb25zdCB7IGNsZWFudXAgfSA9IGU7XG4gIGUuY2xlYW51cCA9IHZvaWQgMDtcbiAgaWYgKGNsZWFudXApIHtcbiAgICBjb25zdCBwcmV2U3ViID0gYWN0aXZlU3ViO1xuICAgIGFjdGl2ZVN1YiA9IHZvaWQgMDtcbiAgICB0cnkge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBhY3RpdmVTdWIgPSBwcmV2U3ViO1xuICAgIH1cbiAgfVxufVxuXG5sZXQgZ2xvYmFsVmVyc2lvbiA9IDA7XG5jbGFzcyBMaW5rIHtcbiAgY29uc3RydWN0b3Ioc3ViLCBkZXApIHtcbiAgICB0aGlzLnN1YiA9IHN1YjtcbiAgICB0aGlzLmRlcCA9IGRlcDtcbiAgICB0aGlzLnZlcnNpb24gPSBkZXAudmVyc2lvbjtcbiAgICB0aGlzLm5leHREZXAgPSB0aGlzLnByZXZEZXAgPSB0aGlzLm5leHRTdWIgPSB0aGlzLnByZXZTdWIgPSB0aGlzLnByZXZBY3RpdmVMaW5rID0gdm9pZCAwO1xuICB9XG59XG5jbGFzcyBEZXAge1xuICBjb25zdHJ1Y3Rvcihjb21wdXRlZCkge1xuICAgIHRoaXMuY29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICB0aGlzLnZlcnNpb24gPSAwO1xuICAgIC8qKlxuICAgICAqIExpbmsgYmV0d2VlbiB0aGlzIGRlcCBhbmQgdGhlIGN1cnJlbnQgYWN0aXZlIGVmZmVjdFxuICAgICAqL1xuICAgIHRoaXMuYWN0aXZlTGluayA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBEb3VibHkgbGlua2VkIGxpc3QgcmVwcmVzZW50aW5nIHRoZSBzdWJzY3JpYmluZyBlZmZlY3RzICh0YWlsKVxuICAgICAqL1xuICAgIHRoaXMuc3VicyA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBGb3Igb2JqZWN0IHByb3BlcnR5IGRlcHMgY2xlYW51cFxuICAgICAqL1xuICAgIHRoaXMubWFwID0gdm9pZCAwO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXIgY291bnRlclxuICAgICAqL1xuICAgIHRoaXMuc2MgPSAwO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB0aGlzLnN1YnNIZWFkID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICB0cmFjayhkZWJ1Z0luZm8pIHtcbiAgICBpZiAoIWFjdGl2ZVN1YiB8fCAhc2hvdWxkVHJhY2sgfHwgYWN0aXZlU3ViID09PSB0aGlzLmNvbXB1dGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBsaW5rID0gdGhpcy5hY3RpdmVMaW5rO1xuICAgIGlmIChsaW5rID09PSB2b2lkIDAgfHwgbGluay5zdWIgIT09IGFjdGl2ZVN1Yikge1xuICAgICAgbGluayA9IHRoaXMuYWN0aXZlTGluayA9IG5ldyBMaW5rKGFjdGl2ZVN1YiwgdGhpcyk7XG4gICAgICBpZiAoIWFjdGl2ZVN1Yi5kZXBzKSB7XG4gICAgICAgIGFjdGl2ZVN1Yi5kZXBzID0gYWN0aXZlU3ViLmRlcHNUYWlsID0gbGluaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmsucHJldkRlcCA9IGFjdGl2ZVN1Yi5kZXBzVGFpbDtcbiAgICAgICAgYWN0aXZlU3ViLmRlcHNUYWlsLm5leHREZXAgPSBsaW5rO1xuICAgICAgICBhY3RpdmVTdWIuZGVwc1RhaWwgPSBsaW5rO1xuICAgICAgfVxuICAgICAgYWRkU3ViKGxpbmspO1xuICAgIH0gZWxzZSBpZiAobGluay52ZXJzaW9uID09PSAtMSkge1xuICAgICAgbGluay52ZXJzaW9uID0gdGhpcy52ZXJzaW9uO1xuICAgICAgaWYgKGxpbmsubmV4dERlcCkge1xuICAgICAgICBjb25zdCBuZXh0ID0gbGluay5uZXh0RGVwO1xuICAgICAgICBuZXh0LnByZXZEZXAgPSBsaW5rLnByZXZEZXA7XG4gICAgICAgIGlmIChsaW5rLnByZXZEZXApIHtcbiAgICAgICAgICBsaW5rLnByZXZEZXAubmV4dERlcCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgbGluay5wcmV2RGVwID0gYWN0aXZlU3ViLmRlcHNUYWlsO1xuICAgICAgICBsaW5rLm5leHREZXAgPSB2b2lkIDA7XG4gICAgICAgIGFjdGl2ZVN1Yi5kZXBzVGFpbC5uZXh0RGVwID0gbGluaztcbiAgICAgICAgYWN0aXZlU3ViLmRlcHNUYWlsID0gbGluaztcbiAgICAgICAgaWYgKGFjdGl2ZVN1Yi5kZXBzID09PSBsaW5rKSB7XG4gICAgICAgICAgYWN0aXZlU3ViLmRlcHMgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGFjdGl2ZVN1Yi5vblRyYWNrKSB7XG4gICAgICBhY3RpdmVTdWIub25UcmFjayhcbiAgICAgICAgZXh0ZW5kKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVmZmVjdDogYWN0aXZlU3ViXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWJ1Z0luZm9cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbms7XG4gIH1cbiAgdHJpZ2dlcihkZWJ1Z0luZm8pIHtcbiAgICB0aGlzLnZlcnNpb24rKztcbiAgICBnbG9iYWxWZXJzaW9uKys7XG4gICAgdGhpcy5ub3RpZnkoZGVidWdJbmZvKTtcbiAgfVxuICBub3RpZnkoZGVidWdJbmZvKSB7XG4gICAgc3RhcnRCYXRjaCgpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBmb3IgKGxldCBoZWFkID0gdGhpcy5zdWJzSGVhZDsgaGVhZDsgaGVhZCA9IGhlYWQubmV4dFN1Yikge1xuICAgICAgICAgIGlmIChoZWFkLnN1Yi5vblRyaWdnZXIgJiYgIShoZWFkLnN1Yi5mbGFncyAmIDgpKSB7XG4gICAgICAgICAgICBoZWFkLnN1Yi5vblRyaWdnZXIoXG4gICAgICAgICAgICAgIGV4dGVuZChcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBlZmZlY3Q6IGhlYWQuc3ViXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkZWJ1Z0luZm9cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGxpbmsgPSB0aGlzLnN1YnM7IGxpbms7IGxpbmsgPSBsaW5rLnByZXZTdWIpIHtcbiAgICAgICAgaWYgKGxpbmsuc3ViLm5vdGlmeSgpKSB7XG4gICAgICAgICAgO1xuICAgICAgICAgIGxpbmsuc3ViLmRlcC5ub3RpZnkoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBlbmRCYXRjaCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYWRkU3ViKGxpbmspIHtcbiAgbGluay5kZXAuc2MrKztcbiAgaWYgKGxpbmsuc3ViLmZsYWdzICYgNCkge1xuICAgIGNvbnN0IGNvbXB1dGVkID0gbGluay5kZXAuY29tcHV0ZWQ7XG4gICAgaWYgKGNvbXB1dGVkICYmICFsaW5rLmRlcC5zdWJzKSB7XG4gICAgICBjb21wdXRlZC5mbGFncyB8PSA0IHwgMTY7XG4gICAgICBmb3IgKGxldCBsID0gY29tcHV0ZWQuZGVwczsgbDsgbCA9IGwubmV4dERlcCkge1xuICAgICAgICBhZGRTdWIobCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRUYWlsID0gbGluay5kZXAuc3VicztcbiAgICBpZiAoY3VycmVudFRhaWwgIT09IGxpbmspIHtcbiAgICAgIGxpbmsucHJldlN1YiA9IGN1cnJlbnRUYWlsO1xuICAgICAgaWYgKGN1cnJlbnRUYWlsKSBjdXJyZW50VGFpbC5uZXh0U3ViID0gbGluaztcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbGluay5kZXAuc3Vic0hlYWQgPT09IHZvaWQgMCkge1xuICAgICAgbGluay5kZXAuc3Vic0hlYWQgPSBsaW5rO1xuICAgIH1cbiAgICBsaW5rLmRlcC5zdWJzID0gbGluaztcbiAgfVxufVxuY29uc3QgdGFyZ2V0TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBJVEVSQVRFX0tFWSA9IFN5bWJvbChcbiAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IFwiT2JqZWN0IGl0ZXJhdGVcIiA6IFwiXCJcbik7XG5jb25zdCBNQVBfS0VZX0lURVJBVEVfS0VZID0gU3ltYm9sKFxuICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gXCJNYXAga2V5cyBpdGVyYXRlXCIgOiBcIlwiXG4pO1xuY29uc3QgQVJSQVlfSVRFUkFURV9LRVkgPSBTeW1ib2woXG4gICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBcIkFycmF5IGl0ZXJhdGVcIiA6IFwiXCJcbik7XG5mdW5jdGlvbiB0cmFjayh0YXJnZXQsIHR5cGUsIGtleSkge1xuICBpZiAoc2hvdWxkVHJhY2sgJiYgYWN0aXZlU3ViKSB7XG4gICAgbGV0IGRlcHNNYXAgPSB0YXJnZXRNYXAuZ2V0KHRhcmdldCk7XG4gICAgaWYgKCFkZXBzTWFwKSB7XG4gICAgICB0YXJnZXRNYXAuc2V0KHRhcmdldCwgZGVwc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIH1cbiAgICBsZXQgZGVwID0gZGVwc01hcC5nZXQoa2V5KTtcbiAgICBpZiAoIWRlcCkge1xuICAgICAgZGVwc01hcC5zZXQoa2V5LCBkZXAgPSBuZXcgRGVwKCkpO1xuICAgICAgZGVwLm1hcCA9IGRlcHNNYXA7XG4gICAgICBkZXAua2V5ID0ga2V5O1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgZGVwLnRyYWNrKHtcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICB0eXBlLFxuICAgICAgICBrZXlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXAudHJhY2soKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXIodGFyZ2V0LCB0eXBlLCBrZXksIG5ld1ZhbHVlLCBvbGRWYWx1ZSwgb2xkVGFyZ2V0KSB7XG4gIGNvbnN0IGRlcHNNYXAgPSB0YXJnZXRNYXAuZ2V0KHRhcmdldCk7XG4gIGlmICghZGVwc01hcCkge1xuICAgIGdsb2JhbFZlcnNpb24rKztcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcnVuID0gKGRlcCkgPT4ge1xuICAgIGlmIChkZXApIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIGRlcC50cmlnZ2VyKHtcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgb2xkVmFsdWUsXG4gICAgICAgICAgb2xkVGFyZ2V0XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVwLnRyaWdnZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHN0YXJ0QmF0Y2goKTtcbiAgaWYgKHR5cGUgPT09IFwiY2xlYXJcIikge1xuICAgIGRlcHNNYXAuZm9yRWFjaChydW4pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHRhcmdldElzQXJyYXkgPSBpc0FycmF5KHRhcmdldCk7XG4gICAgY29uc3QgaXNBcnJheUluZGV4ID0gdGFyZ2V0SXNBcnJheSAmJiBpc0ludGVnZXJLZXkoa2V5KTtcbiAgICBpZiAodGFyZ2V0SXNBcnJheSAmJiBrZXkgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgIGNvbnN0IG5ld0xlbmd0aCA9IE51bWJlcihuZXdWYWx1ZSk7XG4gICAgICBkZXBzTWFwLmZvckVhY2goKGRlcCwga2V5MikgPT4ge1xuICAgICAgICBpZiAoa2V5MiA9PT0gXCJsZW5ndGhcIiB8fCBrZXkyID09PSBBUlJBWV9JVEVSQVRFX0tFWSB8fCAhaXNTeW1ib2woa2V5MikgJiYga2V5MiA+PSBuZXdMZW5ndGgpIHtcbiAgICAgICAgICBydW4oZGVwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChrZXkgIT09IHZvaWQgMCB8fCBkZXBzTWFwLmhhcyh2b2lkIDApKSB7XG4gICAgICAgIHJ1bihkZXBzTWFwLmdldChrZXkpKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5SW5kZXgpIHtcbiAgICAgICAgcnVuKGRlcHNNYXAuZ2V0KEFSUkFZX0lURVJBVEVfS0VZKSk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImFkZFwiOlxuICAgICAgICAgIGlmICghdGFyZ2V0SXNBcnJheSkge1xuICAgICAgICAgICAgcnVuKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XG4gICAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xuICAgICAgICAgICAgICBydW4oZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheUluZGV4KSB7XG4gICAgICAgICAgICBydW4oZGVwc01hcC5nZXQoXCJsZW5ndGhcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRlbGV0ZVwiOlxuICAgICAgICAgIGlmICghdGFyZ2V0SXNBcnJheSkge1xuICAgICAgICAgICAgcnVuKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XG4gICAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xuICAgICAgICAgICAgICBydW4oZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNldFwiOlxuICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XG4gICAgICAgICAgICBydW4oZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVuZEJhdGNoKCk7XG59XG5mdW5jdGlvbiBnZXREZXBGcm9tUmVhY3RpdmUob2JqZWN0LCBrZXkpIHtcbiAgY29uc3QgZGVwTWFwID0gdGFyZ2V0TWFwLmdldChvYmplY3QpO1xuICByZXR1cm4gZGVwTWFwICYmIGRlcE1hcC5nZXQoa2V5KTtcbn1cblxuZnVuY3Rpb24gcmVhY3RpdmVSZWFkQXJyYXkoYXJyYXkpIHtcbiAgY29uc3QgcmF3ID0gdG9SYXcoYXJyYXkpO1xuICBpZiAocmF3ID09PSBhcnJheSkgcmV0dXJuIHJhdztcbiAgdHJhY2socmF3LCBcIml0ZXJhdGVcIiwgQVJSQVlfSVRFUkFURV9LRVkpO1xuICByZXR1cm4gaXNTaGFsbG93KGFycmF5KSA/IHJhdyA6IHJhdy5tYXAodG9SZWFjdGl2ZSk7XG59XG5mdW5jdGlvbiBzaGFsbG93UmVhZEFycmF5KGFycikge1xuICB0cmFjayhhcnIgPSB0b1JhdyhhcnIpLCBcIml0ZXJhdGVcIiwgQVJSQVlfSVRFUkFURV9LRVkpO1xuICByZXR1cm4gYXJyO1xufVxuY29uc3QgYXJyYXlJbnN0cnVtZW50YXRpb25zID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiBpdGVyYXRvcih0aGlzLCBTeW1ib2wuaXRlcmF0b3IsIHRvUmVhY3RpdmUpO1xuICB9LFxuICBjb25jYXQoLi4uYXJncykge1xuICAgIHJldHVybiByZWFjdGl2ZVJlYWRBcnJheSh0aGlzKS5jb25jYXQoXG4gICAgICAuLi5hcmdzLm1hcCgoeCkgPT4gaXNBcnJheSh4KSA/IHJlYWN0aXZlUmVhZEFycmF5KHgpIDogeClcbiAgICApO1xuICB9LFxuICBlbnRyaWVzKCkge1xuICAgIHJldHVybiBpdGVyYXRvcih0aGlzLCBcImVudHJpZXNcIiwgKHZhbHVlKSA9PiB7XG4gICAgICB2YWx1ZVsxXSA9IHRvUmVhY3RpdmUodmFsdWVbMV0pO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pO1xuICB9LFxuICBldmVyeShmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcImV2ZXJ5XCIsIGZuLCB0aGlzQXJnLCB2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIGZpbHRlcihmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcImZpbHRlclwiLCBmbiwgdGhpc0FyZywgKHYpID0+IHYubWFwKHRvUmVhY3RpdmUpLCBhcmd1bWVudHMpO1xuICB9LFxuICBmaW5kKGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwiZmluZFwiLCBmbiwgdGhpc0FyZywgdG9SZWFjdGl2ZSwgYXJndW1lbnRzKTtcbiAgfSxcbiAgZmluZEluZGV4KGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwiZmluZEluZGV4XCIsIGZuLCB0aGlzQXJnLCB2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIGZpbmRMYXN0KGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwiZmluZExhc3RcIiwgZm4sIHRoaXNBcmcsIHRvUmVhY3RpdmUsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIGZpbmRMYXN0SW5kZXgoZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJmaW5kTGFzdEluZGV4XCIsIGZuLCB0aGlzQXJnLCB2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIC8vIGZsYXQsIGZsYXRNYXAgY291bGQgYmVuZWZpdCBmcm9tIEFSUkFZX0lURVJBVEUgYnV0IGFyZSBub3Qgc3RyYWlnaHQtZm9yd2FyZCB0byBpbXBsZW1lbnRcbiAgZm9yRWFjaChmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcImZvckVhY2hcIiwgZm4sIHRoaXNBcmcsIHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfSxcbiAgaW5jbHVkZXMoLi4uYXJncykge1xuICAgIHJldHVybiBzZWFyY2hQcm94eSh0aGlzLCBcImluY2x1ZGVzXCIsIGFyZ3MpO1xuICB9LFxuICBpbmRleE9mKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gc2VhcmNoUHJveHkodGhpcywgXCJpbmRleE9mXCIsIGFyZ3MpO1xuICB9LFxuICBqb2luKHNlcGFyYXRvcikge1xuICAgIHJldHVybiByZWFjdGl2ZVJlYWRBcnJheSh0aGlzKS5qb2luKHNlcGFyYXRvcik7XG4gIH0sXG4gIC8vIGtleXMoKSBpdGVyYXRvciBvbmx5IHJlYWRzIGBsZW5ndGhgLCBubyBvcHRpbWlzYXRpb24gcmVxdWlyZWRcbiAgbGFzdEluZGV4T2YoLi4uYXJncykge1xuICAgIHJldHVybiBzZWFyY2hQcm94eSh0aGlzLCBcImxhc3RJbmRleE9mXCIsIGFyZ3MpO1xuICB9LFxuICBtYXAoZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJtYXBcIiwgZm4sIHRoaXNBcmcsIHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfSxcbiAgcG9wKCkge1xuICAgIHJldHVybiBub1RyYWNraW5nKHRoaXMsIFwicG9wXCIpO1xuICB9LFxuICBwdXNoKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbm9UcmFja2luZyh0aGlzLCBcInB1c2hcIiwgYXJncyk7XG4gIH0sXG4gIHJlZHVjZShmbiwgLi4uYXJncykge1xuICAgIHJldHVybiByZWR1Y2UodGhpcywgXCJyZWR1Y2VcIiwgZm4sIGFyZ3MpO1xuICB9LFxuICByZWR1Y2VSaWdodChmbiwgLi4uYXJncykge1xuICAgIHJldHVybiByZWR1Y2UodGhpcywgXCJyZWR1Y2VSaWdodFwiLCBmbiwgYXJncyk7XG4gIH0sXG4gIHNoaWZ0KCkge1xuICAgIHJldHVybiBub1RyYWNraW5nKHRoaXMsIFwic2hpZnRcIik7XG4gIH0sXG4gIC8vIHNsaWNlIGNvdWxkIHVzZSBBUlJBWV9JVEVSQVRFIGJ1dCBhbHNvIHNlZW1zIHRvIGJlZyBmb3IgcmFuZ2UgdHJhY2tpbmdcbiAgc29tZShmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcInNvbWVcIiwgZm4sIHRoaXNBcmcsIHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfSxcbiAgc3BsaWNlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbm9UcmFja2luZyh0aGlzLCBcInNwbGljZVwiLCBhcmdzKTtcbiAgfSxcbiAgdG9SZXZlcnNlZCgpIHtcbiAgICByZXR1cm4gcmVhY3RpdmVSZWFkQXJyYXkodGhpcykudG9SZXZlcnNlZCgpO1xuICB9LFxuICB0b1NvcnRlZChjb21wYXJlcikge1xuICAgIHJldHVybiByZWFjdGl2ZVJlYWRBcnJheSh0aGlzKS50b1NvcnRlZChjb21wYXJlcik7XG4gIH0sXG4gIHRvU3BsaWNlZCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHJlYWN0aXZlUmVhZEFycmF5KHRoaXMpLnRvU3BsaWNlZCguLi5hcmdzKTtcbiAgfSxcbiAgdW5zaGlmdCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG5vVHJhY2tpbmcodGhpcywgXCJ1bnNoaWZ0XCIsIGFyZ3MpO1xuICB9LFxuICB2YWx1ZXMoKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yKHRoaXMsIFwidmFsdWVzXCIsIHRvUmVhY3RpdmUpO1xuICB9XG59O1xuZnVuY3Rpb24gaXRlcmF0b3Ioc2VsZiwgbWV0aG9kLCB3cmFwVmFsdWUpIHtcbiAgY29uc3QgYXJyID0gc2hhbGxvd1JlYWRBcnJheShzZWxmKTtcbiAgY29uc3QgaXRlciA9IGFyclttZXRob2RdKCk7XG4gIGlmIChhcnIgIT09IHNlbGYgJiYgIWlzU2hhbGxvdyhzZWxmKSkge1xuICAgIGl0ZXIuX25leHQgPSBpdGVyLm5leHQ7XG4gICAgaXRlci5uZXh0ID0gKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gaXRlci5fbmV4dCgpO1xuICAgICAgaWYgKHJlc3VsdC52YWx1ZSkge1xuICAgICAgICByZXN1bHQudmFsdWUgPSB3cmFwVmFsdWUocmVzdWx0LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gaXRlcjtcbn1cbmNvbnN0IGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5mdW5jdGlvbiBhcHBseShzZWxmLCBtZXRob2QsIGZuLCB0aGlzQXJnLCB3cmFwcGVkUmV0Rm4sIGFyZ3MpIHtcbiAgY29uc3QgYXJyID0gc2hhbGxvd1JlYWRBcnJheShzZWxmKTtcbiAgY29uc3QgbmVlZHNXcmFwID0gYXJyICE9PSBzZWxmICYmICFpc1NoYWxsb3coc2VsZik7XG4gIGNvbnN0IG1ldGhvZEZuID0gYXJyW21ldGhvZF07XG4gIGlmIChtZXRob2RGbiAhPT0gYXJyYXlQcm90b1ttZXRob2RdKSB7XG4gICAgY29uc3QgcmVzdWx0MiA9IG1ldGhvZEZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIHJldHVybiBuZWVkc1dyYXAgPyB0b1JlYWN0aXZlKHJlc3VsdDIpIDogcmVzdWx0MjtcbiAgfVxuICBsZXQgd3JhcHBlZEZuID0gZm47XG4gIGlmIChhcnIgIT09IHNlbGYpIHtcbiAgICBpZiAobmVlZHNXcmFwKSB7XG4gICAgICB3cmFwcGVkRm4gPSBmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCB0b1JlYWN0aXZlKGl0ZW0pLCBpbmRleCwgc2VsZik7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZm4ubGVuZ3RoID4gMikge1xuICAgICAgd3JhcHBlZEZuID0gZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgaXRlbSwgaW5kZXgsIHNlbGYpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gbWV0aG9kRm4uY2FsbChhcnIsIHdyYXBwZWRGbiwgdGhpc0FyZyk7XG4gIHJldHVybiBuZWVkc1dyYXAgJiYgd3JhcHBlZFJldEZuID8gd3JhcHBlZFJldEZuKHJlc3VsdCkgOiByZXN1bHQ7XG59XG5mdW5jdGlvbiByZWR1Y2Uoc2VsZiwgbWV0aG9kLCBmbiwgYXJncykge1xuICBjb25zdCBhcnIgPSBzaGFsbG93UmVhZEFycmF5KHNlbGYpO1xuICBsZXQgd3JhcHBlZEZuID0gZm47XG4gIGlmIChhcnIgIT09IHNlbGYpIHtcbiAgICBpZiAoIWlzU2hhbGxvdyhzZWxmKSkge1xuICAgICAgd3JhcHBlZEZuID0gZnVuY3Rpb24oYWNjLCBpdGVtLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhY2MsIHRvUmVhY3RpdmUoaXRlbSksIGluZGV4LCBzZWxmKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChmbi5sZW5ndGggPiAzKSB7XG4gICAgICB3cmFwcGVkRm4gPSBmdW5jdGlvbihhY2MsIGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGFjYywgaXRlbSwgaW5kZXgsIHNlbGYpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFyclttZXRob2RdKHdyYXBwZWRGbiwgLi4uYXJncyk7XG59XG5mdW5jdGlvbiBzZWFyY2hQcm94eShzZWxmLCBtZXRob2QsIGFyZ3MpIHtcbiAgY29uc3QgYXJyID0gdG9SYXcoc2VsZik7XG4gIHRyYWNrKGFyciwgXCJpdGVyYXRlXCIsIEFSUkFZX0lURVJBVEVfS0VZKTtcbiAgY29uc3QgcmVzID0gYXJyW21ldGhvZF0oLi4uYXJncyk7XG4gIGlmICgocmVzID09PSAtMSB8fCByZXMgPT09IGZhbHNlKSAmJiBpc1Byb3h5KGFyZ3NbMF0pKSB7XG4gICAgYXJnc1swXSA9IHRvUmF3KGFyZ3NbMF0pO1xuICAgIHJldHVybiBhcnJbbWV0aG9kXSguLi5hcmdzKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gbm9UcmFja2luZyhzZWxmLCBtZXRob2QsIGFyZ3MgPSBbXSkge1xuICBwYXVzZVRyYWNraW5nKCk7XG4gIHN0YXJ0QmF0Y2goKTtcbiAgY29uc3QgcmVzID0gdG9SYXcoc2VsZilbbWV0aG9kXS5hcHBseShzZWxmLCBhcmdzKTtcbiAgZW5kQmF0Y2goKTtcbiAgcmVzZXRUcmFja2luZygpO1xuICByZXR1cm4gcmVzO1xufVxuXG5jb25zdCBpc05vblRyYWNrYWJsZUtleXMgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChgX19wcm90b19fLF9fdl9pc1JlZixfX2lzVnVlYCk7XG5jb25zdCBidWlsdEluU3ltYm9scyA9IG5ldyBTZXQoXG4gIC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhTeW1ib2wpLmZpbHRlcigoa2V5KSA9PiBrZXkgIT09IFwiYXJndW1lbnRzXCIgJiYga2V5ICE9PSBcImNhbGxlclwiKS5tYXAoKGtleSkgPT4gU3ltYm9sW2tleV0pLmZpbHRlcihpc1N5bWJvbClcbik7XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShrZXkpIHtcbiAgaWYgKCFpc1N5bWJvbChrZXkpKSBrZXkgPSBTdHJpbmcoa2V5KTtcbiAgY29uc3Qgb2JqID0gdG9SYXcodGhpcyk7XG4gIHRyYWNrKG9iaiwgXCJoYXNcIiwga2V5KTtcbiAgcmV0dXJuIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpO1xufVxuY2xhc3MgQmFzZVJlYWN0aXZlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKF9pc1JlYWRvbmx5ID0gZmFsc2UsIF9pc1NoYWxsb3cgPSBmYWxzZSkge1xuICAgIHRoaXMuX2lzUmVhZG9ubHkgPSBfaXNSZWFkb25seTtcbiAgICB0aGlzLl9pc1NoYWxsb3cgPSBfaXNTaGFsbG93O1xuICB9XG4gIGdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAoa2V5ID09PSBcIl9fdl9za2lwXCIpIHJldHVybiB0YXJnZXRbXCJfX3Zfc2tpcFwiXTtcbiAgICBjb25zdCBpc1JlYWRvbmx5MiA9IHRoaXMuX2lzUmVhZG9ubHksIGlzU2hhbGxvdzIgPSB0aGlzLl9pc1NoYWxsb3c7XG4gICAgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFjdGl2ZVwiKSB7XG4gICAgICByZXR1cm4gIWlzUmVhZG9ubHkyO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWRvbmx5XCIpIHtcbiAgICAgIHJldHVybiBpc1JlYWRvbmx5MjtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNTaGFsbG93XCIpIHtcbiAgICAgIHJldHVybiBpc1NoYWxsb3cyO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9yYXdcIikge1xuICAgICAgaWYgKHJlY2VpdmVyID09PSAoaXNSZWFkb25seTIgPyBpc1NoYWxsb3cyID8gc2hhbGxvd1JlYWRvbmx5TWFwIDogcmVhZG9ubHlNYXAgOiBpc1NoYWxsb3cyID8gc2hhbGxvd1JlYWN0aXZlTWFwIDogcmVhY3RpdmVNYXApLmdldCh0YXJnZXQpIHx8IC8vIHJlY2VpdmVyIGlzIG5vdCB0aGUgcmVhY3RpdmUgcHJveHksIGJ1dCBoYXMgdGhlIHNhbWUgcHJvdG90eXBlXG4gICAgICAvLyB0aGlzIG1lYW5zIHRoZSByZWNlaXZlciBpcyBhIHVzZXIgcHJveHkgb2YgdGhlIHJlYWN0aXZlIHByb3h5XG4gICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHJlY2VpdmVyKSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRJc0FycmF5ID0gaXNBcnJheSh0YXJnZXQpO1xuICAgIGlmICghaXNSZWFkb25seTIpIHtcbiAgICAgIGxldCBmbjtcbiAgICAgIGlmICh0YXJnZXRJc0FycmF5ICYmIChmbiA9IGFycmF5SW5zdHJ1bWVudGF0aW9uc1trZXldKSkge1xuICAgICAgICByZXR1cm4gZm47XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSBcImhhc093blByb3BlcnR5XCIpIHtcbiAgICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXMgPSBSZWZsZWN0LmdldChcbiAgICAgIHRhcmdldCxcbiAgICAgIGtleSxcbiAgICAgIC8vIGlmIHRoaXMgaXMgYSBwcm94eSB3cmFwcGluZyBhIHJlZiwgcmV0dXJuIG1ldGhvZHMgdXNpbmcgdGhlIHJhdyByZWZcbiAgICAgIC8vIGFzIHJlY2VpdmVyIHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBjYWxsIGB0b1Jhd2Agb24gdGhlIHJlZiBpbiBhbGxcbiAgICAgIC8vIGl0cyBjbGFzcyBtZXRob2RzXG4gICAgICBpc1JlZih0YXJnZXQpID8gdGFyZ2V0IDogcmVjZWl2ZXJcbiAgICApO1xuICAgIGlmIChpc1N5bWJvbChrZXkpID8gYnVpbHRJblN5bWJvbHMuaGFzKGtleSkgOiBpc05vblRyYWNrYWJsZUtleXMoa2V5KSkge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgaWYgKCFpc1JlYWRvbmx5Mikge1xuICAgICAgdHJhY2sodGFyZ2V0LCBcImdldFwiLCBrZXkpO1xuICAgIH1cbiAgICBpZiAoaXNTaGFsbG93Mikge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgaWYgKGlzUmVmKHJlcykpIHtcbiAgICAgIHJldHVybiB0YXJnZXRJc0FycmF5ICYmIGlzSW50ZWdlcktleShrZXkpID8gcmVzIDogcmVzLnZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgcmV0dXJuIGlzUmVhZG9ubHkyID8gcmVhZG9ubHkocmVzKSA6IHJlYWN0aXZlKHJlcyk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbn1cbmNsYXNzIE11dGFibGVSZWFjdGl2ZUhhbmRsZXIgZXh0ZW5kcyBCYXNlUmVhY3RpdmVIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IoaXNTaGFsbG93MiA9IGZhbHNlKSB7XG4gICAgc3VwZXIoZmFsc2UsIGlzU2hhbGxvdzIpO1xuICB9XG4gIHNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgbGV0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgaWYgKCF0aGlzLl9pc1NoYWxsb3cpIHtcbiAgICAgIGNvbnN0IGlzT2xkVmFsdWVSZWFkb25seSA9IGlzUmVhZG9ubHkob2xkVmFsdWUpO1xuICAgICAgaWYgKCFpc1NoYWxsb3codmFsdWUpICYmICFpc1JlYWRvbmx5KHZhbHVlKSkge1xuICAgICAgICBvbGRWYWx1ZSA9IHRvUmF3KG9sZFZhbHVlKTtcbiAgICAgICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXJyYXkodGFyZ2V0KSAmJiBpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xuICAgICAgICBpZiAoaXNPbGRWYWx1ZVJlYWRvbmx5KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9sZFZhbHVlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaGFkS2V5ID0gaXNBcnJheSh0YXJnZXQpICYmIGlzSW50ZWdlcktleShrZXkpID8gTnVtYmVyKGtleSkgPCB0YXJnZXQubGVuZ3RoIDogaGFzT3duKHRhcmdldCwga2V5KTtcbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LnNldChcbiAgICAgIHRhcmdldCxcbiAgICAgIGtleSxcbiAgICAgIHZhbHVlLFxuICAgICAgaXNSZWYodGFyZ2V0KSA/IHRhcmdldCA6IHJlY2VpdmVyXG4gICAgKTtcbiAgICBpZiAodGFyZ2V0ID09PSB0b1JhdyhyZWNlaXZlcikpIHtcbiAgICAgIGlmICghaGFkS2V5KSB7XG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiLCBrZXksIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzQ2hhbmdlZCh2YWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiLCBrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcbiAgICBjb25zdCBoYWRLZXkgPSBoYXNPd24odGFyZ2V0LCBrZXkpO1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSk7XG4gICAgaWYgKHJlc3VsdCAmJiBoYWRLZXkpIHtcbiAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImRlbGV0ZVwiLCBrZXksIHZvaWQgMCwgb2xkVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGhhcyh0YXJnZXQsIGtleSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuaGFzKHRhcmdldCwga2V5KTtcbiAgICBpZiAoIWlzU3ltYm9sKGtleSkgfHwgIWJ1aWx0SW5TeW1ib2xzLmhhcyhrZXkpKSB7XG4gICAgICB0cmFjayh0YXJnZXQsIFwiaGFzXCIsIGtleSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgb3duS2V5cyh0YXJnZXQpIHtcbiAgICB0cmFjayhcbiAgICAgIHRhcmdldCxcbiAgICAgIFwiaXRlcmF0ZVwiLFxuICAgICAgaXNBcnJheSh0YXJnZXQpID8gXCJsZW5ndGhcIiA6IElURVJBVEVfS0VZXG4gICAgKTtcbiAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XG4gIH1cbn1cbmNsYXNzIFJlYWRvbmx5UmVhY3RpdmVIYW5kbGVyIGV4dGVuZHMgQmFzZVJlYWN0aXZlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKGlzU2hhbGxvdzIgPSBmYWxzZSkge1xuICAgIHN1cGVyKHRydWUsIGlzU2hhbGxvdzIpO1xuICB9XG4gIHNldCh0YXJnZXQsIGtleSkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgU2V0IG9wZXJhdGlvbiBvbiBrZXkgXCIke1N0cmluZyhrZXkpfVwiIGZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsXG4gICAgICAgIHRhcmdldFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihcbiAgICAgICAgYERlbGV0ZSBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLFxuICAgICAgICB0YXJnZXRcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5jb25zdCBtdXRhYmxlSGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE11dGFibGVSZWFjdGl2ZUhhbmRsZXIoKTtcbmNvbnN0IHJlYWRvbmx5SGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlYWRvbmx5UmVhY3RpdmVIYW5kbGVyKCk7XG5jb25zdCBzaGFsbG93UmVhY3RpdmVIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTXV0YWJsZVJlYWN0aXZlSGFuZGxlcih0cnVlKTtcbmNvbnN0IHNoYWxsb3dSZWFkb25seUhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBSZWFkb25seVJlYWN0aXZlSGFuZGxlcih0cnVlKTtcblxuY29uc3QgdG9TaGFsbG93ID0gKHZhbHVlKSA9PiB2YWx1ZTtcbmNvbnN0IGdldFByb3RvID0gKHYpID0+IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2Yodik7XG5mdW5jdGlvbiBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIGlzUmVhZG9ubHkyLCBpc1NoYWxsb3cyKSB7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIl07XG4gICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcbiAgICBjb25zdCB0YXJnZXRJc01hcCA9IGlzTWFwKHJhd1RhcmdldCk7XG4gICAgY29uc3QgaXNQYWlyID0gbWV0aG9kID09PSBcImVudHJpZXNcIiB8fCBtZXRob2QgPT09IFN5bWJvbC5pdGVyYXRvciAmJiB0YXJnZXRJc01hcDtcbiAgICBjb25zdCBpc0tleU9ubHkgPSBtZXRob2QgPT09IFwia2V5c1wiICYmIHRhcmdldElzTWFwO1xuICAgIGNvbnN0IGlubmVySXRlcmF0b3IgPSB0YXJnZXRbbWV0aG9kXSguLi5hcmdzKTtcbiAgICBjb25zdCB3cmFwID0gaXNTaGFsbG93MiA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkyID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XG4gICAgIWlzUmVhZG9ubHkyICYmIHRyYWNrKFxuICAgICAgcmF3VGFyZ2V0LFxuICAgICAgXCJpdGVyYXRlXCIsXG4gICAgICBpc0tleU9ubHkgPyBNQVBfS0VZX0lURVJBVEVfS0VZIDogSVRFUkFURV9LRVlcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAvLyBpdGVyYXRvciBwcm90b2NvbFxuICAgICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHJldHVybiBkb25lID8geyB2YWx1ZSwgZG9uZSB9IDoge1xuICAgICAgICAgIHZhbHVlOiBpc1BhaXIgPyBbd3JhcCh2YWx1ZVswXSksIHdyYXAodmFsdWVbMV0pXSA6IHdyYXAodmFsdWUpLFxuICAgICAgICAgIGRvbmVcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICAvLyBpdGVyYWJsZSBwcm90b2NvbFxuICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSZWFkb25seU1ldGhvZCh0eXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGNvbnN0IGtleSA9IGFyZ3NbMF0gPyBgb24ga2V5IFwiJHthcmdzWzBdfVwiIGAgOiBgYDtcbiAgICAgIHdhcm4oXG4gICAgICAgIGAke2NhcGl0YWxpemUodHlwZSl9IG9wZXJhdGlvbiAke2tleX1mYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLFxuICAgICAgICB0b1Jhdyh0aGlzKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGUgPT09IFwiZGVsZXRlXCIgPyBmYWxzZSA6IHR5cGUgPT09IFwiY2xlYXJcIiA/IHZvaWQgMCA6IHRoaXM7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVJbnN0cnVtZW50YXRpb25zKHJlYWRvbmx5LCBzaGFsbG93KSB7XG4gIGNvbnN0IGluc3RydW1lbnRhdGlvbnMgPSB7XG4gICAgZ2V0KGtleSkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIl07XG4gICAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICAgICAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcbiAgICAgIGlmICghcmVhZG9ubHkpIHtcbiAgICAgICAgaWYgKGhhc0NoYW5nZWQoa2V5LCByYXdLZXkpKSB7XG4gICAgICAgICAgdHJhY2socmF3VGFyZ2V0LCBcImdldFwiLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJnZXRcIiwgcmF3S2V5KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgaGFzIH0gPSBnZXRQcm90byhyYXdUYXJnZXQpO1xuICAgICAgY29uc3Qgd3JhcCA9IHNoYWxsb3cgPyB0b1NoYWxsb3cgOiByZWFkb25seSA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xuICAgICAgaWYgKGhhcy5jYWxsKHJhd1RhcmdldCwga2V5KSkge1xuICAgICAgICByZXR1cm4gd3JhcCh0YXJnZXQuZ2V0KGtleSkpO1xuICAgICAgfSBlbHNlIGlmIChoYXMuY2FsbChyYXdUYXJnZXQsIHJhd0tleSkpIHtcbiAgICAgICAgcmV0dXJuIHdyYXAodGFyZ2V0LmdldChyYXdLZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0ICE9PSByYXdUYXJnZXQpIHtcbiAgICAgICAgdGFyZ2V0LmdldChrZXkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiXTtcbiAgICAgICFyZWFkb25seSAmJiB0cmFjayh0b1Jhdyh0YXJnZXQpLCBcIml0ZXJhdGVcIiwgSVRFUkFURV9LRVkpO1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgXCJzaXplXCIsIHRhcmdldCk7XG4gICAgfSxcbiAgICBoYXMoa2V5KSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiXTtcbiAgICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XG4gICAgICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xuICAgICAgaWYgKCFyZWFkb25seSkge1xuICAgICAgICBpZiAoaGFzQ2hhbmdlZChrZXksIHJhd0tleSkpIHtcbiAgICAgICAgICB0cmFjayhyYXdUYXJnZXQsIFwiaGFzXCIsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2socmF3VGFyZ2V0LCBcImhhc1wiLCByYXdLZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleSA9PT0gcmF3S2V5ID8gdGFyZ2V0LmhhcyhrZXkpIDogdGFyZ2V0LmhhcyhrZXkpIHx8IHRhcmdldC5oYXMocmF3S2V5KTtcbiAgICB9LFxuICAgIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIGNvbnN0IG9ic2VydmVkID0gdGhpcztcbiAgICAgIGNvbnN0IHRhcmdldCA9IG9ic2VydmVkW1wiX192X3Jhd1wiXTtcbiAgICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XG4gICAgICBjb25zdCB3cmFwID0gc2hhbGxvdyA/IHRvU2hhbGxvdyA6IHJlYWRvbmx5ID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XG4gICAgICAhcmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcIml0ZXJhdGVcIiwgSVRFUkFURV9LRVkpO1xuICAgICAgcmV0dXJuIHRhcmdldC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHdyYXAodmFsdWUpLCB3cmFwKGtleSksIG9ic2VydmVkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgZXh0ZW5kKFxuICAgIGluc3RydW1lbnRhdGlvbnMsXG4gICAgcmVhZG9ubHkgPyB7XG4gICAgICBhZGQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiYWRkXCIpLFxuICAgICAgc2V0OiBjcmVhdGVSZWFkb25seU1ldGhvZChcInNldFwiKSxcbiAgICAgIGRlbGV0ZTogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJkZWxldGVcIiksXG4gICAgICBjbGVhcjogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJjbGVhclwiKVxuICAgIH0gOiB7XG4gICAgICBhZGQodmFsdWUpIHtcbiAgICAgICAgaWYgKCFzaGFsbG93ICYmICFpc1NoYWxsb3codmFsdWUpICYmICFpc1JlYWRvbmx5KHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xuICAgICAgICBjb25zdCBwcm90byA9IGdldFByb3RvKHRhcmdldCk7XG4gICAgICAgIGNvbnN0IGhhZEtleSA9IHByb3RvLmhhcy5jYWxsKHRhcmdldCwgdmFsdWUpO1xuICAgICAgICBpZiAoIWhhZEtleSkge1xuICAgICAgICAgIHRhcmdldC5hZGQodmFsdWUpO1xuICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiLCB2YWx1ZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICghc2hhbGxvdyAmJiAhaXNTaGFsbG93KHZhbHVlKSAmJiAhaXNSZWFkb25seSh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyBoYXMsIGdldCB9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcbiAgICAgICAgbGV0IGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcbiAgICAgICAgaWYgKCFoYWRLZXkpIHtcbiAgICAgICAgICBrZXkgPSB0b1JhdyhrZXkpO1xuICAgICAgICAgIGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBnZXQuY2FsbCh0YXJnZXQsIGtleSk7XG4gICAgICAgIHRhcmdldC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIGlmICghaGFkS2V5KSB7XG4gICAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIsIGtleSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGhhc0NoYW5nZWQodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiLCBrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgZGVsZXRlKGtleSkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyBoYXMsIGdldCB9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcbiAgICAgICAgbGV0IGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcbiAgICAgICAgaWYgKCFoYWRLZXkpIHtcbiAgICAgICAgICBrZXkgPSB0b1JhdyhrZXkpO1xuICAgICAgICAgIGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBnZXQgPyBnZXQuY2FsbCh0YXJnZXQsIGtleSkgOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRhcmdldC5kZWxldGUoa2V5KTtcbiAgICAgICAgaWYgKGhhZEtleSkge1xuICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImRlbGV0ZVwiLCBrZXksIHZvaWQgMCwgb2xkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgY2xlYXIoKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xuICAgICAgICBjb25zdCBoYWRJdGVtcyA9IHRhcmdldC5zaXplICE9PSAwO1xuICAgICAgICBjb25zdCBvbGRUYXJnZXQgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gaXNNYXAodGFyZ2V0KSA/IG5ldyBNYXAodGFyZ2V0KSA6IG5ldyBTZXQodGFyZ2V0KSA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGFyZ2V0LmNsZWFyKCk7XG4gICAgICAgIGlmIChoYWRJdGVtcykge1xuICAgICAgICAgIHRyaWdnZXIoXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBcImNsZWFyXCIsXG4gICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICBvbGRUYXJnZXRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICApO1xuICBjb25zdCBpdGVyYXRvck1ldGhvZHMgPSBbXG4gICAgXCJrZXlzXCIsXG4gICAgXCJ2YWx1ZXNcIixcbiAgICBcImVudHJpZXNcIixcbiAgICBTeW1ib2wuaXRlcmF0b3JcbiAgXTtcbiAgaXRlcmF0b3JNZXRob2RzLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICAgIGluc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgcmVhZG9ubHksIHNoYWxsb3cpO1xuICB9KTtcbiAgcmV0dXJuIGluc3RydW1lbnRhdGlvbnM7XG59XG5mdW5jdGlvbiBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoaXNSZWFkb25seTIsIHNoYWxsb3cpIHtcbiAgY29uc3QgaW5zdHJ1bWVudGF0aW9ucyA9IGNyZWF0ZUluc3RydW1lbnRhdGlvbnMoaXNSZWFkb25seTIsIHNoYWxsb3cpO1xuICByZXR1cm4gKHRhcmdldCwga2V5LCByZWNlaXZlcikgPT4ge1xuICAgIGlmIChrZXkgPT09IFwiX192X2lzUmVhY3RpdmVcIikge1xuICAgICAgcmV0dXJuICFpc1JlYWRvbmx5MjtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiKSB7XG4gICAgICByZXR1cm4gaXNSZWFkb25seTI7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICByZXR1cm4gUmVmbGVjdC5nZXQoXG4gICAgICBoYXNPd24oaW5zdHJ1bWVudGF0aW9ucywga2V5KSAmJiBrZXkgaW4gdGFyZ2V0ID8gaW5zdHJ1bWVudGF0aW9ucyA6IHRhcmdldCxcbiAgICAgIGtleSxcbiAgICAgIHJlY2VpdmVyXG4gICAgKTtcbiAgfTtcbn1cbmNvbnN0IG11dGFibGVDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gIGdldDogLyogQF9fUFVSRV9fICovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihmYWxzZSwgZmFsc2UpXG59O1xuY29uc3Qgc2hhbGxvd0NvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgZ2V0OiAvKiBAX19QVVJFX18gKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGZhbHNlLCB0cnVlKVxufTtcbmNvbnN0IHJlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICBnZXQ6IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIodHJ1ZSwgZmFsc2UpXG59O1xuY29uc3Qgc2hhbGxvd1JlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICBnZXQ6IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIodHJ1ZSwgdHJ1ZSlcbn07XG5mdW5jdGlvbiBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhcywga2V5KSB7XG4gIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XG4gIGlmIChyYXdLZXkgIT09IGtleSAmJiBoYXMuY2FsbCh0YXJnZXQsIHJhd0tleSkpIHtcbiAgICBjb25zdCB0eXBlID0gdG9SYXdUeXBlKHRhcmdldCk7XG4gICAgd2FybihcbiAgICAgIGBSZWFjdGl2ZSAke3R5cGV9IGNvbnRhaW5zIGJvdGggdGhlIHJhdyBhbmQgcmVhY3RpdmUgdmVyc2lvbnMgb2YgdGhlIHNhbWUgb2JqZWN0JHt0eXBlID09PSBgTWFwYCA/IGAgYXMga2V5c2AgOiBgYH0sIHdoaWNoIGNhbiBsZWFkIHRvIGluY29uc2lzdGVuY2llcy4gQXZvaWQgZGlmZmVyZW50aWF0aW5nIGJldHdlZW4gdGhlIHJhdyBhbmQgcmVhY3RpdmUgdmVyc2lvbnMgb2YgYW4gb2JqZWN0IGFuZCBvbmx5IHVzZSB0aGUgcmVhY3RpdmUgdmVyc2lvbiBpZiBwb3NzaWJsZS5gXG4gICAgKTtcbiAgfVxufVxuXG5jb25zdCByZWFjdGl2ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3Qgc2hhbGxvd1JlYWN0aXZlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCByZWFkb25seU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3Qgc2hhbGxvd1JlYWRvbmx5TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiB0YXJnZXRUeXBlTWFwKHJhd1R5cGUpIHtcbiAgc3dpdGNoIChyYXdUeXBlKSB7XG4gICAgY2FzZSBcIk9iamVjdFwiOlxuICAgIGNhc2UgXCJBcnJheVwiOlxuICAgICAgcmV0dXJuIDEgLyogQ09NTU9OICovO1xuICAgIGNhc2UgXCJNYXBcIjpcbiAgICBjYXNlIFwiU2V0XCI6XG4gICAgY2FzZSBcIldlYWtNYXBcIjpcbiAgICBjYXNlIFwiV2Vha1NldFwiOlxuICAgICAgcmV0dXJuIDIgLyogQ09MTEVDVElPTiAqLztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIDAgLyogSU5WQUxJRCAqLztcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VGFyZ2V0VHlwZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWVbXCJfX3Zfc2tpcFwiXSB8fCAhT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgPyAwIC8qIElOVkFMSUQgKi8gOiB0YXJnZXRUeXBlTWFwKHRvUmF3VHlwZSh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gcmVhY3RpdmUodGFyZ2V0KSB7XG4gIGlmIChpc1JlYWRvbmx5KHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdChcbiAgICB0YXJnZXQsXG4gICAgZmFsc2UsXG4gICAgbXV0YWJsZUhhbmRsZXJzLFxuICAgIG11dGFibGVDb2xsZWN0aW9uSGFuZGxlcnMsXG4gICAgcmVhY3RpdmVNYXBcbiAgKTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dSZWFjdGl2ZSh0YXJnZXQpIHtcbiAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KFxuICAgIHRhcmdldCxcbiAgICBmYWxzZSxcbiAgICBzaGFsbG93UmVhY3RpdmVIYW5kbGVycyxcbiAgICBzaGFsbG93Q29sbGVjdGlvbkhhbmRsZXJzLFxuICAgIHNoYWxsb3dSZWFjdGl2ZU1hcFxuICApO1xufVxuZnVuY3Rpb24gcmVhZG9ubHkodGFyZ2V0KSB7XG4gIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdChcbiAgICB0YXJnZXQsXG4gICAgdHJ1ZSxcbiAgICByZWFkb25seUhhbmRsZXJzLFxuICAgIHJlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzLFxuICAgIHJlYWRvbmx5TWFwXG4gICk7XG59XG5mdW5jdGlvbiBzaGFsbG93UmVhZG9ubHkodGFyZ2V0KSB7XG4gIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdChcbiAgICB0YXJnZXQsXG4gICAgdHJ1ZSxcbiAgICBzaGFsbG93UmVhZG9ubHlIYW5kbGVycyxcbiAgICBzaGFsbG93UmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMsXG4gICAgc2hhbGxvd1JlYWRvbmx5TWFwXG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIGlzUmVhZG9ubHkyLCBiYXNlSGFuZGxlcnMsIGNvbGxlY3Rpb25IYW5kbGVycywgcHJveHlNYXApIHtcbiAgaWYgKCFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGB2YWx1ZSBjYW5ub3QgYmUgbWFkZSAke2lzUmVhZG9ubHkyID8gXCJyZWFkb25seVwiIDogXCJyZWFjdGl2ZVwifTogJHtTdHJpbmcoXG4gICAgICAgICAgdGFyZ2V0XG4gICAgICAgICl9YFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBpZiAodGFyZ2V0W1wiX192X3Jhd1wiXSAmJiAhKGlzUmVhZG9ubHkyICYmIHRhcmdldFtcIl9fdl9pc1JlYWN0aXZlXCJdKSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgY29uc3QgdGFyZ2V0VHlwZSA9IGdldFRhcmdldFR5cGUodGFyZ2V0KTtcbiAgaWYgKHRhcmdldFR5cGUgPT09IDAgLyogSU5WQUxJRCAqLykge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdQcm94eSA9IHByb3h5TWFwLmdldCh0YXJnZXQpO1xuICBpZiAoZXhpc3RpbmdQcm94eSkge1xuICAgIHJldHVybiBleGlzdGluZ1Byb3h5O1xuICB9XG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KFxuICAgIHRhcmdldCxcbiAgICB0YXJnZXRUeXBlID09PSAyIC8qIENPTExFQ1RJT04gKi8gPyBjb2xsZWN0aW9uSGFuZGxlcnMgOiBiYXNlSGFuZGxlcnNcbiAgKTtcbiAgcHJveHlNYXAuc2V0KHRhcmdldCwgcHJveHkpO1xuICByZXR1cm4gcHJveHk7XG59XG5mdW5jdGlvbiBpc1JlYWN0aXZlKHZhbHVlKSB7XG4gIGlmIChpc1JlYWRvbmx5KHZhbHVlKSkge1xuICAgIHJldHVybiBpc1JlYWN0aXZlKHZhbHVlW1wiX192X3Jhd1wiXSk7XG4gIH1cbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzUmVhY3RpdmVcIl0pO1xufVxuZnVuY3Rpb24gaXNSZWFkb25seSh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNSZWFkb25seVwiXSk7XG59XG5mdW5jdGlvbiBpc1NoYWxsb3codmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzU2hhbGxvd1wiXSk7XG59XG5mdW5jdGlvbiBpc1Byb3h5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA/ICEhdmFsdWVbXCJfX3ZfcmF3XCJdIDogZmFsc2U7XG59XG5mdW5jdGlvbiB0b1JhdyhvYnNlcnZlZCkge1xuICBjb25zdCByYXcgPSBvYnNlcnZlZCAmJiBvYnNlcnZlZFtcIl9fdl9yYXdcIl07XG4gIHJldHVybiByYXcgPyB0b1JhdyhyYXcpIDogb2JzZXJ2ZWQ7XG59XG5mdW5jdGlvbiBtYXJrUmF3KHZhbHVlKSB7XG4gIGlmICghaGFzT3duKHZhbHVlLCBcIl9fdl9za2lwXCIpICYmIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpKSB7XG4gICAgZGVmKHZhbHVlLCBcIl9fdl9za2lwXCIsIHRydWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmNvbnN0IHRvUmVhY3RpdmUgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSA/IHJlYWN0aXZlKHZhbHVlKSA6IHZhbHVlO1xuY29uc3QgdG9SZWFkb25seSA9ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpID8gcmVhZG9ubHkodmFsdWUpIDogdmFsdWU7XG5cbmZ1bmN0aW9uIGlzUmVmKHIpIHtcbiAgcmV0dXJuIHIgPyByW1wiX192X2lzUmVmXCJdID09PSB0cnVlIDogZmFsc2U7XG59XG5mdW5jdGlvbiByZWYodmFsdWUpIHtcbiAgcmV0dXJuIGNyZWF0ZVJlZih2YWx1ZSwgZmFsc2UpO1xufVxuZnVuY3Rpb24gc2hhbGxvd1JlZih2YWx1ZSkge1xuICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlZihyYXdWYWx1ZSwgc2hhbGxvdykge1xuICBpZiAoaXNSZWYocmF3VmFsdWUpKSB7XG4gICAgcmV0dXJuIHJhd1ZhbHVlO1xuICB9XG4gIHJldHVybiBuZXcgUmVmSW1wbChyYXdWYWx1ZSwgc2hhbGxvdyk7XG59XG5jbGFzcyBSZWZJbXBsIHtcbiAgY29uc3RydWN0b3IodmFsdWUsIGlzU2hhbGxvdzIpIHtcbiAgICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgICB0aGlzW1wiX192X2lzUmVmXCJdID0gdHJ1ZTtcbiAgICB0aGlzW1wiX192X2lzU2hhbGxvd1wiXSA9IGZhbHNlO1xuICAgIHRoaXMuX3Jhd1ZhbHVlID0gaXNTaGFsbG93MiA/IHZhbHVlIDogdG9SYXcodmFsdWUpO1xuICAgIHRoaXMuX3ZhbHVlID0gaXNTaGFsbG93MiA/IHZhbHVlIDogdG9SZWFjdGl2ZSh2YWx1ZSk7XG4gICAgdGhpc1tcIl9fdl9pc1NoYWxsb3dcIl0gPSBpc1NoYWxsb3cyO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgdGhpcy5kZXAudHJhY2soe1xuICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiZ2V0XCIsXG4gICAgICAgIGtleTogXCJ2YWx1ZVwiXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZXAudHJhY2soKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG4gIHNldCB2YWx1ZShuZXdWYWx1ZSkge1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fcmF3VmFsdWU7XG4gICAgY29uc3QgdXNlRGlyZWN0VmFsdWUgPSB0aGlzW1wiX192X2lzU2hhbGxvd1wiXSB8fCBpc1NoYWxsb3cobmV3VmFsdWUpIHx8IGlzUmVhZG9ubHkobmV3VmFsdWUpO1xuICAgIG5ld1ZhbHVlID0gdXNlRGlyZWN0VmFsdWUgPyBuZXdWYWx1ZSA6IHRvUmF3KG5ld1ZhbHVlKTtcbiAgICBpZiAoaGFzQ2hhbmdlZChuZXdWYWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICB0aGlzLl9yYXdWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgdGhpcy5fdmFsdWUgPSB1c2VEaXJlY3RWYWx1ZSA/IG5ld1ZhbHVlIDogdG9SZWFjdGl2ZShuZXdWYWx1ZSk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICB0aGlzLmRlcC50cmlnZ2VyKHtcbiAgICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAgICBrZXk6IFwidmFsdWVcIixcbiAgICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgICBvbGRWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVwLnRyaWdnZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXJSZWYocmVmMikge1xuICBpZiAocmVmMi5kZXApIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgcmVmMi5kZXAudHJpZ2dlcih7XG4gICAgICAgIHRhcmdldDogcmVmMixcbiAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAga2V5OiBcInZhbHVlXCIsXG4gICAgICAgIG5ld1ZhbHVlOiByZWYyLl92YWx1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZjIuZGVwLnRyaWdnZXIoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHVucmVmKHJlZjIpIHtcbiAgcmV0dXJuIGlzUmVmKHJlZjIpID8gcmVmMi52YWx1ZSA6IHJlZjI7XG59XG5mdW5jdGlvbiB0b1ZhbHVlKHNvdXJjZSkge1xuICByZXR1cm4gaXNGdW5jdGlvbihzb3VyY2UpID8gc291cmNlKCkgOiB1bnJlZihzb3VyY2UpO1xufVxuY29uc3Qgc2hhbGxvd1Vud3JhcEhhbmRsZXJzID0ge1xuICBnZXQ6ICh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpID0+IGtleSA9PT0gXCJfX3ZfcmF3XCIgPyB0YXJnZXQgOiB1bnJlZihSZWZsZWN0LmdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpKSxcbiAgc2V0OiAodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikgPT4ge1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgaWYgKGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XG4gICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBwcm94eVJlZnMob2JqZWN0V2l0aFJlZnMpIHtcbiAgcmV0dXJuIGlzUmVhY3RpdmUob2JqZWN0V2l0aFJlZnMpID8gb2JqZWN0V2l0aFJlZnMgOiBuZXcgUHJveHkob2JqZWN0V2l0aFJlZnMsIHNoYWxsb3dVbndyYXBIYW5kbGVycyk7XG59XG5jbGFzcyBDdXN0b21SZWZJbXBsIHtcbiAgY29uc3RydWN0b3IoZmFjdG9yeSkge1xuICAgIHRoaXNbXCJfX3ZfaXNSZWZcIl0gPSB0cnVlO1xuICAgIHRoaXMuX3ZhbHVlID0gdm9pZCAwO1xuICAgIGNvbnN0IGRlcCA9IHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICAgIGNvbnN0IHsgZ2V0LCBzZXQgfSA9IGZhY3RvcnkoZGVwLnRyYWNrLmJpbmQoZGVwKSwgZGVwLnRyaWdnZXIuYmluZChkZXApKTtcbiAgICB0aGlzLl9nZXQgPSBnZXQ7XG4gICAgdGhpcy5fc2V0ID0gc2V0O1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWUgPSB0aGlzLl9nZXQoKTtcbiAgfVxuICBzZXQgdmFsdWUobmV3VmFsKSB7XG4gICAgdGhpcy5fc2V0KG5ld1ZhbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGN1c3RvbVJlZihmYWN0b3J5KSB7XG4gIHJldHVybiBuZXcgQ3VzdG9tUmVmSW1wbChmYWN0b3J5KTtcbn1cbmZ1bmN0aW9uIHRvUmVmcyhvYmplY3QpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzUHJveHkob2JqZWN0KSkge1xuICAgIHdhcm4oYHRvUmVmcygpIGV4cGVjdHMgYSByZWFjdGl2ZSBvYmplY3QgYnV0IHJlY2VpdmVkIGEgcGxhaW4gb25lLmApO1xuICB9XG4gIGNvbnN0IHJldCA9IGlzQXJyYXkob2JqZWN0KSA/IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKSA6IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICByZXRba2V5XSA9IHByb3BlcnR5VG9SZWYob2JqZWN0LCBrZXkpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5jbGFzcyBPYmplY3RSZWZJbXBsIHtcbiAgY29uc3RydWN0b3IoX29iamVjdCwgX2tleSwgX2RlZmF1bHRWYWx1ZSkge1xuICAgIHRoaXMuX29iamVjdCA9IF9vYmplY3Q7XG4gICAgdGhpcy5fa2V5ID0gX2tleTtcbiAgICB0aGlzLl9kZWZhdWx0VmFsdWUgPSBfZGVmYXVsdFZhbHVlO1xuICAgIHRoaXNbXCJfX3ZfaXNSZWZcIl0gPSB0cnVlO1xuICAgIHRoaXMuX3ZhbHVlID0gdm9pZCAwO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICBjb25zdCB2YWwgPSB0aGlzLl9vYmplY3RbdGhpcy5fa2V5XTtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWUgPSB2YWwgPT09IHZvaWQgMCA/IHRoaXMuX2RlZmF1bHRWYWx1ZSA6IHZhbDtcbiAgfVxuICBzZXQgdmFsdWUobmV3VmFsKSB7XG4gICAgdGhpcy5fb2JqZWN0W3RoaXMuX2tleV0gPSBuZXdWYWw7XG4gIH1cbiAgZ2V0IGRlcCgpIHtcbiAgICByZXR1cm4gZ2V0RGVwRnJvbVJlYWN0aXZlKHRvUmF3KHRoaXMuX29iamVjdCksIHRoaXMuX2tleSk7XG4gIH1cbn1cbmNsYXNzIEdldHRlclJlZkltcGwge1xuICBjb25zdHJ1Y3RvcihfZ2V0dGVyKSB7XG4gICAgdGhpcy5fZ2V0dGVyID0gX2dldHRlcjtcbiAgICB0aGlzW1wiX192X2lzUmVmXCJdID0gdHJ1ZTtcbiAgICB0aGlzW1wiX192X2lzUmVhZG9ubHlcIl0gPSB0cnVlO1xuICAgIHRoaXMuX3ZhbHVlID0gdm9pZCAwO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWUgPSB0aGlzLl9nZXR0ZXIoKTtcbiAgfVxufVxuZnVuY3Rpb24gdG9SZWYoc291cmNlLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAoaXNSZWYoc291cmNlKSkge1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihzb3VyY2UpKSB7XG4gICAgcmV0dXJuIG5ldyBHZXR0ZXJSZWZJbXBsKHNvdXJjZSk7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3Qoc291cmNlKSAmJiBhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBwcm9wZXJ0eVRvUmVmKHNvdXJjZSwga2V5LCBkZWZhdWx0VmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZWYoc291cmNlKTtcbiAgfVxufVxuZnVuY3Rpb24gcHJvcGVydHlUb1JlZihzb3VyY2UsIGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gIGNvbnN0IHZhbCA9IHNvdXJjZVtrZXldO1xuICByZXR1cm4gaXNSZWYodmFsKSA/IHZhbCA6IG5ldyBPYmplY3RSZWZJbXBsKHNvdXJjZSwga2V5LCBkZWZhdWx0VmFsdWUpO1xufVxuXG5jbGFzcyBDb21wdXRlZFJlZkltcGwge1xuICBjb25zdHJ1Y3Rvcihmbiwgc2V0dGVyLCBpc1NTUikge1xuICAgIHRoaXMuZm4gPSBmbjtcbiAgICB0aGlzLnNldHRlciA9IHNldHRlcjtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLl92YWx1ZSA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmRlcCA9IG5ldyBEZXAodGhpcyk7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xuICAgIC8vIFRPRE8gaXNvbGF0ZWREZWNsYXJhdGlvbnMgXCJfX3ZfaXNSZWFkb25seVwiXG4gICAgLy8gQSBjb21wdXRlZCBpcyBhbHNvIGEgc3Vic2NyaWJlciB0aGF0IHRyYWNrcyBvdGhlciBkZXBzXG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5kZXBzID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZGVwc1RhaWwgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5mbGFncyA9IDE2O1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZ2xvYmFsVmVyc2lvbiA9IGdsb2JhbFZlcnNpb24gLSAxO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMubmV4dCA9IHZvaWQgMDtcbiAgICAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICAgIHRoaXMuZWZmZWN0ID0gdGhpcztcbiAgICB0aGlzW1wiX192X2lzUmVhZG9ubHlcIl0gPSAhc2V0dGVyO1xuICAgIHRoaXMuaXNTU1IgPSBpc1NTUjtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBub3RpZnkoKSB7XG4gICAgdGhpcy5mbGFncyB8PSAxNjtcbiAgICBpZiAoISh0aGlzLmZsYWdzICYgOCkgJiYgLy8gYXZvaWQgaW5maW5pdGUgc2VsZiByZWN1cnNpb25cbiAgICBhY3RpdmVTdWIgIT09IHRoaXMpIHtcbiAgICAgIGJhdGNoKHRoaXMsIHRydWUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSA7XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIGNvbnN0IGxpbmsgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gdGhpcy5kZXAudHJhY2soe1xuICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgdHlwZTogXCJnZXRcIixcbiAgICAgIGtleTogXCJ2YWx1ZVwiXG4gICAgfSkgOiB0aGlzLmRlcC50cmFjaygpO1xuICAgIHJlZnJlc2hDb21wdXRlZCh0aGlzKTtcbiAgICBpZiAobGluaykge1xuICAgICAgbGluay52ZXJzaW9uID0gdGhpcy5kZXAudmVyc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG4gIHNldCB2YWx1ZShuZXdWYWx1ZSkge1xuICAgIGlmICh0aGlzLnNldHRlcikge1xuICAgICAgdGhpcy5zZXR0ZXIobmV3VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihcIldyaXRlIG9wZXJhdGlvbiBmYWlsZWQ6IGNvbXB1dGVkIHZhbHVlIGlzIHJlYWRvbmx5XCIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZWQoZ2V0dGVyT3JPcHRpb25zLCBkZWJ1Z09wdGlvbnMsIGlzU1NSID0gZmFsc2UpIHtcbiAgbGV0IGdldHRlcjtcbiAgbGV0IHNldHRlcjtcbiAgaWYgKGlzRnVuY3Rpb24oZ2V0dGVyT3JPcHRpb25zKSkge1xuICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucztcbiAgfSBlbHNlIHtcbiAgICBnZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnMuZ2V0O1xuICAgIHNldHRlciA9IGdldHRlck9yT3B0aW9ucy5zZXQ7XG4gIH1cbiAgY29uc3QgY1JlZiA9IG5ldyBDb21wdXRlZFJlZkltcGwoZ2V0dGVyLCBzZXR0ZXIsIGlzU1NSKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgZGVidWdPcHRpb25zICYmICFpc1NTUikge1xuICAgIGNSZWYub25UcmFjayA9IGRlYnVnT3B0aW9ucy5vblRyYWNrO1xuICAgIGNSZWYub25UcmlnZ2VyID0gZGVidWdPcHRpb25zLm9uVHJpZ2dlcjtcbiAgfVxuICByZXR1cm4gY1JlZjtcbn1cblxuY29uc3QgVHJhY2tPcFR5cGVzID0ge1xuICBcIkdFVFwiOiBcImdldFwiLFxuICBcIkhBU1wiOiBcImhhc1wiLFxuICBcIklURVJBVEVcIjogXCJpdGVyYXRlXCJcbn07XG5jb25zdCBUcmlnZ2VyT3BUeXBlcyA9IHtcbiAgXCJTRVRcIjogXCJzZXRcIixcbiAgXCJBRERcIjogXCJhZGRcIixcbiAgXCJERUxFVEVcIjogXCJkZWxldGVcIixcbiAgXCJDTEVBUlwiOiBcImNsZWFyXCJcbn07XG5jb25zdCBSZWFjdGl2ZUZsYWdzID0ge1xuICBcIlNLSVBcIjogXCJfX3Zfc2tpcFwiLFxuICBcIklTX1JFQUNUSVZFXCI6IFwiX192X2lzUmVhY3RpdmVcIixcbiAgXCJJU19SRUFET05MWVwiOiBcIl9fdl9pc1JlYWRvbmx5XCIsXG4gIFwiSVNfU0hBTExPV1wiOiBcIl9fdl9pc1NoYWxsb3dcIixcbiAgXCJSQVdcIjogXCJfX3ZfcmF3XCIsXG4gIFwiSVNfUkVGXCI6IFwiX192X2lzUmVmXCJcbn07XG5cbmNvbnN0IFdhdGNoRXJyb3JDb2RlcyA9IHtcbiAgXCJXQVRDSF9HRVRURVJcIjogMixcbiAgXCIyXCI6IFwiV0FUQ0hfR0VUVEVSXCIsXG4gIFwiV0FUQ0hfQ0FMTEJBQ0tcIjogMyxcbiAgXCIzXCI6IFwiV0FUQ0hfQ0FMTEJBQ0tcIixcbiAgXCJXQVRDSF9DTEVBTlVQXCI6IDQsXG4gIFwiNFwiOiBcIldBVENIX0NMRUFOVVBcIlxufTtcbmNvbnN0IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA9IHt9O1xuY29uc3QgY2xlYW51cE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xubGV0IGFjdGl2ZVdhdGNoZXIgPSB2b2lkIDA7XG5mdW5jdGlvbiBnZXRDdXJyZW50V2F0Y2hlcigpIHtcbiAgcmV0dXJuIGFjdGl2ZVdhdGNoZXI7XG59XG5mdW5jdGlvbiBvbldhdGNoZXJDbGVhbnVwKGNsZWFudXBGbiwgZmFpbFNpbGVudGx5ID0gZmFsc2UsIG93bmVyID0gYWN0aXZlV2F0Y2hlcikge1xuICBpZiAob3duZXIpIHtcbiAgICBsZXQgY2xlYW51cHMgPSBjbGVhbnVwTWFwLmdldChvd25lcik7XG4gICAgaWYgKCFjbGVhbnVwcykgY2xlYW51cE1hcC5zZXQob3duZXIsIGNsZWFudXBzID0gW10pO1xuICAgIGNsZWFudXBzLnB1c2goY2xlYW51cEZuKTtcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFmYWlsU2lsZW50bHkpIHtcbiAgICB3YXJuKFxuICAgICAgYG9uV2F0Y2hlckNsZWFudXAoKSB3YXMgY2FsbGVkIHdoZW4gdGhlcmUgd2FzIG5vIGFjdGl2ZSB3YXRjaGVyIHRvIGFzc29jaWF0ZSB3aXRoLmBcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiB3YXRjaChzb3VyY2UsIGNiLCBvcHRpb25zID0gRU1QVFlfT0JKKSB7XG4gIGNvbnN0IHsgaW1tZWRpYXRlLCBkZWVwLCBvbmNlLCBzY2hlZHVsZXIsIGF1Z21lbnRKb2IsIGNhbGwgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHdhcm5JbnZhbGlkU291cmNlID0gKHMpID0+IHtcbiAgICAob3B0aW9ucy5vbldhcm4gfHwgd2FybikoXG4gICAgICBgSW52YWxpZCB3YXRjaCBzb3VyY2U6IGAsXG4gICAgICBzLFxuICAgICAgYEEgd2F0Y2ggc291cmNlIGNhbiBvbmx5IGJlIGEgZ2V0dGVyL2VmZmVjdCBmdW5jdGlvbiwgYSByZWYsIGEgcmVhY3RpdmUgb2JqZWN0LCBvciBhbiBhcnJheSBvZiB0aGVzZSB0eXBlcy5gXG4gICAgKTtcbiAgfTtcbiAgY29uc3QgcmVhY3RpdmVHZXR0ZXIgPSAoc291cmNlMikgPT4ge1xuICAgIGlmIChkZWVwKSByZXR1cm4gc291cmNlMjtcbiAgICBpZiAoaXNTaGFsbG93KHNvdXJjZTIpIHx8IGRlZXAgPT09IGZhbHNlIHx8IGRlZXAgPT09IDApXG4gICAgICByZXR1cm4gdHJhdmVyc2Uoc291cmNlMiwgMSk7XG4gICAgcmV0dXJuIHRyYXZlcnNlKHNvdXJjZTIpO1xuICB9O1xuICBsZXQgZWZmZWN0O1xuICBsZXQgZ2V0dGVyO1xuICBsZXQgY2xlYW51cDtcbiAgbGV0IGJvdW5kQ2xlYW51cDtcbiAgbGV0IGZvcmNlVHJpZ2dlciA9IGZhbHNlO1xuICBsZXQgaXNNdWx0aVNvdXJjZSA9IGZhbHNlO1xuICBpZiAoaXNSZWYoc291cmNlKSkge1xuICAgIGdldHRlciA9ICgpID0+IHNvdXJjZS52YWx1ZTtcbiAgICBmb3JjZVRyaWdnZXIgPSBpc1NoYWxsb3coc291cmNlKTtcbiAgfSBlbHNlIGlmIChpc1JlYWN0aXZlKHNvdXJjZSkpIHtcbiAgICBnZXR0ZXIgPSAoKSA9PiByZWFjdGl2ZUdldHRlcihzb3VyY2UpO1xuICAgIGZvcmNlVHJpZ2dlciA9IHRydWU7XG4gIH0gZWxzZSBpZiAoaXNBcnJheShzb3VyY2UpKSB7XG4gICAgaXNNdWx0aVNvdXJjZSA9IHRydWU7XG4gICAgZm9yY2VUcmlnZ2VyID0gc291cmNlLnNvbWUoKHMpID0+IGlzUmVhY3RpdmUocykgfHwgaXNTaGFsbG93KHMpKTtcbiAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UubWFwKChzKSA9PiB7XG4gICAgICBpZiAoaXNSZWYocykpIHtcbiAgICAgICAgcmV0dXJuIHMudmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKGlzUmVhY3RpdmUocykpIHtcbiAgICAgICAgcmV0dXJuIHJlYWN0aXZlR2V0dGVyKHMpO1xuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHMpKSB7XG4gICAgICAgIHJldHVybiBjYWxsID8gY2FsbChzLCAyKSA6IHMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybkludmFsaWRTb3VyY2Uocyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihzb3VyY2UpKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBnZXR0ZXIgPSBjYWxsID8gKCkgPT4gY2FsbChzb3VyY2UsIDIpIDogc291cmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZXR0ZXIgPSAoKSA9PiB7XG4gICAgICAgIGlmIChjbGVhbnVwKSB7XG4gICAgICAgICAgcGF1c2VUcmFja2luZygpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudEVmZmVjdCA9IGFjdGl2ZVdhdGNoZXI7XG4gICAgICAgIGFjdGl2ZVdhdGNoZXIgPSBlZmZlY3Q7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGwgPyBjYWxsKHNvdXJjZSwgMywgW2JvdW5kQ2xlYW51cF0pIDogc291cmNlKGJvdW5kQ2xlYW51cCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgYWN0aXZlV2F0Y2hlciA9IGN1cnJlbnRFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGdldHRlciA9IE5PT1A7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuSW52YWxpZFNvdXJjZShzb3VyY2UpO1xuICB9XG4gIGlmIChjYiAmJiBkZWVwKSB7XG4gICAgY29uc3QgYmFzZUdldHRlciA9IGdldHRlcjtcbiAgICBjb25zdCBkZXB0aCA9IGRlZXAgPT09IHRydWUgPyBJbmZpbml0eSA6IGRlZXA7XG4gICAgZ2V0dGVyID0gKCkgPT4gdHJhdmVyc2UoYmFzZUdldHRlcigpLCBkZXB0aCk7XG4gIH1cbiAgY29uc3Qgc2NvcGUgPSBnZXRDdXJyZW50U2NvcGUoKTtcbiAgY29uc3Qgd2F0Y2hIYW5kbGUgPSAoKSA9PiB7XG4gICAgZWZmZWN0LnN0b3AoKTtcbiAgICBpZiAoc2NvcGUgJiYgc2NvcGUuYWN0aXZlKSB7XG4gICAgICByZW1vdmUoc2NvcGUuZWZmZWN0cywgZWZmZWN0KTtcbiAgICB9XG4gIH07XG4gIGlmIChvbmNlICYmIGNiKSB7XG4gICAgY29uc3QgX2NiID0gY2I7XG4gICAgY2IgPSAoLi4uYXJncykgPT4ge1xuICAgICAgX2NiKC4uLmFyZ3MpO1xuICAgICAgd2F0Y2hIYW5kbGUoKTtcbiAgICB9O1xuICB9XG4gIGxldCBvbGRWYWx1ZSA9IGlzTXVsdGlTb3VyY2UgPyBuZXcgQXJyYXkoc291cmNlLmxlbmd0aCkuZmlsbChJTklUSUFMX1dBVENIRVJfVkFMVUUpIDogSU5JVElBTF9XQVRDSEVSX1ZBTFVFO1xuICBjb25zdCBqb2IgPSAoaW1tZWRpYXRlRmlyc3RSdW4pID0+IHtcbiAgICBpZiAoIShlZmZlY3QuZmxhZ3MgJiAxKSB8fCAhZWZmZWN0LmRpcnR5ICYmICFpbW1lZGlhdGVGaXJzdFJ1bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2IpIHtcbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0gZWZmZWN0LnJ1bigpO1xuICAgICAgaWYgKGRlZXAgfHwgZm9yY2VUcmlnZ2VyIHx8IChpc011bHRpU291cmNlID8gbmV3VmFsdWUuc29tZSgodiwgaSkgPT4gaGFzQ2hhbmdlZCh2LCBvbGRWYWx1ZVtpXSkpIDogaGFzQ2hhbmdlZChuZXdWYWx1ZSwgb2xkVmFsdWUpKSkge1xuICAgICAgICBpZiAoY2xlYW51cCkge1xuICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50V2F0Y2hlciA9IGFjdGl2ZVdhdGNoZXI7XG4gICAgICAgIGFjdGl2ZVdhdGNoZXIgPSBlZmZlY3Q7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgYXJncyA9IFtcbiAgICAgICAgICAgIG5ld1ZhbHVlLFxuICAgICAgICAgICAgLy8gcGFzcyB1bmRlZmluZWQgYXMgdGhlIG9sZCB2YWx1ZSB3aGVuIGl0J3MgY2hhbmdlZCBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgICAgIG9sZFZhbHVlID09PSBJTklUSUFMX1dBVENIRVJfVkFMVUUgPyB2b2lkIDAgOiBpc011bHRpU291cmNlICYmIG9sZFZhbHVlWzBdID09PSBJTklUSUFMX1dBVENIRVJfVkFMVUUgPyBbXSA6IG9sZFZhbHVlLFxuICAgICAgICAgICAgYm91bmRDbGVhbnVwXG4gICAgICAgICAgXTtcbiAgICAgICAgICBvbGRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgIGNhbGwgPyBjYWxsKGNiLCAzLCBhcmdzKSA6IChcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIGNiKC4uLmFyZ3MpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBhY3RpdmVXYXRjaGVyID0gY3VycmVudFdhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWZmZWN0LnJ1bigpO1xuICAgIH1cbiAgfTtcbiAgaWYgKGF1Z21lbnRKb2IpIHtcbiAgICBhdWdtZW50Sm9iKGpvYik7XG4gIH1cbiAgZWZmZWN0ID0gbmV3IFJlYWN0aXZlRWZmZWN0KGdldHRlcik7XG4gIGVmZmVjdC5zY2hlZHVsZXIgPSBzY2hlZHVsZXIgPyAoKSA9PiBzY2hlZHVsZXIoam9iLCBmYWxzZSkgOiBqb2I7XG4gIGJvdW5kQ2xlYW51cCA9IChmbikgPT4gb25XYXRjaGVyQ2xlYW51cChmbiwgZmFsc2UsIGVmZmVjdCk7XG4gIGNsZWFudXAgPSBlZmZlY3Qub25TdG9wID0gKCkgPT4ge1xuICAgIGNvbnN0IGNsZWFudXBzID0gY2xlYW51cE1hcC5nZXQoZWZmZWN0KTtcbiAgICBpZiAoY2xlYW51cHMpIHtcbiAgICAgIGlmIChjYWxsKSB7XG4gICAgICAgIGNhbGwoY2xlYW51cHMsIDQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBjbGVhbnVwMiBvZiBjbGVhbnVwcykgY2xlYW51cDIoKTtcbiAgICAgIH1cbiAgICAgIGNsZWFudXBNYXAuZGVsZXRlKGVmZmVjdCk7XG4gICAgfVxuICB9O1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGVmZmVjdC5vblRyYWNrID0gb3B0aW9ucy5vblRyYWNrO1xuICAgIGVmZmVjdC5vblRyaWdnZXIgPSBvcHRpb25zLm9uVHJpZ2dlcjtcbiAgfVxuICBpZiAoY2IpIHtcbiAgICBpZiAoaW1tZWRpYXRlKSB7XG4gICAgICBqb2IodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9sZFZhbHVlID0gZWZmZWN0LnJ1bigpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzY2hlZHVsZXIpIHtcbiAgICBzY2hlZHVsZXIoam9iLmJpbmQobnVsbCwgdHJ1ZSksIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGVmZmVjdC5ydW4oKTtcbiAgfVxuICB3YXRjaEhhbmRsZS5wYXVzZSA9IGVmZmVjdC5wYXVzZS5iaW5kKGVmZmVjdCk7XG4gIHdhdGNoSGFuZGxlLnJlc3VtZSA9IGVmZmVjdC5yZXN1bWUuYmluZChlZmZlY3QpO1xuICB3YXRjaEhhbmRsZS5zdG9wID0gd2F0Y2hIYW5kbGU7XG4gIHJldHVybiB3YXRjaEhhbmRsZTtcbn1cbmZ1bmN0aW9uIHRyYXZlcnNlKHZhbHVlLCBkZXB0aCA9IEluZmluaXR5LCBzZWVuKSB7XG4gIGlmIChkZXB0aCA8PSAwIHx8ICFpc09iamVjdCh2YWx1ZSkgfHwgdmFsdWVbXCJfX3Zfc2tpcFwiXSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBzZWVuID0gc2VlbiB8fCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBpZiAoc2Vlbi5oYXModmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHNlZW4uYWRkKHZhbHVlKTtcbiAgZGVwdGgtLTtcbiAgaWYgKGlzUmVmKHZhbHVlKSkge1xuICAgIHRyYXZlcnNlKHZhbHVlLnZhbHVlLCBkZXB0aCwgc2Vlbik7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZVtpXSwgZGVwdGgsIHNlZW4pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1NldCh2YWx1ZSkgfHwgaXNNYXAodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaCgodikgPT4ge1xuICAgICAgdHJhdmVyc2UodiwgZGVwdGgsIHNlZW4pO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIHRyYXZlcnNlKHZhbHVlW2tleV0sIGRlcHRoLCBzZWVuKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh2YWx1ZSkpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgICAgdHJhdmVyc2UodmFsdWVba2V5XSwgZGVwdGgsIHNlZW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCB7IEFSUkFZX0lURVJBVEVfS0VZLCBFZmZlY3RGbGFncywgRWZmZWN0U2NvcGUsIElURVJBVEVfS0VZLCBNQVBfS0VZX0lURVJBVEVfS0VZLCBSZWFjdGl2ZUVmZmVjdCwgUmVhY3RpdmVGbGFncywgVHJhY2tPcFR5cGVzLCBUcmlnZ2VyT3BUeXBlcywgV2F0Y2hFcnJvckNvZGVzLCBjb21wdXRlZCwgY3VzdG9tUmVmLCBlZmZlY3QsIGVmZmVjdFNjb3BlLCBlbmFibGVUcmFja2luZywgZ2V0Q3VycmVudFNjb3BlLCBnZXRDdXJyZW50V2F0Y2hlciwgaXNQcm94eSwgaXNSZWFjdGl2ZSwgaXNSZWFkb25seSwgaXNSZWYsIGlzU2hhbGxvdywgbWFya1Jhdywgb25FZmZlY3RDbGVhbnVwLCBvblNjb3BlRGlzcG9zZSwgb25XYXRjaGVyQ2xlYW51cCwgcGF1c2VUcmFja2luZywgcHJveHlSZWZzLCByZWFjdGl2ZSwgcmVhY3RpdmVSZWFkQXJyYXksIHJlYWRvbmx5LCByZWYsIHJlc2V0VHJhY2tpbmcsIHNoYWxsb3dSZWFjdGl2ZSwgc2hhbGxvd1JlYWRBcnJheSwgc2hhbGxvd1JlYWRvbmx5LCBzaGFsbG93UmVmLCBzdG9wLCB0b1JhdywgdG9SZWFjdGl2ZSwgdG9SZWFkb25seSwgdG9SZWYsIHRvUmVmcywgdG9WYWx1ZSwgdHJhY2ssIHRyYXZlcnNlLCB0cmlnZ2VyLCB0cmlnZ2VyUmVmLCB1bnJlZiwgd2F0Y2ggfTtcbiIsIi8qKlxuKiBAdnVlL3NoYXJlZCB2My41LjE2XG4qIChjKSAyMDE4LXByZXNlbnQgWXV4aSAoRXZhbikgWW91IGFuZCBWdWUgY29udHJpYnV0b3JzXG4qIEBsaWNlbnNlIE1JVFxuKiovXG4vKiEgI19fTk9fU0lERV9FRkZFQ1RTX18gKi9cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBtYWtlTWFwKHN0cikge1xuICBjb25zdCBtYXAgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yIChjb25zdCBrZXkgb2Ygc3RyLnNwbGl0KFwiLFwiKSkgbWFwW2tleV0gPSAxO1xuICByZXR1cm4gKHZhbCkgPT4gdmFsIGluIG1hcDtcbn1cblxuY29uc3QgRU1QVFlfT0JKID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IE9iamVjdC5mcmVlemUoe30pIDoge307XG5jb25zdCBFTVBUWV9BUlIgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gT2JqZWN0LmZyZWV6ZShbXSkgOiBbXTtcbmNvbnN0IE5PT1AgPSAoKSA9PiB7XG59O1xuY29uc3QgTk8gPSAoKSA9PiBmYWxzZTtcbmNvbnN0IGlzT24gPSAoa2V5KSA9PiBrZXkuY2hhckNvZGVBdCgwKSA9PT0gMTExICYmIGtleS5jaGFyQ29kZUF0KDEpID09PSAxMTAgJiYgLy8gdXBwZXJjYXNlIGxldHRlclxuKGtleS5jaGFyQ29kZUF0KDIpID4gMTIyIHx8IGtleS5jaGFyQ29kZUF0KDIpIDwgOTcpO1xuY29uc3QgaXNNb2RlbExpc3RlbmVyID0gKGtleSkgPT4ga2V5LnN0YXJ0c1dpdGgoXCJvblVwZGF0ZTpcIik7XG5jb25zdCBleHRlbmQgPSBPYmplY3QuYXNzaWduO1xuY29uc3QgcmVtb3ZlID0gKGFyciwgZWwpID0+IHtcbiAgY29uc3QgaSA9IGFyci5pbmRleE9mKGVsKTtcbiAgaWYgKGkgPiAtMSkge1xuICAgIGFyci5zcGxpY2UoaSwgMSk7XG4gIH1cbn07XG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5jb25zdCBoYXNPd24gPSAodmFsLCBrZXkpID0+IGhhc093blByb3BlcnR5LmNhbGwodmFsLCBrZXkpO1xuY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5jb25zdCBpc01hcCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgTWFwXVwiO1xuY29uc3QgaXNTZXQgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IFNldF1cIjtcbmNvbnN0IGlzRGF0ZSA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgRGF0ZV1cIjtcbmNvbnN0IGlzUmVnRXhwID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBSZWdFeHBdXCI7XG5jb25zdCBpc0Z1bmN0aW9uID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3QgaXNTdHJpbmcgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiO1xuY29uc3QgaXNTeW1ib2wgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN5bWJvbFwiO1xuY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIjtcbmNvbnN0IGlzUHJvbWlzZSA9ICh2YWwpID0+IHtcbiAgcmV0dXJuIChpc09iamVjdCh2YWwpIHx8IGlzRnVuY3Rpb24odmFsKSkgJiYgaXNGdW5jdGlvbih2YWwudGhlbikgJiYgaXNGdW5jdGlvbih2YWwuY2F0Y2gpO1xufTtcbmNvbnN0IG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IHRvVHlwZVN0cmluZyA9ICh2YWx1ZSkgPT4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5jb25zdCB0b1Jhd1R5cGUgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIHRvVHlwZVN0cmluZyh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xufTtcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbmNvbnN0IGlzSW50ZWdlcktleSA9IChrZXkpID0+IGlzU3RyaW5nKGtleSkgJiYga2V5ICE9PSBcIk5hTlwiICYmIGtleVswXSAhPT0gXCItXCIgJiYgXCJcIiArIHBhcnNlSW50KGtleSwgMTApID09PSBrZXk7XG5jb25zdCBpc1Jlc2VydmVkUHJvcCA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICAvLyB0aGUgbGVhZGluZyBjb21tYSBpcyBpbnRlbnRpb25hbCBzbyBlbXB0eSBzdHJpbmcgXCJcIiBpcyBhbHNvIGluY2x1ZGVkXG4gIFwiLGtleSxyZWYscmVmX2ZvcixyZWZfa2V5LG9uVm5vZGVCZWZvcmVNb3VudCxvblZub2RlTW91bnRlZCxvblZub2RlQmVmb3JlVXBkYXRlLG9uVm5vZGVVcGRhdGVkLG9uVm5vZGVCZWZvcmVVbm1vdW50LG9uVm5vZGVVbm1vdW50ZWRcIlxuKTtcbmNvbnN0IGlzQnVpbHRJbkRpcmVjdGl2ZSA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBcImJpbmQsY2xvYWssZWxzZS1pZixlbHNlLGZvcixodG1sLGlmLG1vZGVsLG9uLG9uY2UscHJlLHNob3csc2xvdCx0ZXh0LG1lbW9cIlxuKTtcbmNvbnN0IGNhY2hlU3RyaW5nRnVuY3Rpb24gPSAoZm4pID0+IHtcbiAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChzdHIpID0+IHtcbiAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcbiAgfTtcbn07XG5jb25zdCBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xuY29uc3QgY2FtZWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKFxuICAoc3RyKSA9PiB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiBjID8gYy50b1VwcGVyQ2FzZSgpIDogXCJcIik7XG4gIH1cbik7XG5jb25zdCBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG5jb25zdCBoeXBoZW5hdGUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKFxuICAoc3RyKSA9PiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgXCItJDFcIikudG9Mb3dlckNhc2UoKVxuKTtcbmNvbnN0IGNhcGl0YWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn0pO1xuY29uc3QgdG9IYW5kbGVyS2V5ID0gY2FjaGVTdHJpbmdGdW5jdGlvbihcbiAgKHN0cikgPT4ge1xuICAgIGNvbnN0IHMgPSBzdHIgPyBgb24ke2NhcGl0YWxpemUoc3RyKX1gIDogYGA7XG4gICAgcmV0dXJuIHM7XG4gIH1cbik7XG5jb25zdCBoYXNDaGFuZ2VkID0gKHZhbHVlLCBvbGRWYWx1ZSkgPT4gIU9iamVjdC5pcyh2YWx1ZSwgb2xkVmFsdWUpO1xuY29uc3QgaW52b2tlQXJyYXlGbnMgPSAoZm5zLCAuLi5hcmcpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICBmbnNbaV0oLi4uYXJnKTtcbiAgfVxufTtcbmNvbnN0IGRlZiA9IChvYmosIGtleSwgdmFsdWUsIHdyaXRhYmxlID0gZmFsc2UpID0+IHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlLFxuICAgIHZhbHVlXG4gIH0pO1xufTtcbmNvbnN0IGxvb3NlVG9OdW1iZXIgPSAodmFsKSA9PiB7XG4gIGNvbnN0IG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG47XG59O1xuY29uc3QgdG9OdW1iZXIgPSAodmFsKSA9PiB7XG4gIGNvbnN0IG4gPSBpc1N0cmluZyh2YWwpID8gTnVtYmVyKHZhbCkgOiBOYU47XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG47XG59O1xubGV0IF9nbG9iYWxUaGlzO1xuY29uc3QgZ2V0R2xvYmFsVGhpcyA9ICgpID0+IHtcbiAgcmV0dXJuIF9nbG9iYWxUaGlzIHx8IChfZ2xvYmFsVGhpcyA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pO1xufTtcbmNvbnN0IGlkZW50UkUgPSAvXltfJGEtekEtWlxceEEwLVxcdUZGRkZdW18kYS16QS1aMC05XFx4QTAtXFx1RkZGRl0qJC87XG5mdW5jdGlvbiBnZW5Qcm9wc0FjY2Vzc0V4cChuYW1lKSB7XG4gIHJldHVybiBpZGVudFJFLnRlc3QobmFtZSkgPyBgX19wcm9wcy4ke25hbWV9YCA6IGBfX3Byb3BzWyR7SlNPTi5zdHJpbmdpZnkobmFtZSl9XWA7XG59XG5mdW5jdGlvbiBnZW5DYWNoZUtleShzb3VyY2UsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHNvdXJjZSArIEpTT04uc3RyaW5naWZ5KFxuICAgIG9wdGlvbnMsXG4gICAgKF8sIHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiID8gdmFsLnRvU3RyaW5nKCkgOiB2YWxcbiAgKTtcbn1cblxuY29uc3QgUGF0Y2hGbGFncyA9IHtcbiAgXCJURVhUXCI6IDEsXG4gIFwiMVwiOiBcIlRFWFRcIixcbiAgXCJDTEFTU1wiOiAyLFxuICBcIjJcIjogXCJDTEFTU1wiLFxuICBcIlNUWUxFXCI6IDQsXG4gIFwiNFwiOiBcIlNUWUxFXCIsXG4gIFwiUFJPUFNcIjogOCxcbiAgXCI4XCI6IFwiUFJPUFNcIixcbiAgXCJGVUxMX1BST1BTXCI6IDE2LFxuICBcIjE2XCI6IFwiRlVMTF9QUk9QU1wiLFxuICBcIk5FRURfSFlEUkFUSU9OXCI6IDMyLFxuICBcIjMyXCI6IFwiTkVFRF9IWURSQVRJT05cIixcbiAgXCJTVEFCTEVfRlJBR01FTlRcIjogNjQsXG4gIFwiNjRcIjogXCJTVEFCTEVfRlJBR01FTlRcIixcbiAgXCJLRVlFRF9GUkFHTUVOVFwiOiAxMjgsXG4gIFwiMTI4XCI6IFwiS0VZRURfRlJBR01FTlRcIixcbiAgXCJVTktFWUVEX0ZSQUdNRU5UXCI6IDI1NixcbiAgXCIyNTZcIjogXCJVTktFWUVEX0ZSQUdNRU5UXCIsXG4gIFwiTkVFRF9QQVRDSFwiOiA1MTIsXG4gIFwiNTEyXCI6IFwiTkVFRF9QQVRDSFwiLFxuICBcIkRZTkFNSUNfU0xPVFNcIjogMTAyNCxcbiAgXCIxMDI0XCI6IFwiRFlOQU1JQ19TTE9UU1wiLFxuICBcIkRFVl9ST09UX0ZSQUdNRU5UXCI6IDIwNDgsXG4gIFwiMjA0OFwiOiBcIkRFVl9ST09UX0ZSQUdNRU5UXCIsXG4gIFwiQ0FDSEVEXCI6IC0xLFxuICBcIi0xXCI6IFwiQ0FDSEVEXCIsXG4gIFwiQkFJTFwiOiAtMixcbiAgXCItMlwiOiBcIkJBSUxcIlxufTtcbmNvbnN0IFBhdGNoRmxhZ05hbWVzID0ge1xuICBbMV06IGBURVhUYCxcbiAgWzJdOiBgQ0xBU1NgLFxuICBbNF06IGBTVFlMRWAsXG4gIFs4XTogYFBST1BTYCxcbiAgWzE2XTogYEZVTExfUFJPUFNgLFxuICBbMzJdOiBgTkVFRF9IWURSQVRJT05gLFxuICBbNjRdOiBgU1RBQkxFX0ZSQUdNRU5UYCxcbiAgWzEyOF06IGBLRVlFRF9GUkFHTUVOVGAsXG4gIFsyNTZdOiBgVU5LRVlFRF9GUkFHTUVOVGAsXG4gIFs1MTJdOiBgTkVFRF9QQVRDSGAsXG4gIFsxMDI0XTogYERZTkFNSUNfU0xPVFNgLFxuICBbMjA0OF06IGBERVZfUk9PVF9GUkFHTUVOVGAsXG4gIFstMV06IGBIT0lTVEVEYCxcbiAgWy0yXTogYEJBSUxgXG59O1xuXG5jb25zdCBTaGFwZUZsYWdzID0ge1xuICBcIkVMRU1FTlRcIjogMSxcbiAgXCIxXCI6IFwiRUxFTUVOVFwiLFxuICBcIkZVTkNUSU9OQUxfQ09NUE9ORU5UXCI6IDIsXG4gIFwiMlwiOiBcIkZVTkNUSU9OQUxfQ09NUE9ORU5UXCIsXG4gIFwiU1RBVEVGVUxfQ09NUE9ORU5UXCI6IDQsXG4gIFwiNFwiOiBcIlNUQVRFRlVMX0NPTVBPTkVOVFwiLFxuICBcIlRFWFRfQ0hJTERSRU5cIjogOCxcbiAgXCI4XCI6IFwiVEVYVF9DSElMRFJFTlwiLFxuICBcIkFSUkFZX0NISUxEUkVOXCI6IDE2LFxuICBcIjE2XCI6IFwiQVJSQVlfQ0hJTERSRU5cIixcbiAgXCJTTE9UU19DSElMRFJFTlwiOiAzMixcbiAgXCIzMlwiOiBcIlNMT1RTX0NISUxEUkVOXCIsXG4gIFwiVEVMRVBPUlRcIjogNjQsXG4gIFwiNjRcIjogXCJURUxFUE9SVFwiLFxuICBcIlNVU1BFTlNFXCI6IDEyOCxcbiAgXCIxMjhcIjogXCJTVVNQRU5TRVwiLFxuICBcIkNPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRVwiOiAyNTYsXG4gIFwiMjU2XCI6IFwiQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFXCIsXG4gIFwiQ09NUE9ORU5UX0tFUFRfQUxJVkVcIjogNTEyLFxuICBcIjUxMlwiOiBcIkNPTVBPTkVOVF9LRVBUX0FMSVZFXCIsXG4gIFwiQ09NUE9ORU5UXCI6IDYsXG4gIFwiNlwiOiBcIkNPTVBPTkVOVFwiXG59O1xuXG5jb25zdCBTbG90RmxhZ3MgPSB7XG4gIFwiU1RBQkxFXCI6IDEsXG4gIFwiMVwiOiBcIlNUQUJMRVwiLFxuICBcIkRZTkFNSUNcIjogMixcbiAgXCIyXCI6IFwiRFlOQU1JQ1wiLFxuICBcIkZPUldBUkRFRFwiOiAzLFxuICBcIjNcIjogXCJGT1JXQVJERURcIlxufTtcbmNvbnN0IHNsb3RGbGFnc1RleHQgPSB7XG4gIFsxXTogXCJTVEFCTEVcIixcbiAgWzJdOiBcIkRZTkFNSUNcIixcbiAgWzNdOiBcIkZPUldBUkRFRFwiXG59O1xuXG5jb25zdCBHTE9CQUxTX0FMTE9XRUQgPSBcIkluZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4scGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLEJpZ0ludCxjb25zb2xlLEVycm9yLFN5bWJvbFwiO1xuY29uc3QgaXNHbG9iYWxseUFsbG93ZWQgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChHTE9CQUxTX0FMTE9XRUQpO1xuY29uc3QgaXNHbG9iYWxseVdoaXRlbGlzdGVkID0gaXNHbG9iYWxseUFsbG93ZWQ7XG5cbmNvbnN0IHJhbmdlID0gMjtcbmZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lKHNvdXJjZSwgc3RhcnQgPSAwLCBlbmQgPSBzb3VyY2UubGVuZ3RoKSB7XG4gIHN0YXJ0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc3RhcnQsIHNvdXJjZS5sZW5ndGgpKTtcbiAgZW5kID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZW5kLCBzb3VyY2UubGVuZ3RoKSk7XG4gIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFwiXCI7XG4gIGxldCBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvKFxccj9cXG4pLyk7XG4gIGNvbnN0IG5ld2xpbmVTZXF1ZW5jZXMgPSBsaW5lcy5maWx0ZXIoKF8sIGlkeCkgPT4gaWR4ICUgMiA9PT0gMSk7XG4gIGxpbmVzID0gbGluZXMuZmlsdGVyKChfLCBpZHgpID0+IGlkeCAlIDIgPT09IDApO1xuICBsZXQgY291bnQgPSAwO1xuICBjb25zdCByZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvdW50ICs9IGxpbmVzW2ldLmxlbmd0aCArIChuZXdsaW5lU2VxdWVuY2VzW2ldICYmIG5ld2xpbmVTZXF1ZW5jZXNbaV0ubGVuZ3RoIHx8IDApO1xuICAgIGlmIChjb3VudCA+PSBzdGFydCkge1xuICAgICAgZm9yIChsZXQgaiA9IGkgLSByYW5nZTsgaiA8PSBpICsgcmFuZ2UgfHwgZW5kID4gY291bnQ7IGorKykge1xuICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBsaW5lcy5sZW5ndGgpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBsaW5lID0gaiArIDE7XG4gICAgICAgIHJlcy5wdXNoKFxuICAgICAgICAgIGAke2xpbmV9JHtcIiBcIi5yZXBlYXQoTWF0aC5tYXgoMyAtIFN0cmluZyhsaW5lKS5sZW5ndGgsIDApKX18ICAke2xpbmVzW2pdfWBcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IGxpbmVzW2pdLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbmV3TGluZVNlcUxlbmd0aCA9IG5ld2xpbmVTZXF1ZW5jZXNbal0gJiYgbmV3bGluZVNlcXVlbmNlc1tqXS5sZW5ndGggfHwgMDtcbiAgICAgICAgaWYgKGogPT09IGkpIHtcbiAgICAgICAgICBjb25zdCBwYWQgPSBzdGFydCAtIChjb3VudCAtIChsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aCkpO1xuICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArIFwiIFwiLnJlcGVhdChwYWQpICsgXCJeXCIucmVwZWF0KGxlbmd0aCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGogPiBpKSB7XG4gICAgICAgICAgaWYgKGVuZCA+IGNvdW50KSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChNYXRoLm1pbihlbmQgLSBjb3VudCwgbGluZUxlbmd0aCksIDEpO1xuICAgICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyBcIl5cIi5yZXBlYXQobGVuZ3RoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvdW50ICs9IGxpbmVMZW5ndGggKyBuZXdMaW5lU2VxTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy5qb2luKFwiXFxuXCIpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZSh2YWx1ZSkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gdmFsdWVbaV07XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gaXNTdHJpbmcoaXRlbSkgPyBwYXJzZVN0cmluZ1N0eWxlKGl0ZW0pIDogbm9ybWFsaXplU3R5bGUoaXRlbSk7XG4gICAgICBpZiAobm9ybWFsaXplZCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBub3JtYWxpemVkKSB7XG4gICAgICAgICAgcmVzW2tleV0gPSBub3JtYWxpemVkW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfSBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkgfHwgaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5jb25zdCBsaXN0RGVsaW1pdGVyUkUgPSAvOyg/IVteKF0qXFwpKS9nO1xuY29uc3QgcHJvcGVydHlEZWxpbWl0ZXJSRSA9IC86KFteXSspLztcbmNvbnN0IHN0eWxlQ29tbWVudFJFID0gL1xcL1xcKlteXSo/XFwqXFwvL2c7XG5mdW5jdGlvbiBwYXJzZVN0cmluZ1N0eWxlKGNzc1RleHQpIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGNzc1RleHQucmVwbGFjZShzdHlsZUNvbW1lbnRSRSwgXCJcIikuc3BsaXQobGlzdERlbGltaXRlclJFKS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIGNvbnN0IHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXJSRSk7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmV0W3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVN0eWxlKHN0eWxlcykge1xuICBpZiAoIXN0eWxlcykgcmV0dXJuIFwiXCI7XG4gIGlmIChpc1N0cmluZyhzdHlsZXMpKSByZXR1cm4gc3R5bGVzO1xuICBsZXQgcmV0ID0gXCJcIjtcbiAgZm9yIChjb25zdCBrZXkgaW4gc3R5bGVzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzdHlsZXNba2V5XTtcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGtleS5zdGFydHNXaXRoKGAtLWApID8ga2V5IDogaHlwaGVuYXRlKGtleSk7XG4gICAgICByZXQgKz0gYCR7bm9ybWFsaXplZEtleX06JHt2YWx1ZX07YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzKHZhbHVlKSB7XG4gIGxldCByZXMgPSBcIlwiO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgcmVzID0gdmFsdWU7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplQ2xhc3ModmFsdWVbaV0pO1xuICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgcmVzICs9IG5vcm1hbGl6ZWQgKyBcIiBcIjtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgZm9yIChjb25zdCBuYW1lIGluIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWVbbmFtZV0pIHtcbiAgICAgICAgcmVzICs9IG5hbWUgKyBcIiBcIjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy50cmltKCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyhwcm9wcykge1xuICBpZiAoIXByb3BzKSByZXR1cm4gbnVsbDtcbiAgbGV0IHsgY2xhc3M6IGtsYXNzLCBzdHlsZSB9ID0gcHJvcHM7XG4gIGlmIChrbGFzcyAmJiAhaXNTdHJpbmcoa2xhc3MpKSB7XG4gICAgcHJvcHMuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhrbGFzcyk7XG4gIH1cbiAgaWYgKHN0eWxlKSB7XG4gICAgcHJvcHMuc3R5bGUgPSBub3JtYWxpemVTdHlsZShzdHlsZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BzO1xufVxuXG5jb25zdCBIVE1MX1RBR1MgPSBcImh0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLGFkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGhncm91cCxoMSxoMixoMyxoNCxoNSxoNixuYXYsc2VjdGlvbixkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCxhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnVieSxzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbyxlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucyxjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0cixidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLG91dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsZGV0YWlscyxkaWFsb2csbWVudSxzdW1tYXJ5LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290XCI7XG5jb25zdCBTVkdfVEFHUyA9IFwic3ZnLGFuaW1hdGUsYW5pbWF0ZU1vdGlvbixhbmltYXRlVHJhbnNmb3JtLGNpcmNsZSxjbGlwUGF0aCxjb2xvci1wcm9maWxlLGRlZnMsZGVzYyxkaXNjYXJkLGVsbGlwc2UsZmVCbGVuZCxmZUNvbG9yTWF0cml4LGZlQ29tcG9uZW50VHJhbnNmZXIsZmVDb21wb3NpdGUsZmVDb252b2x2ZU1hdHJpeCxmZURpZmZ1c2VMaWdodGluZyxmZURpc3BsYWNlbWVudE1hcCxmZURpc3RhbnRMaWdodCxmZURyb3BTaGFkb3csZmVGbG9vZCxmZUZ1bmNBLGZlRnVuY0IsZmVGdW5jRyxmZUZ1bmNSLGZlR2F1c3NpYW5CbHVyLGZlSW1hZ2UsZmVNZXJnZSxmZU1lcmdlTm9kZSxmZU1vcnBob2xvZ3ksZmVPZmZzZXQsZmVQb2ludExpZ2h0LGZlU3BlY3VsYXJMaWdodGluZyxmZVNwb3RMaWdodCxmZVRpbGUsZmVUdXJidWxlbmNlLGZpbHRlcixmb3JlaWduT2JqZWN0LGcsaGF0Y2gsaGF0Y2hwYXRoLGltYWdlLGxpbmUsbGluZWFyR3JhZGllbnQsbWFya2VyLG1hc2ssbWVzaCxtZXNoZ3JhZGllbnQsbWVzaHBhdGNoLG1lc2hyb3csbWV0YWRhdGEsbXBhdGgscGF0aCxwYXR0ZXJuLHBvbHlnb24scG9seWxpbmUscmFkaWFsR3JhZGllbnQscmVjdCxzZXQsc29saWRjb2xvcixzdG9wLHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0UGF0aCx0aXRsZSx0c3Bhbix1bmtub3duLHVzZSx2aWV3XCI7XG5jb25zdCBNQVRIX1RBR1MgPSBcImFubm90YXRpb24sYW5ub3RhdGlvbi14bWwsbWFjdGlvbixtYWxpZ25ncm91cCxtYWxpZ25tYXJrLG1hdGgsbWVuY2xvc2UsbWVycm9yLG1mZW5jZWQsbWZyYWMsbWZyYWN0aW9uLG1nbHlwaCxtaSxtbGFiZWxlZHRyLG1sb25nZGl2LG1tdWx0aXNjcmlwdHMsbW4sbW8sbW92ZXIsbXBhZGRlZCxtcGhhbnRvbSxtcHJlc2NyaXB0cyxtcm9vdCxtcm93LG1zLG1zY2Fycmllcyxtc2NhcnJ5LG1zZ3JvdXAsbXNsaW5lLG1zcGFjZSxtc3FydCxtc3Jvdyxtc3RhY2ssbXN0eWxlLG1zdWIsbXN1YnN1cCxtc3VwLG10YWJsZSxtdGQsbXRleHQsbXRyLG11bmRlcixtdW5kZXJvdmVyLG5vbmUsc2VtYW50aWNzXCI7XG5jb25zdCBWT0lEX1RBR1MgPSBcImFyZWEsYmFzZSxicixjb2wsZW1iZWQsaHIsaW1nLGlucHV0LGxpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyXCI7XG5jb25zdCBpc0hUTUxUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChIVE1MX1RBR1MpO1xuY29uc3QgaXNTVkdUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChTVkdfVEFHUyk7XG5jb25zdCBpc01hdGhNTFRhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKE1BVEhfVEFHUyk7XG5jb25zdCBpc1ZvaWRUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChWT0lEX1RBR1MpO1xuXG5jb25zdCBzcGVjaWFsQm9vbGVhbkF0dHJzID0gYGl0ZW1zY29wZSxhbGxvd2Z1bGxzY3JlZW4sZm9ybW5vdmFsaWRhdGUsaXNtYXAsbm9tb2R1bGUsbm92YWxpZGF0ZSxyZWFkb25seWA7XG5jb25zdCBpc1NwZWNpYWxCb29sZWFuQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKHNwZWNpYWxCb29sZWFuQXR0cnMpO1xuY29uc3QgaXNCb29sZWFuQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBzcGVjaWFsQm9vbGVhbkF0dHJzICsgYCxhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY29udHJvbHMsZGVmYXVsdCxkZWZlcixkaXNhYmxlZCxoaWRkZW4saW5lcnQsbG9vcCxvcGVuLHJlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxjaGVja2VkLG11dGVkLG11bHRpcGxlLHNlbGVjdGVkYFxuKTtcbmZ1bmN0aW9uIGluY2x1ZGVCb29sZWFuQXR0cih2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSB8fCB2YWx1ZSA9PT0gXCJcIjtcbn1cbmNvbnN0IHVuc2FmZUF0dHJDaGFyUkUgPSAvWz4vPVwiJ1xcdTAwMDlcXHUwMDBhXFx1MDAwY1xcdTAwMjBdLztcbmNvbnN0IGF0dHJWYWxpZGF0aW9uQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGlzU1NSU2FmZUF0dHJOYW1lKG5hbWUpIHtcbiAgaWYgKGF0dHJWYWxpZGF0aW9uQ2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICByZXR1cm4gYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXTtcbiAgfVxuICBjb25zdCBpc1Vuc2FmZSA9IHVuc2FmZUF0dHJDaGFyUkUudGVzdChuYW1lKTtcbiAgaWYgKGlzVW5zYWZlKSB7XG4gICAgY29uc29sZS5lcnJvcihgdW5zYWZlIGF0dHJpYnV0ZSBuYW1lOiAke25hbWV9YCk7XG4gIH1cbiAgcmV0dXJuIGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV0gPSAhaXNVbnNhZmU7XG59XG5jb25zdCBwcm9wc1RvQXR0ck1hcCA9IHtcbiAgYWNjZXB0Q2hhcnNldDogXCJhY2NlcHQtY2hhcnNldFwiLFxuICBjbGFzc05hbWU6IFwiY2xhc3NcIixcbiAgaHRtbEZvcjogXCJmb3JcIixcbiAgaHR0cEVxdWl2OiBcImh0dHAtZXF1aXZcIlxufTtcbmNvbnN0IGlzS25vd25IdG1sQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBgYWNjZXB0LGFjY2VwdC1jaGFyc2V0LGFjY2Vzc2tleSxhY3Rpb24sYWxpZ24sYWxsb3csYWx0LGFzeW5jLGF1dG9jYXBpdGFsaXplLGF1dG9jb21wbGV0ZSxhdXRvZm9jdXMsYXV0b3BsYXksYmFja2dyb3VuZCxiZ2NvbG9yLGJvcmRlcixidWZmZXJlZCxjYXB0dXJlLGNoYWxsZW5nZSxjaGFyc2V0LGNoZWNrZWQsY2l0ZSxjbGFzcyxjb2RlLGNvZGViYXNlLGNvbG9yLGNvbHMsY29sc3Bhbixjb250ZW50LGNvbnRlbnRlZGl0YWJsZSxjb250ZXh0bWVudSxjb250cm9scyxjb29yZHMsY3Jvc3NvcmlnaW4sY3NwLGRhdGEsZGF0ZXRpbWUsZGVjb2RpbmcsZGVmYXVsdCxkZWZlcixkaXIsZGlybmFtZSxkaXNhYmxlZCxkb3dubG9hZCxkcmFnZ2FibGUsZHJvcHpvbmUsZW5jdHlwZSxlbnRlcmtleWhpbnQsZm9yLGZvcm0sZm9ybWFjdGlvbixmb3JtZW5jdHlwZSxmb3JtbWV0aG9kLGZvcm1ub3ZhbGlkYXRlLGZvcm10YXJnZXQsaGVhZGVycyxoZWlnaHQsaGlkZGVuLGhpZ2gsaHJlZixocmVmbGFuZyxodHRwLWVxdWl2LGljb24saWQsaW1wb3J0YW5jZSxpbmVydCxpbnRlZ3JpdHksaXNtYXAsaXRlbXByb3Asa2V5dHlwZSxraW5kLGxhYmVsLGxhbmcsbGFuZ3VhZ2UsbG9hZGluZyxsaXN0LGxvb3AsbG93LG1hbmlmZXN0LG1heCxtYXhsZW5ndGgsbWlubGVuZ3RoLG1lZGlhLG1pbixtdWx0aXBsZSxtdXRlZCxuYW1lLG5vdmFsaWRhdGUsb3BlbixvcHRpbXVtLHBhdHRlcm4scGluZyxwbGFjZWhvbGRlcixwb3N0ZXIscHJlbG9hZCxyYWRpb2dyb3VwLHJlYWRvbmx5LHJlZmVycmVycG9saWN5LHJlbCxyZXF1aXJlZCxyZXZlcnNlZCxyb3dzLHJvd3NwYW4sc2FuZGJveCxzY29wZSxzY29wZWQsc2VsZWN0ZWQsc2hhcGUsc2l6ZSxzaXplcyxzbG90LHNwYW4sc3BlbGxjaGVjayxzcmMsc3JjZG9jLHNyY2xhbmcsc3Jjc2V0LHN0YXJ0LHN0ZXAsc3R5bGUsc3VtbWFyeSx0YWJpbmRleCx0YXJnZXQsdGl0bGUsdHJhbnNsYXRlLHR5cGUsdXNlbWFwLHZhbHVlLHdpZHRoLHdyYXBgXG4pO1xuY29uc3QgaXNLbm93blN2Z0F0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgYHhtbG5zLGFjY2VudC1oZWlnaHQsYWNjdW11bGF0ZSxhZGRpdGl2ZSxhbGlnbm1lbnQtYmFzZWxpbmUsYWxwaGFiZXRpYyxhbXBsaXR1ZGUsYXJhYmljLWZvcm0sYXNjZW50LGF0dHJpYnV0ZU5hbWUsYXR0cmlidXRlVHlwZSxhemltdXRoLGJhc2VGcmVxdWVuY3ksYmFzZWxpbmUtc2hpZnQsYmFzZVByb2ZpbGUsYmJveCxiZWdpbixiaWFzLGJ5LGNhbGNNb2RlLGNhcC1oZWlnaHQsY2xhc3MsY2xpcCxjbGlwUGF0aFVuaXRzLGNsaXAtcGF0aCxjbGlwLXJ1bGUsY29sb3IsY29sb3ItaW50ZXJwb2xhdGlvbixjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMsY29sb3ItcHJvZmlsZSxjb2xvci1yZW5kZXJpbmcsY29udGVudFNjcmlwdFR5cGUsY29udGVudFN0eWxlVHlwZSxjcm9zc29yaWdpbixjdXJzb3IsY3gsY3ksZCxkZWNlbGVyYXRlLGRlc2NlbnQsZGlmZnVzZUNvbnN0YW50LGRpcmVjdGlvbixkaXNwbGF5LGRpdmlzb3IsZG9taW5hbnQtYmFzZWxpbmUsZHVyLGR4LGR5LGVkZ2VNb2RlLGVsZXZhdGlvbixlbmFibGUtYmFja2dyb3VuZCxlbmQsZXhwb25lbnQsZmlsbCxmaWxsLW9wYWNpdHksZmlsbC1ydWxlLGZpbHRlcixmaWx0ZXJSZXMsZmlsdGVyVW5pdHMsZmxvb2QtY29sb3IsZmxvb2Qtb3BhY2l0eSxmb250LWZhbWlseSxmb250LXNpemUsZm9udC1zaXplLWFkanVzdCxmb250LXN0cmV0Y2gsZm9udC1zdHlsZSxmb250LXZhcmlhbnQsZm9udC13ZWlnaHQsZm9ybWF0LGZyb20sZnIsZngsZnksZzEsZzIsZ2x5cGgtbmFtZSxnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsLGdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsLGdseXBoUmVmLGdyYWRpZW50VHJhbnNmb3JtLGdyYWRpZW50VW5pdHMsaGFuZ2luZyxoZWlnaHQsaHJlZixocmVmbGFuZyxob3Jpei1hZHYteCxob3Jpei1vcmlnaW4teCxpZCxpZGVvZ3JhcGhpYyxpbWFnZS1yZW5kZXJpbmcsaW4saW4yLGludGVyY2VwdCxrLGsxLGsyLGszLGs0LGtlcm5lbE1hdHJpeCxrZXJuZWxVbml0TGVuZ3RoLGtlcm5pbmcsa2V5UG9pbnRzLGtleVNwbGluZXMsa2V5VGltZXMsbGFuZyxsZW5ndGhBZGp1c3QsbGV0dGVyLXNwYWNpbmcsbGlnaHRpbmctY29sb3IsbGltaXRpbmdDb25lQW5nbGUsbG9jYWwsbWFya2VyLWVuZCxtYXJrZXItbWlkLG1hcmtlci1zdGFydCxtYXJrZXJIZWlnaHQsbWFya2VyVW5pdHMsbWFya2VyV2lkdGgsbWFzayxtYXNrQ29udGVudFVuaXRzLG1hc2tVbml0cyxtYXRoZW1hdGljYWwsbWF4LG1lZGlhLG1ldGhvZCxtaW4sbW9kZSxuYW1lLG51bU9jdGF2ZXMsb2Zmc2V0LG9wYWNpdHksb3BlcmF0b3Isb3JkZXIsb3JpZW50LG9yaWVudGF0aW9uLG9yaWdpbixvdmVyZmxvdyxvdmVybGluZS1wb3NpdGlvbixvdmVybGluZS10aGlja25lc3MscGFub3NlLTEscGFpbnQtb3JkZXIscGF0aCxwYXRoTGVuZ3RoLHBhdHRlcm5Db250ZW50VW5pdHMscGF0dGVyblRyYW5zZm9ybSxwYXR0ZXJuVW5pdHMscGluZyxwb2ludGVyLWV2ZW50cyxwb2ludHMscG9pbnRzQXRYLHBvaW50c0F0WSxwb2ludHNBdFoscHJlc2VydmVBbHBoYSxwcmVzZXJ2ZUFzcGVjdFJhdGlvLHByaW1pdGl2ZVVuaXRzLHIscmFkaXVzLHJlZmVycmVyUG9saWN5LHJlZlgscmVmWSxyZWwscmVuZGVyaW5nLWludGVudCxyZXBlYXRDb3VudCxyZXBlYXREdXIscmVxdWlyZWRFeHRlbnNpb25zLHJlcXVpcmVkRmVhdHVyZXMscmVzdGFydCxyZXN1bHQscm90YXRlLHJ4LHJ5LHNjYWxlLHNlZWQsc2hhcGUtcmVuZGVyaW5nLHNsb3BlLHNwYWNpbmcsc3BlY3VsYXJDb25zdGFudCxzcGVjdWxhckV4cG9uZW50LHNwZWVkLHNwcmVhZE1ldGhvZCxzdGFydE9mZnNldCxzdGREZXZpYXRpb24sc3RlbWgsc3RlbXYsc3RpdGNoVGlsZXMsc3RvcC1jb2xvcixzdG9wLW9wYWNpdHksc3RyaWtldGhyb3VnaC1wb3NpdGlvbixzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyxzdHJpbmcsc3Ryb2tlLHN0cm9rZS1kYXNoYXJyYXksc3Ryb2tlLWRhc2hvZmZzZXQsc3Ryb2tlLWxpbmVjYXAsc3Ryb2tlLWxpbmVqb2luLHN0cm9rZS1taXRlcmxpbWl0LHN0cm9rZS1vcGFjaXR5LHN0cm9rZS13aWR0aCxzdHlsZSxzdXJmYWNlU2NhbGUsc3lzdGVtTGFuZ3VhZ2UsdGFiaW5kZXgsdGFibGVWYWx1ZXMsdGFyZ2V0LHRhcmdldFgsdGFyZ2V0WSx0ZXh0LWFuY2hvcix0ZXh0LWRlY29yYXRpb24sdGV4dC1yZW5kZXJpbmcsdGV4dExlbmd0aCx0byx0cmFuc2Zvcm0sdHJhbnNmb3JtLW9yaWdpbix0eXBlLHUxLHUyLHVuZGVybGluZS1wb3NpdGlvbix1bmRlcmxpbmUtdGhpY2tuZXNzLHVuaWNvZGUsdW5pY29kZS1iaWRpLHVuaWNvZGUtcmFuZ2UsdW5pdHMtcGVyLWVtLHYtYWxwaGFiZXRpYyx2LWhhbmdpbmcsdi1pZGVvZ3JhcGhpYyx2LW1hdGhlbWF0aWNhbCx2YWx1ZXMsdmVjdG9yLWVmZmVjdCx2ZXJzaW9uLHZlcnQtYWR2LXksdmVydC1vcmlnaW4teCx2ZXJ0LW9yaWdpbi15LHZpZXdCb3gsdmlld1RhcmdldCx2aXNpYmlsaXR5LHdpZHRoLHdpZHRocyx3b3JkLXNwYWNpbmcsd3JpdGluZy1tb2RlLHgseC1oZWlnaHQseDEseDIseENoYW5uZWxTZWxlY3Rvcix4bGluazphY3R1YXRlLHhsaW5rOmFyY3JvbGUseGxpbms6aHJlZix4bGluazpyb2xlLHhsaW5rOnNob3cseGxpbms6dGl0bGUseGxpbms6dHlwZSx4bWxuczp4bGluayx4bWw6YmFzZSx4bWw6bGFuZyx4bWw6c3BhY2UseSx5MSx5Mix5Q2hhbm5lbFNlbGVjdG9yLHosem9vbUFuZFBhbmBcbik7XG5jb25zdCBpc0tub3duTWF0aE1MQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBgYWNjZW50LGFjY2VudHVuZGVyLGFjdGlvbnR5cGUsYWxpZ24sYWxpZ25tZW50c2NvcGUsYWx0aW1nLGFsdGltZy1oZWlnaHQsYWx0aW1nLXZhbGlnbixhbHRpbWctd2lkdGgsYWx0dGV4dCxiZXZlbGxlZCxjbG9zZSxjb2x1bW5zYWxpZ24sY29sdW1ubGluZXMsY29sdW1uc3BhbixkZW5vbWFsaWduLGRlcHRoLGRpcixkaXNwbGF5LGRpc3BsYXlzdHlsZSxlbmNvZGluZyxlcXVhbGNvbHVtbnMsZXF1YWxyb3dzLGZlbmNlLGZvbnRzdHlsZSxmb250d2VpZ2h0LGZvcm0sZnJhbWUsZnJhbWVzcGFjaW5nLGdyb3VwYWxpZ24saGVpZ2h0LGhyZWYsaWQsaW5kZW50YWxpZ24saW5kZW50YWxpZ25maXJzdCxpbmRlbnRhbGlnbmxhc3QsaW5kZW50c2hpZnQsaW5kZW50c2hpZnRmaXJzdCxpbmRlbnRzaGlmdGxhc3QsaW5kZXh0eXBlLGp1c3RpZnksbGFyZ2V0b3AsbGFyZ2VvcCxscXVvdGUsbHNwYWNlLG1hdGhiYWNrZ3JvdW5kLG1hdGhjb2xvcixtYXRoc2l6ZSxtYXRodmFyaWFudCxtYXhzaXplLG1pbmxhYmVsc3BhY2luZyxtb2RlLG90aGVyLG92ZXJmbG93LHBvc2l0aW9uLHJvd2FsaWduLHJvd2xpbmVzLHJvd3NwYW4scnF1b3RlLHJzcGFjZSxzY3JpcHRsZXZlbCxzY3JpcHRtaW5zaXplLHNjcmlwdHNpemVtdWx0aXBsaWVyLHNlbGVjdGlvbixzZXBhcmF0b3Isc2VwYXJhdG9ycyxzaGlmdCxzaWRlLHNyYyxzdGFja2FsaWduLHN0cmV0Y2h5LHN1YnNjcmlwdHNoaWZ0LHN1cGVyc2NyaXB0c2hpZnQsc3ltbWV0cmljLHZvZmZzZXQsd2lkdGgsd2lkdGhzLHhsaW5rOmhyZWYseGxpbms6c2hvdyx4bGluazp0eXBlLHhtbG5zYFxuKTtcbmZ1bmN0aW9uIGlzUmVuZGVyYWJsZUF0dHJWYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiO1xufVxuXG5jb25zdCBlc2NhcGVSRSA9IC9bXCInJjw+XS87XG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xuICBjb25zdCBzdHIgPSBcIlwiICsgc3RyaW5nO1xuICBjb25zdCBtYXRjaCA9IGVzY2FwZVJFLmV4ZWMoc3RyKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgbGV0IGh0bWwgPSBcIlwiO1xuICBsZXQgZXNjYXBlZDtcbiAgbGV0IGluZGV4O1xuICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgY2FzZSAzNDpcbiAgICAgICAgZXNjYXBlZCA9IFwiJnF1b3Q7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzODpcbiAgICAgICAgZXNjYXBlZCA9IFwiJmFtcDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM5OlxuICAgICAgICBlc2NhcGVkID0gXCImIzM5O1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNjA6XG4gICAgICAgIGVzY2FwZWQgPSBcIiZsdDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDYyOlxuICAgICAgICBlc2NhcGVkID0gXCImZ3Q7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChsYXN0SW5kZXggIT09IGluZGV4KSB7XG4gICAgICBodG1sICs9IHN0ci5zbGljZShsYXN0SW5kZXgsIGluZGV4KTtcbiAgICB9XG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyAxO1xuICAgIGh0bWwgKz0gZXNjYXBlZDtcbiAgfVxuICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc2xpY2UobGFzdEluZGV4LCBpbmRleCkgOiBodG1sO1xufVxuY29uc3QgY29tbWVudFN0cmlwUkUgPSAvXi0/Pnw8IS0tfC0tPnwtLSE+fDwhLSQvZztcbmZ1bmN0aW9uIGVzY2FwZUh0bWxDb21tZW50KHNyYykge1xuICByZXR1cm4gc3JjLnJlcGxhY2UoY29tbWVudFN0cmlwUkUsIFwiXCIpO1xufVxuY29uc3QgY3NzVmFyTmFtZUVzY2FwZVN5bWJvbHNSRSA9IC9bICFcIiMkJSYnKCkqKywuLzo7PD0+P0BbXFxcXFxcXV5ge3x9fl0vZztcbmZ1bmN0aW9uIGdldEVzY2FwZWRDc3NWYXJOYW1lKGtleSwgZG91YmxlRXNjYXBlKSB7XG4gIHJldHVybiBrZXkucmVwbGFjZShcbiAgICBjc3NWYXJOYW1lRXNjYXBlU3ltYm9sc1JFLFxuICAgIChzKSA9PiBkb3VibGVFc2NhcGUgPyBzID09PSAnXCInID8gJ1xcXFxcXFxcXFxcXFwiJyA6IGBcXFxcXFxcXCR7c31gIDogYFxcXFwke3N9YFxuICApO1xufVxuXG5mdW5jdGlvbiBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikge1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIGxldCBlcXVhbCA9IHRydWU7XG4gIGZvciAobGV0IGkgPSAwOyBlcXVhbCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGVxdWFsID0gbG9vc2VFcXVhbChhW2ldLCBiW2ldKTtcbiAgfVxuICByZXR1cm4gZXF1YWw7XG59XG5mdW5jdGlvbiBsb29zZUVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuICBsZXQgYVZhbGlkVHlwZSA9IGlzRGF0ZShhKTtcbiAgbGV0IGJWYWxpZFR5cGUgPSBpc0RhdGUoYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpIDogZmFsc2U7XG4gIH1cbiAgYVZhbGlkVHlwZSA9IGlzU3ltYm9sKGEpO1xuICBiVmFsaWRUeXBlID0gaXNTeW1ib2woYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgfVxuICBhVmFsaWRUeXBlID0gaXNBcnJheShhKTtcbiAgYlZhbGlkVHlwZSA9IGlzQXJyYXkoYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gbG9vc2VDb21wYXJlQXJyYXlzKGEsIGIpIDogZmFsc2U7XG4gIH1cbiAgYVZhbGlkVHlwZSA9IGlzT2JqZWN0KGEpO1xuICBiVmFsaWRUeXBlID0gaXNPYmplY3QoYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICBpZiAoIWFWYWxpZFR5cGUgfHwgIWJWYWxpZFR5cGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYUtleXNDb3VudCA9IE9iamVjdC5rZXlzKGEpLmxlbmd0aDtcbiAgICBjb25zdCBiS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYikubGVuZ3RoO1xuICAgIGlmIChhS2V5c0NvdW50ICE9PSBiS2V5c0NvdW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIGEpIHtcbiAgICAgIGNvbnN0IGFIYXNLZXkgPSBhLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICBjb25zdCBiSGFzS2V5ID0gYi5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgICAgaWYgKGFIYXNLZXkgJiYgIWJIYXNLZXkgfHwgIWFIYXNLZXkgJiYgYkhhc0tleSB8fCAhbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYik7XG59XG5mdW5jdGlvbiBsb29zZUluZGV4T2YoYXJyLCB2YWwpIHtcbiAgcmV0dXJuIGFyci5maW5kSW5kZXgoKGl0ZW0pID0+IGxvb3NlRXF1YWwoaXRlbSwgdmFsKSk7XG59XG5cbmNvbnN0IGlzUmVmID0gKHZhbCkgPT4ge1xuICByZXR1cm4gISEodmFsICYmIHZhbFtcIl9fdl9pc1JlZlwiXSA9PT0gdHJ1ZSk7XG59O1xuY29uc3QgdG9EaXNwbGF5U3RyaW5nID0gKHZhbCkgPT4ge1xuICByZXR1cm4gaXNTdHJpbmcodmFsKSA/IHZhbCA6IHZhbCA9PSBudWxsID8gXCJcIiA6IGlzQXJyYXkodmFsKSB8fCBpc09iamVjdCh2YWwpICYmICh2YWwudG9TdHJpbmcgPT09IG9iamVjdFRvU3RyaW5nIHx8ICFpc0Z1bmN0aW9uKHZhbC50b1N0cmluZykpID8gaXNSZWYodmFsKSA/IHRvRGlzcGxheVN0cmluZyh2YWwudmFsdWUpIDogSlNPTi5zdHJpbmdpZnkodmFsLCByZXBsYWNlciwgMikgOiBTdHJpbmcodmFsKTtcbn07XG5jb25zdCByZXBsYWNlciA9IChfa2V5LCB2YWwpID0+IHtcbiAgaWYgKGlzUmVmKHZhbCkpIHtcbiAgICByZXR1cm4gcmVwbGFjZXIoX2tleSwgdmFsLnZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc01hcCh2YWwpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtgTWFwKCR7dmFsLnNpemV9KWBdOiBbLi4udmFsLmVudHJpZXMoKV0ucmVkdWNlKFxuICAgICAgICAoZW50cmllcywgW2tleSwgdmFsMl0sIGkpID0+IHtcbiAgICAgICAgICBlbnRyaWVzW3N0cmluZ2lmeVN5bWJvbChrZXksIGkpICsgXCIgPT5cIl0gPSB2YWwyO1xuICAgICAgICAgIHJldHVybiBlbnRyaWVzO1xuICAgICAgICB9LFxuICAgICAgICB7fVxuICAgICAgKVxuICAgIH07XG4gIH0gZWxzZSBpZiAoaXNTZXQodmFsKSkge1xuICAgIHJldHVybiB7XG4gICAgICBbYFNldCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC52YWx1ZXMoKV0ubWFwKCh2KSA9PiBzdHJpbmdpZnlTeW1ib2wodikpXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpc1N5bWJvbCh2YWwpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeVN5bWJvbCh2YWwpO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkgJiYgIWlzQXJyYXkodmFsKSAmJiAhaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgcmV0dXJuIFN0cmluZyh2YWwpO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuY29uc3Qgc3RyaW5naWZ5U3ltYm9sID0gKHYsIGkgPSBcIlwiKSA9PiB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIChcbiAgICAvLyBTeW1ib2wuZGVzY3JpcHRpb24gaW4gZXMyMDE5KyBzbyB3ZSBuZWVkIHRvIGNhc3QgaGVyZSB0byBwYXNzXG4gICAgLy8gdGhlIGxpYjogZXMyMDE2IGNoZWNrXG4gICAgaXNTeW1ib2wodikgPyBgU3ltYm9sKCR7KF9hID0gdi5kZXNjcmlwdGlvbikgIT0gbnVsbCA/IF9hIDogaX0pYCA6IHZcbiAgKTtcbn07XG5cbmV4cG9ydCB7IEVNUFRZX0FSUiwgRU1QVFlfT0JKLCBOTywgTk9PUCwgUGF0Y2hGbGFnTmFtZXMsIFBhdGNoRmxhZ3MsIFNoYXBlRmxhZ3MsIFNsb3RGbGFncywgY2FtZWxpemUsIGNhcGl0YWxpemUsIGNzc1Zhck5hbWVFc2NhcGVTeW1ib2xzUkUsIGRlZiwgZXNjYXBlSHRtbCwgZXNjYXBlSHRtbENvbW1lbnQsIGV4dGVuZCwgZ2VuQ2FjaGVLZXksIGdlblByb3BzQWNjZXNzRXhwLCBnZW5lcmF0ZUNvZGVGcmFtZSwgZ2V0RXNjYXBlZENzc1Zhck5hbWUsIGdldEdsb2JhbFRoaXMsIGhhc0NoYW5nZWQsIGhhc093biwgaHlwaGVuYXRlLCBpbmNsdWRlQm9vbGVhbkF0dHIsIGludm9rZUFycmF5Rm5zLCBpc0FycmF5LCBpc0Jvb2xlYW5BdHRyLCBpc0J1aWx0SW5EaXJlY3RpdmUsIGlzRGF0ZSwgaXNGdW5jdGlvbiwgaXNHbG9iYWxseUFsbG93ZWQsIGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCwgaXNIVE1MVGFnLCBpc0ludGVnZXJLZXksIGlzS25vd25IdG1sQXR0ciwgaXNLbm93bk1hdGhNTEF0dHIsIGlzS25vd25TdmdBdHRyLCBpc01hcCwgaXNNYXRoTUxUYWcsIGlzTW9kZWxMaXN0ZW5lciwgaXNPYmplY3QsIGlzT24sIGlzUGxhaW5PYmplY3QsIGlzUHJvbWlzZSwgaXNSZWdFeHAsIGlzUmVuZGVyYWJsZUF0dHJWYWx1ZSwgaXNSZXNlcnZlZFByb3AsIGlzU1NSU2FmZUF0dHJOYW1lLCBpc1NWR1RhZywgaXNTZXQsIGlzU3BlY2lhbEJvb2xlYW5BdHRyLCBpc1N0cmluZywgaXNTeW1ib2wsIGlzVm9pZFRhZywgbG9vc2VFcXVhbCwgbG9vc2VJbmRleE9mLCBsb29zZVRvTnVtYmVyLCBtYWtlTWFwLCBub3JtYWxpemVDbGFzcywgbm9ybWFsaXplUHJvcHMsIG5vcm1hbGl6ZVN0eWxlLCBvYmplY3RUb1N0cmluZywgcGFyc2VTdHJpbmdTdHlsZSwgcHJvcHNUb0F0dHJNYXAsIHJlbW92ZSwgc2xvdEZsYWdzVGV4dCwgc3RyaW5naWZ5U3R5bGUsIHRvRGlzcGxheVN0cmluZywgdG9IYW5kbGVyS2V5LCB0b051bWJlciwgdG9SYXdUeXBlLCB0b1R5cGVTdHJpbmcgfTtcbiIsImV4cG9ydHMuaW50ZXJvcERlZmF1bHQgPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4gYSAmJiBhLl9fZXNNb2R1bGUgPyBhIDoge2RlZmF1bHQ6IGF9O1xufTtcblxuZXhwb3J0cy5kZWZpbmVJbnRlcm9wRmxhZyA9IGZ1bmN0aW9uIChhKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCAnX19lc01vZHVsZScsIHt2YWx1ZTogdHJ1ZX0pO1xufTtcblxuZXhwb3J0cy5leHBvcnRBbGwgPSBmdW5jdGlvbiAoc291cmNlLCBkZXN0KSB7XG4gIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGtleSA9PT0gJ2RlZmF1bHQnIHx8IGtleSA9PT0gJ19fZXNNb2R1bGUnIHx8IGRlc3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXN0LCBrZXksIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZVtrZXldO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5leHBvcnRzLmV4cG9ydCA9IGZ1bmN0aW9uIChkZXN0LCBkZXN0TmFtZSwgZ2V0KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXN0LCBkZXN0TmFtZSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBnZXQsXG4gIH0pO1xufTtcbiIsIi8qKlxuKiBAdnVlL3NoYXJlZCB2My41LjE2XG4qIChjKSAyMDE4LXByZXNlbnQgWXV4aSAoRXZhbikgWW91IGFuZCBWdWUgY29udHJpYnV0b3JzXG4qIEBsaWNlbnNlIE1JVFxuKiovXG4vKiEgI19fTk9fU0lERV9FRkZFQ1RTX18gKi9cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBtYWtlTWFwKHN0cikge1xuICBjb25zdCBtYXAgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yIChjb25zdCBrZXkgb2Ygc3RyLnNwbGl0KFwiLFwiKSkgbWFwW2tleV0gPSAxO1xuICByZXR1cm4gKHZhbCkgPT4gdmFsIGluIG1hcDtcbn1cblxuY29uc3QgRU1QVFlfT0JKID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IE9iamVjdC5mcmVlemUoe30pIDoge307XG5jb25zdCBFTVBUWV9BUlIgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gT2JqZWN0LmZyZWV6ZShbXSkgOiBbXTtcbmNvbnN0IE5PT1AgPSAoKSA9PiB7XG59O1xuY29uc3QgTk8gPSAoKSA9PiBmYWxzZTtcbmNvbnN0IGlzT24gPSAoa2V5KSA9PiBrZXkuY2hhckNvZGVBdCgwKSA9PT0gMTExICYmIGtleS5jaGFyQ29kZUF0KDEpID09PSAxMTAgJiYgLy8gdXBwZXJjYXNlIGxldHRlclxuKGtleS5jaGFyQ29kZUF0KDIpID4gMTIyIHx8IGtleS5jaGFyQ29kZUF0KDIpIDwgOTcpO1xuY29uc3QgaXNNb2RlbExpc3RlbmVyID0gKGtleSkgPT4ga2V5LnN0YXJ0c1dpdGgoXCJvblVwZGF0ZTpcIik7XG5jb25zdCBleHRlbmQgPSBPYmplY3QuYXNzaWduO1xuY29uc3QgcmVtb3ZlID0gKGFyciwgZWwpID0+IHtcbiAgY29uc3QgaSA9IGFyci5pbmRleE9mKGVsKTtcbiAgaWYgKGkgPiAtMSkge1xuICAgIGFyci5zcGxpY2UoaSwgMSk7XG4gIH1cbn07XG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5jb25zdCBoYXNPd24gPSAodmFsLCBrZXkpID0+IGhhc093blByb3BlcnR5LmNhbGwodmFsLCBrZXkpO1xuY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5jb25zdCBpc01hcCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgTWFwXVwiO1xuY29uc3QgaXNTZXQgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IFNldF1cIjtcbmNvbnN0IGlzRGF0ZSA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgRGF0ZV1cIjtcbmNvbnN0IGlzUmVnRXhwID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBSZWdFeHBdXCI7XG5jb25zdCBpc0Z1bmN0aW9uID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3QgaXNTdHJpbmcgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiO1xuY29uc3QgaXNTeW1ib2wgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN5bWJvbFwiO1xuY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIjtcbmNvbnN0IGlzUHJvbWlzZSA9ICh2YWwpID0+IHtcbiAgcmV0dXJuIChpc09iamVjdCh2YWwpIHx8IGlzRnVuY3Rpb24odmFsKSkgJiYgaXNGdW5jdGlvbih2YWwudGhlbikgJiYgaXNGdW5jdGlvbih2YWwuY2F0Y2gpO1xufTtcbmNvbnN0IG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IHRvVHlwZVN0cmluZyA9ICh2YWx1ZSkgPT4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5jb25zdCB0b1Jhd1R5cGUgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIHRvVHlwZVN0cmluZyh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xufTtcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbmNvbnN0IGlzSW50ZWdlcktleSA9IChrZXkpID0+IGlzU3RyaW5nKGtleSkgJiYga2V5ICE9PSBcIk5hTlwiICYmIGtleVswXSAhPT0gXCItXCIgJiYgXCJcIiArIHBhcnNlSW50KGtleSwgMTApID09PSBrZXk7XG5jb25zdCBpc1Jlc2VydmVkUHJvcCA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICAvLyB0aGUgbGVhZGluZyBjb21tYSBpcyBpbnRlbnRpb25hbCBzbyBlbXB0eSBzdHJpbmcgXCJcIiBpcyBhbHNvIGluY2x1ZGVkXG4gIFwiLGtleSxyZWYscmVmX2ZvcixyZWZfa2V5LG9uVm5vZGVCZWZvcmVNb3VudCxvblZub2RlTW91bnRlZCxvblZub2RlQmVmb3JlVXBkYXRlLG9uVm5vZGVVcGRhdGVkLG9uVm5vZGVCZWZvcmVVbm1vdW50LG9uVm5vZGVVbm1vdW50ZWRcIlxuKTtcbmNvbnN0IGlzQnVpbHRJbkRpcmVjdGl2ZSA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBcImJpbmQsY2xvYWssZWxzZS1pZixlbHNlLGZvcixodG1sLGlmLG1vZGVsLG9uLG9uY2UscHJlLHNob3csc2xvdCx0ZXh0LG1lbW9cIlxuKTtcbmNvbnN0IGNhY2hlU3RyaW5nRnVuY3Rpb24gPSAoZm4pID0+IHtcbiAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChzdHIpID0+IHtcbiAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcbiAgfTtcbn07XG5jb25zdCBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xuY29uc3QgY2FtZWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKFxuICAoc3RyKSA9PiB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiBjID8gYy50b1VwcGVyQ2FzZSgpIDogXCJcIik7XG4gIH1cbik7XG5jb25zdCBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG5jb25zdCBoeXBoZW5hdGUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKFxuICAoc3RyKSA9PiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgXCItJDFcIikudG9Mb3dlckNhc2UoKVxuKTtcbmNvbnN0IGNhcGl0YWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn0pO1xuY29uc3QgdG9IYW5kbGVyS2V5ID0gY2FjaGVTdHJpbmdGdW5jdGlvbihcbiAgKHN0cikgPT4ge1xuICAgIGNvbnN0IHMgPSBzdHIgPyBgb24ke2NhcGl0YWxpemUoc3RyKX1gIDogYGA7XG4gICAgcmV0dXJuIHM7XG4gIH1cbik7XG5jb25zdCBoYXNDaGFuZ2VkID0gKHZhbHVlLCBvbGRWYWx1ZSkgPT4gIU9iamVjdC5pcyh2YWx1ZSwgb2xkVmFsdWUpO1xuY29uc3QgaW52b2tlQXJyYXlGbnMgPSAoZm5zLCAuLi5hcmcpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICBmbnNbaV0oLi4uYXJnKTtcbiAgfVxufTtcbmNvbnN0IGRlZiA9IChvYmosIGtleSwgdmFsdWUsIHdyaXRhYmxlID0gZmFsc2UpID0+IHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlLFxuICAgIHZhbHVlXG4gIH0pO1xufTtcbmNvbnN0IGxvb3NlVG9OdW1iZXIgPSAodmFsKSA9PiB7XG4gIGNvbnN0IG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG47XG59O1xuY29uc3QgdG9OdW1iZXIgPSAodmFsKSA9PiB7XG4gIGNvbnN0IG4gPSBpc1N0cmluZyh2YWwpID8gTnVtYmVyKHZhbCkgOiBOYU47XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG47XG59O1xubGV0IF9nbG9iYWxUaGlzO1xuY29uc3QgZ2V0R2xvYmFsVGhpcyA9ICgpID0+IHtcbiAgcmV0dXJuIF9nbG9iYWxUaGlzIHx8IChfZ2xvYmFsVGhpcyA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pO1xufTtcbmNvbnN0IGlkZW50UkUgPSAvXltfJGEtekEtWlxceEEwLVxcdUZGRkZdW18kYS16QS1aMC05XFx4QTAtXFx1RkZGRl0qJC87XG5mdW5jdGlvbiBnZW5Qcm9wc0FjY2Vzc0V4cChuYW1lKSB7XG4gIHJldHVybiBpZGVudFJFLnRlc3QobmFtZSkgPyBgX19wcm9wcy4ke25hbWV9YCA6IGBfX3Byb3BzWyR7SlNPTi5zdHJpbmdpZnkobmFtZSl9XWA7XG59XG5mdW5jdGlvbiBnZW5DYWNoZUtleShzb3VyY2UsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHNvdXJjZSArIEpTT04uc3RyaW5naWZ5KFxuICAgIG9wdGlvbnMsXG4gICAgKF8sIHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiID8gdmFsLnRvU3RyaW5nKCkgOiB2YWxcbiAgKTtcbn1cblxuY29uc3QgUGF0Y2hGbGFncyA9IHtcbiAgXCJURVhUXCI6IDEsXG4gIFwiMVwiOiBcIlRFWFRcIixcbiAgXCJDTEFTU1wiOiAyLFxuICBcIjJcIjogXCJDTEFTU1wiLFxuICBcIlNUWUxFXCI6IDQsXG4gIFwiNFwiOiBcIlNUWUxFXCIsXG4gIFwiUFJPUFNcIjogOCxcbiAgXCI4XCI6IFwiUFJPUFNcIixcbiAgXCJGVUxMX1BST1BTXCI6IDE2LFxuICBcIjE2XCI6IFwiRlVMTF9QUk9QU1wiLFxuICBcIk5FRURfSFlEUkFUSU9OXCI6IDMyLFxuICBcIjMyXCI6IFwiTkVFRF9IWURSQVRJT05cIixcbiAgXCJTVEFCTEVfRlJBR01FTlRcIjogNjQsXG4gIFwiNjRcIjogXCJTVEFCTEVfRlJBR01FTlRcIixcbiAgXCJLRVlFRF9GUkFHTUVOVFwiOiAxMjgsXG4gIFwiMTI4XCI6IFwiS0VZRURfRlJBR01FTlRcIixcbiAgXCJVTktFWUVEX0ZSQUdNRU5UXCI6IDI1NixcbiAgXCIyNTZcIjogXCJVTktFWUVEX0ZSQUdNRU5UXCIsXG4gIFwiTkVFRF9QQVRDSFwiOiA1MTIsXG4gIFwiNTEyXCI6IFwiTkVFRF9QQVRDSFwiLFxuICBcIkRZTkFNSUNfU0xPVFNcIjogMTAyNCxcbiAgXCIxMDI0XCI6IFwiRFlOQU1JQ19TTE9UU1wiLFxuICBcIkRFVl9ST09UX0ZSQUdNRU5UXCI6IDIwNDgsXG4gIFwiMjA0OFwiOiBcIkRFVl9ST09UX0ZSQUdNRU5UXCIsXG4gIFwiQ0FDSEVEXCI6IC0xLFxuICBcIi0xXCI6IFwiQ0FDSEVEXCIsXG4gIFwiQkFJTFwiOiAtMixcbiAgXCItMlwiOiBcIkJBSUxcIlxufTtcbmNvbnN0IFBhdGNoRmxhZ05hbWVzID0ge1xuICBbMV06IGBURVhUYCxcbiAgWzJdOiBgQ0xBU1NgLFxuICBbNF06IGBTVFlMRWAsXG4gIFs4XTogYFBST1BTYCxcbiAgWzE2XTogYEZVTExfUFJPUFNgLFxuICBbMzJdOiBgTkVFRF9IWURSQVRJT05gLFxuICBbNjRdOiBgU1RBQkxFX0ZSQUdNRU5UYCxcbiAgWzEyOF06IGBLRVlFRF9GUkFHTUVOVGAsXG4gIFsyNTZdOiBgVU5LRVlFRF9GUkFHTUVOVGAsXG4gIFs1MTJdOiBgTkVFRF9QQVRDSGAsXG4gIFsxMDI0XTogYERZTkFNSUNfU0xPVFNgLFxuICBbMjA0OF06IGBERVZfUk9PVF9GUkFHTUVOVGAsXG4gIFstMV06IGBIT0lTVEVEYCxcbiAgWy0yXTogYEJBSUxgXG59O1xuXG5jb25zdCBTaGFwZUZsYWdzID0ge1xuICBcIkVMRU1FTlRcIjogMSxcbiAgXCIxXCI6IFwiRUxFTUVOVFwiLFxuICBcIkZVTkNUSU9OQUxfQ09NUE9ORU5UXCI6IDIsXG4gIFwiMlwiOiBcIkZVTkNUSU9OQUxfQ09NUE9ORU5UXCIsXG4gIFwiU1RBVEVGVUxfQ09NUE9ORU5UXCI6IDQsXG4gIFwiNFwiOiBcIlNUQVRFRlVMX0NPTVBPTkVOVFwiLFxuICBcIlRFWFRfQ0hJTERSRU5cIjogOCxcbiAgXCI4XCI6IFwiVEVYVF9DSElMRFJFTlwiLFxuICBcIkFSUkFZX0NISUxEUkVOXCI6IDE2LFxuICBcIjE2XCI6IFwiQVJSQVlfQ0hJTERSRU5cIixcbiAgXCJTTE9UU19DSElMRFJFTlwiOiAzMixcbiAgXCIzMlwiOiBcIlNMT1RTX0NISUxEUkVOXCIsXG4gIFwiVEVMRVBPUlRcIjogNjQsXG4gIFwiNjRcIjogXCJURUxFUE9SVFwiLFxuICBcIlNVU1BFTlNFXCI6IDEyOCxcbiAgXCIxMjhcIjogXCJTVVNQRU5TRVwiLFxuICBcIkNPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRVwiOiAyNTYsXG4gIFwiMjU2XCI6IFwiQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFXCIsXG4gIFwiQ09NUE9ORU5UX0tFUFRfQUxJVkVcIjogNTEyLFxuICBcIjUxMlwiOiBcIkNPTVBPTkVOVF9LRVBUX0FMSVZFXCIsXG4gIFwiQ09NUE9ORU5UXCI6IDYsXG4gIFwiNlwiOiBcIkNPTVBPTkVOVFwiXG59O1xuXG5jb25zdCBTbG90RmxhZ3MgPSB7XG4gIFwiU1RBQkxFXCI6IDEsXG4gIFwiMVwiOiBcIlNUQUJMRVwiLFxuICBcIkRZTkFNSUNcIjogMixcbiAgXCIyXCI6IFwiRFlOQU1JQ1wiLFxuICBcIkZPUldBUkRFRFwiOiAzLFxuICBcIjNcIjogXCJGT1JXQVJERURcIlxufTtcbmNvbnN0IHNsb3RGbGFnc1RleHQgPSB7XG4gIFsxXTogXCJTVEFCTEVcIixcbiAgWzJdOiBcIkRZTkFNSUNcIixcbiAgWzNdOiBcIkZPUldBUkRFRFwiXG59O1xuXG5jb25zdCBHTE9CQUxTX0FMTE9XRUQgPSBcIkluZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4scGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLEJpZ0ludCxjb25zb2xlLEVycm9yLFN5bWJvbFwiO1xuY29uc3QgaXNHbG9iYWxseUFsbG93ZWQgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChHTE9CQUxTX0FMTE9XRUQpO1xuY29uc3QgaXNHbG9iYWxseVdoaXRlbGlzdGVkID0gaXNHbG9iYWxseUFsbG93ZWQ7XG5cbmNvbnN0IHJhbmdlID0gMjtcbmZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lKHNvdXJjZSwgc3RhcnQgPSAwLCBlbmQgPSBzb3VyY2UubGVuZ3RoKSB7XG4gIHN0YXJ0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc3RhcnQsIHNvdXJjZS5sZW5ndGgpKTtcbiAgZW5kID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZW5kLCBzb3VyY2UubGVuZ3RoKSk7XG4gIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFwiXCI7XG4gIGxldCBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvKFxccj9cXG4pLyk7XG4gIGNvbnN0IG5ld2xpbmVTZXF1ZW5jZXMgPSBsaW5lcy5maWx0ZXIoKF8sIGlkeCkgPT4gaWR4ICUgMiA9PT0gMSk7XG4gIGxpbmVzID0gbGluZXMuZmlsdGVyKChfLCBpZHgpID0+IGlkeCAlIDIgPT09IDApO1xuICBsZXQgY291bnQgPSAwO1xuICBjb25zdCByZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvdW50ICs9IGxpbmVzW2ldLmxlbmd0aCArIChuZXdsaW5lU2VxdWVuY2VzW2ldICYmIG5ld2xpbmVTZXF1ZW5jZXNbaV0ubGVuZ3RoIHx8IDApO1xuICAgIGlmIChjb3VudCA+PSBzdGFydCkge1xuICAgICAgZm9yIChsZXQgaiA9IGkgLSByYW5nZTsgaiA8PSBpICsgcmFuZ2UgfHwgZW5kID4gY291bnQ7IGorKykge1xuICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBsaW5lcy5sZW5ndGgpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBsaW5lID0gaiArIDE7XG4gICAgICAgIHJlcy5wdXNoKFxuICAgICAgICAgIGAke2xpbmV9JHtcIiBcIi5yZXBlYXQoTWF0aC5tYXgoMyAtIFN0cmluZyhsaW5lKS5sZW5ndGgsIDApKX18ICAke2xpbmVzW2pdfWBcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IGxpbmVzW2pdLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbmV3TGluZVNlcUxlbmd0aCA9IG5ld2xpbmVTZXF1ZW5jZXNbal0gJiYgbmV3bGluZVNlcXVlbmNlc1tqXS5sZW5ndGggfHwgMDtcbiAgICAgICAgaWYgKGogPT09IGkpIHtcbiAgICAgICAgICBjb25zdCBwYWQgPSBzdGFydCAtIChjb3VudCAtIChsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aCkpO1xuICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArIFwiIFwiLnJlcGVhdChwYWQpICsgXCJeXCIucmVwZWF0KGxlbmd0aCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGogPiBpKSB7XG4gICAgICAgICAgaWYgKGVuZCA+IGNvdW50KSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChNYXRoLm1pbihlbmQgLSBjb3VudCwgbGluZUxlbmd0aCksIDEpO1xuICAgICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyBcIl5cIi5yZXBlYXQobGVuZ3RoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvdW50ICs9IGxpbmVMZW5ndGggKyBuZXdMaW5lU2VxTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy5qb2luKFwiXFxuXCIpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZSh2YWx1ZSkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gdmFsdWVbaV07XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gaXNTdHJpbmcoaXRlbSkgPyBwYXJzZVN0cmluZ1N0eWxlKGl0ZW0pIDogbm9ybWFsaXplU3R5bGUoaXRlbSk7XG4gICAgICBpZiAobm9ybWFsaXplZCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBub3JtYWxpemVkKSB7XG4gICAgICAgICAgcmVzW2tleV0gPSBub3JtYWxpemVkW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfSBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkgfHwgaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5jb25zdCBsaXN0RGVsaW1pdGVyUkUgPSAvOyg/IVteKF0qXFwpKS9nO1xuY29uc3QgcHJvcGVydHlEZWxpbWl0ZXJSRSA9IC86KFteXSspLztcbmNvbnN0IHN0eWxlQ29tbWVudFJFID0gL1xcL1xcKlteXSo/XFwqXFwvL2c7XG5mdW5jdGlvbiBwYXJzZVN0cmluZ1N0eWxlKGNzc1RleHQpIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGNzc1RleHQucmVwbGFjZShzdHlsZUNvbW1lbnRSRSwgXCJcIikuc3BsaXQobGlzdERlbGltaXRlclJFKS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIGNvbnN0IHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXJSRSk7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmV0W3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVN0eWxlKHN0eWxlcykge1xuICBpZiAoIXN0eWxlcykgcmV0dXJuIFwiXCI7XG4gIGlmIChpc1N0cmluZyhzdHlsZXMpKSByZXR1cm4gc3R5bGVzO1xuICBsZXQgcmV0ID0gXCJcIjtcbiAgZm9yIChjb25zdCBrZXkgaW4gc3R5bGVzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzdHlsZXNba2V5XTtcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGtleS5zdGFydHNXaXRoKGAtLWApID8ga2V5IDogaHlwaGVuYXRlKGtleSk7XG4gICAgICByZXQgKz0gYCR7bm9ybWFsaXplZEtleX06JHt2YWx1ZX07YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzKHZhbHVlKSB7XG4gIGxldCByZXMgPSBcIlwiO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgcmVzID0gdmFsdWU7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplQ2xhc3ModmFsdWVbaV0pO1xuICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgcmVzICs9IG5vcm1hbGl6ZWQgKyBcIiBcIjtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgZm9yIChjb25zdCBuYW1lIGluIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWVbbmFtZV0pIHtcbiAgICAgICAgcmVzICs9IG5hbWUgKyBcIiBcIjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy50cmltKCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyhwcm9wcykge1xuICBpZiAoIXByb3BzKSByZXR1cm4gbnVsbDtcbiAgbGV0IHsgY2xhc3M6IGtsYXNzLCBzdHlsZSB9ID0gcHJvcHM7XG4gIGlmIChrbGFzcyAmJiAhaXNTdHJpbmcoa2xhc3MpKSB7XG4gICAgcHJvcHMuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhrbGFzcyk7XG4gIH1cbiAgaWYgKHN0eWxlKSB7XG4gICAgcHJvcHMuc3R5bGUgPSBub3JtYWxpemVTdHlsZShzdHlsZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BzO1xufVxuXG5jb25zdCBIVE1MX1RBR1MgPSBcImh0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLGFkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGhncm91cCxoMSxoMixoMyxoNCxoNSxoNixuYXYsc2VjdGlvbixkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCxhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnVieSxzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbyxlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucyxjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0cixidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLG91dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsZGV0YWlscyxkaWFsb2csbWVudSxzdW1tYXJ5LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290XCI7XG5jb25zdCBTVkdfVEFHUyA9IFwic3ZnLGFuaW1hdGUsYW5pbWF0ZU1vdGlvbixhbmltYXRlVHJhbnNmb3JtLGNpcmNsZSxjbGlwUGF0aCxjb2xvci1wcm9maWxlLGRlZnMsZGVzYyxkaXNjYXJkLGVsbGlwc2UsZmVCbGVuZCxmZUNvbG9yTWF0cml4LGZlQ29tcG9uZW50VHJhbnNmZXIsZmVDb21wb3NpdGUsZmVDb252b2x2ZU1hdHJpeCxmZURpZmZ1c2VMaWdodGluZyxmZURpc3BsYWNlbWVudE1hcCxmZURpc3RhbnRMaWdodCxmZURyb3BTaGFkb3csZmVGbG9vZCxmZUZ1bmNBLGZlRnVuY0IsZmVGdW5jRyxmZUZ1bmNSLGZlR2F1c3NpYW5CbHVyLGZlSW1hZ2UsZmVNZXJnZSxmZU1lcmdlTm9kZSxmZU1vcnBob2xvZ3ksZmVPZmZzZXQsZmVQb2ludExpZ2h0LGZlU3BlY3VsYXJMaWdodGluZyxmZVNwb3RMaWdodCxmZVRpbGUsZmVUdXJidWxlbmNlLGZpbHRlcixmb3JlaWduT2JqZWN0LGcsaGF0Y2gsaGF0Y2hwYXRoLGltYWdlLGxpbmUsbGluZWFyR3JhZGllbnQsbWFya2VyLG1hc2ssbWVzaCxtZXNoZ3JhZGllbnQsbWVzaHBhdGNoLG1lc2hyb3csbWV0YWRhdGEsbXBhdGgscGF0aCxwYXR0ZXJuLHBvbHlnb24scG9seWxpbmUscmFkaWFsR3JhZGllbnQscmVjdCxzZXQsc29saWRjb2xvcixzdG9wLHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0UGF0aCx0aXRsZSx0c3Bhbix1bmtub3duLHVzZSx2aWV3XCI7XG5jb25zdCBNQVRIX1RBR1MgPSBcImFubm90YXRpb24sYW5ub3RhdGlvbi14bWwsbWFjdGlvbixtYWxpZ25ncm91cCxtYWxpZ25tYXJrLG1hdGgsbWVuY2xvc2UsbWVycm9yLG1mZW5jZWQsbWZyYWMsbWZyYWN0aW9uLG1nbHlwaCxtaSxtbGFiZWxlZHRyLG1sb25nZGl2LG1tdWx0aXNjcmlwdHMsbW4sbW8sbW92ZXIsbXBhZGRlZCxtcGhhbnRvbSxtcHJlc2NyaXB0cyxtcm9vdCxtcm93LG1zLG1zY2Fycmllcyxtc2NhcnJ5LG1zZ3JvdXAsbXNsaW5lLG1zcGFjZSxtc3FydCxtc3Jvdyxtc3RhY2ssbXN0eWxlLG1zdWIsbXN1YnN1cCxtc3VwLG10YWJsZSxtdGQsbXRleHQsbXRyLG11bmRlcixtdW5kZXJvdmVyLG5vbmUsc2VtYW50aWNzXCI7XG5jb25zdCBWT0lEX1RBR1MgPSBcImFyZWEsYmFzZSxicixjb2wsZW1iZWQsaHIsaW1nLGlucHV0LGxpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyXCI7XG5jb25zdCBpc0hUTUxUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChIVE1MX1RBR1MpO1xuY29uc3QgaXNTVkdUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChTVkdfVEFHUyk7XG5jb25zdCBpc01hdGhNTFRhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKE1BVEhfVEFHUyk7XG5jb25zdCBpc1ZvaWRUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChWT0lEX1RBR1MpO1xuXG5jb25zdCBzcGVjaWFsQm9vbGVhbkF0dHJzID0gYGl0ZW1zY29wZSxhbGxvd2Z1bGxzY3JlZW4sZm9ybW5vdmFsaWRhdGUsaXNtYXAsbm9tb2R1bGUsbm92YWxpZGF0ZSxyZWFkb25seWA7XG5jb25zdCBpc1NwZWNpYWxCb29sZWFuQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKHNwZWNpYWxCb29sZWFuQXR0cnMpO1xuY29uc3QgaXNCb29sZWFuQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBzcGVjaWFsQm9vbGVhbkF0dHJzICsgYCxhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY29udHJvbHMsZGVmYXVsdCxkZWZlcixkaXNhYmxlZCxoaWRkZW4saW5lcnQsbG9vcCxvcGVuLHJlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxjaGVja2VkLG11dGVkLG11bHRpcGxlLHNlbGVjdGVkYFxuKTtcbmZ1bmN0aW9uIGluY2x1ZGVCb29sZWFuQXR0cih2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSB8fCB2YWx1ZSA9PT0gXCJcIjtcbn1cbmNvbnN0IHVuc2FmZUF0dHJDaGFyUkUgPSAvWz4vPVwiJ1xcdTAwMDlcXHUwMDBhXFx1MDAwY1xcdTAwMjBdLztcbmNvbnN0IGF0dHJWYWxpZGF0aW9uQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGlzU1NSU2FmZUF0dHJOYW1lKG5hbWUpIHtcbiAgaWYgKGF0dHJWYWxpZGF0aW9uQ2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICByZXR1cm4gYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXTtcbiAgfVxuICBjb25zdCBpc1Vuc2FmZSA9IHVuc2FmZUF0dHJDaGFyUkUudGVzdChuYW1lKTtcbiAgaWYgKGlzVW5zYWZlKSB7XG4gICAgY29uc29sZS5lcnJvcihgdW5zYWZlIGF0dHJpYnV0ZSBuYW1lOiAke25hbWV9YCk7XG4gIH1cbiAgcmV0dXJuIGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV0gPSAhaXNVbnNhZmU7XG59XG5jb25zdCBwcm9wc1RvQXR0ck1hcCA9IHtcbiAgYWNjZXB0Q2hhcnNldDogXCJhY2NlcHQtY2hhcnNldFwiLFxuICBjbGFzc05hbWU6IFwiY2xhc3NcIixcbiAgaHRtbEZvcjogXCJmb3JcIixcbiAgaHR0cEVxdWl2OiBcImh0dHAtZXF1aXZcIlxufTtcbmNvbnN0IGlzS25vd25IdG1sQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBgYWNjZXB0LGFjY2VwdC1jaGFyc2V0LGFjY2Vzc2tleSxhY3Rpb24sYWxpZ24sYWxsb3csYWx0LGFzeW5jLGF1dG9jYXBpdGFsaXplLGF1dG9jb21wbGV0ZSxhdXRvZm9jdXMsYXV0b3BsYXksYmFja2dyb3VuZCxiZ2NvbG9yLGJvcmRlcixidWZmZXJlZCxjYXB0dXJlLGNoYWxsZW5nZSxjaGFyc2V0LGNoZWNrZWQsY2l0ZSxjbGFzcyxjb2RlLGNvZGViYXNlLGNvbG9yLGNvbHMsY29sc3Bhbixjb250ZW50LGNvbnRlbnRlZGl0YWJsZSxjb250ZXh0bWVudSxjb250cm9scyxjb29yZHMsY3Jvc3NvcmlnaW4sY3NwLGRhdGEsZGF0ZXRpbWUsZGVjb2RpbmcsZGVmYXVsdCxkZWZlcixkaXIsZGlybmFtZSxkaXNhYmxlZCxkb3dubG9hZCxkcmFnZ2FibGUsZHJvcHpvbmUsZW5jdHlwZSxlbnRlcmtleWhpbnQsZm9yLGZvcm0sZm9ybWFjdGlvbixmb3JtZW5jdHlwZSxmb3JtbWV0aG9kLGZvcm1ub3ZhbGlkYXRlLGZvcm10YXJnZXQsaGVhZGVycyxoZWlnaHQsaGlkZGVuLGhpZ2gsaHJlZixocmVmbGFuZyxodHRwLWVxdWl2LGljb24saWQsaW1wb3J0YW5jZSxpbmVydCxpbnRlZ3JpdHksaXNtYXAsaXRlbXByb3Asa2V5dHlwZSxraW5kLGxhYmVsLGxhbmcsbGFuZ3VhZ2UsbG9hZGluZyxsaXN0LGxvb3AsbG93LG1hbmlmZXN0LG1heCxtYXhsZW5ndGgsbWlubGVuZ3RoLG1lZGlhLG1pbixtdWx0aXBsZSxtdXRlZCxuYW1lLG5vdmFsaWRhdGUsb3BlbixvcHRpbXVtLHBhdHRlcm4scGluZyxwbGFjZWhvbGRlcixwb3N0ZXIscHJlbG9hZCxyYWRpb2dyb3VwLHJlYWRvbmx5LHJlZmVycmVycG9saWN5LHJlbCxyZXF1aXJlZCxyZXZlcnNlZCxyb3dzLHJvd3NwYW4sc2FuZGJveCxzY29wZSxzY29wZWQsc2VsZWN0ZWQsc2hhcGUsc2l6ZSxzaXplcyxzbG90LHNwYW4sc3BlbGxjaGVjayxzcmMsc3JjZG9jLHNyY2xhbmcsc3Jjc2V0LHN0YXJ0LHN0ZXAsc3R5bGUsc3VtbWFyeSx0YWJpbmRleCx0YXJnZXQsdGl0bGUsdHJhbnNsYXRlLHR5cGUsdXNlbWFwLHZhbHVlLHdpZHRoLHdyYXBgXG4pO1xuY29uc3QgaXNLbm93blN2Z0F0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgYHhtbG5zLGFjY2VudC1oZWlnaHQsYWNjdW11bGF0ZSxhZGRpdGl2ZSxhbGlnbm1lbnQtYmFzZWxpbmUsYWxwaGFiZXRpYyxhbXBsaXR1ZGUsYXJhYmljLWZvcm0sYXNjZW50LGF0dHJpYnV0ZU5hbWUsYXR0cmlidXRlVHlwZSxhemltdXRoLGJhc2VGcmVxdWVuY3ksYmFzZWxpbmUtc2hpZnQsYmFzZVByb2ZpbGUsYmJveCxiZWdpbixiaWFzLGJ5LGNhbGNNb2RlLGNhcC1oZWlnaHQsY2xhc3MsY2xpcCxjbGlwUGF0aFVuaXRzLGNsaXAtcGF0aCxjbGlwLXJ1bGUsY29sb3IsY29sb3ItaW50ZXJwb2xhdGlvbixjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMsY29sb3ItcHJvZmlsZSxjb2xvci1yZW5kZXJpbmcsY29udGVudFNjcmlwdFR5cGUsY29udGVudFN0eWxlVHlwZSxjcm9zc29yaWdpbixjdXJzb3IsY3gsY3ksZCxkZWNlbGVyYXRlLGRlc2NlbnQsZGlmZnVzZUNvbnN0YW50LGRpcmVjdGlvbixkaXNwbGF5LGRpdmlzb3IsZG9taW5hbnQtYmFzZWxpbmUsZHVyLGR4LGR5LGVkZ2VNb2RlLGVsZXZhdGlvbixlbmFibGUtYmFja2dyb3VuZCxlbmQsZXhwb25lbnQsZmlsbCxmaWxsLW9wYWNpdHksZmlsbC1ydWxlLGZpbHRlcixmaWx0ZXJSZXMsZmlsdGVyVW5pdHMsZmxvb2QtY29sb3IsZmxvb2Qtb3BhY2l0eSxmb250LWZhbWlseSxmb250LXNpemUsZm9udC1zaXplLWFkanVzdCxmb250LXN0cmV0Y2gsZm9udC1zdHlsZSxmb250LXZhcmlhbnQsZm9udC13ZWlnaHQsZm9ybWF0LGZyb20sZnIsZngsZnksZzEsZzIsZ2x5cGgtbmFtZSxnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsLGdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsLGdseXBoUmVmLGdyYWRpZW50VHJhbnNmb3JtLGdyYWRpZW50VW5pdHMsaGFuZ2luZyxoZWlnaHQsaHJlZixocmVmbGFuZyxob3Jpei1hZHYteCxob3Jpei1vcmlnaW4teCxpZCxpZGVvZ3JhcGhpYyxpbWFnZS1yZW5kZXJpbmcsaW4saW4yLGludGVyY2VwdCxrLGsxLGsyLGszLGs0LGtlcm5lbE1hdHJpeCxrZXJuZWxVbml0TGVuZ3RoLGtlcm5pbmcsa2V5UG9pbnRzLGtleVNwbGluZXMsa2V5VGltZXMsbGFuZyxsZW5ndGhBZGp1c3QsbGV0dGVyLXNwYWNpbmcsbGlnaHRpbmctY29sb3IsbGltaXRpbmdDb25lQW5nbGUsbG9jYWwsbWFya2VyLWVuZCxtYXJrZXItbWlkLG1hcmtlci1zdGFydCxtYXJrZXJIZWlnaHQsbWFya2VyVW5pdHMsbWFya2VyV2lkdGgsbWFzayxtYXNrQ29udGVudFVuaXRzLG1hc2tVbml0cyxtYXRoZW1hdGljYWwsbWF4LG1lZGlhLG1ldGhvZCxtaW4sbW9kZSxuYW1lLG51bU9jdGF2ZXMsb2Zmc2V0LG9wYWNpdHksb3BlcmF0b3Isb3JkZXIsb3JpZW50LG9yaWVudGF0aW9uLG9yaWdpbixvdmVyZmxvdyxvdmVybGluZS1wb3NpdGlvbixvdmVybGluZS10aGlja25lc3MscGFub3NlLTEscGFpbnQtb3JkZXIscGF0aCxwYXRoTGVuZ3RoLHBhdHRlcm5Db250ZW50VW5pdHMscGF0dGVyblRyYW5zZm9ybSxwYXR0ZXJuVW5pdHMscGluZyxwb2ludGVyLWV2ZW50cyxwb2ludHMscG9pbnRzQXRYLHBvaW50c0F0WSxwb2ludHNBdFoscHJlc2VydmVBbHBoYSxwcmVzZXJ2ZUFzcGVjdFJhdGlvLHByaW1pdGl2ZVVuaXRzLHIscmFkaXVzLHJlZmVycmVyUG9saWN5LHJlZlgscmVmWSxyZWwscmVuZGVyaW5nLWludGVudCxyZXBlYXRDb3VudCxyZXBlYXREdXIscmVxdWlyZWRFeHRlbnNpb25zLHJlcXVpcmVkRmVhdHVyZXMscmVzdGFydCxyZXN1bHQscm90YXRlLHJ4LHJ5LHNjYWxlLHNlZWQsc2hhcGUtcmVuZGVyaW5nLHNsb3BlLHNwYWNpbmcsc3BlY3VsYXJDb25zdGFudCxzcGVjdWxhckV4cG9uZW50LHNwZWVkLHNwcmVhZE1ldGhvZCxzdGFydE9mZnNldCxzdGREZXZpYXRpb24sc3RlbWgsc3RlbXYsc3RpdGNoVGlsZXMsc3RvcC1jb2xvcixzdG9wLW9wYWNpdHksc3RyaWtldGhyb3VnaC1wb3NpdGlvbixzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyxzdHJpbmcsc3Ryb2tlLHN0cm9rZS1kYXNoYXJyYXksc3Ryb2tlLWRhc2hvZmZzZXQsc3Ryb2tlLWxpbmVjYXAsc3Ryb2tlLWxpbmVqb2luLHN0cm9rZS1taXRlcmxpbWl0LHN0cm9rZS1vcGFjaXR5LHN0cm9rZS13aWR0aCxzdHlsZSxzdXJmYWNlU2NhbGUsc3lzdGVtTGFuZ3VhZ2UsdGFiaW5kZXgsdGFibGVWYWx1ZXMsdGFyZ2V0LHRhcmdldFgsdGFyZ2V0WSx0ZXh0LWFuY2hvcix0ZXh0LWRlY29yYXRpb24sdGV4dC1yZW5kZXJpbmcsdGV4dExlbmd0aCx0byx0cmFuc2Zvcm0sdHJhbnNmb3JtLW9yaWdpbix0eXBlLHUxLHUyLHVuZGVybGluZS1wb3NpdGlvbix1bmRlcmxpbmUtdGhpY2tuZXNzLHVuaWNvZGUsdW5pY29kZS1iaWRpLHVuaWNvZGUtcmFuZ2UsdW5pdHMtcGVyLWVtLHYtYWxwaGFiZXRpYyx2LWhhbmdpbmcsdi1pZGVvZ3JhcGhpYyx2LW1hdGhlbWF0aWNhbCx2YWx1ZXMsdmVjdG9yLWVmZmVjdCx2ZXJzaW9uLHZlcnQtYWR2LXksdmVydC1vcmlnaW4teCx2ZXJ0LW9yaWdpbi15LHZpZXdCb3gsdmlld1RhcmdldCx2aXNpYmlsaXR5LHdpZHRoLHdpZHRocyx3b3JkLXNwYWNpbmcsd3JpdGluZy1tb2RlLHgseC1oZWlnaHQseDEseDIseENoYW5uZWxTZWxlY3Rvcix4bGluazphY3R1YXRlLHhsaW5rOmFyY3JvbGUseGxpbms6aHJlZix4bGluazpyb2xlLHhsaW5rOnNob3cseGxpbms6dGl0bGUseGxpbms6dHlwZSx4bWxuczp4bGluayx4bWw6YmFzZSx4bWw6bGFuZyx4bWw6c3BhY2UseSx5MSx5Mix5Q2hhbm5lbFNlbGVjdG9yLHosem9vbUFuZFBhbmBcbik7XG5jb25zdCBpc0tub3duTWF0aE1MQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBgYWNjZW50LGFjY2VudHVuZGVyLGFjdGlvbnR5cGUsYWxpZ24sYWxpZ25tZW50c2NvcGUsYWx0aW1nLGFsdGltZy1oZWlnaHQsYWx0aW1nLXZhbGlnbixhbHRpbWctd2lkdGgsYWx0dGV4dCxiZXZlbGxlZCxjbG9zZSxjb2x1bW5zYWxpZ24sY29sdW1ubGluZXMsY29sdW1uc3BhbixkZW5vbWFsaWduLGRlcHRoLGRpcixkaXNwbGF5LGRpc3BsYXlzdHlsZSxlbmNvZGluZyxlcXVhbGNvbHVtbnMsZXF1YWxyb3dzLGZlbmNlLGZvbnRzdHlsZSxmb250d2VpZ2h0LGZvcm0sZnJhbWUsZnJhbWVzcGFjaW5nLGdyb3VwYWxpZ24saGVpZ2h0LGhyZWYsaWQsaW5kZW50YWxpZ24saW5kZW50YWxpZ25maXJzdCxpbmRlbnRhbGlnbmxhc3QsaW5kZW50c2hpZnQsaW5kZW50c2hpZnRmaXJzdCxpbmRlbnRzaGlmdGxhc3QsaW5kZXh0eXBlLGp1c3RpZnksbGFyZ2V0b3AsbGFyZ2VvcCxscXVvdGUsbHNwYWNlLG1hdGhiYWNrZ3JvdW5kLG1hdGhjb2xvcixtYXRoc2l6ZSxtYXRodmFyaWFudCxtYXhzaXplLG1pbmxhYmVsc3BhY2luZyxtb2RlLG90aGVyLG92ZXJmbG93LHBvc2l0aW9uLHJvd2FsaWduLHJvd2xpbmVzLHJvd3NwYW4scnF1b3RlLHJzcGFjZSxzY3JpcHRsZXZlbCxzY3JpcHRtaW5zaXplLHNjcmlwdHNpemVtdWx0aXBsaWVyLHNlbGVjdGlvbixzZXBhcmF0b3Isc2VwYXJhdG9ycyxzaGlmdCxzaWRlLHNyYyxzdGFja2FsaWduLHN0cmV0Y2h5LHN1YnNjcmlwdHNoaWZ0LHN1cGVyc2NyaXB0c2hpZnQsc3ltbWV0cmljLHZvZmZzZXQsd2lkdGgsd2lkdGhzLHhsaW5rOmhyZWYseGxpbms6c2hvdyx4bGluazp0eXBlLHhtbG5zYFxuKTtcbmZ1bmN0aW9uIGlzUmVuZGVyYWJsZUF0dHJWYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiO1xufVxuXG5jb25zdCBlc2NhcGVSRSA9IC9bXCInJjw+XS87XG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xuICBjb25zdCBzdHIgPSBcIlwiICsgc3RyaW5nO1xuICBjb25zdCBtYXRjaCA9IGVzY2FwZVJFLmV4ZWMoc3RyKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgbGV0IGh0bWwgPSBcIlwiO1xuICBsZXQgZXNjYXBlZDtcbiAgbGV0IGluZGV4O1xuICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgY2FzZSAzNDpcbiAgICAgICAgZXNjYXBlZCA9IFwiJnF1b3Q7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzODpcbiAgICAgICAgZXNjYXBlZCA9IFwiJmFtcDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM5OlxuICAgICAgICBlc2NhcGVkID0gXCImIzM5O1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNjA6XG4gICAgICAgIGVzY2FwZWQgPSBcIiZsdDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDYyOlxuICAgICAgICBlc2NhcGVkID0gXCImZ3Q7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChsYXN0SW5kZXggIT09IGluZGV4KSB7XG4gICAgICBodG1sICs9IHN0ci5zbGljZShsYXN0SW5kZXgsIGluZGV4KTtcbiAgICB9XG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyAxO1xuICAgIGh0bWwgKz0gZXNjYXBlZDtcbiAgfVxuICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc2xpY2UobGFzdEluZGV4LCBpbmRleCkgOiBodG1sO1xufVxuY29uc3QgY29tbWVudFN0cmlwUkUgPSAvXi0/Pnw8IS0tfC0tPnwtLSE+fDwhLSQvZztcbmZ1bmN0aW9uIGVzY2FwZUh0bWxDb21tZW50KHNyYykge1xuICByZXR1cm4gc3JjLnJlcGxhY2UoY29tbWVudFN0cmlwUkUsIFwiXCIpO1xufVxuY29uc3QgY3NzVmFyTmFtZUVzY2FwZVN5bWJvbHNSRSA9IC9bICFcIiMkJSYnKCkqKywuLzo7PD0+P0BbXFxcXFxcXV5ge3x9fl0vZztcbmZ1bmN0aW9uIGdldEVzY2FwZWRDc3NWYXJOYW1lKGtleSwgZG91YmxlRXNjYXBlKSB7XG4gIHJldHVybiBrZXkucmVwbGFjZShcbiAgICBjc3NWYXJOYW1lRXNjYXBlU3ltYm9sc1JFLFxuICAgIChzKSA9PiBkb3VibGVFc2NhcGUgPyBzID09PSAnXCInID8gJ1xcXFxcXFxcXFxcXFwiJyA6IGBcXFxcXFxcXCR7c31gIDogYFxcXFwke3N9YFxuICApO1xufVxuXG5mdW5jdGlvbiBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikge1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIGxldCBlcXVhbCA9IHRydWU7XG4gIGZvciAobGV0IGkgPSAwOyBlcXVhbCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGVxdWFsID0gbG9vc2VFcXVhbChhW2ldLCBiW2ldKTtcbiAgfVxuICByZXR1cm4gZXF1YWw7XG59XG5mdW5jdGlvbiBsb29zZUVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuICBsZXQgYVZhbGlkVHlwZSA9IGlzRGF0ZShhKTtcbiAgbGV0IGJWYWxpZFR5cGUgPSBpc0RhdGUoYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpIDogZmFsc2U7XG4gIH1cbiAgYVZhbGlkVHlwZSA9IGlzU3ltYm9sKGEpO1xuICBiVmFsaWRUeXBlID0gaXNTeW1ib2woYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgfVxuICBhVmFsaWRUeXBlID0gaXNBcnJheShhKTtcbiAgYlZhbGlkVHlwZSA9IGlzQXJyYXkoYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gbG9vc2VDb21wYXJlQXJyYXlzKGEsIGIpIDogZmFsc2U7XG4gIH1cbiAgYVZhbGlkVHlwZSA9IGlzT2JqZWN0KGEpO1xuICBiVmFsaWRUeXBlID0gaXNPYmplY3QoYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICBpZiAoIWFWYWxpZFR5cGUgfHwgIWJWYWxpZFR5cGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYUtleXNDb3VudCA9IE9iamVjdC5rZXlzKGEpLmxlbmd0aDtcbiAgICBjb25zdCBiS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYikubGVuZ3RoO1xuICAgIGlmIChhS2V5c0NvdW50ICE9PSBiS2V5c0NvdW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIGEpIHtcbiAgICAgIGNvbnN0IGFIYXNLZXkgPSBhLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICBjb25zdCBiSGFzS2V5ID0gYi5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgICAgaWYgKGFIYXNLZXkgJiYgIWJIYXNLZXkgfHwgIWFIYXNLZXkgJiYgYkhhc0tleSB8fCAhbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYik7XG59XG5mdW5jdGlvbiBsb29zZUluZGV4T2YoYXJyLCB2YWwpIHtcbiAgcmV0dXJuIGFyci5maW5kSW5kZXgoKGl0ZW0pID0+IGxvb3NlRXF1YWwoaXRlbSwgdmFsKSk7XG59XG5cbmNvbnN0IGlzUmVmID0gKHZhbCkgPT4ge1xuICByZXR1cm4gISEodmFsICYmIHZhbFtcIl9fdl9pc1JlZlwiXSA9PT0gdHJ1ZSk7XG59O1xuY29uc3QgdG9EaXNwbGF5U3RyaW5nID0gKHZhbCkgPT4ge1xuICByZXR1cm4gaXNTdHJpbmcodmFsKSA/IHZhbCA6IHZhbCA9PSBudWxsID8gXCJcIiA6IGlzQXJyYXkodmFsKSB8fCBpc09iamVjdCh2YWwpICYmICh2YWwudG9TdHJpbmcgPT09IG9iamVjdFRvU3RyaW5nIHx8ICFpc0Z1bmN0aW9uKHZhbC50b1N0cmluZykpID8gaXNSZWYodmFsKSA/IHRvRGlzcGxheVN0cmluZyh2YWwudmFsdWUpIDogSlNPTi5zdHJpbmdpZnkodmFsLCByZXBsYWNlciwgMikgOiBTdHJpbmcodmFsKTtcbn07XG5jb25zdCByZXBsYWNlciA9IChfa2V5LCB2YWwpID0+IHtcbiAgaWYgKGlzUmVmKHZhbCkpIHtcbiAgICByZXR1cm4gcmVwbGFjZXIoX2tleSwgdmFsLnZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc01hcCh2YWwpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtgTWFwKCR7dmFsLnNpemV9KWBdOiBbLi4udmFsLmVudHJpZXMoKV0ucmVkdWNlKFxuICAgICAgICAoZW50cmllcywgW2tleSwgdmFsMl0sIGkpID0+IHtcbiAgICAgICAgICBlbnRyaWVzW3N0cmluZ2lmeVN5bWJvbChrZXksIGkpICsgXCIgPT5cIl0gPSB2YWwyO1xuICAgICAgICAgIHJldHVybiBlbnRyaWVzO1xuICAgICAgICB9LFxuICAgICAgICB7fVxuICAgICAgKVxuICAgIH07XG4gIH0gZWxzZSBpZiAoaXNTZXQodmFsKSkge1xuICAgIHJldHVybiB7XG4gICAgICBbYFNldCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC52YWx1ZXMoKV0ubWFwKCh2KSA9PiBzdHJpbmdpZnlTeW1ib2wodikpXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpc1N5bWJvbCh2YWwpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeVN5bWJvbCh2YWwpO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkgJiYgIWlzQXJyYXkodmFsKSAmJiAhaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgcmV0dXJuIFN0cmluZyh2YWwpO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuY29uc3Qgc3RyaW5naWZ5U3ltYm9sID0gKHYsIGkgPSBcIlwiKSA9PiB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIChcbiAgICAvLyBTeW1ib2wuZGVzY3JpcHRpb24gaW4gZXMyMDE5KyBzbyB3ZSBuZWVkIHRvIGNhc3QgaGVyZSB0byBwYXNzXG4gICAgLy8gdGhlIGxpYjogZXMyMDE2IGNoZWNrXG4gICAgaXNTeW1ib2wodikgPyBgU3ltYm9sKCR7KF9hID0gdi5kZXNjcmlwdGlvbikgIT0gbnVsbCA/IF9hIDogaX0pYCA6IHZcbiAgKTtcbn07XG5cbmV4cG9ydCB7IEVNUFRZX0FSUiwgRU1QVFlfT0JKLCBOTywgTk9PUCwgUGF0Y2hGbGFnTmFtZXMsIFBhdGNoRmxhZ3MsIFNoYXBlRmxhZ3MsIFNsb3RGbGFncywgY2FtZWxpemUsIGNhcGl0YWxpemUsIGNzc1Zhck5hbWVFc2NhcGVTeW1ib2xzUkUsIGRlZiwgZXNjYXBlSHRtbCwgZXNjYXBlSHRtbENvbW1lbnQsIGV4dGVuZCwgZ2VuQ2FjaGVLZXksIGdlblByb3BzQWNjZXNzRXhwLCBnZW5lcmF0ZUNvZGVGcmFtZSwgZ2V0RXNjYXBlZENzc1Zhck5hbWUsIGdldEdsb2JhbFRoaXMsIGhhc0NoYW5nZWQsIGhhc093biwgaHlwaGVuYXRlLCBpbmNsdWRlQm9vbGVhbkF0dHIsIGludm9rZUFycmF5Rm5zLCBpc0FycmF5LCBpc0Jvb2xlYW5BdHRyLCBpc0J1aWx0SW5EaXJlY3RpdmUsIGlzRGF0ZSwgaXNGdW5jdGlvbiwgaXNHbG9iYWxseUFsbG93ZWQsIGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCwgaXNIVE1MVGFnLCBpc0ludGVnZXJLZXksIGlzS25vd25IdG1sQXR0ciwgaXNLbm93bk1hdGhNTEF0dHIsIGlzS25vd25TdmdBdHRyLCBpc01hcCwgaXNNYXRoTUxUYWcsIGlzTW9kZWxMaXN0ZW5lciwgaXNPYmplY3QsIGlzT24sIGlzUGxhaW5PYmplY3QsIGlzUHJvbWlzZSwgaXNSZWdFeHAsIGlzUmVuZGVyYWJsZUF0dHJWYWx1ZSwgaXNSZXNlcnZlZFByb3AsIGlzU1NSU2FmZUF0dHJOYW1lLCBpc1NWR1RhZywgaXNTZXQsIGlzU3BlY2lhbEJvb2xlYW5BdHRyLCBpc1N0cmluZywgaXNTeW1ib2wsIGlzVm9pZFRhZywgbG9vc2VFcXVhbCwgbG9vc2VJbmRleE9mLCBsb29zZVRvTnVtYmVyLCBtYWtlTWFwLCBub3JtYWxpemVDbGFzcywgbm9ybWFsaXplUHJvcHMsIG5vcm1hbGl6ZVN0eWxlLCBvYmplY3RUb1N0cmluZywgcGFyc2VTdHJpbmdTdHlsZSwgcHJvcHNUb0F0dHJNYXAsIHJlbW92ZSwgc2xvdEZsYWdzVGV4dCwgc3RyaW5naWZ5U3R5bGUsIHRvRGlzcGxheVN0cmluZywgdG9IYW5kbGVyS2V5LCB0b051bWJlciwgdG9SYXdUeXBlLCB0b1R5cGVTdHJpbmcgfTtcbiIsIi8qKlxuKiBAdnVlL3NoYXJlZCB2My41LjE2XG4qIChjKSAyMDE4LXByZXNlbnQgWXV4aSAoRXZhbikgWW91IGFuZCBWdWUgY29udHJpYnV0b3JzXG4qIEBsaWNlbnNlIE1JVFxuKiovXG4vKiEgI19fTk9fU0lERV9FRkZFQ1RTX18gKi9cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBtYWtlTWFwKHN0cikge1xuICBjb25zdCBtYXAgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yIChjb25zdCBrZXkgb2Ygc3RyLnNwbGl0KFwiLFwiKSkgbWFwW2tleV0gPSAxO1xuICByZXR1cm4gKHZhbCkgPT4gdmFsIGluIG1hcDtcbn1cblxuY29uc3QgRU1QVFlfT0JKID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IE9iamVjdC5mcmVlemUoe30pIDoge307XG5jb25zdCBFTVBUWV9BUlIgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gT2JqZWN0LmZyZWV6ZShbXSkgOiBbXTtcbmNvbnN0IE5PT1AgPSAoKSA9PiB7XG59O1xuY29uc3QgTk8gPSAoKSA9PiBmYWxzZTtcbmNvbnN0IGlzT24gPSAoa2V5KSA9PiBrZXkuY2hhckNvZGVBdCgwKSA9PT0gMTExICYmIGtleS5jaGFyQ29kZUF0KDEpID09PSAxMTAgJiYgLy8gdXBwZXJjYXNlIGxldHRlclxuKGtleS5jaGFyQ29kZUF0KDIpID4gMTIyIHx8IGtleS5jaGFyQ29kZUF0KDIpIDwgOTcpO1xuY29uc3QgaXNNb2RlbExpc3RlbmVyID0gKGtleSkgPT4ga2V5LnN0YXJ0c1dpdGgoXCJvblVwZGF0ZTpcIik7XG5jb25zdCBleHRlbmQgPSBPYmplY3QuYXNzaWduO1xuY29uc3QgcmVtb3ZlID0gKGFyciwgZWwpID0+IHtcbiAgY29uc3QgaSA9IGFyci5pbmRleE9mKGVsKTtcbiAgaWYgKGkgPiAtMSkge1xuICAgIGFyci5zcGxpY2UoaSwgMSk7XG4gIH1cbn07XG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5jb25zdCBoYXNPd24gPSAodmFsLCBrZXkpID0+IGhhc093blByb3BlcnR5LmNhbGwodmFsLCBrZXkpO1xuY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5jb25zdCBpc01hcCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgTWFwXVwiO1xuY29uc3QgaXNTZXQgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IFNldF1cIjtcbmNvbnN0IGlzRGF0ZSA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgRGF0ZV1cIjtcbmNvbnN0IGlzUmVnRXhwID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBSZWdFeHBdXCI7XG5jb25zdCBpc0Z1bmN0aW9uID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3QgaXNTdHJpbmcgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiO1xuY29uc3QgaXNTeW1ib2wgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN5bWJvbFwiO1xuY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIjtcbmNvbnN0IGlzUHJvbWlzZSA9ICh2YWwpID0+IHtcbiAgcmV0dXJuIChpc09iamVjdCh2YWwpIHx8IGlzRnVuY3Rpb24odmFsKSkgJiYgaXNGdW5jdGlvbih2YWwudGhlbikgJiYgaXNGdW5jdGlvbih2YWwuY2F0Y2gpO1xufTtcbmNvbnN0IG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IHRvVHlwZVN0cmluZyA9ICh2YWx1ZSkgPT4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5jb25zdCB0b1Jhd1R5cGUgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIHRvVHlwZVN0cmluZyh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xufTtcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbmNvbnN0IGlzSW50ZWdlcktleSA9IChrZXkpID0+IGlzU3RyaW5nKGtleSkgJiYga2V5ICE9PSBcIk5hTlwiICYmIGtleVswXSAhPT0gXCItXCIgJiYgXCJcIiArIHBhcnNlSW50KGtleSwgMTApID09PSBrZXk7XG5jb25zdCBpc1Jlc2VydmVkUHJvcCA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICAvLyB0aGUgbGVhZGluZyBjb21tYSBpcyBpbnRlbnRpb25hbCBzbyBlbXB0eSBzdHJpbmcgXCJcIiBpcyBhbHNvIGluY2x1ZGVkXG4gIFwiLGtleSxyZWYscmVmX2ZvcixyZWZfa2V5LG9uVm5vZGVCZWZvcmVNb3VudCxvblZub2RlTW91bnRlZCxvblZub2RlQmVmb3JlVXBkYXRlLG9uVm5vZGVVcGRhdGVkLG9uVm5vZGVCZWZvcmVVbm1vdW50LG9uVm5vZGVVbm1vdW50ZWRcIlxuKTtcbmNvbnN0IGlzQnVpbHRJbkRpcmVjdGl2ZSA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBcImJpbmQsY2xvYWssZWxzZS1pZixlbHNlLGZvcixodG1sLGlmLG1vZGVsLG9uLG9uY2UscHJlLHNob3csc2xvdCx0ZXh0LG1lbW9cIlxuKTtcbmNvbnN0IGNhY2hlU3RyaW5nRnVuY3Rpb24gPSAoZm4pID0+IHtcbiAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChzdHIpID0+IHtcbiAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcbiAgfTtcbn07XG5jb25zdCBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xuY29uc3QgY2FtZWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKFxuICAoc3RyKSA9PiB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiBjID8gYy50b1VwcGVyQ2FzZSgpIDogXCJcIik7XG4gIH1cbik7XG5jb25zdCBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG5jb25zdCBoeXBoZW5hdGUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKFxuICAoc3RyKSA9PiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgXCItJDFcIikudG9Mb3dlckNhc2UoKVxuKTtcbmNvbnN0IGNhcGl0YWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn0pO1xuY29uc3QgdG9IYW5kbGVyS2V5ID0gY2FjaGVTdHJpbmdGdW5jdGlvbihcbiAgKHN0cikgPT4ge1xuICAgIGNvbnN0IHMgPSBzdHIgPyBgb24ke2NhcGl0YWxpemUoc3RyKX1gIDogYGA7XG4gICAgcmV0dXJuIHM7XG4gIH1cbik7XG5jb25zdCBoYXNDaGFuZ2VkID0gKHZhbHVlLCBvbGRWYWx1ZSkgPT4gIU9iamVjdC5pcyh2YWx1ZSwgb2xkVmFsdWUpO1xuY29uc3QgaW52b2tlQXJyYXlGbnMgPSAoZm5zLCAuLi5hcmcpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICBmbnNbaV0oLi4uYXJnKTtcbiAgfVxufTtcbmNvbnN0IGRlZiA9IChvYmosIGtleSwgdmFsdWUsIHdyaXRhYmxlID0gZmFsc2UpID0+IHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlLFxuICAgIHZhbHVlXG4gIH0pO1xufTtcbmNvbnN0IGxvb3NlVG9OdW1iZXIgPSAodmFsKSA9PiB7XG4gIGNvbnN0IG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG47XG59O1xuY29uc3QgdG9OdW1iZXIgPSAodmFsKSA9PiB7XG4gIGNvbnN0IG4gPSBpc1N0cmluZyh2YWwpID8gTnVtYmVyKHZhbCkgOiBOYU47XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG47XG59O1xubGV0IF9nbG9iYWxUaGlzO1xuY29uc3QgZ2V0R2xvYmFsVGhpcyA9ICgpID0+IHtcbiAgcmV0dXJuIF9nbG9iYWxUaGlzIHx8IChfZ2xvYmFsVGhpcyA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pO1xufTtcbmNvbnN0IGlkZW50UkUgPSAvXltfJGEtekEtWlxceEEwLVxcdUZGRkZdW18kYS16QS1aMC05XFx4QTAtXFx1RkZGRl0qJC87XG5mdW5jdGlvbiBnZW5Qcm9wc0FjY2Vzc0V4cChuYW1lKSB7XG4gIHJldHVybiBpZGVudFJFLnRlc3QobmFtZSkgPyBgX19wcm9wcy4ke25hbWV9YCA6IGBfX3Byb3BzWyR7SlNPTi5zdHJpbmdpZnkobmFtZSl9XWA7XG59XG5mdW5jdGlvbiBnZW5DYWNoZUtleShzb3VyY2UsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHNvdXJjZSArIEpTT04uc3RyaW5naWZ5KFxuICAgIG9wdGlvbnMsXG4gICAgKF8sIHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiID8gdmFsLnRvU3RyaW5nKCkgOiB2YWxcbiAgKTtcbn1cblxuY29uc3QgUGF0Y2hGbGFncyA9IHtcbiAgXCJURVhUXCI6IDEsXG4gIFwiMVwiOiBcIlRFWFRcIixcbiAgXCJDTEFTU1wiOiAyLFxuICBcIjJcIjogXCJDTEFTU1wiLFxuICBcIlNUWUxFXCI6IDQsXG4gIFwiNFwiOiBcIlNUWUxFXCIsXG4gIFwiUFJPUFNcIjogOCxcbiAgXCI4XCI6IFwiUFJPUFNcIixcbiAgXCJGVUxMX1BST1BTXCI6IDE2LFxuICBcIjE2XCI6IFwiRlVMTF9QUk9QU1wiLFxuICBcIk5FRURfSFlEUkFUSU9OXCI6IDMyLFxuICBcIjMyXCI6IFwiTkVFRF9IWURSQVRJT05cIixcbiAgXCJTVEFCTEVfRlJBR01FTlRcIjogNjQsXG4gIFwiNjRcIjogXCJTVEFCTEVfRlJBR01FTlRcIixcbiAgXCJLRVlFRF9GUkFHTUVOVFwiOiAxMjgsXG4gIFwiMTI4XCI6IFwiS0VZRURfRlJBR01FTlRcIixcbiAgXCJVTktFWUVEX0ZSQUdNRU5UXCI6IDI1NixcbiAgXCIyNTZcIjogXCJVTktFWUVEX0ZSQUdNRU5UXCIsXG4gIFwiTkVFRF9QQVRDSFwiOiA1MTIsXG4gIFwiNTEyXCI6IFwiTkVFRF9QQVRDSFwiLFxuICBcIkRZTkFNSUNfU0xPVFNcIjogMTAyNCxcbiAgXCIxMDI0XCI6IFwiRFlOQU1JQ19TTE9UU1wiLFxuICBcIkRFVl9ST09UX0ZSQUdNRU5UXCI6IDIwNDgsXG4gIFwiMjA0OFwiOiBcIkRFVl9ST09UX0ZSQUdNRU5UXCIsXG4gIFwiQ0FDSEVEXCI6IC0xLFxuICBcIi0xXCI6IFwiQ0FDSEVEXCIsXG4gIFwiQkFJTFwiOiAtMixcbiAgXCItMlwiOiBcIkJBSUxcIlxufTtcbmNvbnN0IFBhdGNoRmxhZ05hbWVzID0ge1xuICBbMV06IGBURVhUYCxcbiAgWzJdOiBgQ0xBU1NgLFxuICBbNF06IGBTVFlMRWAsXG4gIFs4XTogYFBST1BTYCxcbiAgWzE2XTogYEZVTExfUFJPUFNgLFxuICBbMzJdOiBgTkVFRF9IWURSQVRJT05gLFxuICBbNjRdOiBgU1RBQkxFX0ZSQUdNRU5UYCxcbiAgWzEyOF06IGBLRVlFRF9GUkFHTUVOVGAsXG4gIFsyNTZdOiBgVU5LRVlFRF9GUkFHTUVOVGAsXG4gIFs1MTJdOiBgTkVFRF9QQVRDSGAsXG4gIFsxMDI0XTogYERZTkFNSUNfU0xPVFNgLFxuICBbMjA0OF06IGBERVZfUk9PVF9GUkFHTUVOVGAsXG4gIFstMV06IGBIT0lTVEVEYCxcbiAgWy0yXTogYEJBSUxgXG59O1xuXG5jb25zdCBTaGFwZUZsYWdzID0ge1xuICBcIkVMRU1FTlRcIjogMSxcbiAgXCIxXCI6IFwiRUxFTUVOVFwiLFxuICBcIkZVTkNUSU9OQUxfQ09NUE9ORU5UXCI6IDIsXG4gIFwiMlwiOiBcIkZVTkNUSU9OQUxfQ09NUE9ORU5UXCIsXG4gIFwiU1RBVEVGVUxfQ09NUE9ORU5UXCI6IDQsXG4gIFwiNFwiOiBcIlNUQVRFRlVMX0NPTVBPTkVOVFwiLFxuICBcIlRFWFRfQ0hJTERSRU5cIjogOCxcbiAgXCI4XCI6IFwiVEVYVF9DSElMRFJFTlwiLFxuICBcIkFSUkFZX0NISUxEUkVOXCI6IDE2LFxuICBcIjE2XCI6IFwiQVJSQVlfQ0hJTERSRU5cIixcbiAgXCJTTE9UU19DSElMRFJFTlwiOiAzMixcbiAgXCIzMlwiOiBcIlNMT1RTX0NISUxEUkVOXCIsXG4gIFwiVEVMRVBPUlRcIjogNjQsXG4gIFwiNjRcIjogXCJURUxFUE9SVFwiLFxuICBcIlNVU1BFTlNFXCI6IDEyOCxcbiAgXCIxMjhcIjogXCJTVVNQRU5TRVwiLFxuICBcIkNPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRVwiOiAyNTYsXG4gIFwiMjU2XCI6IFwiQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFXCIsXG4gIFwiQ09NUE9ORU5UX0tFUFRfQUxJVkVcIjogNTEyLFxuICBcIjUxMlwiOiBcIkNPTVBPTkVOVF9LRVBUX0FMSVZFXCIsXG4gIFwiQ09NUE9ORU5UXCI6IDYsXG4gIFwiNlwiOiBcIkNPTVBPTkVOVFwiXG59O1xuXG5jb25zdCBTbG90RmxhZ3MgPSB7XG4gIFwiU1RBQkxFXCI6IDEsXG4gIFwiMVwiOiBcIlNUQUJMRVwiLFxuICBcIkRZTkFNSUNcIjogMixcbiAgXCIyXCI6IFwiRFlOQU1JQ1wiLFxuICBcIkZPUldBUkRFRFwiOiAzLFxuICBcIjNcIjogXCJGT1JXQVJERURcIlxufTtcbmNvbnN0IHNsb3RGbGFnc1RleHQgPSB7XG4gIFsxXTogXCJTVEFCTEVcIixcbiAgWzJdOiBcIkRZTkFNSUNcIixcbiAgWzNdOiBcIkZPUldBUkRFRFwiXG59O1xuXG5jb25zdCBHTE9CQUxTX0FMTE9XRUQgPSBcIkluZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4scGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLEJpZ0ludCxjb25zb2xlLEVycm9yLFN5bWJvbFwiO1xuY29uc3QgaXNHbG9iYWxseUFsbG93ZWQgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChHTE9CQUxTX0FMTE9XRUQpO1xuY29uc3QgaXNHbG9iYWxseVdoaXRlbGlzdGVkID0gaXNHbG9iYWxseUFsbG93ZWQ7XG5cbmNvbnN0IHJhbmdlID0gMjtcbmZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lKHNvdXJjZSwgc3RhcnQgPSAwLCBlbmQgPSBzb3VyY2UubGVuZ3RoKSB7XG4gIHN0YXJ0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc3RhcnQsIHNvdXJjZS5sZW5ndGgpKTtcbiAgZW5kID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZW5kLCBzb3VyY2UubGVuZ3RoKSk7XG4gIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFwiXCI7XG4gIGxldCBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvKFxccj9cXG4pLyk7XG4gIGNvbnN0IG5ld2xpbmVTZXF1ZW5jZXMgPSBsaW5lcy5maWx0ZXIoKF8sIGlkeCkgPT4gaWR4ICUgMiA9PT0gMSk7XG4gIGxpbmVzID0gbGluZXMuZmlsdGVyKChfLCBpZHgpID0+IGlkeCAlIDIgPT09IDApO1xuICBsZXQgY291bnQgPSAwO1xuICBjb25zdCByZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvdW50ICs9IGxpbmVzW2ldLmxlbmd0aCArIChuZXdsaW5lU2VxdWVuY2VzW2ldICYmIG5ld2xpbmVTZXF1ZW5jZXNbaV0ubGVuZ3RoIHx8IDApO1xuICAgIGlmIChjb3VudCA+PSBzdGFydCkge1xuICAgICAgZm9yIChsZXQgaiA9IGkgLSByYW5nZTsgaiA8PSBpICsgcmFuZ2UgfHwgZW5kID4gY291bnQ7IGorKykge1xuICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBsaW5lcy5sZW5ndGgpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBsaW5lID0gaiArIDE7XG4gICAgICAgIHJlcy5wdXNoKFxuICAgICAgICAgIGAke2xpbmV9JHtcIiBcIi5yZXBlYXQoTWF0aC5tYXgoMyAtIFN0cmluZyhsaW5lKS5sZW5ndGgsIDApKX18ICAke2xpbmVzW2pdfWBcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IGxpbmVzW2pdLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbmV3TGluZVNlcUxlbmd0aCA9IG5ld2xpbmVTZXF1ZW5jZXNbal0gJiYgbmV3bGluZVNlcXVlbmNlc1tqXS5sZW5ndGggfHwgMDtcbiAgICAgICAgaWYgKGogPT09IGkpIHtcbiAgICAgICAgICBjb25zdCBwYWQgPSBzdGFydCAtIChjb3VudCAtIChsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aCkpO1xuICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArIFwiIFwiLnJlcGVhdChwYWQpICsgXCJeXCIucmVwZWF0KGxlbmd0aCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGogPiBpKSB7XG4gICAgICAgICAgaWYgKGVuZCA+IGNvdW50KSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChNYXRoLm1pbihlbmQgLSBjb3VudCwgbGluZUxlbmd0aCksIDEpO1xuICAgICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyBcIl5cIi5yZXBlYXQobGVuZ3RoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvdW50ICs9IGxpbmVMZW5ndGggKyBuZXdMaW5lU2VxTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy5qb2luKFwiXFxuXCIpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZSh2YWx1ZSkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gdmFsdWVbaV07XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gaXNTdHJpbmcoaXRlbSkgPyBwYXJzZVN0cmluZ1N0eWxlKGl0ZW0pIDogbm9ybWFsaXplU3R5bGUoaXRlbSk7XG4gICAgICBpZiAobm9ybWFsaXplZCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBub3JtYWxpemVkKSB7XG4gICAgICAgICAgcmVzW2tleV0gPSBub3JtYWxpemVkW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfSBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkgfHwgaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5jb25zdCBsaXN0RGVsaW1pdGVyUkUgPSAvOyg/IVteKF0qXFwpKS9nO1xuY29uc3QgcHJvcGVydHlEZWxpbWl0ZXJSRSA9IC86KFteXSspLztcbmNvbnN0IHN0eWxlQ29tbWVudFJFID0gL1xcL1xcKlteXSo/XFwqXFwvL2c7XG5mdW5jdGlvbiBwYXJzZVN0cmluZ1N0eWxlKGNzc1RleHQpIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGNzc1RleHQucmVwbGFjZShzdHlsZUNvbW1lbnRSRSwgXCJcIikuc3BsaXQobGlzdERlbGltaXRlclJFKS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIGNvbnN0IHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXJSRSk7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmV0W3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVN0eWxlKHN0eWxlcykge1xuICBpZiAoIXN0eWxlcykgcmV0dXJuIFwiXCI7XG4gIGlmIChpc1N0cmluZyhzdHlsZXMpKSByZXR1cm4gc3R5bGVzO1xuICBsZXQgcmV0ID0gXCJcIjtcbiAgZm9yIChjb25zdCBrZXkgaW4gc3R5bGVzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzdHlsZXNba2V5XTtcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGtleS5zdGFydHNXaXRoKGAtLWApID8ga2V5IDogaHlwaGVuYXRlKGtleSk7XG4gICAgICByZXQgKz0gYCR7bm9ybWFsaXplZEtleX06JHt2YWx1ZX07YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzKHZhbHVlKSB7XG4gIGxldCByZXMgPSBcIlwiO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgcmVzID0gdmFsdWU7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplQ2xhc3ModmFsdWVbaV0pO1xuICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgcmVzICs9IG5vcm1hbGl6ZWQgKyBcIiBcIjtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgZm9yIChjb25zdCBuYW1lIGluIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWVbbmFtZV0pIHtcbiAgICAgICAgcmVzICs9IG5hbWUgKyBcIiBcIjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy50cmltKCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyhwcm9wcykge1xuICBpZiAoIXByb3BzKSByZXR1cm4gbnVsbDtcbiAgbGV0IHsgY2xhc3M6IGtsYXNzLCBzdHlsZSB9ID0gcHJvcHM7XG4gIGlmIChrbGFzcyAmJiAhaXNTdHJpbmcoa2xhc3MpKSB7XG4gICAgcHJvcHMuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhrbGFzcyk7XG4gIH1cbiAgaWYgKHN0eWxlKSB7XG4gICAgcHJvcHMuc3R5bGUgPSBub3JtYWxpemVTdHlsZShzdHlsZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BzO1xufVxuXG5jb25zdCBIVE1MX1RBR1MgPSBcImh0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLGFkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGhncm91cCxoMSxoMixoMyxoNCxoNSxoNixuYXYsc2VjdGlvbixkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCxhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnVieSxzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbyxlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucyxjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0cixidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLG91dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsZGV0YWlscyxkaWFsb2csbWVudSxzdW1tYXJ5LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290XCI7XG5jb25zdCBTVkdfVEFHUyA9IFwic3ZnLGFuaW1hdGUsYW5pbWF0ZU1vdGlvbixhbmltYXRlVHJhbnNmb3JtLGNpcmNsZSxjbGlwUGF0aCxjb2xvci1wcm9maWxlLGRlZnMsZGVzYyxkaXNjYXJkLGVsbGlwc2UsZmVCbGVuZCxmZUNvbG9yTWF0cml4LGZlQ29tcG9uZW50VHJhbnNmZXIsZmVDb21wb3NpdGUsZmVDb252b2x2ZU1hdHJpeCxmZURpZmZ1c2VMaWdodGluZyxmZURpc3BsYWNlbWVudE1hcCxmZURpc3RhbnRMaWdodCxmZURyb3BTaGFkb3csZmVGbG9vZCxmZUZ1bmNBLGZlRnVuY0IsZmVGdW5jRyxmZUZ1bmNSLGZlR2F1c3NpYW5CbHVyLGZlSW1hZ2UsZmVNZXJnZSxmZU1lcmdlTm9kZSxmZU1vcnBob2xvZ3ksZmVPZmZzZXQsZmVQb2ludExpZ2h0LGZlU3BlY3VsYXJMaWdodGluZyxmZVNwb3RMaWdodCxmZVRpbGUsZmVUdXJidWxlbmNlLGZpbHRlcixmb3JlaWduT2JqZWN0LGcsaGF0Y2gsaGF0Y2hwYXRoLGltYWdlLGxpbmUsbGluZWFyR3JhZGllbnQsbWFya2VyLG1hc2ssbWVzaCxtZXNoZ3JhZGllbnQsbWVzaHBhdGNoLG1lc2hyb3csbWV0YWRhdGEsbXBhdGgscGF0aCxwYXR0ZXJuLHBvbHlnb24scG9seWxpbmUscmFkaWFsR3JhZGllbnQscmVjdCxzZXQsc29saWRjb2xvcixzdG9wLHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0UGF0aCx0aXRsZSx0c3Bhbix1bmtub3duLHVzZSx2aWV3XCI7XG5jb25zdCBNQVRIX1RBR1MgPSBcImFubm90YXRpb24sYW5ub3RhdGlvbi14bWwsbWFjdGlvbixtYWxpZ25ncm91cCxtYWxpZ25tYXJrLG1hdGgsbWVuY2xvc2UsbWVycm9yLG1mZW5jZWQsbWZyYWMsbWZyYWN0aW9uLG1nbHlwaCxtaSxtbGFiZWxlZHRyLG1sb25nZGl2LG1tdWx0aXNjcmlwdHMsbW4sbW8sbW92ZXIsbXBhZGRlZCxtcGhhbnRvbSxtcHJlc2NyaXB0cyxtcm9vdCxtcm93LG1zLG1zY2Fycmllcyxtc2NhcnJ5LG1zZ3JvdXAsbXNsaW5lLG1zcGFjZSxtc3FydCxtc3Jvdyxtc3RhY2ssbXN0eWxlLG1zdWIsbXN1YnN1cCxtc3VwLG10YWJsZSxtdGQsbXRleHQsbXRyLG11bmRlcixtdW5kZXJvdmVyLG5vbmUsc2VtYW50aWNzXCI7XG5jb25zdCBWT0lEX1RBR1MgPSBcImFyZWEsYmFzZSxicixjb2wsZW1iZWQsaHIsaW1nLGlucHV0LGxpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyXCI7XG5jb25zdCBpc0hUTUxUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChIVE1MX1RBR1MpO1xuY29uc3QgaXNTVkdUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChTVkdfVEFHUyk7XG5jb25zdCBpc01hdGhNTFRhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKE1BVEhfVEFHUyk7XG5jb25zdCBpc1ZvaWRUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChWT0lEX1RBR1MpO1xuXG5jb25zdCBzcGVjaWFsQm9vbGVhbkF0dHJzID0gYGl0ZW1zY29wZSxhbGxvd2Z1bGxzY3JlZW4sZm9ybW5vdmFsaWRhdGUsaXNtYXAsbm9tb2R1bGUsbm92YWxpZGF0ZSxyZWFkb25seWA7XG5jb25zdCBpc1NwZWNpYWxCb29sZWFuQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKHNwZWNpYWxCb29sZWFuQXR0cnMpO1xuY29uc3QgaXNCb29sZWFuQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBzcGVjaWFsQm9vbGVhbkF0dHJzICsgYCxhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY29udHJvbHMsZGVmYXVsdCxkZWZlcixkaXNhYmxlZCxoaWRkZW4saW5lcnQsbG9vcCxvcGVuLHJlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxjaGVja2VkLG11dGVkLG11bHRpcGxlLHNlbGVjdGVkYFxuKTtcbmZ1bmN0aW9uIGluY2x1ZGVCb29sZWFuQXR0cih2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSB8fCB2YWx1ZSA9PT0gXCJcIjtcbn1cbmNvbnN0IHVuc2FmZUF0dHJDaGFyUkUgPSAvWz4vPVwiJ1xcdTAwMDlcXHUwMDBhXFx1MDAwY1xcdTAwMjBdLztcbmNvbnN0IGF0dHJWYWxpZGF0aW9uQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGlzU1NSU2FmZUF0dHJOYW1lKG5hbWUpIHtcbiAgaWYgKGF0dHJWYWxpZGF0aW9uQ2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICByZXR1cm4gYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXTtcbiAgfVxuICBjb25zdCBpc1Vuc2FmZSA9IHVuc2FmZUF0dHJDaGFyUkUudGVzdChuYW1lKTtcbiAgaWYgKGlzVW5zYWZlKSB7XG4gICAgY29uc29sZS5lcnJvcihgdW5zYWZlIGF0dHJpYnV0ZSBuYW1lOiAke25hbWV9YCk7XG4gIH1cbiAgcmV0dXJuIGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV0gPSAhaXNVbnNhZmU7XG59XG5jb25zdCBwcm9wc1RvQXR0ck1hcCA9IHtcbiAgYWNjZXB0Q2hhcnNldDogXCJhY2NlcHQtY2hhcnNldFwiLFxuICBjbGFzc05hbWU6IFwiY2xhc3NcIixcbiAgaHRtbEZvcjogXCJmb3JcIixcbiAgaHR0cEVxdWl2OiBcImh0dHAtZXF1aXZcIlxufTtcbmNvbnN0IGlzS25vd25IdG1sQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBgYWNjZXB0LGFjY2VwdC1jaGFyc2V0LGFjY2Vzc2tleSxhY3Rpb24sYWxpZ24sYWxsb3csYWx0LGFzeW5jLGF1dG9jYXBpdGFsaXplLGF1dG9jb21wbGV0ZSxhdXRvZm9jdXMsYXV0b3BsYXksYmFja2dyb3VuZCxiZ2NvbG9yLGJvcmRlcixidWZmZXJlZCxjYXB0dXJlLGNoYWxsZW5nZSxjaGFyc2V0LGNoZWNrZWQsY2l0ZSxjbGFzcyxjb2RlLGNvZGViYXNlLGNvbG9yLGNvbHMsY29sc3Bhbixjb250ZW50LGNvbnRlbnRlZGl0YWJsZSxjb250ZXh0bWVudSxjb250cm9scyxjb29yZHMsY3Jvc3NvcmlnaW4sY3NwLGRhdGEsZGF0ZXRpbWUsZGVjb2RpbmcsZGVmYXVsdCxkZWZlcixkaXIsZGlybmFtZSxkaXNhYmxlZCxkb3dubG9hZCxkcmFnZ2FibGUsZHJvcHpvbmUsZW5jdHlwZSxlbnRlcmtleWhpbnQsZm9yLGZvcm0sZm9ybWFjdGlvbixmb3JtZW5jdHlwZSxmb3JtbWV0aG9kLGZvcm1ub3ZhbGlkYXRlLGZvcm10YXJnZXQsaGVhZGVycyxoZWlnaHQsaGlkZGVuLGhpZ2gsaHJlZixocmVmbGFuZyxodHRwLWVxdWl2LGljb24saWQsaW1wb3J0YW5jZSxpbmVydCxpbnRlZ3JpdHksaXNtYXAsaXRlbXByb3Asa2V5dHlwZSxraW5kLGxhYmVsLGxhbmcsbGFuZ3VhZ2UsbG9hZGluZyxsaXN0LGxvb3AsbG93LG1hbmlmZXN0LG1heCxtYXhsZW5ndGgsbWlubGVuZ3RoLG1lZGlhLG1pbixtdWx0aXBsZSxtdXRlZCxuYW1lLG5vdmFsaWRhdGUsb3BlbixvcHRpbXVtLHBhdHRlcm4scGluZyxwbGFjZWhvbGRlcixwb3N0ZXIscHJlbG9hZCxyYWRpb2dyb3VwLHJlYWRvbmx5LHJlZmVycmVycG9saWN5LHJlbCxyZXF1aXJlZCxyZXZlcnNlZCxyb3dzLHJvd3NwYW4sc2FuZGJveCxzY29wZSxzY29wZWQsc2VsZWN0ZWQsc2hhcGUsc2l6ZSxzaXplcyxzbG90LHNwYW4sc3BlbGxjaGVjayxzcmMsc3JjZG9jLHNyY2xhbmcsc3Jjc2V0LHN0YXJ0LHN0ZXAsc3R5bGUsc3VtbWFyeSx0YWJpbmRleCx0YXJnZXQsdGl0bGUsdHJhbnNsYXRlLHR5cGUsdXNlbWFwLHZhbHVlLHdpZHRoLHdyYXBgXG4pO1xuY29uc3QgaXNLbm93blN2Z0F0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgYHhtbG5zLGFjY2VudC1oZWlnaHQsYWNjdW11bGF0ZSxhZGRpdGl2ZSxhbGlnbm1lbnQtYmFzZWxpbmUsYWxwaGFiZXRpYyxhbXBsaXR1ZGUsYXJhYmljLWZvcm0sYXNjZW50LGF0dHJpYnV0ZU5hbWUsYXR0cmlidXRlVHlwZSxhemltdXRoLGJhc2VGcmVxdWVuY3ksYmFzZWxpbmUtc2hpZnQsYmFzZVByb2ZpbGUsYmJveCxiZWdpbixiaWFzLGJ5LGNhbGNNb2RlLGNhcC1oZWlnaHQsY2xhc3MsY2xpcCxjbGlwUGF0aFVuaXRzLGNsaXAtcGF0aCxjbGlwLXJ1bGUsY29sb3IsY29sb3ItaW50ZXJwb2xhdGlvbixjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMsY29sb3ItcHJvZmlsZSxjb2xvci1yZW5kZXJpbmcsY29udGVudFNjcmlwdFR5cGUsY29udGVudFN0eWxlVHlwZSxjcm9zc29yaWdpbixjdXJzb3IsY3gsY3ksZCxkZWNlbGVyYXRlLGRlc2NlbnQsZGlmZnVzZUNvbnN0YW50LGRpcmVjdGlvbixkaXNwbGF5LGRpdmlzb3IsZG9taW5hbnQtYmFzZWxpbmUsZHVyLGR4LGR5LGVkZ2VNb2RlLGVsZXZhdGlvbixlbmFibGUtYmFja2dyb3VuZCxlbmQsZXhwb25lbnQsZmlsbCxmaWxsLW9wYWNpdHksZmlsbC1ydWxlLGZpbHRlcixmaWx0ZXJSZXMsZmlsdGVyVW5pdHMsZmxvb2QtY29sb3IsZmxvb2Qtb3BhY2l0eSxmb250LWZhbWlseSxmb250LXNpemUsZm9udC1zaXplLWFkanVzdCxmb250LXN0cmV0Y2gsZm9udC1zdHlsZSxmb250LXZhcmlhbnQsZm9udC13ZWlnaHQsZm9ybWF0LGZyb20sZnIsZngsZnksZzEsZzIsZ2x5cGgtbmFtZSxnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsLGdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsLGdseXBoUmVmLGdyYWRpZW50VHJhbnNmb3JtLGdyYWRpZW50VW5pdHMsaGFuZ2luZyxoZWlnaHQsaHJlZixocmVmbGFuZyxob3Jpei1hZHYteCxob3Jpei1vcmlnaW4teCxpZCxpZGVvZ3JhcGhpYyxpbWFnZS1yZW5kZXJpbmcsaW4saW4yLGludGVyY2VwdCxrLGsxLGsyLGszLGs0LGtlcm5lbE1hdHJpeCxrZXJuZWxVbml0TGVuZ3RoLGtlcm5pbmcsa2V5UG9pbnRzLGtleVNwbGluZXMsa2V5VGltZXMsbGFuZyxsZW5ndGhBZGp1c3QsbGV0dGVyLXNwYWNpbmcsbGlnaHRpbmctY29sb3IsbGltaXRpbmdDb25lQW5nbGUsbG9jYWwsbWFya2VyLWVuZCxtYXJrZXItbWlkLG1hcmtlci1zdGFydCxtYXJrZXJIZWlnaHQsbWFya2VyVW5pdHMsbWFya2VyV2lkdGgsbWFzayxtYXNrQ29udGVudFVuaXRzLG1hc2tVbml0cyxtYXRoZW1hdGljYWwsbWF4LG1lZGlhLG1ldGhvZCxtaW4sbW9kZSxuYW1lLG51bU9jdGF2ZXMsb2Zmc2V0LG9wYWNpdHksb3BlcmF0b3Isb3JkZXIsb3JpZW50LG9yaWVudGF0aW9uLG9yaWdpbixvdmVyZmxvdyxvdmVybGluZS1wb3NpdGlvbixvdmVybGluZS10aGlja25lc3MscGFub3NlLTEscGFpbnQtb3JkZXIscGF0aCxwYXRoTGVuZ3RoLHBhdHRlcm5Db250ZW50VW5pdHMscGF0dGVyblRyYW5zZm9ybSxwYXR0ZXJuVW5pdHMscGluZyxwb2ludGVyLWV2ZW50cyxwb2ludHMscG9pbnRzQXRYLHBvaW50c0F0WSxwb2ludHNBdFoscHJlc2VydmVBbHBoYSxwcmVzZXJ2ZUFzcGVjdFJhdGlvLHByaW1pdGl2ZVVuaXRzLHIscmFkaXVzLHJlZmVycmVyUG9saWN5LHJlZlgscmVmWSxyZWwscmVuZGVyaW5nLWludGVudCxyZXBlYXRDb3VudCxyZXBlYXREdXIscmVxdWlyZWRFeHRlbnNpb25zLHJlcXVpcmVkRmVhdHVyZXMscmVzdGFydCxyZXN1bHQscm90YXRlLHJ4LHJ5LHNjYWxlLHNlZWQsc2hhcGUtcmVuZGVyaW5nLHNsb3BlLHNwYWNpbmcsc3BlY3VsYXJDb25zdGFudCxzcGVjdWxhckV4cG9uZW50LHNwZWVkLHNwcmVhZE1ldGhvZCxzdGFydE9mZnNldCxzdGREZXZpYXRpb24sc3RlbWgsc3RlbXYsc3RpdGNoVGlsZXMsc3RvcC1jb2xvcixzdG9wLW9wYWNpdHksc3RyaWtldGhyb3VnaC1wb3NpdGlvbixzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyxzdHJpbmcsc3Ryb2tlLHN0cm9rZS1kYXNoYXJyYXksc3Ryb2tlLWRhc2hvZmZzZXQsc3Ryb2tlLWxpbmVjYXAsc3Ryb2tlLWxpbmVqb2luLHN0cm9rZS1taXRlcmxpbWl0LHN0cm9rZS1vcGFjaXR5LHN0cm9rZS13aWR0aCxzdHlsZSxzdXJmYWNlU2NhbGUsc3lzdGVtTGFuZ3VhZ2UsdGFiaW5kZXgsdGFibGVWYWx1ZXMsdGFyZ2V0LHRhcmdldFgsdGFyZ2V0WSx0ZXh0LWFuY2hvcix0ZXh0LWRlY29yYXRpb24sdGV4dC1yZW5kZXJpbmcsdGV4dExlbmd0aCx0byx0cmFuc2Zvcm0sdHJhbnNmb3JtLW9yaWdpbix0eXBlLHUxLHUyLHVuZGVybGluZS1wb3NpdGlvbix1bmRlcmxpbmUtdGhpY2tuZXNzLHVuaWNvZGUsdW5pY29kZS1iaWRpLHVuaWNvZGUtcmFuZ2UsdW5pdHMtcGVyLWVtLHYtYWxwaGFiZXRpYyx2LWhhbmdpbmcsdi1pZGVvZ3JhcGhpYyx2LW1hdGhlbWF0aWNhbCx2YWx1ZXMsdmVjdG9yLWVmZmVjdCx2ZXJzaW9uLHZlcnQtYWR2LXksdmVydC1vcmlnaW4teCx2ZXJ0LW9yaWdpbi15LHZpZXdCb3gsdmlld1RhcmdldCx2aXNpYmlsaXR5LHdpZHRoLHdpZHRocyx3b3JkLXNwYWNpbmcsd3JpdGluZy1tb2RlLHgseC1oZWlnaHQseDEseDIseENoYW5uZWxTZWxlY3Rvcix4bGluazphY3R1YXRlLHhsaW5rOmFyY3JvbGUseGxpbms6aHJlZix4bGluazpyb2xlLHhsaW5rOnNob3cseGxpbms6dGl0bGUseGxpbms6dHlwZSx4bWxuczp4bGluayx4bWw6YmFzZSx4bWw6bGFuZyx4bWw6c3BhY2UseSx5MSx5Mix5Q2hhbm5lbFNlbGVjdG9yLHosem9vbUFuZFBhbmBcbik7XG5jb25zdCBpc0tub3duTWF0aE1MQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBgYWNjZW50LGFjY2VudHVuZGVyLGFjdGlvbnR5cGUsYWxpZ24sYWxpZ25tZW50c2NvcGUsYWx0aW1nLGFsdGltZy1oZWlnaHQsYWx0aW1nLXZhbGlnbixhbHRpbWctd2lkdGgsYWx0dGV4dCxiZXZlbGxlZCxjbG9zZSxjb2x1bW5zYWxpZ24sY29sdW1ubGluZXMsY29sdW1uc3BhbixkZW5vbWFsaWduLGRlcHRoLGRpcixkaXNwbGF5LGRpc3BsYXlzdHlsZSxlbmNvZGluZyxlcXVhbGNvbHVtbnMsZXF1YWxyb3dzLGZlbmNlLGZvbnRzdHlsZSxmb250d2VpZ2h0LGZvcm0sZnJhbWUsZnJhbWVzcGFjaW5nLGdyb3VwYWxpZ24saGVpZ2h0LGhyZWYsaWQsaW5kZW50YWxpZ24saW5kZW50YWxpZ25maXJzdCxpbmRlbnRhbGlnbmxhc3QsaW5kZW50c2hpZnQsaW5kZW50c2hpZnRmaXJzdCxpbmRlbnRzaGlmdGxhc3QsaW5kZXh0eXBlLGp1c3RpZnksbGFyZ2V0b3AsbGFyZ2VvcCxscXVvdGUsbHNwYWNlLG1hdGhiYWNrZ3JvdW5kLG1hdGhjb2xvcixtYXRoc2l6ZSxtYXRodmFyaWFudCxtYXhzaXplLG1pbmxhYmVsc3BhY2luZyxtb2RlLG90aGVyLG92ZXJmbG93LHBvc2l0aW9uLHJvd2FsaWduLHJvd2xpbmVzLHJvd3NwYW4scnF1b3RlLHJzcGFjZSxzY3JpcHRsZXZlbCxzY3JpcHRtaW5zaXplLHNjcmlwdHNpemVtdWx0aXBsaWVyLHNlbGVjdGlvbixzZXBhcmF0b3Isc2VwYXJhdG9ycyxzaGlmdCxzaWRlLHNyYyxzdGFja2FsaWduLHN0cmV0Y2h5LHN1YnNjcmlwdHNoaWZ0LHN1cGVyc2NyaXB0c2hpZnQsc3ltbWV0cmljLHZvZmZzZXQsd2lkdGgsd2lkdGhzLHhsaW5rOmhyZWYseGxpbms6c2hvdyx4bGluazp0eXBlLHhtbG5zYFxuKTtcbmZ1bmN0aW9uIGlzUmVuZGVyYWJsZUF0dHJWYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiO1xufVxuXG5jb25zdCBlc2NhcGVSRSA9IC9bXCInJjw+XS87XG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xuICBjb25zdCBzdHIgPSBcIlwiICsgc3RyaW5nO1xuICBjb25zdCBtYXRjaCA9IGVzY2FwZVJFLmV4ZWMoc3RyKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgbGV0IGh0bWwgPSBcIlwiO1xuICBsZXQgZXNjYXBlZDtcbiAgbGV0IGluZGV4O1xuICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgY2FzZSAzNDpcbiAgICAgICAgZXNjYXBlZCA9IFwiJnF1b3Q7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzODpcbiAgICAgICAgZXNjYXBlZCA9IFwiJmFtcDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM5OlxuICAgICAgICBlc2NhcGVkID0gXCImIzM5O1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNjA6XG4gICAgICAgIGVzY2FwZWQgPSBcIiZsdDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDYyOlxuICAgICAgICBlc2NhcGVkID0gXCImZ3Q7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChsYXN0SW5kZXggIT09IGluZGV4KSB7XG4gICAgICBodG1sICs9IHN0ci5zbGljZShsYXN0SW5kZXgsIGluZGV4KTtcbiAgICB9XG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyAxO1xuICAgIGh0bWwgKz0gZXNjYXBlZDtcbiAgfVxuICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc2xpY2UobGFzdEluZGV4LCBpbmRleCkgOiBodG1sO1xufVxuY29uc3QgY29tbWVudFN0cmlwUkUgPSAvXi0/Pnw8IS0tfC0tPnwtLSE+fDwhLSQvZztcbmZ1bmN0aW9uIGVzY2FwZUh0bWxDb21tZW50KHNyYykge1xuICByZXR1cm4gc3JjLnJlcGxhY2UoY29tbWVudFN0cmlwUkUsIFwiXCIpO1xufVxuY29uc3QgY3NzVmFyTmFtZUVzY2FwZVN5bWJvbHNSRSA9IC9bICFcIiMkJSYnKCkqKywuLzo7PD0+P0BbXFxcXFxcXV5ge3x9fl0vZztcbmZ1bmN0aW9uIGdldEVzY2FwZWRDc3NWYXJOYW1lKGtleSwgZG91YmxlRXNjYXBlKSB7XG4gIHJldHVybiBrZXkucmVwbGFjZShcbiAgICBjc3NWYXJOYW1lRXNjYXBlU3ltYm9sc1JFLFxuICAgIChzKSA9PiBkb3VibGVFc2NhcGUgPyBzID09PSAnXCInID8gJ1xcXFxcXFxcXFxcXFwiJyA6IGBcXFxcXFxcXCR7c31gIDogYFxcXFwke3N9YFxuICApO1xufVxuXG5mdW5jdGlvbiBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikge1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIGxldCBlcXVhbCA9IHRydWU7XG4gIGZvciAobGV0IGkgPSAwOyBlcXVhbCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGVxdWFsID0gbG9vc2VFcXVhbChhW2ldLCBiW2ldKTtcbiAgfVxuICByZXR1cm4gZXF1YWw7XG59XG5mdW5jdGlvbiBsb29zZUVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuICBsZXQgYVZhbGlkVHlwZSA9IGlzRGF0ZShhKTtcbiAgbGV0IGJWYWxpZFR5cGUgPSBpc0RhdGUoYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpIDogZmFsc2U7XG4gIH1cbiAgYVZhbGlkVHlwZSA9IGlzU3ltYm9sKGEpO1xuICBiVmFsaWRUeXBlID0gaXNTeW1ib2woYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgfVxuICBhVmFsaWRUeXBlID0gaXNBcnJheShhKTtcbiAgYlZhbGlkVHlwZSA9IGlzQXJyYXkoYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gbG9vc2VDb21wYXJlQXJyYXlzKGEsIGIpIDogZmFsc2U7XG4gIH1cbiAgYVZhbGlkVHlwZSA9IGlzT2JqZWN0KGEpO1xuICBiVmFsaWRUeXBlID0gaXNPYmplY3QoYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICBpZiAoIWFWYWxpZFR5cGUgfHwgIWJWYWxpZFR5cGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYUtleXNDb3VudCA9IE9iamVjdC5rZXlzKGEpLmxlbmd0aDtcbiAgICBjb25zdCBiS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYikubGVuZ3RoO1xuICAgIGlmIChhS2V5c0NvdW50ICE9PSBiS2V5c0NvdW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIGEpIHtcbiAgICAgIGNvbnN0IGFIYXNLZXkgPSBhLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICBjb25zdCBiSGFzS2V5ID0gYi5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgICAgaWYgKGFIYXNLZXkgJiYgIWJIYXNLZXkgfHwgIWFIYXNLZXkgJiYgYkhhc0tleSB8fCAhbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYik7XG59XG5mdW5jdGlvbiBsb29zZUluZGV4T2YoYXJyLCB2YWwpIHtcbiAgcmV0dXJuIGFyci5maW5kSW5kZXgoKGl0ZW0pID0+IGxvb3NlRXF1YWwoaXRlbSwgdmFsKSk7XG59XG5cbmNvbnN0IGlzUmVmID0gKHZhbCkgPT4ge1xuICByZXR1cm4gISEodmFsICYmIHZhbFtcIl9fdl9pc1JlZlwiXSA9PT0gdHJ1ZSk7XG59O1xuY29uc3QgdG9EaXNwbGF5U3RyaW5nID0gKHZhbCkgPT4ge1xuICByZXR1cm4gaXNTdHJpbmcodmFsKSA/IHZhbCA6IHZhbCA9PSBudWxsID8gXCJcIiA6IGlzQXJyYXkodmFsKSB8fCBpc09iamVjdCh2YWwpICYmICh2YWwudG9TdHJpbmcgPT09IG9iamVjdFRvU3RyaW5nIHx8ICFpc0Z1bmN0aW9uKHZhbC50b1N0cmluZykpID8gaXNSZWYodmFsKSA/IHRvRGlzcGxheVN0cmluZyh2YWwudmFsdWUpIDogSlNPTi5zdHJpbmdpZnkodmFsLCByZXBsYWNlciwgMikgOiBTdHJpbmcodmFsKTtcbn07XG5jb25zdCByZXBsYWNlciA9IChfa2V5LCB2YWwpID0+IHtcbiAgaWYgKGlzUmVmKHZhbCkpIHtcbiAgICByZXR1cm4gcmVwbGFjZXIoX2tleSwgdmFsLnZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc01hcCh2YWwpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtgTWFwKCR7dmFsLnNpemV9KWBdOiBbLi4udmFsLmVudHJpZXMoKV0ucmVkdWNlKFxuICAgICAgICAoZW50cmllcywgW2tleSwgdmFsMl0sIGkpID0+IHtcbiAgICAgICAgICBlbnRyaWVzW3N0cmluZ2lmeVN5bWJvbChrZXksIGkpICsgXCIgPT5cIl0gPSB2YWwyO1xuICAgICAgICAgIHJldHVybiBlbnRyaWVzO1xuICAgICAgICB9LFxuICAgICAgICB7fVxuICAgICAgKVxuICAgIH07XG4gIH0gZWxzZSBpZiAoaXNTZXQodmFsKSkge1xuICAgIHJldHVybiB7XG4gICAgICBbYFNldCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC52YWx1ZXMoKV0ubWFwKCh2KSA9PiBzdHJpbmdpZnlTeW1ib2wodikpXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpc1N5bWJvbCh2YWwpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeVN5bWJvbCh2YWwpO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkgJiYgIWlzQXJyYXkodmFsKSAmJiAhaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgcmV0dXJuIFN0cmluZyh2YWwpO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuY29uc3Qgc3RyaW5naWZ5U3ltYm9sID0gKHYsIGkgPSBcIlwiKSA9PiB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIChcbiAgICAvLyBTeW1ib2wuZGVzY3JpcHRpb24gaW4gZXMyMDE5KyBzbyB3ZSBuZWVkIHRvIGNhc3QgaGVyZSB0byBwYXNzXG4gICAgLy8gdGhlIGxpYjogZXMyMDE2IGNoZWNrXG4gICAgaXNTeW1ib2wodikgPyBgU3ltYm9sKCR7KF9hID0gdi5kZXNjcmlwdGlvbikgIT0gbnVsbCA/IF9hIDogaX0pYCA6IHZcbiAgKTtcbn07XG5cbmV4cG9ydCB7IEVNUFRZX0FSUiwgRU1QVFlfT0JKLCBOTywgTk9PUCwgUGF0Y2hGbGFnTmFtZXMsIFBhdGNoRmxhZ3MsIFNoYXBlRmxhZ3MsIFNsb3RGbGFncywgY2FtZWxpemUsIGNhcGl0YWxpemUsIGNzc1Zhck5hbWVFc2NhcGVTeW1ib2xzUkUsIGRlZiwgZXNjYXBlSHRtbCwgZXNjYXBlSHRtbENvbW1lbnQsIGV4dGVuZCwgZ2VuQ2FjaGVLZXksIGdlblByb3BzQWNjZXNzRXhwLCBnZW5lcmF0ZUNvZGVGcmFtZSwgZ2V0RXNjYXBlZENzc1Zhck5hbWUsIGdldEdsb2JhbFRoaXMsIGhhc0NoYW5nZWQsIGhhc093biwgaHlwaGVuYXRlLCBpbmNsdWRlQm9vbGVhbkF0dHIsIGludm9rZUFycmF5Rm5zLCBpc0FycmF5LCBpc0Jvb2xlYW5BdHRyLCBpc0J1aWx0SW5EaXJlY3RpdmUsIGlzRGF0ZSwgaXNGdW5jdGlvbiwgaXNHbG9iYWxseUFsbG93ZWQsIGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCwgaXNIVE1MVGFnLCBpc0ludGVnZXJLZXksIGlzS25vd25IdG1sQXR0ciwgaXNLbm93bk1hdGhNTEF0dHIsIGlzS25vd25TdmdBdHRyLCBpc01hcCwgaXNNYXRoTUxUYWcsIGlzTW9kZWxMaXN0ZW5lciwgaXNPYmplY3QsIGlzT24sIGlzUGxhaW5PYmplY3QsIGlzUHJvbWlzZSwgaXNSZWdFeHAsIGlzUmVuZGVyYWJsZUF0dHJWYWx1ZSwgaXNSZXNlcnZlZFByb3AsIGlzU1NSU2FmZUF0dHJOYW1lLCBpc1NWR1RhZywgaXNTZXQsIGlzU3BlY2lhbEJvb2xlYW5BdHRyLCBpc1N0cmluZywgaXNTeW1ib2wsIGlzVm9pZFRhZywgbG9vc2VFcXVhbCwgbG9vc2VJbmRleE9mLCBsb29zZVRvTnVtYmVyLCBtYWtlTWFwLCBub3JtYWxpemVDbGFzcywgbm9ybWFsaXplUHJvcHMsIG5vcm1hbGl6ZVN0eWxlLCBvYmplY3RUb1N0cmluZywgcGFyc2VTdHJpbmdTdHlsZSwgcHJvcHNUb0F0dHJNYXAsIHJlbW92ZSwgc2xvdEZsYWdzVGV4dCwgc3RyaW5naWZ5U3R5bGUsIHRvRGlzcGxheVN0cmluZywgdG9IYW5kbGVyS2V5LCB0b051bWJlciwgdG9SYXdUeXBlLCB0b1R5cGVTdHJpbmcgfTtcbiIsIi8qIVxuICogcGluaWEgdjIuMy4xXG4gKiAoYykgMjAyNSBFZHVhcmRvIFNhbiBNYXJ0aW4gTW9yb3RlXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgaGFzSW5qZWN0aW9uQ29udGV4dCwgaW5qZWN0LCB0b1Jhdywgd2F0Y2gsIHVucmVmLCBtYXJrUmF3LCBlZmZlY3RTY29wZSwgcmVmLCBpc1Z1ZTIsIGlzUmVmLCBpc1JlYWN0aXZlLCBzZXQsIGdldEN1cnJlbnRTY29wZSwgb25TY29wZURpc3Bvc2UsIGdldEN1cnJlbnRJbnN0YW5jZSwgcmVhY3RpdmUsIHRvUmVmLCBkZWwsIG5leHRUaWNrLCBjb21wdXRlZCwgdG9SZWZzIH0gZnJvbSAndnVlLWRlbWknO1xuaW1wb3J0IHsgc2V0dXBEZXZ0b29sc1BsdWdpbiB9IGZyb20gJ0B2dWUvZGV2dG9vbHMtYXBpJztcblxuLyoqXG4gKiBzZXRBY3RpdmVQaW5pYSBtdXN0IGJlIGNhbGxlZCB0byBoYW5kbGUgU1NSIGF0IHRoZSB0b3Agb2YgZnVuY3Rpb25zIGxpa2VcbiAqIGBmZXRjaGAsIGBzZXR1cGAsIGBzZXJ2ZXJQcmVmZXRjaGAgYW5kIG90aGVyc1xuICovXG5sZXQgYWN0aXZlUGluaWE7XG4vKipcbiAqIFNldHMgb3IgdW5zZXRzIHRoZSBhY3RpdmUgcGluaWEuIFVzZWQgaW4gU1NSIGFuZCBpbnRlcm5hbGx5IHdoZW4gY2FsbGluZ1xuICogYWN0aW9ucyBhbmQgZ2V0dGVyc1xuICpcbiAqIEBwYXJhbSBwaW5pYSAtIFBpbmlhIGluc3RhbmNlXG4gKi9cbi8vIEB0cy1leHBlY3QtZXJyb3I6IGNhbm5vdCBjb25zdHJhaW4gdGhlIHR5cGUgb2YgdGhlIHJldHVyblxuY29uc3Qgc2V0QWN0aXZlUGluaWEgPSAocGluaWEpID0+IChhY3RpdmVQaW5pYSA9IHBpbmlhKTtcbi8qKlxuICogR2V0IHRoZSBjdXJyZW50bHkgYWN0aXZlIHBpbmlhIGlmIHRoZXJlIGlzIGFueS5cbiAqL1xuY29uc3QgZ2V0QWN0aXZlUGluaWEgPSAoKSA9PiAoaGFzSW5qZWN0aW9uQ29udGV4dCgpICYmIGluamVjdChwaW5pYVN5bWJvbCkpIHx8IGFjdGl2ZVBpbmlhO1xuY29uc3QgcGluaWFTeW1ib2wgPSAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gU3ltYm9sKCdwaW5pYScpIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gU3ltYm9sKCkpO1xuXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbm8pIHtcbiAgICByZXR1cm4gKG8gJiZcbiAgICAgICAgdHlwZW9mIG8gPT09ICdvYmplY3QnICYmXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiZcbiAgICAgICAgdHlwZW9mIG8udG9KU09OICE9PSAnZnVuY3Rpb24nKTtcbn1cbi8vIHR5cGUgRGVlcFJlYWRvbmx5PFQ+ID0geyByZWFkb25seSBbUCBpbiBrZXlvZiBUXTogRGVlcFJlYWRvbmx5PFRbUF0+IH1cbi8vIFRPRE86IGNhbiB3ZSBjaGFuZ2UgdGhlc2UgdG8gbnVtYmVycz9cbi8qKlxuICogUG9zc2libGUgdHlwZXMgZm9yIFN1YnNjcmlwdGlvbkNhbGxiYWNrXG4gKi9cbnZhciBNdXRhdGlvblR5cGU7XG4oZnVuY3Rpb24gKE11dGF0aW9uVHlwZSkge1xuICAgIC8qKlxuICAgICAqIERpcmVjdCBtdXRhdGlvbiBvZiB0aGUgc3RhdGU6XG4gICAgICpcbiAgICAgKiAtIGBzdG9yZS5uYW1lID0gJ25ldyBuYW1lJ2BcbiAgICAgKiAtIGBzdG9yZS4kc3RhdGUubmFtZSA9ICduZXcgbmFtZSdgXG4gICAgICogLSBgc3RvcmUubGlzdC5wdXNoKCduZXcgaXRlbScpYFxuICAgICAqL1xuICAgIE11dGF0aW9uVHlwZVtcImRpcmVjdFwiXSA9IFwiZGlyZWN0XCI7XG4gICAgLyoqXG4gICAgICogTXV0YXRlZCB0aGUgc3RhdGUgd2l0aCBgJHBhdGNoYCBhbmQgYW4gb2JqZWN0XG4gICAgICpcbiAgICAgKiAtIGBzdG9yZS4kcGF0Y2goeyBuYW1lOiAnbmV3TmFtZScgfSlgXG4gICAgICovXG4gICAgTXV0YXRpb25UeXBlW1wicGF0Y2hPYmplY3RcIl0gPSBcInBhdGNoIG9iamVjdFwiO1xuICAgIC8qKlxuICAgICAqIE11dGF0ZWQgdGhlIHN0YXRlIHdpdGggYCRwYXRjaGAgYW5kIGEgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIC0gYHN0b3JlLiRwYXRjaChzdGF0ZSA9PiBzdGF0ZS5uYW1lID0gJ25ld05hbWUnKWBcbiAgICAgKi9cbiAgICBNdXRhdGlvblR5cGVbXCJwYXRjaEZ1bmN0aW9uXCJdID0gXCJwYXRjaCBmdW5jdGlvblwiO1xuICAgIC8vIG1heWJlIHJlc2V0PyBmb3IgJHN0YXRlID0ge30gYW5kICRyZXNldFxufSkoTXV0YXRpb25UeXBlIHx8IChNdXRhdGlvblR5cGUgPSB7fSkpO1xuXG5jb25zdCBJU19DTElFTlQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcblxuLypcbiAqIEZpbGVTYXZlci5qcyBBIHNhdmVBcygpIEZpbGVTYXZlciBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBPcmlnaW5hbGx5IGJ5IEVsaSBHcmV5LCBhZGFwdGVkIGFzIGFuIEVTTSBtb2R1bGUgYnkgRWR1YXJkbyBTYW4gTWFydGluXG4gKiBNb3JvdGUuXG4gKlxuICogTGljZW5zZSA6IE1JVFxuICovXG4vLyBUaGUgb25lIGFuZCBvbmx5IHdheSBvZiBnZXR0aW5nIGdsb2JhbCBzY29wZSBpbiBhbGwgZW52aXJvbm1lbnRzXG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMzI3NzE4Mi8xMDA4OTk5XG5jb25zdCBfZ2xvYmFsID0gLyojX19QVVJFX18qLyAoKCkgPT4gdHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LndpbmRvdyA9PT0gd2luZG93XG4gICAgPyB3aW5kb3dcbiAgICA6IHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JyAmJiBzZWxmLnNlbGYgPT09IHNlbGZcbiAgICAgICAgPyBzZWxmXG4gICAgICAgIDogdHlwZW9mIGdsb2JhbCA9PT0gJ29iamVjdCcgJiYgZ2xvYmFsLmdsb2JhbCA9PT0gZ2xvYmFsXG4gICAgICAgICAgICA/IGdsb2JhbFxuICAgICAgICAgICAgOiB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgICA/IGdsb2JhbFRoaXNcbiAgICAgICAgICAgICAgICA6IHsgSFRNTEVsZW1lbnQ6IG51bGwgfSkoKTtcbmZ1bmN0aW9uIGJvbShibG9iLCB7IGF1dG9Cb20gPSBmYWxzZSB9ID0ge30pIHtcbiAgICAvLyBwcmVwZW5kIEJPTSBmb3IgVVRGLTggWE1MIGFuZCB0ZXh0LyogdHlwZXMgKGluY2x1ZGluZyBIVE1MKVxuICAgIC8vIG5vdGU6IHlvdXIgYnJvd3NlciB3aWxsIGF1dG9tYXRpY2FsbHkgY29udmVydCBVVEYtMTYgVStGRUZGIHRvIEVGIEJCIEJGXG4gICAgaWYgKGF1dG9Cb20gJiZcbiAgICAgICAgL15cXHMqKD86dGV4dFxcL1xcUyp8YXBwbGljYXRpb25cXC94bWx8XFxTKlxcL1xcUypcXCt4bWwpXFxzKjsuKmNoYXJzZXRcXHMqPVxccyp1dGYtOC9pLnRlc3QoYmxvYi50eXBlKSkge1xuICAgICAgICByZXR1cm4gbmV3IEJsb2IoW1N0cmluZy5mcm9tQ2hhckNvZGUoMHhmZWZmKSwgYmxvYl0sIHsgdHlwZTogYmxvYi50eXBlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYmxvYjtcbn1cbmZ1bmN0aW9uIGRvd25sb2FkKHVybCwgbmFtZSwgb3B0cykge1xuICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2F2ZUFzKHhoci5yZXNwb25zZSwgbmFtZSwgb3B0cyk7XG4gICAgfTtcbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignY291bGQgbm90IGRvd25sb2FkIGZpbGUnKTtcbiAgICB9O1xuICAgIHhoci5zZW5kKCk7XG59XG5mdW5jdGlvbiBjb3JzRW5hYmxlZCh1cmwpIHtcbiAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAvLyB1c2Ugc3luYyB0byBhdm9pZCBwb3B1cCBibG9ja2VyXG4gICAgeGhyLm9wZW4oJ0hFQUQnLCB1cmwsIGZhbHNlKTtcbiAgICB0cnkge1xuICAgICAgICB4aHIuc2VuZCgpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkgeyB9XG4gICAgcmV0dXJuIHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPD0gMjk5O1xufVxuLy8gYGEuY2xpY2soKWAgZG9lc24ndCB3b3JrIGZvciBhbGwgYnJvd3NlcnMgKCM0NjUpXG5mdW5jdGlvbiBjbGljayhub2RlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbm9kZS5kaXNwYXRjaEV2ZW50KG5ldyBNb3VzZUV2ZW50KCdjbGljaycpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc3QgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnRzJyk7XG4gICAgICAgIGV2dC5pbml0TW91c2VFdmVudCgnY2xpY2snLCB0cnVlLCB0cnVlLCB3aW5kb3csIDAsIDAsIDAsIDgwLCAyMCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuICAgICAgICBub2RlLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICB9XG59XG5jb25zdCBfbmF2aWdhdG9yID0gdHlwZW9mIG5hdmlnYXRvciA9PT0gJ29iamVjdCcgPyBuYXZpZ2F0b3IgOiB7IHVzZXJBZ2VudDogJycgfTtcbi8vIERldGVjdCBXZWJWaWV3IGluc2lkZSBhIG5hdGl2ZSBtYWNPUyBhcHAgYnkgcnVsaW5nIG91dCBhbGwgYnJvd3NlcnNcbi8vIFdlIGp1c3QgbmVlZCB0byBjaGVjayBmb3IgJ1NhZmFyaScgYmVjYXVzZSBhbGwgb3RoZXIgYnJvd3NlcnMgKGJlc2lkZXMgRmlyZWZveCkgaW5jbHVkZSB0aGF0IHRvb1xuLy8gaHR0cHM6Ly93d3cud2hhdGlzbXlicm93c2VyLmNvbS9ndWlkZXMvdGhlLWxhdGVzdC11c2VyLWFnZW50L21hY29zXG5jb25zdCBpc01hY09TV2ViVmlldyA9IC8qI19fUFVSRV9fKi8gKCgpID0+IC9NYWNpbnRvc2gvLnRlc3QoX25hdmlnYXRvci51c2VyQWdlbnQpICYmXG4gICAgL0FwcGxlV2ViS2l0Ly50ZXN0KF9uYXZpZ2F0b3IudXNlckFnZW50KSAmJlxuICAgICEvU2FmYXJpLy50ZXN0KF9uYXZpZ2F0b3IudXNlckFnZW50KSkoKTtcbmNvbnN0IHNhdmVBcyA9ICFJU19DTElFTlRcbiAgICA/ICgpID0+IHsgfSAvLyBub29wXG4gICAgOiAvLyBVc2UgZG93bmxvYWQgYXR0cmlidXRlIGZpcnN0IGlmIHBvc3NpYmxlICgjMTkzIEx1bWlhIG1vYmlsZSkgdW5sZXNzIHRoaXMgaXMgYSBtYWNPUyBXZWJWaWV3IG9yIG1pbmkgcHJvZ3JhbVxuICAgICAgICB0eXBlb2YgSFRNTEFuY2hvckVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAnZG93bmxvYWQnIGluIEhUTUxBbmNob3JFbGVtZW50LnByb3RvdHlwZSAmJlxuICAgICAgICAgICAgIWlzTWFjT1NXZWJWaWV3XG4gICAgICAgICAgICA/IGRvd25sb2FkU2F2ZUFzXG4gICAgICAgICAgICA6IC8vIFVzZSBtc1NhdmVPck9wZW5CbG9iIGFzIGEgc2Vjb25kIGFwcHJvYWNoXG4gICAgICAgICAgICAgICAgJ21zU2F2ZU9yT3BlbkJsb2InIGluIF9uYXZpZ2F0b3JcbiAgICAgICAgICAgICAgICAgICAgPyBtc1NhdmVBc1xuICAgICAgICAgICAgICAgICAgICA6IC8vIEZhbGxiYWNrIHRvIHVzaW5nIEZpbGVSZWFkZXIgYW5kIGEgcG9wdXBcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVTYXZlclNhdmVBcztcbmZ1bmN0aW9uIGRvd25sb2FkU2F2ZUFzKGJsb2IsIG5hbWUgPSAnZG93bmxvYWQnLCBvcHRzKSB7XG4gICAgY29uc3QgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICBhLmRvd25sb2FkID0gbmFtZTtcbiAgICBhLnJlbCA9ICdub29wZW5lcic7IC8vIHRhYm5hYmJpbmdcbiAgICAvLyBUT0RPOiBkZXRlY3QgY2hyb21lIGV4dGVuc2lvbnMgJiBwYWNrYWdlZCBhcHBzXG4gICAgLy8gYS50YXJnZXQgPSAnX2JsYW5rJ1xuICAgIGlmICh0eXBlb2YgYmxvYiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gU3VwcG9ydCByZWd1bGFyIGxpbmtzXG4gICAgICAgIGEuaHJlZiA9IGJsb2I7XG4gICAgICAgIGlmIChhLm9yaWdpbiAhPT0gbG9jYXRpb24ub3JpZ2luKSB7XG4gICAgICAgICAgICBpZiAoY29yc0VuYWJsZWQoYS5ocmVmKSkge1xuICAgICAgICAgICAgICAgIGRvd25sb2FkKGJsb2IsIG5hbWUsIG9wdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYS50YXJnZXQgPSAnX2JsYW5rJztcbiAgICAgICAgICAgICAgICBjbGljayhhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsaWNrKGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBTdXBwb3J0IGJsb2JzXG4gICAgICAgIGEuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChhLmhyZWYpO1xuICAgICAgICB9LCA0ZTQpOyAvLyA0MHNcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbGljayhhKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxufVxuZnVuY3Rpb24gbXNTYXZlQXMoYmxvYiwgbmFtZSA9ICdkb3dubG9hZCcsIG9wdHMpIHtcbiAgICBpZiAodHlwZW9mIGJsb2IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChjb3JzRW5hYmxlZChibG9iKSkge1xuICAgICAgICAgICAgZG93bmxvYWQoYmxvYiwgbmFtZSwgb3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICAgICAgYS5ocmVmID0gYmxvYjtcbiAgICAgICAgICAgIGEudGFyZ2V0ID0gJ19ibGFuayc7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjbGljayhhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBAdHMtaWdub3JlOiB3b3JrcyBvbiB3aW5kb3dzXG4gICAgICAgIG5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKGJvbShibG9iLCBvcHRzKSwgbmFtZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZmlsZVNhdmVyU2F2ZUFzKGJsb2IsIG5hbWUsIG9wdHMsIHBvcHVwKSB7XG4gICAgLy8gT3BlbiBhIHBvcHVwIGltbWVkaWF0ZWx5IGRvIGdvIGFyb3VuZCBwb3B1cCBibG9ja2VyXG4gICAgLy8gTW9zdGx5IG9ubHkgYXZhaWxhYmxlIG9uIHVzZXIgaW50ZXJhY3Rpb24gYW5kIHRoZSBmaWxlUmVhZGVyIGlzIGFzeW5jIHNvLi4uXG4gICAgcG9wdXAgPSBwb3B1cCB8fCBvcGVuKCcnLCAnX2JsYW5rJyk7XG4gICAgaWYgKHBvcHVwKSB7XG4gICAgICAgIHBvcHVwLmRvY3VtZW50LnRpdGxlID0gcG9wdXAuZG9jdW1lbnQuYm9keS5pbm5lclRleHQgPSAnZG93bmxvYWRpbmcuLi4nO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGJsb2IgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gZG93bmxvYWQoYmxvYiwgbmFtZSwgb3B0cyk7XG4gICAgY29uc3QgZm9yY2UgPSBibG9iLnR5cGUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICAgIGNvbnN0IGlzU2FmYXJpID0gL2NvbnN0cnVjdG9yL2kudGVzdChTdHJpbmcoX2dsb2JhbC5IVE1MRWxlbWVudCkpIHx8ICdzYWZhcmknIGluIF9nbG9iYWw7XG4gICAgY29uc3QgaXNDaHJvbWVJT1MgPSAvQ3JpT1NcXC9bXFxkXSsvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgaWYgKChpc0Nocm9tZUlPUyB8fCAoZm9yY2UgJiYgaXNTYWZhcmkpIHx8IGlzTWFjT1NXZWJWaWV3KSAmJlxuICAgICAgICB0eXBlb2YgRmlsZVJlYWRlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gU2FmYXJpIGRvZXNuJ3QgYWxsb3cgZG93bmxvYWRpbmcgb2YgYmxvYiBVUkxzXG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsZXQgdXJsID0gcmVhZGVyLnJlc3VsdDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHBvcHVwID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIHJlYWRlci5yZXN1bHQgdHlwZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXJsID0gaXNDaHJvbWVJT1NcbiAgICAgICAgICAgICAgICA/IHVybFxuICAgICAgICAgICAgICAgIDogdXJsLnJlcGxhY2UoL15kYXRhOlteO10qOy8sICdkYXRhOmF0dGFjaG1lbnQvZmlsZTsnKTtcbiAgICAgICAgICAgIGlmIChwb3B1cCkge1xuICAgICAgICAgICAgICAgIHBvcHVwLmxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbi5hc3NpZ24odXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcHVwID0gbnVsbDsgLy8gcmV2ZXJzZS10YWJuYWJiaW5nICM0NjBcbiAgICAgICAgfTtcbiAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICBpZiAocG9wdXApXG4gICAgICAgICAgICBwb3B1cC5sb2NhdGlvbi5hc3NpZ24odXJsKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbG9jYXRpb24uaHJlZiA9IHVybDtcbiAgICAgICAgcG9wdXAgPSBudWxsOyAvLyByZXZlcnNlLXRhYm5hYmJpbmcgIzQ2MFxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICAgICAgfSwgNGU0KTsgLy8gNDBzXG4gICAgfVxufVxuXG4vKipcbiAqIFNob3dzIGEgdG9hc3Qgb3IgY29uc29sZS5sb2dcbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgdG8gbG9nXG4gKiBAcGFyYW0gdHlwZSAtIGRpZmZlcmVudCBjb2xvciBvZiB0aGUgdG9vbHRpcFxuICovXG5mdW5jdGlvbiB0b2FzdE1lc3NhZ2UobWVzc2FnZSwgdHlwZSkge1xuICAgIGNvbnN0IHBpbmlhTWVzc2FnZSA9ICfwn42NICcgKyBtZXNzYWdlO1xuICAgIGlmICh0eXBlb2YgX19WVUVfREVWVE9PTFNfVE9BU1RfXyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBObyBsb25nZXIgYXZhaWxhYmxlIDooXG4gICAgICAgIF9fVlVFX0RFVlRPT0xTX1RPQVNUX18ocGluaWFNZXNzYWdlLCB0eXBlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKHBpbmlhTWVzc2FnZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICd3YXJuJykge1xuICAgICAgICBjb25zb2xlLndhcm4ocGluaWFNZXNzYWdlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKHBpbmlhTWVzc2FnZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNQaW5pYShvKSB7XG4gICAgcmV0dXJuICdfYScgaW4gbyAmJiAnaW5zdGFsbCcgaW4gbztcbn1cblxuLyoqXG4gKiBUaGlzIGZpbGUgY29udGFpbiBkZXZ0b29scyBhY3Rpb25zLCB0aGV5IGFyZSBub3QgUGluaWEgYWN0aW9ucy5cbiAqL1xuLy8gLS0tXG5mdW5jdGlvbiBjaGVja0NsaXBib2FyZEFjY2VzcygpIHtcbiAgICBpZiAoISgnY2xpcGJvYXJkJyBpbiBuYXZpZ2F0b3IpKSB7XG4gICAgICAgIHRvYXN0TWVzc2FnZShgWW91ciBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgQ2xpcGJvYXJkIEFQSWAsICdlcnJvcicpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja05vdEZvY3VzZWRFcnJvcihlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICAgIGVycm9yLm1lc3NhZ2UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnZG9jdW1lbnQgaXMgbm90IGZvY3VzZWQnKSkge1xuICAgICAgICB0b2FzdE1lc3NhZ2UoJ1lvdSBuZWVkIHRvIGFjdGl2YXRlIHRoZSBcIkVtdWxhdGUgYSBmb2N1c2VkIHBhZ2VcIiBzZXR0aW5nIGluIHRoZSBcIlJlbmRlcmluZ1wiIHBhbmVsIG9mIGRldnRvb2xzLicsICd3YXJuJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5hc3luYyBmdW5jdGlvbiBhY3Rpb25HbG9iYWxDb3B5U3RhdGUocGluaWEpIHtcbiAgICBpZiAoY2hlY2tDbGlwYm9hcmRBY2Nlc3MoKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KEpTT04uc3RyaW5naWZ5KHBpbmlhLnN0YXRlLnZhbHVlKSk7XG4gICAgICAgIHRvYXN0TWVzc2FnZSgnR2xvYmFsIHN0YXRlIGNvcGllZCB0byBjbGlwYm9hcmQuJyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoY2hlY2tOb3RGb2N1c2VkRXJyb3IoZXJyb3IpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0b2FzdE1lc3NhZ2UoYEZhaWxlZCB0byBzZXJpYWxpemUgdGhlIHN0YXRlLiBDaGVjayB0aGUgY29uc29sZSBmb3IgbW9yZSBkZXRhaWxzLmAsICdlcnJvcicpO1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBhY3Rpb25HbG9iYWxQYXN0ZVN0YXRlKHBpbmlhKSB7XG4gICAgaWYgKGNoZWNrQ2xpcGJvYXJkQWNjZXNzKCkpXG4gICAgICAgIHJldHVybjtcbiAgICB0cnkge1xuICAgICAgICBsb2FkU3RvcmVzU3RhdGUocGluaWEsIEpTT04ucGFyc2UoYXdhaXQgbmF2aWdhdG9yLmNsaXBib2FyZC5yZWFkVGV4dCgpKSk7XG4gICAgICAgIHRvYXN0TWVzc2FnZSgnR2xvYmFsIHN0YXRlIHBhc3RlZCBmcm9tIGNsaXBib2FyZC4nKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChjaGVja05vdEZvY3VzZWRFcnJvcihlcnJvcikpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRvYXN0TWVzc2FnZShgRmFpbGVkIHRvIGRlc2VyaWFsaXplIHRoZSBzdGF0ZSBmcm9tIGNsaXBib2FyZC4gQ2hlY2sgdGhlIGNvbnNvbGUgZm9yIG1vcmUgZGV0YWlscy5gLCAnZXJyb3InKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gYWN0aW9uR2xvYmFsU2F2ZVN0YXRlKHBpbmlhKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgc2F2ZUFzKG5ldyBCbG9iKFtKU09OLnN0cmluZ2lmeShwaW5pYS5zdGF0ZS52YWx1ZSldLCB7XG4gICAgICAgICAgICB0eXBlOiAndGV4dC9wbGFpbjtjaGFyc2V0PXV0Zi04JyxcbiAgICAgICAgfSksICdwaW5pYS1zdGF0ZS5qc29uJyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICB0b2FzdE1lc3NhZ2UoYEZhaWxlZCB0byBleHBvcnQgdGhlIHN0YXRlIGFzIEpTT04uIENoZWNrIHRoZSBjb25zb2xlIGZvciBtb3JlIGRldGFpbHMuYCwgJ2Vycm9yJyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH1cbn1cbmxldCBmaWxlSW5wdXQ7XG5mdW5jdGlvbiBnZXRGaWxlT3BlbmVyKCkge1xuICAgIGlmICghZmlsZUlucHV0KSB7XG4gICAgICAgIGZpbGVJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIGZpbGVJbnB1dC50eXBlID0gJ2ZpbGUnO1xuICAgICAgICBmaWxlSW5wdXQuYWNjZXB0ID0gJy5qc29uJztcbiAgICB9XG4gICAgZnVuY3Rpb24gb3BlbkZpbGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBmaWxlSW5wdXQub25jaGFuZ2UgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZXMgPSBmaWxlSW5wdXQuZmlsZXM7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWxlcylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZSA9IGZpbGVzLml0ZW0oMCk7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWxlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7IHRleHQ6IGF3YWl0IGZpbGUudGV4dCgpLCBmaWxlIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmU6IFRPRE86IGNoYW5nZWQgZnJvbSA0LjMgdG8gNC40XG4gICAgICAgICAgICBmaWxlSW5wdXQub25jYW5jZWwgPSAoKSA9PiByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgZmlsZUlucHV0Lm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgICAgICBmaWxlSW5wdXQuY2xpY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvcGVuRmlsZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGFjdGlvbkdsb2JhbE9wZW5TdGF0ZUZpbGUocGluaWEpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBvcGVuID0gZ2V0RmlsZU9wZW5lcigpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBvcGVuKCk7XG4gICAgICAgIGlmICghcmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IHRleHQsIGZpbGUgfSA9IHJlc3VsdDtcbiAgICAgICAgbG9hZFN0b3Jlc1N0YXRlKHBpbmlhLCBKU09OLnBhcnNlKHRleHQpKTtcbiAgICAgICAgdG9hc3RNZXNzYWdlKGBHbG9iYWwgc3RhdGUgaW1wb3J0ZWQgZnJvbSBcIiR7ZmlsZS5uYW1lfVwiLmApO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdG9hc3RNZXNzYWdlKGBGYWlsZWQgdG8gaW1wb3J0IHRoZSBzdGF0ZSBmcm9tIEpTT04uIENoZWNrIHRoZSBjb25zb2xlIGZvciBtb3JlIGRldGFpbHMuYCwgJ2Vycm9yJyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxvYWRTdG9yZXNTdGF0ZShwaW5pYSwgc3RhdGUpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzdGF0ZSkge1xuICAgICAgICBjb25zdCBzdG9yZVN0YXRlID0gcGluaWEuc3RhdGUudmFsdWVba2V5XTtcbiAgICAgICAgLy8gc3RvcmUgaXMgYWxyZWFkeSBpbnN0YW50aWF0ZWQsIHBhdGNoIGl0XG4gICAgICAgIGlmIChzdG9yZVN0YXRlKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHN0b3JlU3RhdGUsIHN0YXRlW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gc3RvcmUgaXMgbm90IGluc3RhbnRpYXRlZCwgc2V0IHRoZSBpbml0aWFsIHN0YXRlXG4gICAgICAgICAgICBwaW5pYS5zdGF0ZS52YWx1ZVtrZXldID0gc3RhdGVba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0RGlzcGxheShkaXNwbGF5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgX2N1c3RvbToge1xuICAgICAgICAgICAgZGlzcGxheSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuY29uc3QgUElOSUFfUk9PVF9MQUJFTCA9ICfwn42NIFBpbmlhIChyb290KSc7XG5jb25zdCBQSU5JQV9ST09UX0lEID0gJ19yb290JztcbmZ1bmN0aW9uIGZvcm1hdFN0b3JlRm9ySW5zcGVjdG9yVHJlZShzdG9yZSkge1xuICAgIHJldHVybiBpc1BpbmlhKHN0b3JlKVxuICAgICAgICA/IHtcbiAgICAgICAgICAgIGlkOiBQSU5JQV9ST09UX0lELFxuICAgICAgICAgICAgbGFiZWw6IFBJTklBX1JPT1RfTEFCRUwsXG4gICAgICAgIH1cbiAgICAgICAgOiB7XG4gICAgICAgICAgICBpZDogc3RvcmUuJGlkLFxuICAgICAgICAgICAgbGFiZWw6IHN0b3JlLiRpZCxcbiAgICAgICAgfTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFN0b3JlRm9ySW5zcGVjdG9yU3RhdGUoc3RvcmUpIHtcbiAgICBpZiAoaXNQaW5pYShzdG9yZSkpIHtcbiAgICAgICAgY29uc3Qgc3RvcmVOYW1lcyA9IEFycmF5LmZyb20oc3RvcmUuX3Mua2V5cygpKTtcbiAgICAgICAgY29uc3Qgc3RvcmVNYXAgPSBzdG9yZS5fcztcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgICAgICBzdGF0ZTogc3RvcmVOYW1lcy5tYXAoKHN0b3JlSWQpID0+ICh7XG4gICAgICAgICAgICAgICAgZWRpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAga2V5OiBzdG9yZUlkLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBzdG9yZS5zdGF0ZS52YWx1ZVtzdG9yZUlkXSxcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIGdldHRlcnM6IHN0b3JlTmFtZXNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChpZCkgPT4gc3RvcmVNYXAuZ2V0KGlkKS5fZ2V0dGVycylcbiAgICAgICAgICAgICAgICAubWFwKChpZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gc3RvcmVNYXAuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGtleTogaWQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzdG9yZS5fZ2V0dGVycy5yZWR1Y2UoKGdldHRlcnMsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0dGVyc1trZXldID0gc3RvcmVba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXR0ZXJzO1xuICAgICAgICAgICAgICAgICAgICB9LCB7fSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICBzdGF0ZTogT2JqZWN0LmtleXMoc3RvcmUuJHN0YXRlKS5tYXAoKGtleSkgPT4gKHtcbiAgICAgICAgICAgIGVkaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWU6IHN0b3JlLiRzdGF0ZVtrZXldLFxuICAgICAgICB9KSksXG4gICAgfTtcbiAgICAvLyBhdm9pZCBhZGRpbmcgZW1wdHkgZ2V0dGVyc1xuICAgIGlmIChzdG9yZS5fZ2V0dGVycyAmJiBzdG9yZS5fZ2V0dGVycy5sZW5ndGgpIHtcbiAgICAgICAgc3RhdGUuZ2V0dGVycyA9IHN0b3JlLl9nZXR0ZXJzLm1hcCgoZ2V0dGVyTmFtZSkgPT4gKHtcbiAgICAgICAgICAgIGVkaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGtleTogZ2V0dGVyTmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiBzdG9yZVtnZXR0ZXJOYW1lXSxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAoc3RvcmUuX2N1c3RvbVByb3BlcnRpZXMuc2l6ZSkge1xuICAgICAgICBzdGF0ZS5jdXN0b21Qcm9wZXJ0aWVzID0gQXJyYXkuZnJvbShzdG9yZS5fY3VzdG9tUHJvcGVydGllcykubWFwKChrZXkpID0+ICh7XG4gICAgICAgICAgICBlZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlOiBzdG9yZVtrZXldLFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIGZvcm1hdEV2ZW50RGF0YShldmVudHMpIHtcbiAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50cykpIHtcbiAgICAgICAgLy8gVE9ETzogaGFuZGxlIGFkZCBhbmQgZGVsZXRlIGZvciBhcnJheXMgYW5kIG9iamVjdHNcbiAgICAgICAgcmV0dXJuIGV2ZW50cy5yZWR1Y2UoKGRhdGEsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBkYXRhLmtleXMucHVzaChldmVudC5rZXkpO1xuICAgICAgICAgICAgZGF0YS5vcGVyYXRpb25zLnB1c2goZXZlbnQudHlwZSk7XG4gICAgICAgICAgICBkYXRhLm9sZFZhbHVlW2V2ZW50LmtleV0gPSBldmVudC5vbGRWYWx1ZTtcbiAgICAgICAgICAgIGRhdGEubmV3VmFsdWVbZXZlbnQua2V5XSA9IGV2ZW50Lm5ld1ZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9sZFZhbHVlOiB7fSxcbiAgICAgICAgICAgIGtleXM6IFtdLFxuICAgICAgICAgICAgb3BlcmF0aW9uczogW10sXG4gICAgICAgICAgICBuZXdWYWx1ZToge30sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogZm9ybWF0RGlzcGxheShldmVudHMudHlwZSksXG4gICAgICAgICAgICBrZXk6IGZvcm1hdERpc3BsYXkoZXZlbnRzLmtleSksXG4gICAgICAgICAgICBvbGRWYWx1ZTogZXZlbnRzLm9sZFZhbHVlLFxuICAgICAgICAgICAgbmV3VmFsdWU6IGV2ZW50cy5uZXdWYWx1ZSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBmb3JtYXRNdXRhdGlvblR5cGUodHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIE11dGF0aW9uVHlwZS5kaXJlY3Q6XG4gICAgICAgICAgICByZXR1cm4gJ211dGF0aW9uJztcbiAgICAgICAgY2FzZSBNdXRhdGlvblR5cGUucGF0Y2hGdW5jdGlvbjpcbiAgICAgICAgICAgIHJldHVybiAnJHBhdGNoJztcbiAgICAgICAgY2FzZSBNdXRhdGlvblR5cGUucGF0Y2hPYmplY3Q6XG4gICAgICAgICAgICByZXR1cm4gJyRwYXRjaCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gJ3Vua25vd24nO1xuICAgIH1cbn1cblxuLy8gdGltZWxpbmUgY2FuIGJlIHBhdXNlZCB3aGVuIGRpcmVjdGx5IGNoYW5naW5nIHRoZSBzdGF0ZVxubGV0IGlzVGltZWxpbmVBY3RpdmUgPSB0cnVlO1xuY29uc3QgY29tcG9uZW50U3RhdGVUeXBlcyA9IFtdO1xuY29uc3QgTVVUQVRJT05TX0xBWUVSX0lEID0gJ3BpbmlhOm11dGF0aW9ucyc7XG5jb25zdCBJTlNQRUNUT1JfSUQgPSAncGluaWEnO1xuY29uc3QgeyBhc3NpZ246IGFzc2lnbiQxIH0gPSBPYmplY3Q7XG4vKipcbiAqIEdldHMgdGhlIGRpc3BsYXllZCBuYW1lIG9mIGEgc3RvcmUgaW4gZGV2dG9vbHNcbiAqXG4gKiBAcGFyYW0gaWQgLSBpZCBvZiB0aGUgc3RvcmVcbiAqIEByZXR1cm5zIGEgZm9ybWF0dGVkIHN0cmluZ1xuICovXG5jb25zdCBnZXRTdG9yZVR5cGUgPSAoaWQpID0+ICfwn42NICcgKyBpZDtcbi8qKlxuICogQWRkIHRoZSBwaW5pYSBwbHVnaW4gd2l0aG91dCBhbnkgc3RvcmUuIEFsbG93cyBkaXNwbGF5aW5nIGEgUGluaWEgcGx1Z2luIHRhYlxuICogYXMgc29vbiBhcyBpdCBpcyBhZGRlZCB0byB0aGUgYXBwbGljYXRpb24uXG4gKlxuICogQHBhcmFtIGFwcCAtIFZ1ZSBhcHBsaWNhdGlvblxuICogQHBhcmFtIHBpbmlhIC0gcGluaWEgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJQaW5pYURldnRvb2xzKGFwcCwgcGluaWEpIHtcbiAgICBzZXR1cERldnRvb2xzUGx1Z2luKHtcbiAgICAgICAgaWQ6ICdkZXYuZXNtLnBpbmlhJyxcbiAgICAgICAgbGFiZWw6ICdQaW5pYSDwn42NJyxcbiAgICAgICAgbG9nbzogJ2h0dHBzOi8vcGluaWEudnVlanMub3JnL2xvZ28uc3ZnJyxcbiAgICAgICAgcGFja2FnZU5hbWU6ICdwaW5pYScsXG4gICAgICAgIGhvbWVwYWdlOiAnaHR0cHM6Ly9waW5pYS52dWVqcy5vcmcnLFxuICAgICAgICBjb21wb25lbnRTdGF0ZVR5cGVzLFxuICAgICAgICBhcHAsXG4gICAgfSwgKGFwaSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGFwaS5ub3cgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRvYXN0TWVzc2FnZSgnWW91IHNlZW0gdG8gYmUgdXNpbmcgYW4gb3V0ZGF0ZWQgdmVyc2lvbiBvZiBWdWUgRGV2dG9vbHMuIEFyZSB5b3Ugc3RpbGwgdXNpbmcgdGhlIEJldGEgcmVsZWFzZSBpbnN0ZWFkIG9mIHRoZSBzdGFibGUgb25lPyBZb3UgY2FuIGZpbmQgdGhlIGxpbmtzIGF0IGh0dHBzOi8vZGV2dG9vbHMudnVlanMub3JnL2d1aWRlL2luc3RhbGxhdGlvbi5odG1sLicpO1xuICAgICAgICB9XG4gICAgICAgIGFwaS5hZGRUaW1lbGluZUxheWVyKHtcbiAgICAgICAgICAgIGlkOiBNVVRBVElPTlNfTEFZRVJfSUQsXG4gICAgICAgICAgICBsYWJlbDogYFBpbmlhIPCfjY1gLFxuICAgICAgICAgICAgY29sb3I6IDB4ZTVkZjg4LFxuICAgICAgICB9KTtcbiAgICAgICAgYXBpLmFkZEluc3BlY3Rvcih7XG4gICAgICAgICAgICBpZDogSU5TUEVDVE9SX0lELFxuICAgICAgICAgICAgbGFiZWw6ICdQaW5pYSDwn42NJyxcbiAgICAgICAgICAgIGljb246ICdzdG9yYWdlJyxcbiAgICAgICAgICAgIHRyZWVGaWx0ZXJQbGFjZWhvbGRlcjogJ1NlYXJjaCBzdG9yZXMnLFxuICAgICAgICAgICAgYWN0aW9uczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogJ2NvbnRlbnRfY29weScsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uR2xvYmFsQ29weVN0YXRlKHBpbmlhKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcDogJ1NlcmlhbGl6ZSBhbmQgY29weSB0aGUgc3RhdGUnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpY29uOiAnY29udGVudF9wYXN0ZScsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgYWN0aW9uR2xvYmFsUGFzdGVTdGF0ZShwaW5pYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcGkuc2VuZEluc3BlY3RvclRyZWUoSU5TUEVDVE9SX0lEKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5zZW5kSW5zcGVjdG9yU3RhdGUoSU5TUEVDVE9SX0lEKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcDogJ1JlcGxhY2UgdGhlIHN0YXRlIHdpdGggdGhlIGNvbnRlbnQgb2YgeW91ciBjbGlwYm9hcmQnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpY29uOiAnc2F2ZScsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uR2xvYmFsU2F2ZVN0YXRlKHBpbmlhKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcDogJ1NhdmUgdGhlIHN0YXRlIGFzIGEgSlNPTiBmaWxlJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogJ2ZvbGRlcl9vcGVuJyxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBhY3Rpb25HbG9iYWxPcGVuU3RhdGVGaWxlKHBpbmlhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5zZW5kSW5zcGVjdG9yVHJlZShJTlNQRUNUT1JfSUQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBpLnNlbmRJbnNwZWN0b3JTdGF0ZShJTlNQRUNUT1JfSUQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwOiAnSW1wb3J0IHRoZSBzdGF0ZSBmcm9tIGEgSlNPTiBmaWxlJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIG5vZGVBY3Rpb25zOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpY29uOiAncmVzdG9yZScsXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6ICdSZXNldCB0aGUgc3RhdGUgKHdpdGggXCIkcmVzZXRcIiknLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IChub2RlSWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gcGluaWEuX3MuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9hc3RNZXNzYWdlKGBDYW5ub3QgcmVzZXQgXCIke25vZGVJZH1cIiBzdG9yZSBiZWNhdXNlIGl0IHdhc24ndCBmb3VuZC5gLCAnd2FybicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHN0b3JlLiRyZXNldCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvYXN0TWVzc2FnZShgQ2Fubm90IHJlc2V0IFwiJHtub2RlSWR9XCIgc3RvcmUgYmVjYXVzZSBpdCBkb2Vzbid0IGhhdmUgYSBcIiRyZXNldFwiIG1ldGhvZCBpbXBsZW1lbnRlZC5gLCAnd2FybicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUuJHJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9hc3RNZXNzYWdlKGBTdG9yZSBcIiR7bm9kZUlkfVwiIHJlc2V0LmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgYXBpLm9uLmluc3BlY3RDb21wb25lbnQoKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJveHkgPSAocGF5bG9hZC5jb21wb25lbnRJbnN0YW5jZSAmJlxuICAgICAgICAgICAgICAgIHBheWxvYWQuY29tcG9uZW50SW5zdGFuY2UucHJveHkpO1xuICAgICAgICAgICAgaWYgKHByb3h5ICYmIHByb3h5Ll9wU3RvcmVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGluaWFTdG9yZXMgPSBwYXlsb2FkLmNvbXBvbmVudEluc3RhbmNlLnByb3h5Ll9wU3RvcmVzO1xuICAgICAgICAgICAgICAgIE9iamVjdC52YWx1ZXMocGluaWFTdG9yZXMpLmZvckVhY2goKHN0b3JlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQuaW5zdGFuY2VEYXRhLnN0YXRlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZ2V0U3RvcmVUeXBlKHN0b3JlLiRpZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdzdGF0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzdG9yZS5faXNPcHRpb25zQVBJXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jdXN0b206IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0b1JhdyhzdG9yZS4kc3RhdGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbjogJ3Jlc3RvcmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwOiAnUmVzZXQgdGhlIHN0YXRlIG9mIHRoaXMgc3RvcmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICgpID0+IHN0b3JlLiRyZXNldCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IC8vIE5PVEU6IHdvcmthcm91bmQgdG8gdW53cmFwIHRyYW5zZmVycmVkIHJlZnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc3RvcmUuJHN0YXRlKS5yZWR1Y2UoKHN0YXRlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlW2tleV0gPSBzdG9yZS4kc3RhdGVba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge30pLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3JlLl9nZXR0ZXJzICYmIHN0b3JlLl9nZXR0ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5pbnN0YW5jZURhdGEuc3RhdGUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZ2V0U3RvcmVUeXBlKHN0b3JlLiRpZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnZ2V0dGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzdG9yZS5fZ2V0dGVycy5yZWR1Y2UoKGdldHRlcnMsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0dGVyc1trZXldID0gc3RvcmVba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHdlIGp1c3Qgd2FudCB0byBzaG93IGl0IGluIGRldnRvb2xzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXR0ZXJzW2tleV0gPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0dGVycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXBpLm9uLmdldEluc3BlY3RvclRyZWUoKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLmFwcCA9PT0gYXBwICYmIHBheWxvYWQuaW5zcGVjdG9ySWQgPT09IElOU1BFQ1RPUl9JRCkge1xuICAgICAgICAgICAgICAgIGxldCBzdG9yZXMgPSBbcGluaWFdO1xuICAgICAgICAgICAgICAgIHN0b3JlcyA9IHN0b3Jlcy5jb25jYXQoQXJyYXkuZnJvbShwaW5pYS5fcy52YWx1ZXMoKSkpO1xuICAgICAgICAgICAgICAgIHBheWxvYWQucm9vdE5vZGVzID0gKHBheWxvYWQuZmlsdGVyXG4gICAgICAgICAgICAgICAgICAgID8gc3RvcmVzLmZpbHRlcigoc3RvcmUpID0+ICckaWQnIGluIHN0b3JlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHN0b3JlLiRpZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmluY2x1ZGVzKHBheWxvYWQuZmlsdGVyLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFBJTklBX1JPT1RfTEFCRUwudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhwYXlsb2FkLmZpbHRlci50b0xvd2VyQ2FzZSgpKSlcbiAgICAgICAgICAgICAgICAgICAgOiBzdG9yZXMpLm1hcChmb3JtYXRTdG9yZUZvckluc3BlY3RvclRyZWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gRXhwb3NlIHBpbmlhIGluc3RhbmNlIGFzICRwaW5pYSB0byB3aW5kb3dcbiAgICAgICAgZ2xvYmFsVGhpcy4kcGluaWEgPSBwaW5pYTtcbiAgICAgICAgYXBpLm9uLmdldEluc3BlY3RvclN0YXRlKChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICBpZiAocGF5bG9hZC5hcHAgPT09IGFwcCAmJiBwYXlsb2FkLmluc3BlY3RvcklkID09PSBJTlNQRUNUT1JfSUQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnNwZWN0ZWRTdG9yZSA9IHBheWxvYWQubm9kZUlkID09PSBQSU5JQV9ST09UX0lEXG4gICAgICAgICAgICAgICAgICAgID8gcGluaWFcbiAgICAgICAgICAgICAgICAgICAgOiBwaW5pYS5fcy5nZXQocGF5bG9hZC5ub2RlSWQpO1xuICAgICAgICAgICAgICAgIGlmICghaW5zcGVjdGVkU3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjb3VsZCBiZSB0aGUgc2VsZWN0ZWQgc3RvcmUgcmVzdG9yZWQgZm9yIGEgZGlmZmVyZW50IHByb2plY3RcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gaXQncyBiZXR0ZXIgbm90IHRvIHNheSBhbnl0aGluZyBoZXJlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluc3BlY3RlZFN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4cG9zZSBzZWxlY3RlZCBzdG9yZSBhcyAkc3RvcmUgdG8gd2luZG93XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkLm5vZGVJZCAhPT0gUElOSUFfUk9PVF9JRClcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbFRoaXMuJHN0b3JlID0gdG9SYXcoaW5zcGVjdGVkU3RvcmUpO1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLnN0YXRlID0gZm9ybWF0U3RvcmVGb3JJbnNwZWN0b3JTdGF0ZShpbnNwZWN0ZWRTdG9yZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXBpLm9uLmVkaXRJbnNwZWN0b3JTdGF0ZSgocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgICAgICBpZiAocGF5bG9hZC5hcHAgPT09IGFwcCAmJiBwYXlsb2FkLmluc3BlY3RvcklkID09PSBJTlNQRUNUT1JfSUQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnNwZWN0ZWRTdG9yZSA9IHBheWxvYWQubm9kZUlkID09PSBQSU5JQV9ST09UX0lEXG4gICAgICAgICAgICAgICAgICAgID8gcGluaWFcbiAgICAgICAgICAgICAgICAgICAgOiBwaW5pYS5fcy5nZXQocGF5bG9hZC5ub2RlSWQpO1xuICAgICAgICAgICAgICAgIGlmICghaW5zcGVjdGVkU3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvYXN0TWVzc2FnZShgc3RvcmUgXCIke3BheWxvYWQubm9kZUlkfVwiIG5vdCBmb3VuZGAsICdlcnJvcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhdGggfSA9IHBheWxvYWQ7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1BpbmlhKGluc3BlY3RlZFN0b3JlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhY2Nlc3Mgb25seSB0aGUgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoICE9PSAxIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhaW5zcGVjdGVkU3RvcmUuX2N1c3RvbVByb3BlcnRpZXMuaGFzKHBhdGhbMF0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoWzBdIGluIGluc3BlY3RlZFN0b3JlLiRzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC51bnNoaWZ0KCckc3RhdGUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUm9vdCBhY2Nlc3MsIHdlIGNhbiBvbWl0IHRoZSBgLnZhbHVlYCBiZWNhdXNlIHRoZSBkZXZ0b29scyBBUEkgZG9lcyBpdCBmb3IgdXNcbiAgICAgICAgICAgICAgICAgICAgcGF0aC51bnNoaWZ0KCdzdGF0ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpc1RpbWVsaW5lQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC5zZXQoaW5zcGVjdGVkU3RvcmUsIHBhdGgsIHBheWxvYWQuc3RhdGUudmFsdWUpO1xuICAgICAgICAgICAgICAgIGlzVGltZWxpbmVBY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXBpLm9uLmVkaXRDb21wb25lbnRTdGF0ZSgocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBheWxvYWQudHlwZS5zdGFydHNXaXRoKCfwn42NJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZUlkID0gcGF5bG9hZC50eXBlLnJlcGxhY2UoL17wn42NXFxzKi8sICcnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZSA9IHBpbmlhLl9zLmdldChzdG9yZUlkKTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2FzdE1lc3NhZ2UoYHN0b3JlIFwiJHtzdG9yZUlkfVwiIG5vdCBmb3VuZGAsICdlcnJvcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhdGggfSA9IHBheWxvYWQ7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGhbMF0gIT09ICdzdGF0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvYXN0TWVzc2FnZShgSW52YWxpZCBwYXRoIGZvciBzdG9yZSBcIiR7c3RvcmVJZH1cIjpcXG4ke3BhdGh9XFxuT25seSBzdGF0ZSBjYW4gYmUgbW9kaWZpZWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHJld3JpdGUgdGhlIGZpcnN0IGVudHJ5IHRvIGJlIGFibGUgdG8gZGlyZWN0bHkgc2V0IHRoZSBzdGF0ZSBhc1xuICAgICAgICAgICAgICAgIC8vIHdlbGwgYXMgYW55IG90aGVyIHBhdGhcbiAgICAgICAgICAgICAgICBwYXRoWzBdID0gJyRzdGF0ZSc7XG4gICAgICAgICAgICAgICAgaXNUaW1lbGluZUFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHBheWxvYWQuc2V0KHN0b3JlLCBwYXRoLCBwYXlsb2FkLnN0YXRlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBpc1RpbWVsaW5lQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBhZGRTdG9yZVRvRGV2dG9vbHMoYXBwLCBzdG9yZSkge1xuICAgIGlmICghY29tcG9uZW50U3RhdGVUeXBlcy5pbmNsdWRlcyhnZXRTdG9yZVR5cGUoc3RvcmUuJGlkKSkpIHtcbiAgICAgICAgY29tcG9uZW50U3RhdGVUeXBlcy5wdXNoKGdldFN0b3JlVHlwZShzdG9yZS4kaWQpKTtcbiAgICB9XG4gICAgc2V0dXBEZXZ0b29sc1BsdWdpbih7XG4gICAgICAgIGlkOiAnZGV2LmVzbS5waW5pYScsXG4gICAgICAgIGxhYmVsOiAnUGluaWEg8J+NjScsXG4gICAgICAgIGxvZ286ICdodHRwczovL3BpbmlhLnZ1ZWpzLm9yZy9sb2dvLnN2ZycsXG4gICAgICAgIHBhY2thZ2VOYW1lOiAncGluaWEnLFxuICAgICAgICBob21lcGFnZTogJ2h0dHBzOi8vcGluaWEudnVlanMub3JnJyxcbiAgICAgICAgY29tcG9uZW50U3RhdGVUeXBlcyxcbiAgICAgICAgYXBwLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgbG9nU3RvcmVDaGFuZ2VzOiB7XG4gICAgICAgICAgICAgICAgbGFiZWw6ICdOb3RpZnkgYWJvdXQgbmV3L2RlbGV0ZWQgc3RvcmVzJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIHVzZUVtb2ppczoge1xuICAgICAgICAgICAgLy8gICBsYWJlbDogJ1VzZSBlbW9qaXMgaW4gbWVzc2FnZXMg4pqh77iPJyxcbiAgICAgICAgICAgIC8vICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgLy8gICBkZWZhdWx0VmFsdWU6IHRydWUsXG4gICAgICAgICAgICAvLyB9LFxuICAgICAgICB9LFxuICAgIH0sIChhcGkpID0+IHtcbiAgICAgICAgLy8gZ3JhY2VmdWxseSBoYW5kbGUgZXJyb3JzXG4gICAgICAgIGNvbnN0IG5vdyA9IHR5cGVvZiBhcGkubm93ID09PSAnZnVuY3Rpb24nID8gYXBpLm5vdy5iaW5kKGFwaSkgOiBEYXRlLm5vdztcbiAgICAgICAgc3RvcmUuJG9uQWN0aW9uKCh7IGFmdGVyLCBvbkVycm9yLCBuYW1lLCBhcmdzIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwSWQgPSBydW5uaW5nQWN0aW9uSWQrKztcbiAgICAgICAgICAgIGFwaS5hZGRUaW1lbGluZUV2ZW50KHtcbiAgICAgICAgICAgICAgICBsYXllcklkOiBNVVRBVElPTlNfTEFZRVJfSUQsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdGltZTogbm93KCksXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiAn8J+bqyAnICsgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc3VidGl0bGU6ICdzdGFydCcsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlOiBmb3JtYXREaXNwbGF5KHN0b3JlLiRpZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGZvcm1hdERpc3BsYXkobmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBncm91cElkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFmdGVyKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBhY3RpdmVBY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYXBpLmFkZFRpbWVsaW5lRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICBsYXllcklkOiBNVVRBVElPTlNfTEFZRVJfSUQsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lOiBub3coKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAn8J+brCAnICsgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnRpdGxlOiAnZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZTogZm9ybWF0RGlzcGxheShzdG9yZS4kaWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogZm9ybWF0RGlzcGxheShuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cElkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvbkVycm9yKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIGFjdGl2ZUFjdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBhcGkuYWRkVGltZWxpbmVFdmVudCh7XG4gICAgICAgICAgICAgICAgICAgIGxheWVySWQ6IE1VVEFUSU9OU19MQVlFUl9JRCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IG5vdygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nVHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAn8J+SpSAnICsgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnRpdGxlOiAnZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZTogZm9ybWF0RGlzcGxheShzdG9yZS4kaWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogZm9ybWF0RGlzcGxheShuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwSWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIHN0b3JlLl9jdXN0b21Qcm9wZXJ0aWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgIHdhdGNoKCgpID0+IHVucmVmKHN0b3JlW25hbWVdKSwgKG5ld1ZhbHVlLCBvbGRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGFwaS5ub3RpZnlDb21wb25lbnRVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICBhcGkuc2VuZEluc3BlY3RvclN0YXRlKElOU1BFQ1RPUl9JRCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzVGltZWxpbmVBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBpLmFkZFRpbWVsaW5lRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJJZDogTVVUQVRJT05TX0xBWUVSX0lELFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lOiBub3coKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ0NoYW5nZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VidGl0bGU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cElkOiBhY3RpdmVBY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7IGRlZXA6IHRydWUgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdG9yZS4kc3Vic2NyaWJlKCh7IGV2ZW50cywgdHlwZSB9LCBzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgYXBpLm5vdGlmeUNvbXBvbmVudFVwZGF0ZSgpO1xuICAgICAgICAgICAgYXBpLnNlbmRJbnNwZWN0b3JTdGF0ZShJTlNQRUNUT1JfSUQpO1xuICAgICAgICAgICAgaWYgKCFpc1RpbWVsaW5lQWN0aXZlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIHJvb3RTdG9yZS5zdGF0ZVtzdG9yZS5pZF0gPSBzdGF0ZVxuICAgICAgICAgICAgY29uc3QgZXZlbnREYXRhID0ge1xuICAgICAgICAgICAgICAgIHRpbWU6IG5vdygpLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBmb3JtYXRNdXRhdGlvblR5cGUodHlwZSksXG4gICAgICAgICAgICAgICAgZGF0YTogYXNzaWduJDEoeyBzdG9yZTogZm9ybWF0RGlzcGxheShzdG9yZS4kaWQpIH0sIGZvcm1hdEV2ZW50RGF0YShldmVudHMpKSxcbiAgICAgICAgICAgICAgICBncm91cElkOiBhY3RpdmVBY3Rpb24sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IE11dGF0aW9uVHlwZS5wYXRjaEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgZXZlbnREYXRhLnN1YnRpdGxlID0gJ+Kkte+4jyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBNdXRhdGlvblR5cGUucGF0Y2hPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBldmVudERhdGEuc3VidGl0bGUgPSAn8J+nqSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudHMgJiYgIUFycmF5LmlzQXJyYXkoZXZlbnRzKSkge1xuICAgICAgICAgICAgICAgIGV2ZW50RGF0YS5zdWJ0aXRsZSA9IGV2ZW50cy50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV2ZW50cykge1xuICAgICAgICAgICAgICAgIGV2ZW50RGF0YS5kYXRhWydyYXdFdmVudChzKSddID0ge1xuICAgICAgICAgICAgICAgICAgICBfY3VzdG9tOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnRGVidWdnZXJFdmVudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6ICdyYXcgRGVidWdnZXJFdmVudFtdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBldmVudHMsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFwaS5hZGRUaW1lbGluZUV2ZW50KHtcbiAgICAgICAgICAgICAgICBsYXllcklkOiBNVVRBVElPTlNfTEFZRVJfSUQsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50RGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB7IGRldGFjaGVkOiB0cnVlLCBmbHVzaDogJ3N5bmMnIH0pO1xuICAgICAgICBjb25zdCBob3RVcGRhdGUgPSBzdG9yZS5faG90VXBkYXRlO1xuICAgICAgICBzdG9yZS5faG90VXBkYXRlID0gbWFya1JhdygobmV3U3RvcmUpID0+IHtcbiAgICAgICAgICAgIGhvdFVwZGF0ZShuZXdTdG9yZSk7XG4gICAgICAgICAgICBhcGkuYWRkVGltZWxpbmVFdmVudCh7XG4gICAgICAgICAgICAgICAgbGF5ZXJJZDogTVVUQVRJT05TX0xBWUVSX0lELFxuICAgICAgICAgICAgICAgIGV2ZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IG5vdygpLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ/CflKUgJyArIHN0b3JlLiRpZCxcbiAgICAgICAgICAgICAgICAgICAgc3VidGl0bGU6ICdITVIgdXBkYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmU6IGZvcm1hdERpc3BsYXkoc3RvcmUuJGlkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm86IGZvcm1hdERpc3BsYXkoYEhNUiB1cGRhdGVgKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGRldnRvb2xzIHRvb1xuICAgICAgICAgICAgYXBpLm5vdGlmeUNvbXBvbmVudFVwZGF0ZSgpO1xuICAgICAgICAgICAgYXBpLnNlbmRJbnNwZWN0b3JUcmVlKElOU1BFQ1RPUl9JRCk7XG4gICAgICAgICAgICBhcGkuc2VuZEluc3BlY3RvclN0YXRlKElOU1BFQ1RPUl9JRCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7ICRkaXNwb3NlIH0gPSBzdG9yZTtcbiAgICAgICAgc3RvcmUuJGRpc3Bvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICAkZGlzcG9zZSgpO1xuICAgICAgICAgICAgYXBpLm5vdGlmeUNvbXBvbmVudFVwZGF0ZSgpO1xuICAgICAgICAgICAgYXBpLnNlbmRJbnNwZWN0b3JUcmVlKElOU1BFQ1RPUl9JRCk7XG4gICAgICAgICAgICBhcGkuc2VuZEluc3BlY3RvclN0YXRlKElOU1BFQ1RPUl9JRCk7XG4gICAgICAgICAgICBhcGkuZ2V0U2V0dGluZ3MoKS5sb2dTdG9yZUNoYW5nZXMgJiZcbiAgICAgICAgICAgICAgICB0b2FzdE1lc3NhZ2UoYERpc3Bvc2VkIFwiJHtzdG9yZS4kaWR9XCIgc3RvcmUg8J+XkWApO1xuICAgICAgICB9O1xuICAgICAgICAvLyB0cmlnZ2VyIGFuIHVwZGF0ZSBzbyBpdCBjYW4gZGlzcGxheSBuZXcgcmVnaXN0ZXJlZCBzdG9yZXNcbiAgICAgICAgYXBpLm5vdGlmeUNvbXBvbmVudFVwZGF0ZSgpO1xuICAgICAgICBhcGkuc2VuZEluc3BlY3RvclRyZWUoSU5TUEVDVE9SX0lEKTtcbiAgICAgICAgYXBpLnNlbmRJbnNwZWN0b3JTdGF0ZShJTlNQRUNUT1JfSUQpO1xuICAgICAgICBhcGkuZ2V0U2V0dGluZ3MoKS5sb2dTdG9yZUNoYW5nZXMgJiZcbiAgICAgICAgICAgIHRvYXN0TWVzc2FnZShgXCIke3N0b3JlLiRpZH1cIiBzdG9yZSBpbnN0YWxsZWQg8J+GlWApO1xuICAgIH0pO1xufVxubGV0IHJ1bm5pbmdBY3Rpb25JZCA9IDA7XG5sZXQgYWN0aXZlQWN0aW9uO1xuLyoqXG4gKiBQYXRjaGVzIGEgc3RvcmUgdG8gZW5hYmxlIGFjdGlvbiBncm91cGluZyBpbiBkZXZ0b29scyBieSB3cmFwcGluZyB0aGUgc3RvcmUgd2l0aCBhIFByb3h5IHRoYXQgaXMgcGFzc2VkIGFzIHRoZVxuICogY29udGV4dCBvZiBhbGwgYWN0aW9ucywgYWxsb3dpbmcgdXMgdG8gc2V0IGBydW5uaW5nQWN0aW9uYCBvbiBlYWNoIGFjY2VzcyBhbmQgZWZmZWN0aXZlbHkgYXNzb2NpYXRpbmcgYW55IHN0YXRlXG4gKiBtdXRhdGlvbiB0byB0aGUgYWN0aW9uLlxuICpcbiAqIEBwYXJhbSBzdG9yZSAtIHN0b3JlIHRvIHBhdGNoXG4gKiBAcGFyYW0gYWN0aW9uTmFtZXMgLSBsaXN0IG9mIGFjdGlvbnN0IHRvIHBhdGNoXG4gKi9cbmZ1bmN0aW9uIHBhdGNoQWN0aW9uRm9yR3JvdXBpbmcoc3RvcmUsIGFjdGlvbk5hbWVzLCB3cmFwV2l0aFByb3h5KSB7XG4gICAgLy8gb3JpZ2luYWwgYWN0aW9ucyBvZiB0aGUgc3RvcmUgYXMgdGhleSBhcmUgZ2l2ZW4gYnkgcGluaWEuIFdlIGFyZSBnb2luZyB0byBvdmVycmlkZSB0aGVtXG4gICAgY29uc3QgYWN0aW9ucyA9IGFjdGlvbk5hbWVzLnJlZHVjZSgoc3RvcmVBY3Rpb25zLCBhY3Rpb25OYW1lKSA9PiB7XG4gICAgICAgIC8vIHVzZSB0b1JhdyB0byBhdm9pZCB0cmFja2luZyAjNTQxXG4gICAgICAgIHN0b3JlQWN0aW9uc1thY3Rpb25OYW1lXSA9IHRvUmF3KHN0b3JlKVthY3Rpb25OYW1lXTtcbiAgICAgICAgcmV0dXJuIHN0b3JlQWN0aW9ucztcbiAgICB9LCB7fSk7XG4gICAgZm9yIChjb25zdCBhY3Rpb25OYW1lIGluIGFjdGlvbnMpIHtcbiAgICAgICAgc3RvcmVbYWN0aW9uTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyB0aGUgcnVubmluZyBhY3Rpb24gaWQgaXMgaW5jcmVtZW50ZWQgaW4gYSBiZWZvcmUgYWN0aW9uIGhvb2tcbiAgICAgICAgICAgIGNvbnN0IF9hY3Rpb25JZCA9IHJ1bm5pbmdBY3Rpb25JZDtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNrZWRTdG9yZSA9IHdyYXBXaXRoUHJveHlcbiAgICAgICAgICAgICAgICA/IG5ldyBQcm94eShzdG9yZSwge1xuICAgICAgICAgICAgICAgICAgICBnZXQoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlQWN0aW9uID0gX2FjdGlvbklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzZXQoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlQWN0aW9uID0gX2FjdGlvbklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3Quc2V0KC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgOiBzdG9yZTtcbiAgICAgICAgICAgIC8vIEZvciBTZXR1cCBTdG9yZXMgd2UgbmVlZCBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1hc3luYy1jb250ZXh0XG4gICAgICAgICAgICBhY3RpdmVBY3Rpb24gPSBfYWN0aW9uSWQ7XG4gICAgICAgICAgICBjb25zdCByZXRWYWx1ZSA9IGFjdGlvbnNbYWN0aW9uTmFtZV0uYXBwbHkodHJhY2tlZFN0b3JlLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBzYWZlciBhcyBhc3luYyBhY3Rpb25zIGluIFNldHVwIFN0b3JlcyB3b3VsZCBhc3NvY2lhdGUgbXV0YXRpb25zIGRvbmUgb3V0c2lkZSBvZiB0aGUgYWN0aW9uXG4gICAgICAgICAgICBhY3RpdmVBY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm4gcmV0VmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiBwaW5pYS51c2UoZGV2dG9vbHNQbHVnaW4pXG4gKi9cbmZ1bmN0aW9uIGRldnRvb2xzUGx1Z2luKHsgYXBwLCBzdG9yZSwgb3B0aW9ucyB9KSB7XG4gICAgLy8gSE1SIG1vZHVsZVxuICAgIGlmIChzdG9yZS4kaWQuc3RhcnRzV2l0aCgnX19ob3Q6JykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBkZXRlY3Qgb3B0aW9uIGFwaSB2cyBzZXR1cCBhcGlcbiAgICBzdG9yZS5faXNPcHRpb25zQVBJID0gISFvcHRpb25zLnN0YXRlO1xuICAgIC8vIERvIG5vdCBvdmVyd3JpdGUgYWN0aW9ucyBtb2NrZWQgYnkgQHBpbmlhL3Rlc3RpbmcgKCMyMjk4KVxuICAgIGlmICghc3RvcmUuX3AuX3Rlc3RpbmcpIHtcbiAgICAgICAgcGF0Y2hBY3Rpb25Gb3JHcm91cGluZyhzdG9yZSwgT2JqZWN0LmtleXMob3B0aW9ucy5hY3Rpb25zKSwgc3RvcmUuX2lzT3B0aW9uc0FQSSk7XG4gICAgICAgIC8vIFVwZ3JhZGUgdGhlIEhNUiB0byBhbHNvIHVwZGF0ZSB0aGUgbmV3IGFjdGlvbnNcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxIb3RVcGRhdGUgPSBzdG9yZS5faG90VXBkYXRlO1xuICAgICAgICB0b1JhdyhzdG9yZSkuX2hvdFVwZGF0ZSA9IGZ1bmN0aW9uIChuZXdTdG9yZSkge1xuICAgICAgICAgICAgb3JpZ2luYWxIb3RVcGRhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHBhdGNoQWN0aW9uRm9yR3JvdXBpbmcoc3RvcmUsIE9iamVjdC5rZXlzKG5ld1N0b3JlLl9obXJQYXlsb2FkLmFjdGlvbnMpLCAhIXN0b3JlLl9pc09wdGlvbnNBUEkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBhZGRTdG9yZVRvRGV2dG9vbHMoYXBwLCBcbiAgICAvLyBGSVhNRTogaXMgdGhlcmUgYSB3YXkgdG8gYWxsb3cgdGhlIGFzc2lnbm1lbnQgZnJvbSBTdG9yZTxJZCwgUywgRywgQT4gdG8gU3RvcmVHZW5lcmljP1xuICAgIHN0b3JlKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgUGluaWEgaW5zdGFuY2UgdG8gYmUgdXNlZCBieSB0aGUgYXBwbGljYXRpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGluaWEoKSB7XG4gICAgY29uc3Qgc2NvcGUgPSBlZmZlY3RTY29wZSh0cnVlKTtcbiAgICAvLyBOT1RFOiBoZXJlIHdlIGNvdWxkIGNoZWNrIHRoZSB3aW5kb3cgb2JqZWN0IGZvciBhIHN0YXRlIGFuZCBkaXJlY3RseSBzZXQgaXRcbiAgICAvLyBpZiB0aGVyZSBpcyBhbnl0aGluZyBsaWtlIGl0IHdpdGggVnVlIDMgU1NSXG4gICAgY29uc3Qgc3RhdGUgPSBzY29wZS5ydW4oKCkgPT4gcmVmKHt9KSk7XG4gICAgbGV0IF9wID0gW107XG4gICAgLy8gcGx1Z2lucyBhZGRlZCBiZWZvcmUgY2FsbGluZyBhcHAudXNlKHBpbmlhKVxuICAgIGxldCB0b0JlSW5zdGFsbGVkID0gW107XG4gICAgY29uc3QgcGluaWEgPSBtYXJrUmF3KHtcbiAgICAgICAgaW5zdGFsbChhcHApIHtcbiAgICAgICAgICAgIC8vIHRoaXMgYWxsb3dzIGNhbGxpbmcgdXNlU3RvcmUoKSBvdXRzaWRlIG9mIGEgY29tcG9uZW50IHNldHVwIGFmdGVyXG4gICAgICAgICAgICAvLyBpbnN0YWxsaW5nIHBpbmlhJ3MgcGx1Z2luXG4gICAgICAgICAgICBzZXRBY3RpdmVQaW5pYShwaW5pYSk7XG4gICAgICAgICAgICBpZiAoIWlzVnVlMikge1xuICAgICAgICAgICAgICAgIHBpbmlhLl9hID0gYXBwO1xuICAgICAgICAgICAgICAgIGFwcC5wcm92aWRlKHBpbmlhU3ltYm9sLCBwaW5pYSk7XG4gICAgICAgICAgICAgICAgYXBwLmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzLiRwaW5pYSA9IHBpbmlhO1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgaWYgKCgoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICh0eXBlb2YgX19WVUVfUFJPRF9ERVZUT09MU19fICE9PSAndW5kZWZpbmVkJyAmJiBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pKSAmJiAhKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpKSAmJiBJU19DTElFTlQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJQaW5pYURldnRvb2xzKGFwcCwgcGluaWEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b0JlSW5zdGFsbGVkLmZvckVhY2goKHBsdWdpbikgPT4gX3AucHVzaChwbHVnaW4pKTtcbiAgICAgICAgICAgICAgICB0b0JlSW5zdGFsbGVkID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVzZShwbHVnaW4pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fYSAmJiAhaXNWdWUyKSB7XG4gICAgICAgICAgICAgICAgdG9CZUluc3RhbGxlZC5wdXNoKHBsdWdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfcC5wdXNoKHBsdWdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgX3AsXG4gICAgICAgIC8vIGl0J3MgYWN0dWFsbHkgdW5kZWZpbmVkIGhlcmVcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBfYTogbnVsbCxcbiAgICAgICAgX2U6IHNjb3BlLFxuICAgICAgICBfczogbmV3IE1hcCgpLFxuICAgICAgICBzdGF0ZSxcbiAgICB9KTtcbiAgICAvLyBwaW5pYSBkZXZ0b29scyByZWx5IG9uIGRldiBvbmx5IGZlYXR1cmVzIHNvIHRoZXkgY2Fubm90IGJlIGZvcmNlZCB1bmxlc3NcbiAgICAvLyB0aGUgZGV2IGJ1aWxkIG9mIFZ1ZSBpcyB1c2VkLiBBdm9pZCBvbGQgYnJvd3NlcnMgbGlrZSBJRTExLlxuICAgIGlmICgoKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCAodHlwZW9mIF9fVlVFX1BST0RfREVWVE9PTFNfXyAhPT0gJ3VuZGVmaW5lZCcgJiYgX19WVUVfUFJPRF9ERVZUT09MU19fKSkgJiYgIShwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSkgJiYgSVNfQ0xJRU5UICYmIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcGluaWEudXNlKGRldnRvb2xzUGx1Z2luKTtcbiAgICB9XG4gICAgcmV0dXJuIHBpbmlhO1xufVxuLyoqXG4gKiBEaXNwb3NlIGEgUGluaWEgaW5zdGFuY2UgYnkgc3RvcHBpbmcgaXRzIGVmZmVjdFNjb3BlIGFuZCByZW1vdmluZyB0aGUgc3RhdGUsIHBsdWdpbnMgYW5kIHN0b3Jlcy4gVGhpcyBpcyBtb3N0bHlcbiAqIHVzZWZ1bCBpbiB0ZXN0cywgd2l0aCBib3RoIGEgdGVzdGluZyBwaW5pYSBvciBhIHJlZ3VsYXIgcGluaWEgYW5kIGluIGFwcGxpY2F0aW9ucyB0aGF0IHVzZSBtdWx0aXBsZSBwaW5pYSBpbnN0YW5jZXMuXG4gKiBPbmNlIGRpc3Bvc2VkLCB0aGUgcGluaWEgaW5zdGFuY2UgY2Fubm90IGJlIHVzZWQgYW55bW9yZS5cbiAqXG4gKiBAcGFyYW0gcGluaWEgLSBwaW5pYSBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBkaXNwb3NlUGluaWEocGluaWEpIHtcbiAgICBwaW5pYS5fZS5zdG9wKCk7XG4gICAgcGluaWEuX3MuY2xlYXIoKTtcbiAgICBwaW5pYS5fcC5zcGxpY2UoMCk7XG4gICAgcGluaWEuc3RhdGUudmFsdWUgPSB7fTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBub24gdmFsaWRcbiAgICBwaW5pYS5fYSA9IG51bGw7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZnVuY3Rpb24gaXMgYSBgU3RvcmVEZWZpbml0aW9uYC5cbiAqXG4gKiBAcGFyYW0gZm4gLSBvYmplY3QgdG8gdGVzdFxuICogQHJldHVybnMgdHJ1ZSBpZiBgZm5gIGlzIGEgU3RvcmVEZWZpbml0aW9uXG4gKi9cbmNvbnN0IGlzVXNlU3RvcmUgPSAoZm4pID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBmbi4kaWQgPT09ICdzdHJpbmcnO1xufTtcbi8qKlxuICogTXV0YXRlcyBpbiBwbGFjZSBgbmV3U3RhdGVgIHdpdGggYG9sZFN0YXRlYCB0byBfaG90IHVwZGF0ZV8gaXQuIEl0IHdpbGxcbiAqIHJlbW92ZSBhbnkga2V5IG5vdCBleGlzdGluZyBpbiBgbmV3U3RhdGVgIGFuZCByZWN1cnNpdmVseSBtZXJnZSBwbGFpblxuICogb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0gbmV3U3RhdGUgLSBuZXcgc3RhdGUgb2JqZWN0IHRvIGJlIHBhdGNoZWRcbiAqIEBwYXJhbSBvbGRTdGF0ZSAtIG9sZCBzdGF0ZSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHBhdGNoIG5ld1N0YXRlXG4gKiBAcmV0dXJucyAtIG5ld1N0YXRlXG4gKi9cbmZ1bmN0aW9uIHBhdGNoT2JqZWN0KG5ld1N0YXRlLCBvbGRTdGF0ZSkge1xuICAgIC8vIG5vIG5lZWQgdG8gZ28gdGhyb3VnaCBzeW1ib2xzIGJlY2F1c2UgdGhleSBjYW5ub3QgYmUgc2VyaWFsaXplZCBhbnl3YXlcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvbGRTdGF0ZSkge1xuICAgICAgICBjb25zdCBzdWJQYXRjaCA9IG9sZFN0YXRlW2tleV07XG4gICAgICAgIC8vIHNraXAgdGhlIHdob2xlIHN1YiB0cmVlXG4gICAgICAgIGlmICghKGtleSBpbiBuZXdTdGF0ZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldFZhbHVlID0gbmV3U3RhdGVba2V5XTtcbiAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QodGFyZ2V0VmFsdWUpICYmXG4gICAgICAgICAgICBpc1BsYWluT2JqZWN0KHN1YlBhdGNoKSAmJlxuICAgICAgICAgICAgIWlzUmVmKHN1YlBhdGNoKSAmJlxuICAgICAgICAgICAgIWlzUmVhY3RpdmUoc3ViUGF0Y2gpKSB7XG4gICAgICAgICAgICBuZXdTdGF0ZVtrZXldID0gcGF0Y2hPYmplY3QodGFyZ2V0VmFsdWUsIHN1YlBhdGNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG9iamVjdHMgYXJlIGVpdGhlciBhIGJpdCBtb3JlIGNvbXBsZXggKGUuZy4gcmVmcykgb3IgcHJpbWl0aXZlcywgc28gd2VcbiAgICAgICAgICAgIC8vIGp1c3Qgc2V0IHRoZSB3aG9sZSB0aGluZ1xuICAgICAgICAgICAgaWYgKGlzVnVlMikge1xuICAgICAgICAgICAgICAgIHNldChuZXdTdGF0ZSwga2V5LCBzdWJQYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZVtrZXldID0gc3ViUGF0Y2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld1N0YXRlO1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIF9hY2NlcHRfIGZ1bmN0aW9uIHRvIHBhc3MgdG8gYGltcG9ydC5tZXRhLmhvdGAgaW4gVml0ZSBhcHBsaWNhdGlvbnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBjb25zdCB1c2VVc2VyID0gZGVmaW5lU3RvcmUoLi4uKVxuICogaWYgKGltcG9ydC5tZXRhLmhvdCkge1xuICogICBpbXBvcnQubWV0YS5ob3QuYWNjZXB0KGFjY2VwdEhNUlVwZGF0ZSh1c2VVc2VyLCBpbXBvcnQubWV0YS5ob3QpKVxuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIGluaXRpYWxVc2VTdG9yZSAtIHJldHVybiBvZiB0aGUgZGVmaW5lU3RvcmUgdG8gaG90IHVwZGF0ZVxuICogQHBhcmFtIGhvdCAtIGBpbXBvcnQubWV0YS5ob3RgXG4gKi9cbmZ1bmN0aW9uIGFjY2VwdEhNUlVwZGF0ZShpbml0aWFsVXNlU3RvcmUsIGhvdCkge1xuICAgIC8vIHN0cmlwIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSBpaWZlLnByb2RcbiAgICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICByZXR1cm4gKCkgPT4geyB9O1xuICAgIH1cbiAgICByZXR1cm4gKG5ld01vZHVsZSkgPT4ge1xuICAgICAgICBjb25zdCBwaW5pYSA9IGhvdC5kYXRhLnBpbmlhIHx8IGluaXRpYWxVc2VTdG9yZS5fcGluaWE7XG4gICAgICAgIGlmICghcGluaWEpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgc3RvcmUgaXMgc3RpbGwgbm90IHVzZWRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBwcmVzZXJ2ZSB0aGUgcGluaWEgaW5zdGFuY2UgYWNyb3NzIGxvYWRzXG4gICAgICAgIGhvdC5kYXRhLnBpbmlhID0gcGluaWE7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdnb3QgZGF0YScsIG5ld1N0b3JlKVxuICAgICAgICBmb3IgKGNvbnN0IGV4cG9ydE5hbWUgaW4gbmV3TW9kdWxlKSB7XG4gICAgICAgICAgICBjb25zdCB1c2VTdG9yZSA9IG5ld01vZHVsZVtleHBvcnROYW1lXTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdjaGVja2luZyBmb3InLCBleHBvcnROYW1lKVxuICAgICAgICAgICAgaWYgKGlzVXNlU3RvcmUodXNlU3RvcmUpICYmIHBpbmlhLl9zLmhhcyh1c2VTdG9yZS4kaWQpKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0FjY2VwdGluZyB1cGRhdGUgZm9yJywgdXNlU3RvcmUuJGlkKVxuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gdXNlU3RvcmUuJGlkO1xuICAgICAgICAgICAgICAgIGlmIChpZCAhPT0gaW5pdGlhbFVzZVN0b3JlLiRpZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFRoZSBpZCBvZiB0aGUgc3RvcmUgY2hhbmdlZCBmcm9tIFwiJHtpbml0aWFsVXNlU3RvcmUuJGlkfVwiIHRvIFwiJHtpZH1cIi4gUmVsb2FkaW5nLmApO1xuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gaW1wb3J0Lm1ldGEuaG90LmludmFsaWRhdGUoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaG90LmludmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdTdG9yZSA9IHBpbmlhLl9zLmdldChpZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFleGlzdGluZ1N0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbUGluaWFdOiBza2lwcGluZyBobXIgYmVjYXVzZSBzdG9yZSBkb2Vzbid0IGV4aXN0IHlldGApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVzZVN0b3JlKHBpbmlhLCBleGlzdGluZ1N0b3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7IH07XG5mdW5jdGlvbiBhZGRTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9ucywgY2FsbGJhY2ssIGRldGFjaGVkLCBvbkNsZWFudXAgPSBub29wKSB7XG4gICAgc3Vic2NyaXB0aW9ucy5wdXNoKGNhbGxiYWNrKTtcbiAgICBjb25zdCByZW1vdmVTdWJzY3JpcHRpb24gPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHN1YnNjcmlwdGlvbnMuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9ucy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIG9uQ2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAoIWRldGFjaGVkICYmIGdldEN1cnJlbnRTY29wZSgpKSB7XG4gICAgICAgIG9uU2NvcGVEaXNwb3NlKHJlbW92ZVN1YnNjcmlwdGlvbik7XG4gICAgfVxuICAgIHJldHVybiByZW1vdmVTdWJzY3JpcHRpb247XG59XG5mdW5jdGlvbiB0cmlnZ2VyU3Vic2NyaXB0aW9ucyhzdWJzY3JpcHRpb25zLCAuLi5hcmdzKSB7XG4gICAgc3Vic2NyaXB0aW9ucy5zbGljZSgpLmZvckVhY2goKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKC4uLmFyZ3MpO1xuICAgIH0pO1xufVxuXG5jb25zdCBmYWxsYmFja1J1bldpdGhDb250ZXh0ID0gKGZuKSA9PiBmbigpO1xuLyoqXG4gKiBNYXJrcyBhIGZ1bmN0aW9uIGFzIGFuIGFjdGlvbiBmb3IgYCRvbkFjdGlvbmBcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBBQ1RJT05fTUFSS0VSID0gU3ltYm9sKCk7XG4vKipcbiAqIEFjdGlvbiBuYW1lIHN5bWJvbC4gQWxsb3dzIHRvIGFkZCBhIG5hbWUgdG8gYW4gYWN0aW9uIGFmdGVyIGRlZmluaW5nIGl0XG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgQUNUSU9OX05BTUUgPSBTeW1ib2woKTtcbmZ1bmN0aW9uIG1lcmdlUmVhY3RpdmVPYmplY3RzKHRhcmdldCwgcGF0Y2hUb0FwcGx5KSB7XG4gICAgLy8gSGFuZGxlIE1hcCBpbnN0YW5jZXNcbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgTWFwICYmIHBhdGNoVG9BcHBseSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBwYXRjaFRvQXBwbHkuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gdGFyZ2V0LnNldChrZXksIHZhbHVlKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFNldCAmJiBwYXRjaFRvQXBwbHkgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgLy8gSGFuZGxlIFNldCBpbnN0YW5jZXNcbiAgICAgICAgcGF0Y2hUb0FwcGx5LmZvckVhY2godGFyZ2V0LmFkZCwgdGFyZ2V0KTtcbiAgICB9XG4gICAgLy8gbm8gbmVlZCB0byBnbyB0aHJvdWdoIHN5bWJvbHMgYmVjYXVzZSB0aGV5IGNhbm5vdCBiZSBzZXJpYWxpemVkIGFueXdheVxuICAgIGZvciAoY29uc3Qga2V5IGluIHBhdGNoVG9BcHBseSkge1xuICAgICAgICBpZiAoIXBhdGNoVG9BcHBseS5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IHN1YlBhdGNoID0gcGF0Y2hUb0FwcGx5W2tleV07XG4gICAgICAgIGNvbnN0IHRhcmdldFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0KHRhcmdldFZhbHVlKSAmJlxuICAgICAgICAgICAgaXNQbGFpbk9iamVjdChzdWJQYXRjaCkgJiZcbiAgICAgICAgICAgIHRhcmdldC5oYXNPd25Qcm9wZXJ0eShrZXkpICYmXG4gICAgICAgICAgICAhaXNSZWYoc3ViUGF0Y2gpICYmXG4gICAgICAgICAgICAhaXNSZWFjdGl2ZShzdWJQYXRjaCkpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IGhlcmUgSSB3YW50ZWQgdG8gd2FybiBhYm91dCBpbmNvbnNpc3RlbnQgdHlwZXMgYnV0IGl0J3Mgbm90IHBvc3NpYmxlIGJlY2F1c2UgaW4gc2V0dXAgc3RvcmVzIG9uZSBtaWdodFxuICAgICAgICAgICAgLy8gc3RhcnQgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgYXMgYSBjZXJ0YWluIHR5cGUgZS5nLiBhIE1hcCwgYW5kIHRoZW4gZm9yIHNvbWUgcmVhc29uLCBkdXJpbmcgU1NSLCBjaGFuZ2UgdGhhdFxuICAgICAgICAgICAgLy8gdG8gYHVuZGVmaW5lZGAuIFdoZW4gdHJ5aW5nIHRvIGh5ZHJhdGUsIHdlIHdhbnQgdG8gb3ZlcnJpZGUgdGhlIE1hcCB3aXRoIGB1bmRlZmluZWRgLlxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBtZXJnZVJlYWN0aXZlT2JqZWN0cyh0YXJnZXRWYWx1ZSwgc3ViUGF0Y2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogc3ViUGF0Y2ggaXMgYSB2YWxpZCB2YWx1ZVxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzdWJQYXRjaDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuY29uc3Qgc2tpcEh5ZHJhdGVTeW1ib2wgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICA/IFN5bWJvbCgncGluaWE6c2tpcEh5ZHJhdGlvbicpXG4gICAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBTeW1ib2woKTtcbi8qKlxuICogVGVsbHMgUGluaWEgdG8gc2tpcCB0aGUgaHlkcmF0aW9uIHByb2Nlc3Mgb2YgYSBnaXZlbiBvYmplY3QuIFRoaXMgaXMgdXNlZnVsIGluIHNldHVwIHN0b3JlcyAob25seSkgd2hlbiB5b3UgcmV0dXJuIGFcbiAqIHN0YXRlZnVsIG9iamVjdCBpbiB0aGUgc3RvcmUgYnV0IGl0IGlzbid0IHJlYWxseSBzdGF0ZS4gZS5nLiByZXR1cm5pbmcgYSByb3V0ZXIgaW5zdGFuY2UgaW4gYSBzZXR1cCBzdG9yZS5cbiAqXG4gKiBAcGFyYW0gb2JqIC0gdGFyZ2V0IG9iamVjdFxuICogQHJldHVybnMgb2JqXG4gKi9cbmZ1bmN0aW9uIHNraXBIeWRyYXRlKG9iaikge1xuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBza2lwSHlkcmF0ZVN5bWJvbCwge30pO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgYSB2YWx1ZSBzaG91bGQgYmUgaHlkcmF0ZWRcbiAqXG4gKiBAcGFyYW0gb2JqIC0gdGFyZ2V0IHZhcmlhYmxlXG4gKiBAcmV0dXJucyB0cnVlIGlmIGBvYmpgIHNob3VsZCBiZSBoeWRyYXRlZFxuICovXG5mdW5jdGlvbiBzaG91bGRIeWRyYXRlKG9iaikge1xuICAgIHJldHVybiAhaXNQbGFpbk9iamVjdChvYmopIHx8ICFvYmouaGFzT3duUHJvcGVydHkoc2tpcEh5ZHJhdGVTeW1ib2wpO1xufVxuY29uc3QgeyBhc3NpZ24gfSA9IE9iamVjdDtcbmZ1bmN0aW9uIGlzQ29tcHV0ZWQobykge1xuICAgIHJldHVybiAhIShpc1JlZihvKSAmJiBvLmVmZmVjdCk7XG59XG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zU3RvcmUoaWQsIG9wdGlvbnMsIHBpbmlhLCBob3QpIHtcbiAgICBjb25zdCB7IHN0YXRlLCBhY3Rpb25zLCBnZXR0ZXJzIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGluaXRpYWxTdGF0ZSA9IHBpbmlhLnN0YXRlLnZhbHVlW2lkXTtcbiAgICBsZXQgc3RvcmU7XG4gICAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgICAgIGlmICghaW5pdGlhbFN0YXRlICYmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICFob3QpKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmIChpc1Z1ZTIpIHtcbiAgICAgICAgICAgICAgICBzZXQocGluaWEuc3RhdGUudmFsdWUsIGlkLCBzdGF0ZSA/IHN0YXRlKCkgOiB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwaW5pYS5zdGF0ZS52YWx1ZVtpZF0gPSBzdGF0ZSA/IHN0YXRlKCkgOiB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhdm9pZCBjcmVhdGluZyBhIHN0YXRlIGluIHBpbmlhLnN0YXRlLnZhbHVlXG4gICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaG90XG4gICAgICAgICAgICA/IC8vIHVzZSByZWYoKSB0byB1bndyYXAgcmVmcyBpbnNpZGUgc3RhdGUgVE9ETzogY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICB0b1JlZnMocmVmKHN0YXRlID8gc3RhdGUoKSA6IHt9KS52YWx1ZSlcbiAgICAgICAgICAgIDogdG9SZWZzKHBpbmlhLnN0YXRlLnZhbHVlW2lkXSk7XG4gICAgICAgIHJldHVybiBhc3NpZ24obG9jYWxTdGF0ZSwgYWN0aW9ucywgT2JqZWN0LmtleXMoZ2V0dGVycyB8fCB7fSkucmVkdWNlKChjb21wdXRlZEdldHRlcnMsIG5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgbmFtZSBpbiBsb2NhbFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBb8J+NjV06IEEgZ2V0dGVyIGNhbm5vdCBoYXZlIHRoZSBzYW1lIG5hbWUgYXMgYW5vdGhlciBzdGF0ZSBwcm9wZXJ0eS4gUmVuYW1lIG9uZSBvZiB0aGVtLiBGb3VuZCB3aXRoIFwiJHtuYW1lfVwiIGluIHN0b3JlIFwiJHtpZH1cIi5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXB1dGVkR2V0dGVyc1tuYW1lXSA9IG1hcmtSYXcoY29tcHV0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldEFjdGl2ZVBpbmlhKHBpbmlhKTtcbiAgICAgICAgICAgICAgICAvLyBpdCB3YXMgY3JlYXRlZCBqdXN0IGJlZm9yZVxuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gcGluaWEuX3MuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICAvLyBhbGxvdyBjcm9zcyB1c2luZyBzdG9yZXNcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoaXNWdWUyICYmICFzdG9yZS5fcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gZ2V0dGVycyFbbmFtZV0uY2FsbChjb250ZXh0LCBjb250ZXh0KVxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGF2b2lkIHJlYWRpbmcgdGhlIGdldHRlciB3aGlsZSBhc3NpZ25pbmcgd2l0aCBhIGdsb2JhbCB2YXJpYWJsZVxuICAgICAgICAgICAgICAgIHJldHVybiBnZXR0ZXJzW25hbWVdLmNhbGwoc3RvcmUsIHN0b3JlKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBjb21wdXRlZEdldHRlcnM7XG4gICAgICAgIH0sIHt9KSk7XG4gICAgfVxuICAgIHN0b3JlID0gY3JlYXRlU2V0dXBTdG9yZShpZCwgc2V0dXAsIG9wdGlvbnMsIHBpbmlhLCBob3QsIHRydWUpO1xuICAgIHJldHVybiBzdG9yZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNldHVwU3RvcmUoJGlkLCBzZXR1cCwgb3B0aW9ucyA9IHt9LCBwaW5pYSwgaG90LCBpc09wdGlvbnNTdG9yZSkge1xuICAgIGxldCBzY29wZTtcbiAgICBjb25zdCBvcHRpb25zRm9yUGx1Z2luID0gYXNzaWduKHsgYWN0aW9uczoge30gfSwgb3B0aW9ucyk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhcGluaWEuX2UuYWN0aXZlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGluaWEgZGVzdHJveWVkJyk7XG4gICAgfVxuICAgIC8vIHdhdGNoZXIgb3B0aW9ucyBmb3IgJHN1YnNjcmliZVxuICAgIGNvbnN0ICRzdWJzY3JpYmVPcHRpb25zID0geyBkZWVwOiB0cnVlIH07XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc1Z1ZTIpIHtcbiAgICAgICAgJHN1YnNjcmliZU9wdGlvbnMub25UcmlnZ2VyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKGlzTGlzdGVuaW5nKSB7XG4gICAgICAgICAgICAgICAgZGVidWdnZXJFdmVudHMgPSBldmVudDtcbiAgICAgICAgICAgICAgICAvLyBhdm9pZCB0cmlnZ2VyaW5nIHRoaXMgd2hpbGUgdGhlIHN0b3JlIGlzIGJlaW5nIGJ1aWx0IGFuZCB0aGUgc3RhdGUgaXMgYmVpbmcgc2V0IGluIHBpbmlhXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0xpc3RlbmluZyA9PSBmYWxzZSAmJiAhc3RvcmUuX2hvdFVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gbGV0IHBhdGNoIHNlbmQgYWxsIHRoZSBldmVudHMgdG9nZXRoZXIgbGF0ZXJcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlYnVnZ2VyRXZlbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Z2dlckV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ/CfjY0gZGVidWdnZXJFdmVudHMgc2hvdWxkIGJlIGFuIGFycmF5LiBUaGlzIGlzIG1vc3QgbGlrZWx5IGFuIGludGVybmFsIFBpbmlhIGJ1Zy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGludGVybmFsIHN0YXRlXG4gICAgbGV0IGlzTGlzdGVuaW5nOyAvLyBzZXQgdG8gdHJ1ZSBhdCB0aGUgZW5kXG4gICAgbGV0IGlzU3luY0xpc3RlbmluZzsgLy8gc2V0IHRvIHRydWUgYXQgdGhlIGVuZFxuICAgIGxldCBzdWJzY3JpcHRpb25zID0gW107XG4gICAgbGV0IGFjdGlvblN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICBsZXQgZGVidWdnZXJFdmVudHM7XG4gICAgY29uc3QgaW5pdGlhbFN0YXRlID0gcGluaWEuc3RhdGUudmFsdWVbJGlkXTtcbiAgICAvLyBhdm9pZCBzZXR0aW5nIHRoZSBzdGF0ZSBmb3Igb3B0aW9uIHN0b3JlcyBpZiBpdCBpcyBzZXRcbiAgICAvLyBieSB0aGUgc2V0dXBcbiAgICBpZiAoIWlzT3B0aW9uc1N0b3JlICYmICFpbml0aWFsU3RhdGUgJiYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgIWhvdCkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc1Z1ZTIpIHtcbiAgICAgICAgICAgIHNldChwaW5pYS5zdGF0ZS52YWx1ZSwgJGlkLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwaW5pYS5zdGF0ZS52YWx1ZVskaWRdID0ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaG90U3RhdGUgPSByZWYoe30pO1xuICAgIC8vIGF2b2lkIHRyaWdnZXJpbmcgdG9vIG1hbnkgbGlzdGVuZXJzXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3BpbmlhL2lzc3Vlcy8xMTI5XG4gICAgbGV0IGFjdGl2ZUxpc3RlbmVyO1xuICAgIGZ1bmN0aW9uICRwYXRjaChwYXJ0aWFsU3RhdGVPck11dGF0b3IpIHtcbiAgICAgICAgbGV0IHN1YnNjcmlwdGlvbk11dGF0aW9uO1xuICAgICAgICBpc0xpc3RlbmluZyA9IGlzU3luY0xpc3RlbmluZyA9IGZhbHNlO1xuICAgICAgICAvLyByZXNldCB0aGUgZGVidWdnZXIgZXZlbnRzIHNpbmNlIHBhdGNoZXMgYXJlIHN5bmNcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgZGVidWdnZXJFdmVudHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhcnRpYWxTdGF0ZU9yTXV0YXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcGFydGlhbFN0YXRlT3JNdXRhdG9yKHBpbmlhLnN0YXRlLnZhbHVlWyRpZF0pO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uTXV0YXRpb24gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogTXV0YXRpb25UeXBlLnBhdGNoRnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgc3RvcmVJZDogJGlkLFxuICAgICAgICAgICAgICAgIGV2ZW50czogZGVidWdnZXJFdmVudHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVyZ2VSZWFjdGl2ZU9iamVjdHMocGluaWEuc3RhdGUudmFsdWVbJGlkXSwgcGFydGlhbFN0YXRlT3JNdXRhdG9yKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbk11dGF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IE11dGF0aW9uVHlwZS5wYXRjaE9iamVjdCxcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiBwYXJ0aWFsU3RhdGVPck11dGF0b3IsXG4gICAgICAgICAgICAgICAgc3RvcmVJZDogJGlkLFxuICAgICAgICAgICAgICAgIGV2ZW50czogZGVidWdnZXJFdmVudHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG15TGlzdGVuZXJJZCA9IChhY3RpdmVMaXN0ZW5lciA9IFN5bWJvbCgpKTtcbiAgICAgICAgbmV4dFRpY2soKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChhY3RpdmVMaXN0ZW5lciA9PT0gbXlMaXN0ZW5lcklkKSB7XG4gICAgICAgICAgICAgICAgaXNMaXN0ZW5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaXNTeW5jTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBwYXVzZWQgdGhlIHdhdGNoZXIsIHdlIG5lZWQgdG8gbWFudWFsbHkgY2FsbCB0aGUgc3Vic2NyaXB0aW9uc1xuICAgICAgICB0cmlnZ2VyU3Vic2NyaXB0aW9ucyhzdWJzY3JpcHRpb25zLCBzdWJzY3JpcHRpb25NdXRhdGlvbiwgcGluaWEuc3RhdGUudmFsdWVbJGlkXSk7XG4gICAgfVxuICAgIGNvbnN0ICRyZXNldCA9IGlzT3B0aW9uc1N0b3JlXG4gICAgICAgID8gZnVuY3Rpb24gJHJlc2V0KCkge1xuICAgICAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YXRlID0gc3RhdGUgPyBzdGF0ZSgpIDoge307XG4gICAgICAgICAgICAvLyB3ZSB1c2UgYSBwYXRjaCB0byBncm91cCBhbGwgY2hhbmdlcyBpbnRvIG9uZSBzaW5nbGUgc3Vic2NyaXB0aW9uXG4gICAgICAgICAgICB0aGlzLiRwYXRjaCgoJHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogRklYTUU6IHNob3VsZG4ndCBlcnJvcj9cbiAgICAgICAgICAgICAgICBhc3NpZ24oJHN0YXRlLCBuZXdTdGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICAgICAgICAgICAgICA/ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGDwn42NOiBTdG9yZSBcIiR7JGlkfVwiIGlzIGJ1aWx0IHVzaW5nIHRoZSBzZXR1cCBzeW50YXggYW5kIGRvZXMgbm90IGltcGxlbWVudCAkcmVzZXQoKS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiBub29wO1xuICAgIGZ1bmN0aW9uICRkaXNwb3NlKCkge1xuICAgICAgICBzY29wZS5zdG9wKCk7XG4gICAgICAgIHN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICAgICAgYWN0aW9uU3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICBwaW5pYS5fcy5kZWxldGUoJGlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIHRoYXQgd3JhcHMgZnVuY3Rpb24gc28gaXQgY2FuIGJlIHRyYWNrZWQgd2l0aCAkb25BY3Rpb25cbiAgICAgKiBAcGFyYW0gZm4gLSBhY3Rpb24gdG8gd3JhcFxuICAgICAqIEBwYXJhbSBuYW1lIC0gbmFtZSBvZiB0aGUgYWN0aW9uXG4gICAgICovXG4gICAgY29uc3QgYWN0aW9uID0gKGZuLCBuYW1lID0gJycpID0+IHtcbiAgICAgICAgaWYgKEFDVElPTl9NQVJLRVIgaW4gZm4pIHtcbiAgICAgICAgICAgIGZuW0FDVElPTl9OQU1FXSA9IG5hbWU7XG4gICAgICAgICAgICByZXR1cm4gZm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd3JhcHBlZEFjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNldEFjdGl2ZVBpbmlhKHBpbmlhKTtcbiAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5mcm9tKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBjb25zdCBhZnRlckNhbGxiYWNrTGlzdCA9IFtdO1xuICAgICAgICAgICAgY29uc3Qgb25FcnJvckNhbGxiYWNrTGlzdCA9IFtdO1xuICAgICAgICAgICAgZnVuY3Rpb24gYWZ0ZXIoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBhZnRlckNhbGxiYWNrTGlzdC5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uRXJyb3IoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yQ2FsbGJhY2tMaXN0LnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgdHJpZ2dlclN1YnNjcmlwdGlvbnMoYWN0aW9uU3Vic2NyaXB0aW9ucywge1xuICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgICAgbmFtZTogd3JhcHBlZEFjdGlvbltBQ1RJT05fTkFNRV0sXG4gICAgICAgICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgICAgICAgYWZ0ZXIsXG4gICAgICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IHJldDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gZm4uYXBwbHkodGhpcyAmJiB0aGlzLiRpZCA9PT0gJGlkID8gdGhpcyA6IHN0b3JlLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgc3luYyBlcnJvcnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRyaWdnZXJTdWJzY3JpcHRpb25zKG9uRXJyb3JDYWxsYmFja0xpc3QsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldFxuICAgICAgICAgICAgICAgICAgICAudGhlbigodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlclN1YnNjcmlwdGlvbnMoYWZ0ZXJDYWxsYmFja0xpc3QsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlclN1YnNjcmlwdGlvbnMob25FcnJvckNhbGxiYWNrTGlzdCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdHJpZ2dlciBhZnRlciBjYWxsYmFja3NcbiAgICAgICAgICAgIHRyaWdnZXJTdWJzY3JpcHRpb25zKGFmdGVyQ2FsbGJhY2tMaXN0LCByZXQpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbiAgICAgICAgd3JhcHBlZEFjdGlvbltBQ1RJT05fTUFSS0VSXSA9IHRydWU7XG4gICAgICAgIHdyYXBwZWRBY3Rpb25bQUNUSU9OX05BTUVdID0gbmFtZTsgLy8gd2lsbCBiZSBzZXQgbGF0ZXJcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogd2UgYXJlIGludGVudGlvbmFsbHkgbGltaXRpbmcgdGhlIHJldHVybmVkIHR5cGUgdG8ganVzdCBGblxuICAgICAgICAvLyBiZWNhdXNlIGFsbCB0aGUgYWRkZWQgcHJvcGVydGllcyBhcmUgaW50ZXJuYWxzIHRoYXQgYXJlIGV4cG9zZWQgdGhyb3VnaCBgJG9uQWN0aW9uKClgIG9ubHlcbiAgICAgICAgcmV0dXJuIHdyYXBwZWRBY3Rpb247XG4gICAgfTtcbiAgICBjb25zdCBfaG1yUGF5bG9hZCA9IC8qI19fUFVSRV9fKi8gbWFya1Jhdyh7XG4gICAgICAgIGFjdGlvbnM6IHt9LFxuICAgICAgICBnZXR0ZXJzOiB7fSxcbiAgICAgICAgc3RhdGU6IFtdLFxuICAgICAgICBob3RTdGF0ZSxcbiAgICB9KTtcbiAgICBjb25zdCBwYXJ0aWFsU3RvcmUgPSB7XG4gICAgICAgIF9wOiBwaW5pYSxcbiAgICAgICAgLy8gX3M6IHNjb3BlLFxuICAgICAgICAkaWQsXG4gICAgICAgICRvbkFjdGlvbjogYWRkU3Vic2NyaXB0aW9uLmJpbmQobnVsbCwgYWN0aW9uU3Vic2NyaXB0aW9ucyksXG4gICAgICAgICRwYXRjaCxcbiAgICAgICAgJHJlc2V0LFxuICAgICAgICAkc3Vic2NyaWJlKGNhbGxiYWNrLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZVN1YnNjcmlwdGlvbiA9IGFkZFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb25zLCBjYWxsYmFjaywgb3B0aW9ucy5kZXRhY2hlZCwgKCkgPT4gc3RvcFdhdGNoZXIoKSk7XG4gICAgICAgICAgICBjb25zdCBzdG9wV2F0Y2hlciA9IHNjb3BlLnJ1bigoKSA9PiB3YXRjaCgoKSA9PiBwaW5pYS5zdGF0ZS52YWx1ZVskaWRdLCAoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5mbHVzaCA9PT0gJ3N5bmMnID8gaXNTeW5jTGlzdGVuaW5nIDogaXNMaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVJZDogJGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogTXV0YXRpb25UeXBlLmRpcmVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50czogZGVidWdnZXJFdmVudHMsXG4gICAgICAgICAgICAgICAgICAgIH0sIHN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBhc3NpZ24oe30sICRzdWJzY3JpYmVPcHRpb25zLCBvcHRpb25zKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZVN1YnNjcmlwdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgJGRpc3Bvc2UsXG4gICAgfTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNWdWUyKSB7XG4gICAgICAgIC8vIHN0YXJ0IGFzIG5vbiByZWFkeVxuICAgICAgICBwYXJ0aWFsU3RvcmUuX3IgPSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc3RvcmUgPSByZWFjdGl2ZSgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgKCgoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICh0eXBlb2YgX19WVUVfUFJPRF9ERVZUT09MU19fICE9PSAndW5kZWZpbmVkJyAmJiBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pKSAmJiAhKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpKSAmJiBJU19DTElFTlQpXG4gICAgICAgID8gYXNzaWduKHtcbiAgICAgICAgICAgIF9obXJQYXlsb2FkLFxuICAgICAgICAgICAgX2N1c3RvbVByb3BlcnRpZXM6IG1hcmtSYXcobmV3IFNldCgpKSwgLy8gZGV2dG9vbHMgY3VzdG9tIHByb3BlcnRpZXNcbiAgICAgICAgfSwgcGFydGlhbFN0b3JlXG4gICAgICAgIC8vIG11c3QgYmUgYWRkZWQgbGF0ZXJcbiAgICAgICAgLy8gc2V0dXBTdG9yZVxuICAgICAgICApXG4gICAgICAgIDogcGFydGlhbFN0b3JlKTtcbiAgICAvLyBzdG9yZSB0aGUgcGFydGlhbCBzdG9yZSBub3cgc28gdGhlIHNldHVwIG9mIHN0b3JlcyBjYW4gaW5zdGFudGlhdGUgZWFjaCBvdGhlciBiZWZvcmUgdGhleSBhcmUgZmluaXNoZWQgd2l0aG91dFxuICAgIC8vIGNyZWF0aW5nIGluZmluaXRlIGxvb3BzLlxuICAgIHBpbmlhLl9zLnNldCgkaWQsIHN0b3JlKTtcbiAgICBjb25zdCBydW5XaXRoQ29udGV4dCA9IChwaW5pYS5fYSAmJiBwaW5pYS5fYS5ydW5XaXRoQ29udGV4dCkgfHwgZmFsbGJhY2tSdW5XaXRoQ29udGV4dDtcbiAgICAvLyBUT0RPOiBpZGVhIGNyZWF0ZSBza2lwU2VyaWFsaXplIHRoYXQgbWFya3MgcHJvcGVydGllcyBhcyBub24gc2VyaWFsaXphYmxlIGFuZCB0aGV5IGFyZSBza2lwcGVkXG4gICAgY29uc3Qgc2V0dXBTdG9yZSA9IHJ1bldpdGhDb250ZXh0KCgpID0+IHBpbmlhLl9lLnJ1bigoKSA9PiAoc2NvcGUgPSBlZmZlY3RTY29wZSgpKS5ydW4oKCkgPT4gc2V0dXAoeyBhY3Rpb24gfSkpKSk7XG4gICAgLy8gb3ZlcndyaXRlIGV4aXN0aW5nIGFjdGlvbnMgdG8gc3VwcG9ydCAkb25BY3Rpb25cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzZXR1cFN0b3JlKSB7XG4gICAgICAgIGNvbnN0IHByb3AgPSBzZXR1cFN0b3JlW2tleV07XG4gICAgICAgIGlmICgoaXNSZWYocHJvcCkgJiYgIWlzQ29tcHV0ZWQocHJvcCkpIHx8IGlzUmVhY3RpdmUocHJvcCkpIHtcbiAgICAgICAgICAgIC8vIG1hcmsgaXQgYXMgYSBwaWVjZSBvZiBzdGF0ZSB0byBiZSBzZXJpYWxpemVkXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGhvdCkge1xuICAgICAgICAgICAgICAgIHNldChob3RTdGF0ZS52YWx1ZSwga2V5LCB0b1JlZihzZXR1cFN0b3JlLCBrZXkpKTtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGVPcHRpb25TdG9yZSBkaXJlY3RseSBzZXRzIHRoZSBzdGF0ZSBpbiBwaW5pYS5zdGF0ZS52YWx1ZSBzbyB3ZVxuICAgICAgICAgICAgICAgIC8vIGNhbiBqdXN0IHNraXAgdGhhdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzT3B0aW9uc1N0b3JlKSB7XG4gICAgICAgICAgICAgICAgLy8gaW4gc2V0dXAgc3RvcmVzIHdlIG11c3QgaHlkcmF0ZSB0aGUgc3RhdGUgYW5kIHN5bmMgcGluaWEgc3RhdGUgdHJlZSB3aXRoIHRoZSByZWZzIHRoZSB1c2VyIGp1c3QgY3JlYXRlZFxuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsU3RhdGUgJiYgc2hvdWxkSHlkcmF0ZShwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZWYocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3AudmFsdWUgPSBpbml0aWFsU3RhdGVba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb2JhYmx5IGEgcmVhY3RpdmUgb2JqZWN0LCBsZXRzIHJlY3Vyc2l2ZWx5IGFzc2lnblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogcHJvcCBpcyB1bmtub3duXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXJnZVJlYWN0aXZlT2JqZWN0cyhwcm9wLCBpbml0aWFsU3RhdGVba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdHJhbnNmZXIgdGhlIHJlZiB0byB0aGUgcGluaWEgc3RhdGUgdG8ga2VlcCBldmVyeXRoaW5nIGluIHN5bmNcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoaXNWdWUyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldChwaW5pYS5zdGF0ZS52YWx1ZVskaWRdLCBrZXksIHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGluaWEuc3RhdGUudmFsdWVbJGlkXVtrZXldID0gcHJvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgIF9obXJQYXlsb2FkLnN0YXRlLnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFjdGlvblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwcm9wID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCBhY3Rpb25WYWx1ZSA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBob3QgPyBwcm9wIDogYWN0aW9uKHByb3AsIGtleSk7XG4gICAgICAgICAgICAvLyB0aGlzIGEgaG90IG1vZHVsZSByZXBsYWNlbWVudCBzdG9yZSBiZWNhdXNlIHRoZSBob3RVcGRhdGUgbWV0aG9kIG5lZWRzXG4gICAgICAgICAgICAvLyB0byBkbyBpdCB3aXRoIHRoZSByaWdodCBjb250ZXh0XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmIChpc1Z1ZTIpIHtcbiAgICAgICAgICAgICAgICBzZXQoc2V0dXBTdG9yZSwga2V5LCBhY3Rpb25WYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgc2V0dXBTdG9yZVtrZXldID0gYWN0aW9uVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgIF9obXJQYXlsb2FkLmFjdGlvbnNba2V5XSA9IHByb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsaXN0IGFjdGlvbnMgc28gdGhleSBjYW4gYmUgdXNlZCBpbiBwbHVnaW5zXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBvcHRpb25zRm9yUGx1Z2luLmFjdGlvbnNba2V5XSA9IHByb3A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAvLyBhZGQgZ2V0dGVycyBmb3IgZGV2dG9vbHNcbiAgICAgICAgICAgIGlmIChpc0NvbXB1dGVkKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgX2htclBheWxvYWQuZ2V0dGVyc1trZXldID0gaXNPcHRpb25zU3RvcmVcbiAgICAgICAgICAgICAgICAgICAgPyAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmdldHRlcnNba2V5XVxuICAgICAgICAgICAgICAgICAgICA6IHByb3A7XG4gICAgICAgICAgICAgICAgaWYgKElTX0NMSUVOVCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnZXR0ZXJzID0gc2V0dXBTdG9yZS5fZ2V0dGVycyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogc2FtZVxuICAgICAgICAgICAgICAgICAgICAgICAgKHNldHVwU3RvcmUuX2dldHRlcnMgPSBtYXJrUmF3KFtdKSk7XG4gICAgICAgICAgICAgICAgICAgIGdldHRlcnMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgdGhlIHN0YXRlLCBnZXR0ZXJzLCBhbmQgYWN0aW9uIHByb3BlcnRpZXNcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNWdWUyKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHNldHVwU3RvcmUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgc2V0KHN0b3JlLCBrZXksIHNldHVwU3RvcmVba2V5XSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXNzaWduKHN0b3JlLCBzZXR1cFN0b3JlKTtcbiAgICAgICAgLy8gYWxsb3dzIHJldHJpZXZpbmcgcmVhY3RpdmUgb2JqZWN0cyB3aXRoIGBzdG9yZVRvUmVmcygpYC4gTXVzdCBiZSBjYWxsZWQgYWZ0ZXIgYXNzaWduaW5nIHRvIHRoZSByZWFjdGl2ZSBvYmplY3QuXG4gICAgICAgIC8vIE1ha2UgYHN0b3JlVG9SZWZzKClgIHdvcmsgd2l0aCBgcmVhY3RpdmUoKWAgIzc5OVxuICAgICAgICBhc3NpZ24odG9SYXcoc3RvcmUpLCBzZXR1cFN0b3JlKTtcbiAgICB9XG4gICAgLy8gdXNlIHRoaXMgaW5zdGVhZCBvZiBhIGNvbXB1dGVkIHdpdGggc2V0dGVyIHRvIGJlIGFibGUgdG8gY3JlYXRlIGl0IGFueXdoZXJlXG4gICAgLy8gd2l0aG91dCBsaW5raW5nIHRoZSBjb21wdXRlZCBsaWZlc3BhbiB0byB3aGVyZXZlciB0aGUgc3RvcmUgaXMgZmlyc3RcbiAgICAvLyBjcmVhdGVkLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdG9yZSwgJyRzdGF0ZScsIHtcbiAgICAgICAgZ2V0OiAoKSA9PiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGhvdCA/IGhvdFN0YXRlLnZhbHVlIDogcGluaWEuc3RhdGUudmFsdWVbJGlkXSksXG4gICAgICAgIHNldDogKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaG90KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3Qgc2V0IGhvdFN0YXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkcGF0Y2goKCRzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IEZJWE1FOiBzaG91bGRuJ3QgZXJyb3I/XG4gICAgICAgICAgICAgICAgYXNzaWduKCRzdGF0ZSwgc3RhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgLy8gYWRkIHRoZSBob3RVcGRhdGUgYmVmb3JlIHBsdWdpbnMgdG8gYWxsb3cgdGhlbSB0byBvdmVycmlkZSBpdFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICBzdG9yZS5faG90VXBkYXRlID0gbWFya1JhdygobmV3U3RvcmUpID0+IHtcbiAgICAgICAgICAgIHN0b3JlLl9ob3RVcGRhdGluZyA9IHRydWU7XG4gICAgICAgICAgICBuZXdTdG9yZS5faG1yUGF5bG9hZC5zdGF0ZS5mb3JFYWNoKChzdGF0ZUtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZUtleSBpbiBzdG9yZS4kc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3U3RhdGVUYXJnZXQgPSBuZXdTdG9yZS4kc3RhdGVbc3RhdGVLZXldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRTdGF0ZVNvdXJjZSA9IHN0b3JlLiRzdGF0ZVtzdGF0ZUtleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3U3RhdGVUYXJnZXQgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1BsYWluT2JqZWN0KG5ld1N0YXRlVGFyZ2V0KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQbGFpbk9iamVjdChvbGRTdGF0ZVNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoT2JqZWN0KG5ld1N0YXRlVGFyZ2V0LCBvbGRTdGF0ZVNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmFuc2ZlciB0aGUgcmVmXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTdG9yZS4kc3RhdGVbc3RhdGVLZXldID0gb2xkU3RhdGVTb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcGF0Y2ggZGlyZWN0IGFjY2VzcyBwcm9wZXJ0aWVzIHRvIGFsbG93IHN0b3JlLnN0YXRlUHJvcGVydHkgdG8gd29yayBhc1xuICAgICAgICAgICAgICAgIC8vIHN0b3JlLiRzdGF0ZS5zdGF0ZVByb3BlcnR5XG4gICAgICAgICAgICAgICAgc2V0KHN0b3JlLCBzdGF0ZUtleSwgdG9SZWYobmV3U3RvcmUuJHN0YXRlLCBzdGF0ZUtleSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyByZW1vdmUgZGVsZXRlZCBzdGF0ZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzdG9yZS4kc3RhdGUpLmZvckVhY2goKHN0YXRlS2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCEoc3RhdGVLZXkgaW4gbmV3U3RvcmUuJHN0YXRlKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWwoc3RvcmUsIHN0YXRlS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGF2b2lkIGRldnRvb2xzIGxvZ2dpbmcgdGhpcyBhcyBhIG11dGF0aW9uXG4gICAgICAgICAgICBpc0xpc3RlbmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaXNTeW5jTGlzdGVuaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBwaW5pYS5zdGF0ZS52YWx1ZVskaWRdID0gdG9SZWYobmV3U3RvcmUuX2htclBheWxvYWQsICdob3RTdGF0ZScpO1xuICAgICAgICAgICAgaXNTeW5jTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIG5leHRUaWNrKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaXNMaXN0ZW5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFjdGlvbk5hbWUgaW4gbmV3U3RvcmUuX2htclBheWxvYWQuYWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjdGlvbkZuID0gbmV3U3RvcmVbYWN0aW9uTmFtZV07XG4gICAgICAgICAgICAgICAgc2V0KHN0b3JlLCBhY3Rpb25OYW1lLCBhY3Rpb24oYWN0aW9uRm4sIGFjdGlvbk5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE86IGRvZXMgdGhpcyB3b3JrIGluIGJvdGggc2V0dXAgYW5kIG9wdGlvbiBzdG9yZT9cbiAgICAgICAgICAgIGZvciAoY29uc3QgZ2V0dGVyTmFtZSBpbiBuZXdTdG9yZS5faG1yUGF5bG9hZC5nZXR0ZXJzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2V0dGVyID0gbmV3U3RvcmUuX2htclBheWxvYWQuZ2V0dGVyc1tnZXR0ZXJOYW1lXTtcbiAgICAgICAgICAgICAgICBjb25zdCBnZXR0ZXJWYWx1ZSA9IGlzT3B0aW9uc1N0b3JlXG4gICAgICAgICAgICAgICAgICAgID8gLy8gc3BlY2lhbCBoYW5kbGluZyBvZiBvcHRpb25zIGFwaVxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEFjdGl2ZVBpbmlhKHBpbmlhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0dGVyLmNhbGwoc3RvcmUsIHN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIDogZ2V0dGVyO1xuICAgICAgICAgICAgICAgIHNldChzdG9yZSwgZ2V0dGVyTmFtZSwgZ2V0dGVyVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVtb3ZlIGRlbGV0ZWQgZ2V0dGVyc1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc3RvcmUuX2htclBheWxvYWQuZ2V0dGVycykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIG5ld1N0b3JlLl9obXJQYXlsb2FkLmdldHRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbChzdG9yZSwga2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBvbGQgYWN0aW9uc1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc3RvcmUuX2htclBheWxvYWQuYWN0aW9ucykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIG5ld1N0b3JlLl9obXJQYXlsb2FkLmFjdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbChzdG9yZSwga2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgdmFsdWVzIHVzZWQgaW4gZGV2dG9vbHMgYW5kIHRvIGFsbG93IGRlbGV0aW5nIG5ldyBwcm9wZXJ0aWVzIGxhdGVyIG9uXG4gICAgICAgICAgICBzdG9yZS5faG1yUGF5bG9hZCA9IG5ld1N0b3JlLl9obXJQYXlsb2FkO1xuICAgICAgICAgICAgc3RvcmUuX2dldHRlcnMgPSBuZXdTdG9yZS5fZ2V0dGVycztcbiAgICAgICAgICAgIHN0b3JlLl9ob3RVcGRhdGluZyA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCgoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICh0eXBlb2YgX19WVUVfUFJPRF9ERVZUT09MU19fICE9PSAndW5kZWZpbmVkJyAmJiBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pKSAmJiAhKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpKSAmJiBJU19DTElFTlQpIHtcbiAgICAgICAgY29uc3Qgbm9uRW51bWVyYWJsZSA9IHtcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgLy8gYXZvaWQgd2FybmluZyBvbiBkZXZ0b29scyB0cnlpbmcgdG8gZGlzcGxheSB0aGlzIHByb3BlcnR5XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgWydfcCcsICdfaG1yUGF5bG9hZCcsICdfZ2V0dGVycycsICdfY3VzdG9tUHJvcGVydGllcyddLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdG9yZSwgcCwgYXNzaWduKHsgdmFsdWU6IHN0b3JlW3BdIH0sIG5vbkVudW1lcmFibGUpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc1Z1ZTIpIHtcbiAgICAgICAgLy8gbWFyayB0aGUgc3RvcmUgYXMgcmVhZHkgYmVmb3JlIHBsdWdpbnNcbiAgICAgICAgc3RvcmUuX3IgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBhcHBseSBhbGwgcGx1Z2luc1xuICAgIHBpbmlhLl9wLmZvckVhY2goKGV4dGVuZGVyKSA9PiB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmICgoKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCAodHlwZW9mIF9fVlVFX1BST0RfREVWVE9PTFNfXyAhPT0gJ3VuZGVmaW5lZCcgJiYgX19WVUVfUFJPRF9ERVZUT09MU19fKSkgJiYgIShwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSkgJiYgSVNfQ0xJRU5UKSB7XG4gICAgICAgICAgICBjb25zdCBleHRlbnNpb25zID0gc2NvcGUucnVuKCgpID0+IGV4dGVuZGVyKHtcbiAgICAgICAgICAgICAgICBzdG9yZTogc3RvcmUsXG4gICAgICAgICAgICAgICAgYXBwOiBwaW5pYS5fYSxcbiAgICAgICAgICAgICAgICBwaW5pYSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zRm9yUGx1Z2luLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZXh0ZW5zaW9ucyB8fCB7fSkuZm9yRWFjaCgoa2V5KSA9PiBzdG9yZS5fY3VzdG9tUHJvcGVydGllcy5hZGQoa2V5KSk7XG4gICAgICAgICAgICBhc3NpZ24oc3RvcmUsIGV4dGVuc2lvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXNzaWduKHN0b3JlLCBzY29wZS5ydW4oKCkgPT4gZXh0ZW5kZXIoe1xuICAgICAgICAgICAgICAgIHN0b3JlOiBzdG9yZSxcbiAgICAgICAgICAgICAgICBhcHA6IHBpbmlhLl9hLFxuICAgICAgICAgICAgICAgIHBpbmlhLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNGb3JQbHVnaW4sXG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICBzdG9yZS4kc3RhdGUgJiZcbiAgICAgICAgdHlwZW9mIHN0b3JlLiRzdGF0ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgdHlwZW9mIHN0b3JlLiRzdGF0ZS5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAhc3RvcmUuJHN0YXRlLmNvbnN0cnVjdG9yLnRvU3RyaW5nKCkuaW5jbHVkZXMoJ1tuYXRpdmUgY29kZV0nKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYFvwn42NXTogVGhlIFwic3RhdGVcIiBtdXN0IGJlIGEgcGxhaW4gb2JqZWN0LiBJdCBjYW5ub3QgYmVcXG5gICtcbiAgICAgICAgICAgIGBcXHRzdGF0ZTogKCkgPT4gbmV3IE15Q2xhc3MoKVxcbmAgK1xuICAgICAgICAgICAgYEZvdW5kIGluIHN0b3JlIFwiJHtzdG9yZS4kaWR9XCIuYCk7XG4gICAgfVxuICAgIC8vIG9ubHkgYXBwbHkgaHlkcmF0ZSB0byBvcHRpb24gc3RvcmVzIHdpdGggYW4gaW5pdGlhbCBzdGF0ZSBpbiBwaW5pYVxuICAgIGlmIChpbml0aWFsU3RhdGUgJiZcbiAgICAgICAgaXNPcHRpb25zU3RvcmUgJiZcbiAgICAgICAgb3B0aW9ucy5oeWRyYXRlKSB7XG4gICAgICAgIG9wdGlvbnMuaHlkcmF0ZShzdG9yZS4kc3RhdGUsIGluaXRpYWxTdGF0ZSk7XG4gICAgfVxuICAgIGlzTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICBpc1N5bmNMaXN0ZW5pbmcgPSB0cnVlO1xuICAgIHJldHVybiBzdG9yZTtcbn1cbi8vIGFsbG93cyB1bnVzZWQgc3RvcmVzIHRvIGJlIHRyZWUgc2hha2VuXG4vKiEgI19fTk9fU0lERV9FRkZFQ1RTX18gKi9cbmZ1bmN0aW9uIGRlZmluZVN0b3JlKFxuLy8gVE9ETzogYWRkIHByb3BlciB0eXBlcyBmcm9tIGFib3ZlXG5pZE9yT3B0aW9ucywgc2V0dXAsIHNldHVwT3B0aW9ucykge1xuICAgIGxldCBpZDtcbiAgICBsZXQgb3B0aW9ucztcbiAgICBjb25zdCBpc1NldHVwU3RvcmUgPSB0eXBlb2Ygc2V0dXAgPT09ICdmdW5jdGlvbic7XG4gICAgaWYgKHR5cGVvZiBpZE9yT3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWQgPSBpZE9yT3B0aW9ucztcbiAgICAgICAgLy8gdGhlIG9wdGlvbiBzdG9yZSBzZXR1cCB3aWxsIGNvbnRhaW4gdGhlIGFjdHVhbCBvcHRpb25zIGluIHRoaXMgY2FzZVxuICAgICAgICBvcHRpb25zID0gaXNTZXR1cFN0b3JlID8gc2V0dXBPcHRpb25zIDogc2V0dXA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvcHRpb25zID0gaWRPck9wdGlvbnM7XG4gICAgICAgIGlkID0gaWRPck9wdGlvbnMuaWQ7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBb8J+NjV06IFwiZGVmaW5lU3RvcmUoKVwiIG11c3QgYmUgcGFzc2VkIGEgc3RvcmUgaWQgYXMgaXRzIGZpcnN0IGFyZ3VtZW50LmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZVN0b3JlKHBpbmlhLCBob3QpIHtcbiAgICAgICAgY29uc3QgaGFzQ29udGV4dCA9IGhhc0luamVjdGlvbkNvbnRleHQoKTtcbiAgICAgICAgcGluaWEgPVxuICAgICAgICAgICAgLy8gaW4gdGVzdCBtb2RlLCBpZ25vcmUgdGhlIGFyZ3VtZW50IHByb3ZpZGVkIGFzIHdlIGNhbiBhbHdheXMgcmV0cmlldmUgYVxuICAgICAgICAgICAgLy8gcGluaWEgaW5zdGFuY2Ugd2l0aCBnZXRBY3RpdmVQaW5pYSgpXG4gICAgICAgICAgICAoKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpICYmIGFjdGl2ZVBpbmlhICYmIGFjdGl2ZVBpbmlhLl90ZXN0aW5nID8gbnVsbCA6IHBpbmlhKSB8fFxuICAgICAgICAgICAgICAgIChoYXNDb250ZXh0ID8gaW5qZWN0KHBpbmlhU3ltYm9sLCBudWxsKSA6IG51bGwpO1xuICAgICAgICBpZiAocGluaWEpXG4gICAgICAgICAgICBzZXRBY3RpdmVQaW5pYShwaW5pYSk7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWFjdGl2ZVBpbmlhKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFvwn42NXTogXCJnZXRBY3RpdmVQaW5pYSgpXCIgd2FzIGNhbGxlZCBidXQgdGhlcmUgd2FzIG5vIGFjdGl2ZSBQaW5pYS4gQXJlIHlvdSB0cnlpbmcgdG8gdXNlIGEgc3RvcmUgYmVmb3JlIGNhbGxpbmcgXCJhcHAudXNlKHBpbmlhKVwiP1xcbmAgK1xuICAgICAgICAgICAgICAgIGBTZWUgaHR0cHM6Ly9waW5pYS52dWVqcy5vcmcvY29yZS1jb25jZXB0cy9vdXRzaWRlLWNvbXBvbmVudC11c2FnZS5odG1sIGZvciBoZWxwLlxcbmAgK1xuICAgICAgICAgICAgICAgIGBUaGlzIHdpbGwgZmFpbCBpbiBwcm9kdWN0aW9uLmApO1xuICAgICAgICB9XG4gICAgICAgIHBpbmlhID0gYWN0aXZlUGluaWE7XG4gICAgICAgIGlmICghcGluaWEuX3MuaGFzKGlkKSkge1xuICAgICAgICAgICAgLy8gY3JlYXRpbmcgdGhlIHN0b3JlIHJlZ2lzdGVycyBpdCBpbiBgcGluaWEuX3NgXG4gICAgICAgICAgICBpZiAoaXNTZXR1cFN0b3JlKSB7XG4gICAgICAgICAgICAgICAgY3JlYXRlU2V0dXBTdG9yZShpZCwgc2V0dXAsIG9wdGlvbnMsIHBpbmlhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNyZWF0ZU9wdGlvbnNTdG9yZShpZCwgb3B0aW9ucywgcGluaWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBub3QgdGhlIHJpZ2h0IGluZmVycmVkIHR5cGVcbiAgICAgICAgICAgICAgICB1c2VTdG9yZS5fcGluaWEgPSBwaW5pYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdG9yZSA9IHBpbmlhLl9zLmdldChpZCk7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaG90KSB7XG4gICAgICAgICAgICBjb25zdCBob3RJZCA9ICdfX2hvdDonICsgaWQ7XG4gICAgICAgICAgICBjb25zdCBuZXdTdG9yZSA9IGlzU2V0dXBTdG9yZVxuICAgICAgICAgICAgICAgID8gY3JlYXRlU2V0dXBTdG9yZShob3RJZCwgc2V0dXAsIG9wdGlvbnMsIHBpbmlhLCB0cnVlKVxuICAgICAgICAgICAgICAgIDogY3JlYXRlT3B0aW9uc1N0b3JlKGhvdElkLCBhc3NpZ24oe30sIG9wdGlvbnMpLCBwaW5pYSwgdHJ1ZSk7XG4gICAgICAgICAgICBob3QuX2hvdFVwZGF0ZShuZXdTdG9yZSk7XG4gICAgICAgICAgICAvLyBjbGVhbnVwIHRoZSBzdGF0ZSBwcm9wZXJ0aWVzIGFuZCB0aGUgc3RvcmUgZnJvbSB0aGUgY2FjaGVcbiAgICAgICAgICAgIGRlbGV0ZSBwaW5pYS5zdGF0ZS52YWx1ZVtob3RJZF07XG4gICAgICAgICAgICBwaW5pYS5fcy5kZWxldGUoaG90SWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgSVNfQ0xJRU5UKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50SW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIC8vIHNhdmUgc3RvcmVzIGluIGluc3RhbmNlcyB0byBhY2Nlc3MgdGhlbSBkZXZ0b29sc1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRJbnN0YW5jZSAmJlxuICAgICAgICAgICAgICAgIGN1cnJlbnRJbnN0YW5jZS5wcm94eSAmJlxuICAgICAgICAgICAgICAgIC8vIGF2b2lkIGFkZGluZyBzdG9yZXMgdGhhdCBhcmUganVzdCBidWlsdCBmb3IgaG90IG1vZHVsZSByZXBsYWNlbWVudFxuICAgICAgICAgICAgICAgICFob3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2bSA9IGN1cnJlbnRJbnN0YW5jZS5wcm94eTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZSA9ICdfcFN0b3JlcycgaW4gdm0gPyB2bS5fcFN0b3JlcyA6ICh2bS5fcFN0b3JlcyA9IHt9KTtcbiAgICAgICAgICAgICAgICBjYWNoZVtpZF0gPSBzdG9yZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTdG9yZUdlbmVyaWMgY2Fubm90IGJlIGNhc3RlZCB0b3dhcmRzIFN0b3JlXG4gICAgICAgIHJldHVybiBzdG9yZTtcbiAgICB9XG4gICAgdXNlU3RvcmUuJGlkID0gaWQ7XG4gICAgcmV0dXJuIHVzZVN0b3JlO1xufVxuXG5sZXQgbWFwU3RvcmVTdWZmaXggPSAnU3RvcmUnO1xuLyoqXG4gKiBDaGFuZ2VzIHRoZSBzdWZmaXggYWRkZWQgYnkgYG1hcFN0b3JlcygpYC4gQ2FuIGJlIHNldCB0byBhbiBlbXB0eSBzdHJpbmcuXG4gKiBEZWZhdWx0cyB0byBgXCJTdG9yZVwiYC4gTWFrZSBzdXJlIHRvIGV4dGVuZCB0aGUgTWFwU3RvcmVzQ3VzdG9taXphdGlvblxuICogaW50ZXJmYWNlIGlmIHlvdSBhcmUgdXNpbmcgVHlwZVNjcmlwdC5cbiAqXG4gKiBAcGFyYW0gc3VmZml4IC0gbmV3IHN1ZmZpeFxuICovXG5mdW5jdGlvbiBzZXRNYXBTdG9yZVN1ZmZpeChzdWZmaXggLy8gY291bGQgYmUgJ1N0b3JlJyBidXQgdGhhdCB3b3VsZCBiZSBhbm5veWluZyBmb3IgSlNcbikge1xuICAgIG1hcFN0b3JlU3VmZml4ID0gc3VmZml4O1xufVxuLyoqXG4gKiBBbGxvd3MgdXNpbmcgc3RvcmVzIHdpdGhvdXQgdGhlIGNvbXBvc2l0aW9uIEFQSSAoYHNldHVwKClgKSBieSBnZW5lcmF0aW5nIGFuXG4gKiBvYmplY3QgdG8gYmUgc3ByZWFkIGluIHRoZSBgY29tcHV0ZWRgIGZpZWxkIG9mIGEgY29tcG9uZW50LiBJdCBhY2NlcHRzIGEgbGlzdFxuICogb2Ygc3RvcmUgZGVmaW5pdGlvbnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBleHBvcnQgZGVmYXVsdCB7XG4gKiAgIGNvbXB1dGVkOiB7XG4gKiAgICAgLy8gb3RoZXIgY29tcHV0ZWQgcHJvcGVydGllc1xuICogICAgIC4uLm1hcFN0b3Jlcyh1c2VVc2VyU3RvcmUsIHVzZUNhcnRTdG9yZSlcbiAqICAgfSxcbiAqXG4gKiAgIGNyZWF0ZWQoKSB7XG4gKiAgICAgdGhpcy51c2VyU3RvcmUgLy8gc3RvcmUgd2l0aCBpZCBcInVzZXJcIlxuICogICAgIHRoaXMuY2FydFN0b3JlIC8vIHN0b3JlIHdpdGggaWQgXCJjYXJ0XCJcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHN0b3JlcyAtIGxpc3Qgb2Ygc3RvcmVzIHRvIG1hcCB0byBhbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gbWFwU3RvcmVzKC4uLnN0b3Jlcykge1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgQXJyYXkuaXNBcnJheShzdG9yZXNbMF0pKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgW/CfjY1dOiBEaXJlY3RseSBwYXNzIGFsbCBzdG9yZXMgdG8gXCJtYXBTdG9yZXMoKVwiIHdpdGhvdXQgcHV0dGluZyB0aGVtIGluIGFuIGFycmF5OlxcbmAgK1xuICAgICAgICAgICAgYFJlcGxhY2VcXG5gICtcbiAgICAgICAgICAgIGBcXHRtYXBTdG9yZXMoW3VzZUF1dGhTdG9yZSwgdXNlQ2FydFN0b3JlXSlcXG5gICtcbiAgICAgICAgICAgIGB3aXRoXFxuYCArXG4gICAgICAgICAgICBgXFx0bWFwU3RvcmVzKHVzZUF1dGhTdG9yZSwgdXNlQ2FydFN0b3JlKVxcbmAgK1xuICAgICAgICAgICAgYFRoaXMgd2lsbCBmYWlsIGluIHByb2R1Y3Rpb24gaWYgbm90IGZpeGVkLmApO1xuICAgICAgICBzdG9yZXMgPSBzdG9yZXNbMF07XG4gICAgfVxuICAgIHJldHVybiBzdG9yZXMucmVkdWNlKChyZWR1Y2VkLCB1c2VTdG9yZSkgPT4ge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiAkaWQgaXMgYWRkZWQgYnkgZGVmaW5lU3RvcmVcbiAgICAgICAgcmVkdWNlZFt1c2VTdG9yZS4kaWQgKyBtYXBTdG9yZVN1ZmZpeF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdXNlU3RvcmUodGhpcy4kcGluaWEpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVkdWNlZDtcbiAgICB9LCB7fSk7XG59XG4vKipcbiAqIEFsbG93cyB1c2luZyBzdGF0ZSBhbmQgZ2V0dGVycyBmcm9tIG9uZSBzdG9yZSB3aXRob3V0IHVzaW5nIHRoZSBjb21wb3NpdGlvblxuICogQVBJIChgc2V0dXAoKWApIGJ5IGdlbmVyYXRpbmcgYW4gb2JqZWN0IHRvIGJlIHNwcmVhZCBpbiB0aGUgYGNvbXB1dGVkYCBmaWVsZFxuICogb2YgYSBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHVzZVN0b3JlIC0gc3RvcmUgdG8gbWFwIGZyb21cbiAqIEBwYXJhbSBrZXlzT3JNYXBwZXIgLSBhcnJheSBvciBvYmplY3RcbiAqL1xuZnVuY3Rpb24gbWFwU3RhdGUodXNlU3RvcmUsIGtleXNPck1hcHBlcikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGtleXNPck1hcHBlcilcbiAgICAgICAgPyBrZXlzT3JNYXBwZXIucmVkdWNlKChyZWR1Y2VkLCBrZXkpID0+IHtcbiAgICAgICAgICAgIHJlZHVjZWRba2V5XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBGSVhNRTogc2hvdWxkIHdvcms/XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZVN0b3JlKHRoaXMuJHBpbmlhKVtrZXldO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiByZWR1Y2VkO1xuICAgICAgICB9LCB7fSlcbiAgICAgICAgOiBPYmplY3Qua2V5cyhrZXlzT3JNYXBwZXIpLnJlZHVjZSgocmVkdWNlZCwga2V5KSA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICByZWR1Y2VkW2tleV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZSh0aGlzLiRwaW5pYSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RvcmVLZXkgPSBrZXlzT3JNYXBwZXJba2V5XTtcbiAgICAgICAgICAgICAgICAvLyBmb3Igc29tZSByZWFzb24gVFMgaXMgdW5hYmxlIHRvIGluZmVyIHRoZSB0eXBlIG9mIHN0b3JlS2V5IHRvIGJlIGFcbiAgICAgICAgICAgICAgICAvLyBmdW5jdGlvblxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygc3RvcmVLZXkgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICAgPyBzdG9yZUtleS5jYWxsKHRoaXMsIHN0b3JlKVxuICAgICAgICAgICAgICAgICAgICA6IC8vIEB0cy1leHBlY3QtZXJyb3I6IEZJWE1FOiBzaG91bGQgd29yaz9cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlW3N0b3JlS2V5XTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcmVkdWNlZDtcbiAgICAgICAgfSwge30pO1xufVxuLyoqXG4gKiBBbGlhcyBmb3IgYG1hcFN0YXRlKClgLiBZb3Ugc2hvdWxkIHVzZSBgbWFwU3RhdGUoKWAgaW5zdGVhZC5cbiAqIEBkZXByZWNhdGVkIHVzZSBgbWFwU3RhdGUoKWAgaW5zdGVhZC5cbiAqL1xuY29uc3QgbWFwR2V0dGVycyA9IG1hcFN0YXRlO1xuLyoqXG4gKiBBbGxvd3MgZGlyZWN0bHkgdXNpbmcgYWN0aW9ucyBmcm9tIHlvdXIgc3RvcmUgd2l0aG91dCB1c2luZyB0aGUgY29tcG9zaXRpb25cbiAqIEFQSSAoYHNldHVwKClgKSBieSBnZW5lcmF0aW5nIGFuIG9iamVjdCB0byBiZSBzcHJlYWQgaW4gdGhlIGBtZXRob2RzYCBmaWVsZFxuICogb2YgYSBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHVzZVN0b3JlIC0gc3RvcmUgdG8gbWFwIGZyb21cbiAqIEBwYXJhbSBrZXlzT3JNYXBwZXIgLSBhcnJheSBvciBvYmplY3RcbiAqL1xuZnVuY3Rpb24gbWFwQWN0aW9ucyh1c2VTdG9yZSwga2V5c09yTWFwcGVyKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoa2V5c09yTWFwcGVyKVxuICAgICAgICA/IGtleXNPck1hcHBlci5yZWR1Y2UoKHJlZHVjZWQsIGtleSkgPT4ge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgcmVkdWNlZFtrZXldID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBGSVhNRTogc2hvdWxkIHdvcms/XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZVN0b3JlKHRoaXMuJHBpbmlhKVtrZXldKC4uLmFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiByZWR1Y2VkO1xuICAgICAgICB9LCB7fSlcbiAgICAgICAgOiBPYmplY3Qua2V5cyhrZXlzT3JNYXBwZXIpLnJlZHVjZSgocmVkdWNlZCwga2V5KSA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICByZWR1Y2VkW2tleV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IEZJWE1FOiBzaG91bGQgd29yaz9cbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlU3RvcmUodGhpcy4kcGluaWEpW2tleXNPck1hcHBlcltrZXldXSguLi5hcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcmVkdWNlZDtcbiAgICAgICAgfSwge30pO1xufVxuLyoqXG4gKiBBbGxvd3MgdXNpbmcgc3RhdGUgYW5kIGdldHRlcnMgZnJvbSBvbmUgc3RvcmUgd2l0aG91dCB1c2luZyB0aGUgY29tcG9zaXRpb25cbiAqIEFQSSAoYHNldHVwKClgKSBieSBnZW5lcmF0aW5nIGFuIG9iamVjdCB0byBiZSBzcHJlYWQgaW4gdGhlIGBjb21wdXRlZGAgZmllbGRcbiAqIG9mIGEgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB1c2VTdG9yZSAtIHN0b3JlIHRvIG1hcCBmcm9tXG4gKiBAcGFyYW0ga2V5c09yTWFwcGVyIC0gYXJyYXkgb3Igb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIG1hcFdyaXRhYmxlU3RhdGUodXNlU3RvcmUsIGtleXNPck1hcHBlcikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGtleXNPck1hcHBlcilcbiAgICAgICAgPyBrZXlzT3JNYXBwZXIucmVkdWNlKChyZWR1Y2VkLCBrZXkpID0+IHtcbiAgICAgICAgICAgIHJlZHVjZWRba2V5XSA9IHtcbiAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1c2VTdG9yZSh0aGlzLiRwaW5pYSlba2V5XTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHVzZVN0b3JlKHRoaXMuJHBpbmlhKVtrZXldID0gdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlZHVjZWQ7XG4gICAgICAgIH0sIHt9KVxuICAgICAgICA6IE9iamVjdC5rZXlzKGtleXNPck1hcHBlcikucmVkdWNlKChyZWR1Y2VkLCBrZXkpID0+IHtcbiAgICAgICAgICAgIHJlZHVjZWRba2V5XSA9IHtcbiAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1c2VTdG9yZSh0aGlzLiRwaW5pYSlba2V5c09yTWFwcGVyW2tleV1dO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodXNlU3RvcmUodGhpcy4kcGluaWEpW2tleXNPck1hcHBlcltrZXldXSA9IHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiByZWR1Y2VkO1xuICAgICAgICB9LCB7fSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3Qgb2YgcmVmZXJlbmNlcyB3aXRoIGFsbCB0aGUgc3RhdGUsIGdldHRlcnMsIGFuZCBwbHVnaW4tYWRkZWRcbiAqIHN0YXRlIHByb3BlcnRpZXMgb2YgdGhlIHN0b3JlLiBTaW1pbGFyIHRvIGB0b1JlZnMoKWAgYnV0IHNwZWNpZmljYWxseVxuICogZGVzaWduZWQgZm9yIFBpbmlhIHN0b3JlcyBzbyBtZXRob2RzIGFuZCBub24gcmVhY3RpdmUgcHJvcGVydGllcyBhcmVcbiAqIGNvbXBsZXRlbHkgaWdub3JlZC5cbiAqXG4gKiBAcGFyYW0gc3RvcmUgLSBzdG9yZSB0byBleHRyYWN0IHRoZSByZWZzIGZyb21cbiAqL1xuZnVuY3Rpb24gc3RvcmVUb1JlZnMoc3RvcmUpIHtcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3BpbmlhL2lzc3Vlcy84NTJcbiAgICAvLyBJdCdzIGVhc2llciB0byBqdXN0IHVzZSB0b1JlZnMoKSBldmVuIGlmIGl0IGluY2x1ZGVzIG1vcmUgc3R1ZmZcbiAgICBpZiAoaXNWdWUyKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHRvUmVmcyBpbmNsdWRlIG1ldGhvZHMgYW5kIG90aGVyc1xuICAgICAgICByZXR1cm4gdG9SZWZzKHN0b3JlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHJhd1N0b3JlID0gdG9SYXcoc3RvcmUpO1xuICAgICAgICBjb25zdCByZWZzID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJhd1N0b3JlKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJhd1N0b3JlW2tleV07XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuYXRpdmUgbWV0aG9kIHRvIGNoZWNrIGZvciBhIGNvbXB1dGVkXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvY29yZS9wdWxsLzQxNjVcbiAgICAgICAgICAgIGlmICh2YWx1ZS5lZmZlY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiB0b28gaGFyZCB0byB0eXBlIGNvcnJlY3RseVxuICAgICAgICAgICAgICAgIHJlZnNba2V5XSA9XG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLlxuICAgICAgICAgICAgICAgICAgICBjb21wdXRlZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHN0b3JlW2tleV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVmKHZhbHVlKSB8fCBpc1JlYWN0aXZlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHRoZSBrZXkgaXMgc3RhdGUgb3IgZ2V0dGVyXG4gICAgICAgICAgICAgICAgcmVmc1trZXldID1cbiAgICAgICAgICAgICAgICAgICAgLy8gLS0tXG4gICAgICAgICAgICAgICAgICAgIHRvUmVmKHN0b3JlLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWZzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBWdWUgMiBQbHVnaW4gdGhhdCBtdXN0IGJlIGluc3RhbGxlZCBmb3IgcGluaWEgdG8gd29yay4gTm90ZSAqKnlvdSBkb24ndCBuZWVkXG4gKiB0aGlzIHBsdWdpbiBpZiB5b3UgYXJlIHVzaW5nIE51eHQuanMqKi4gVXNlIHRoZSBgYnVpbGRNb2R1bGVgIGluc3RlYWQ6XG4gKiBodHRwczovL3BpbmlhLnZ1ZWpzLm9yZy9zc3IvbnV4dC5odG1sLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogaW1wb3J0IFZ1ZSBmcm9tICd2dWUnXG4gKiBpbXBvcnQgeyBQaW5pYVZ1ZVBsdWdpbiwgY3JlYXRlUGluaWEgfSBmcm9tICdwaW5pYSdcbiAqXG4gKiBWdWUudXNlKFBpbmlhVnVlUGx1Z2luKVxuICogY29uc3QgcGluaWEgPSBjcmVhdGVQaW5pYSgpXG4gKlxuICogbmV3IFZ1ZSh7XG4gKiAgIGVsOiAnI2FwcCcsXG4gKiAgIC8vIC4uLlxuICogICBwaW5pYSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gX1Z1ZSAtIGBWdWVgIGltcG9ydGVkIGZyb20gJ3Z1ZScuXG4gKi9cbmNvbnN0IFBpbmlhVnVlUGx1Z2luID0gZnVuY3Rpb24gKF9WdWUpIHtcbiAgICAvLyBFcXVpdmFsZW50IG9mXG4gICAgLy8gYXBwLmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzLiRwaW5pYSA9IHBpbmlhXG4gICAgX1Z1ZS5taXhpbih7XG4gICAgICAgIGJlZm9yZUNyZWF0ZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGluaWEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwaW5pYSA9IG9wdGlvbnMucGluaWE7XG4gICAgICAgICAgICAgICAgLy8gSEFDSzogdGFrZW4gZnJvbSBwcm92aWRlKCk6IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy9jb21wb3NpdGlvbi1hcGkvYmxvYi9tYWluL3NyYy9hcGlzL2luamVjdC50cyNMMzFcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcHJvdmlkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvdmlkZUNhY2hlID0ge307XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX3Byb3ZpZGVkJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBwcm92aWRlQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQ6ICh2KSA9PiBPYmplY3QuYXNzaWduKHByb3ZpZGVDYWNoZSwgdiksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9wcm92aWRlZFtwaW5pYVN5bWJvbF0gPSBwaW5pYTtcbiAgICAgICAgICAgICAgICAvLyBwcm9wYWdhdGUgdGhlIHBpbmlhIGluc3RhbmNlIGluIGFuIFNTUiBmcmllbmRseSB3YXlcbiAgICAgICAgICAgICAgICAvLyBhdm9pZCBhZGRpbmcgaXQgdG8gbnV4dCB0d2ljZVxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLiRwaW5pYSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRwaW5pYSA9IHBpbmlhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwaW5pYS5fYSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKElTX0NMSUVOVCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGFsbG93cyBjYWxsaW5nIHVzZVN0b3JlKCkgb3V0c2lkZSBvZiBhIGNvbXBvbmVudCBzZXR1cCBhZnRlclxuICAgICAgICAgICAgICAgICAgICAvLyBpbnN0YWxsaW5nIHBpbmlhJ3MgcGx1Z2luXG4gICAgICAgICAgICAgICAgICAgIHNldEFjdGl2ZVBpbmlhKHBpbmlhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCgoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICh0eXBlb2YgX19WVUVfUFJPRF9ERVZUT09MU19fICE9PSAndW5kZWZpbmVkJyAmJiBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pKSAmJiAhKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpKSAmJiBJU19DTElFTlQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJQaW5pYURldnRvb2xzKHBpbmlhLl9hLCBwaW5pYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuJHBpbmlhICYmIG9wdGlvbnMucGFyZW50ICYmIG9wdGlvbnMucGFyZW50LiRwaW5pYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHBpbmlhID0gb3B0aW9ucy5wYXJlbnQuJHBpbmlhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95ZWQoKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fcFN0b3JlcztcbiAgICAgICAgfSxcbiAgICB9KTtcbn07XG5cbmV4cG9ydCB7IE11dGF0aW9uVHlwZSwgUGluaWFWdWVQbHVnaW4sIGFjY2VwdEhNUlVwZGF0ZSwgY3JlYXRlUGluaWEsIGRlZmluZVN0b3JlLCBkaXNwb3NlUGluaWEsIGdldEFjdGl2ZVBpbmlhLCBtYXBBY3Rpb25zLCBtYXBHZXR0ZXJzLCBtYXBTdGF0ZSwgbWFwU3RvcmVzLCBtYXBXcml0YWJsZVN0YXRlLCBzZXRBY3RpdmVQaW5pYSwgc2V0TWFwU3RvcmVTdWZmaXgsIHNob3VsZEh5ZHJhdGUsIHNraXBIeWRyYXRlLCBzdG9yZVRvUmVmcyB9O1xuIiwiaW1wb3J0ICogYXMgVnVlIGZyb20gJ3Z1ZSdcblxudmFyIGlzVnVlMiA9IGZhbHNlXG52YXIgaXNWdWUzID0gdHJ1ZVxudmFyIFZ1ZTIgPSB1bmRlZmluZWRcblxuZnVuY3Rpb24gaW5zdGFsbCgpIHt9XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQodGFyZ2V0LCBrZXksIHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgdGFyZ2V0Lmxlbmd0aCA9IE1hdGgubWF4KHRhcmdldC5sZW5ndGgsIGtleSlcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKVxuICAgIHJldHVybiB2YWxcbiAgfVxuICB0YXJnZXRba2V5XSA9IHZhbFxuICByZXR1cm4gdmFsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWwodGFyZ2V0LCBrZXkpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKVxuICAgIHJldHVyblxuICB9XG4gIGRlbGV0ZSB0YXJnZXRba2V5XVxufVxuXG5leHBvcnQgKiBmcm9tICd2dWUnXG5leHBvcnQge1xuICBWdWUsXG4gIFZ1ZTIsXG4gIGlzVnVlMixcbiAgaXNWdWUzLFxuICBpbnN0YWxsLFxufVxuIiwiaW1wb3J0IHsgZ2V0RGV2dG9vbHNHbG9iYWxIb29rLCBnZXRUYXJnZXQsIGlzUHJveHlBdmFpbGFibGUgfSBmcm9tICcuL2Vudi5qcyc7XG5pbXBvcnQgeyBIT09LX1NFVFVQIH0gZnJvbSAnLi9jb25zdC5qcyc7XG5pbXBvcnQgeyBBcGlQcm94eSB9IGZyb20gJy4vcHJveHkuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9hcGkvaW5kZXguanMnO1xuZXhwb3J0ICogZnJvbSAnLi9wbHVnaW4uanMnO1xuZXhwb3J0ICogZnJvbSAnLi90aW1lLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBzZXR1cERldnRvb2xzUGx1Z2luKHBsdWdpbkRlc2NyaXB0b3IsIHNldHVwRm4pIHtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gcGx1Z2luRGVzY3JpcHRvcjtcbiAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQoKTtcbiAgICBjb25zdCBob29rID0gZ2V0RGV2dG9vbHNHbG9iYWxIb29rKCk7XG4gICAgY29uc3QgZW5hYmxlUHJveHkgPSBpc1Byb3h5QXZhaWxhYmxlICYmIGRlc2NyaXB0b3IuZW5hYmxlRWFybHlQcm94eTtcbiAgICBpZiAoaG9vayAmJiAodGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX1BMVUdJTl9BUElfQVZBSUxBQkxFX18gfHwgIWVuYWJsZVByb3h5KSkge1xuICAgICAgICBob29rLmVtaXQoSE9PS19TRVRVUCwgcGx1Z2luRGVzY3JpcHRvciwgc2V0dXBGbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBwcm94eSA9IGVuYWJsZVByb3h5ID8gbmV3IEFwaVByb3h5KGRlc2NyaXB0b3IsIGhvb2spIDogbnVsbDtcbiAgICAgICAgY29uc3QgbGlzdCA9IHRhcmdldC5fX1ZVRV9ERVZUT09MU19QTFVHSU5TX18gPSB0YXJnZXQuX19WVUVfREVWVE9PTFNfUExVR0lOU19fIHx8IFtdO1xuICAgICAgICBsaXN0LnB1c2goe1xuICAgICAgICAgICAgcGx1Z2luRGVzY3JpcHRvcjogZGVzY3JpcHRvcixcbiAgICAgICAgICAgIHNldHVwRm4sXG4gICAgICAgICAgICBwcm94eSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwcm94eSkge1xuICAgICAgICAgICAgc2V0dXBGbihwcm94eS5wcm94aWVkVGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBnZXREZXZ0b29sc0dsb2JhbEhvb2soKSB7XG4gICAgcmV0dXJuIGdldFRhcmdldCgpLl9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0VGFyZ2V0KCkge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgbmF2aWdhdG9yIGFuZCB3aW5kb3dzIGFyZSBub3QgYXZhaWxhYmxlIGluIGFsbCBlbnZpcm9ubWVudHNcbiAgICByZXR1cm4gKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICA/IHdpbmRvd1xuICAgICAgICA6IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBnbG9iYWxUaGlzXG4gICAgICAgICAgICA6IHt9O1xufVxuZXhwb3J0IGNvbnN0IGlzUHJveHlBdmFpbGFibGUgPSB0eXBlb2YgUHJveHkgPT09ICdmdW5jdGlvbic7XG4iLCJleHBvcnQgY29uc3QgSE9PS19TRVRVUCA9ICdkZXZ0b29scy1wbHVnaW46c2V0dXAnO1xuZXhwb3J0IGNvbnN0IEhPT0tfUExVR0lOX1NFVFRJTkdTX1NFVCA9ICdwbHVnaW46c2V0dGluZ3M6c2V0JztcbiIsImltcG9ydCB7IEhPT0tfUExVR0lOX1NFVFRJTkdTX1NFVCB9IGZyb20gJy4vY29uc3QuanMnO1xuaW1wb3J0IHsgbm93IH0gZnJvbSAnLi90aW1lLmpzJztcbmV4cG9ydCBjbGFzcyBBcGlQcm94eSB7XG4gICAgY29uc3RydWN0b3IocGx1Z2luLCBob29rKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy50YXJnZXRRdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLm9uUXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgICAgIHRoaXMuaG9vayA9IGhvb2s7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRTZXR0aW5ncyA9IHt9O1xuICAgICAgICBpZiAocGx1Z2luLnNldHRpbmdzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlkIGluIHBsdWdpbi5zZXR0aW5ncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBwbHVnaW4uc2V0dGluZ3NbaWRdO1xuICAgICAgICAgICAgICAgIGRlZmF1bHRTZXR0aW5nc1tpZF0gPSBpdGVtLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb2NhbFNldHRpbmdzU2F2ZUlkID0gYF9fdnVlLWRldnRvb2xzLXBsdWdpbi1zZXR0aW5nc19fJHtwbHVnaW4uaWR9YDtcbiAgICAgICAgbGV0IGN1cnJlbnRTZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRTZXR0aW5ncyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByYXcgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShsb2NhbFNldHRpbmdzU2F2ZUlkKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHJhdyk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGN1cnJlbnRTZXR0aW5ncywgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIGdldFNldHRpbmdzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50U2V0dGluZ3M7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0U2V0dGluZ3ModmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShsb2NhbFNldHRpbmdzU2F2ZUlkLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBub29wXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRTZXR0aW5ncyA9IHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5vdygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm93KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaG9vaykge1xuICAgICAgICAgICAgaG9vay5vbihIT09LX1BMVUdJTl9TRVRUSU5HU19TRVQsIChwbHVnaW5JZCwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luSWQgPT09IHRoaXMucGx1Z2luLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmFsbGJhY2tzLnNldFNldHRpbmdzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb3hpZWRPbiA9IG5ldyBQcm94eSh7fSwge1xuICAgICAgICAgICAgZ2V0OiAoX3RhcmdldCwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50YXJnZXQub25bcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25RdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHByb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByb3hpZWRUYXJnZXQgPSBuZXcgUHJveHkoe30sIHtcbiAgICAgICAgICAgIGdldDogKF90YXJnZXQsIHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9wID09PSAnb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3hpZWRPbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoT2JqZWN0LmtleXModGhpcy5mYWxsYmFja3MpLmluY2x1ZGVzKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXRRdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHByb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlOiAoKSA9PiB7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZhbGxiYWNrc1twcm9wXSguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXRRdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBwcm9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHNldFJlYWxUYXJnZXQodGFyZ2V0KSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5vblF1ZXVlKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldC5vbltpdGVtLm1ldGhvZF0oLi4uaXRlbS5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy50YXJnZXRRdWV1ZSkge1xuICAgICAgICAgICAgaXRlbS5yZXNvbHZlKGF3YWl0IHRoaXMudGFyZ2V0W2l0ZW0ubWV0aG9kXSguLi5pdGVtLmFyZ3MpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImxldCBzdXBwb3J0ZWQ7XG5sZXQgcGVyZjtcbmV4cG9ydCBmdW5jdGlvbiBpc1BlcmZvcm1hbmNlU3VwcG9ydGVkKCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoc3VwcG9ydGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHN1cHBvcnRlZDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wZXJmb3JtYW5jZSkge1xuICAgICAgICBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICBwZXJmID0gd2luZG93LnBlcmZvcm1hbmNlO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgKChfYSA9IGdsb2JhbFRoaXMucGVyZl9ob29rcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBlcmZvcm1hbmNlKSkge1xuICAgICAgICBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICBwZXJmID0gZ2xvYmFsVGhpcy5wZXJmX2hvb2tzLnBlcmZvcm1hbmNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3VwcG9ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzdXBwb3J0ZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gbm93KCkge1xuICAgIHJldHVybiBpc1BlcmZvcm1hbmNlU3VwcG9ydGVkKCkgPyBwZXJmLm5vdygpIDogRGF0ZS5ub3coKTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiAkZ2V0dGV4dCh0ZXh0KSB7XG4gIGxldCByZXMgPSAnJ1xuICB0cnkge1xuICAgIGNvbnN0IGtleSA9IHRleHQucmVwbGFjZSgvW15BLVphLXowLTlfXS9nLCAnXycpXG4gICAgcmVzID0gY2hyb21lLmkxOG4uZ2V0TWVzc2FnZShrZXkpIHx8IHRleHRcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJlcyA9IHRleHRcbiAgfVxuXG4gIHJldHVybiByZXNcbn1cblxuZXhwb3J0IGNvbnN0IGkxOG5QbHVnaW4gPSB7XG4gIGluc3RhbGwoYXBwKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbiAgICBhcHAuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMuJGdldHRleHQgPSAkZ2V0dGV4dFxuICB9LFxufVxuIiwiaW1wb3J0IHtyZWZ9IGZyb20gJ3Z1ZSdcbmltcG9ydCB7ZGVmaW5lU3RvcmV9IGZyb20gJ3BpbmlhJ1xuaW1wb3J0IHtTdG9yYWdlfSBmcm9tICdAcGxhc21vaHEvc3RvcmFnZSdcblxuaW1wb3J0IHtXRUJQSUxPVF9DT05GSUdfU1RPUkFHRV9LRVksIGRlZmF1bHRDb25maWcsIFdFQlBJTE9UX09QRU5BSX0gZnJvbSAnQC9jb25maWcnXG5cbmNvbnN0IHVzZVN0b3JlID0gZGVmaW5lU3RvcmUoJ3N0b3JlJywgKCkgPT4ge1xuICBjb25zdCBzdG9yYWdlID0gbmV3IFN0b3JhZ2UoKVxuICBjb25zdCBjb25maWcgPSByZWYoZGVmYXVsdENvbmZpZylcblxuICAvLyBzZWxlY3RlZCB0ZXh0XG4gIGNvbnN0IHNlbGVjdGVkVGV4dCA9IHJlZignJylcblxuICBjb25zdCBzZXRTZWxlY3RlZFRleHQgPSB0ZXh0ID0+IHtcbiAgICBzZWxlY3RlZFRleHQudmFsdWUgPSB0ZXh0XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBpbml0Q29uZmlnKCkge1xuICAgIGNvbnN0IHN0b3JlZENvbmZpZyA9IGF3YWl0IHN0b3JhZ2UuZ2V0KFdFQlBJTE9UX0NPTkZJR19TVE9SQUdFX0tFWSlcbiAgICBpZiAoc3RvcmVkQ29uZmlnICYmIHR5cGVvZiBzdG9yZWRDb25maWcgPT09ICdvYmplY3QnKSB7XG4gICAgICBjb25maWcudmFsdWUgPSBzdG9yZWRDb25maWdcblxuICAgICAgLy8gRm9yIG9sZCB1c2VycyB3aG8gaGF2ZSBzYXZlZCBzb21lIG9sZCBkYXRhLCBwZXJmb3JtIHNvbWUgZGF0YSBjb3JyZWN0aW9uXG4gICAgICBpZiAoY29uZmlnLnZhbHVlLmFwaU9yaWdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbmZpZy52YWx1ZS5hcGlPcmlnaW4gPSAncGVyc29uYWwnXG4gICAgICB9XG4gICAgICBpZiAoY29uZmlnLnZhbHVlLnNlbGZIb3N0VXJsID09PSBXRUJQSUxPVF9PUEVOQUkuSE9TVF9VUkwpIHtcbiAgICAgICAgY29uZmlnLnZhbHVlLnNlbGZIb3N0VXJsID0gJydcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgIWNvbmZpZy52YWx1ZS5sYXRlc3RBc2tlZFF1ZXN0aW9uUHJvbXB0SW5kZXggJiZcbiAgICAgICAgIWNvbmZpZy52YWx1ZS5sYXRlc3RUZXh0U2VsZWN0aW9uUHJvbXB0SW5kZXggJiZcbiAgICAgICAgIWNvbmZpZy52YWx1ZS5Bc2tlZFF1ZXN0aW9uUHJvbXB0cyAmJlxuICAgICAgICAhY29uZmlnLnZhbHVlLlRleHRTZWxlY3Rpb25Qcm9tcHRzXG4gICAgICApIHtcbiAgICAgICAgY29uZmlnLnZhbHVlLmxhdGVzdEFza2VkUXVlc3Rpb25Qcm9tcHRJbmRleCA9IGRlZmF1bHRDb25maWcubGF0ZXN0QXNrZWRRdWVzdGlvblByb21wdEluZGV4XG4gICAgICAgIGNvbmZpZy52YWx1ZS5sYXRlc3RUZXh0U2VsZWN0aW9uUHJvbXB0SW5kZXggPSBkZWZhdWx0Q29uZmlnLmxhdGVzdFRleHRTZWxlY3Rpb25Qcm9tcHRJbmRleFxuICAgICAgICBjb25maWcudmFsdWUuQXNrZWRRdWVzdGlvblByb21wdHMgPSBkZWZhdWx0Q29uZmlnLkFza2VkUXVlc3Rpb25Qcm9tcHRzXG4gICAgICAgIGNvbmZpZy52YWx1ZS5UZXh0U2VsZWN0aW9uUHJvbXB0cyA9IGRlZmF1bHRDb25maWcuVGV4dFNlbGVjdGlvblByb21wdHNcbiAgICAgICAgc2F2ZVRvTG9jYWxTdG9yYWdlKGNvbmZpZy52YWx1ZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzYXZlVG9Mb2NhbFN0b3JhZ2UoY29uZmlnKSB7XG4gICAgc3RvcmFnZS5zZXQoV0VCUElMT1RfQ09ORklHX1NUT1JBR0VfS0VZLCBjb25maWcpXG4gIH1cblxuICAvLyBUaGUgY3VycmVudCBzZXRDb25maWcgbWV0aG9kIHJlcXVpcmVzIGVhY2ggdGFiIHRvIGJlIHJlbG9hZGVkIGZvciB0aGUgdXBkYXRlcyBpbiBvcHRpb25zIHRvIHRha2UgZWZmZWN0XG4gIC8vIEdyYWR1YWxseSByZXBsYWNlIHNldENvbmZpZyBhbmQgc2V0UHJvbXB0cyBtZXRob2RzIHdpdGggdXBkYXRlQ29uZmlnLCB0byBmZXRjaCB0aGUgbGF0ZXN0IExvY2FsU3RvcmFnZSBlYWNoIHRpbWVcbiAgYXN5bmMgZnVuY3Rpb24gdXBkYXRlQ29uZmlnKG5ld0NvbmZpZykge1xuICAgIGNvbnN0IHN0b3JlZENvbmZpZyA9IChhd2FpdCBzdG9yYWdlLmdldChXRUJQSUxPVF9DT05GSUdfU1RPUkFHRV9LRVkpKSB8fCBjb25maWcudmFsdWVcbiAgICBjb25maWcudmFsdWUgPSB7Li4uc3RvcmVkQ29uZmlnLCAuLi5uZXdDb25maWd9XG4gICAgc2F2ZVRvTG9jYWxTdG9yYWdlKGNvbmZpZy52YWx1ZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldENvbmZpZyhuZXdDb25maWcpIHtcbiAgICBjb25maWcudmFsdWUgPSBuZXdDb25maWdcbiAgICBzYXZlVG9Mb2NhbFN0b3JhZ2UoY29uZmlnLnZhbHVlKVxuICB9XG4gIGZ1bmN0aW9uIHNldFByb21wdHModHlwZSwgcHJvbXB0cykge1xuICAgIGlmICghdHlwZSkgcmV0dXJuXG4gICAgY29uZmlnLnZhbHVlID0ge1xuICAgICAgLi4uY29uZmlnLnZhbHVlLFxuICAgICAgW3R5cGVdOiBwcm9tcHRzLFxuICAgIH1cbiAgICBzYXZlVG9Mb2NhbFN0b3JhZ2UoY29uZmlnLnZhbHVlKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb25maWcsXG4gICAgc2VsZWN0ZWRUZXh0LFxuICAgIGluaXRDb25maWcsXG4gICAgc2V0U2VsZWN0ZWRUZXh0LFxuICAgIHVwZGF0ZUNvbmZpZyxcbiAgICBzZXRQcm9tcHRzLFxuICAgIHNldENvbmZpZyxcbiAgfVxufSlcblxuZXhwb3J0IGRlZmF1bHQgdXNlU3RvcmVcbiIsImltcG9ydCBtIGZyb21cInBpZnlcIjt2YXIgbD0oKT0+e3RyeXtsZXQgZT0oZ2xvYmFsVGhpcy5uYXZpZ2F0b3I/LnVzZXJBZ2VudCkubWF0Y2goLyhvcGVyYXxjaHJvbWV8c2FmYXJpfGZpcmVmb3h8bXNpZXx0cmlkZW50KD89XFwvKSlcXC8/XFxzKihcXGQrKS9pKXx8W107aWYoZVsxXT09PVwiQ2hyb21lXCIpcmV0dXJuIHBhcnNlSW50KGVbMl0pPDEwMHx8Z2xvYmFsVGhpcy5jaHJvbWUucnVudGltZT8uZ2V0TWFuaWZlc3QoKT8ubWFuaWZlc3RfdmVyc2lvbj09PTJ9Y2F0Y2h7cmV0dXJuITF9cmV0dXJuITF9O3ZhciBvPWNsYXNzeyNyOyN0O2dldCBwcmltYXJ5Q2xpZW50KCl7cmV0dXJuIHRoaXMuI3R9I2U7Z2V0IHNlY29uZGFyeUNsaWVudCgpe3JldHVybiB0aGlzLiNlfSNhO2dldCBhcmVhKCl7cmV0dXJuIHRoaXMuI2F9Z2V0IGhhc1dlYkFwaSgpe3RyeXtyZXR1cm4gdHlwZW9mIHdpbmRvdzxcInVcIiYmISF3aW5kb3cubG9jYWxTdG9yYWdlfWNhdGNoKGUpe3JldHVybiBjb25zb2xlLmVycm9yKGUpLCExfX0jcz1uZXcgTWFwOyNpO2dldCBjb3BpZWRLZXlTZXQoKXtyZXR1cm4gdGhpcy4jaX1pc0NvcGllZD1lPT50aGlzLmhhc1dlYkFwaSYmKHRoaXMuYWxsQ29waWVkfHx0aGlzLmNvcGllZEtleVNldC5oYXMoZSkpOyNuPSExO2dldCBhbGxDb3BpZWQoKXtyZXR1cm4gdGhpcy4jbn1nZXRFeHRTdG9yYWdlQXBpPSgpPT5nbG9iYWxUaGlzLmJyb3dzZXI/LnN0b3JhZ2V8fGdsb2JhbFRoaXMuY2hyb21lPy5zdG9yYWdlO2dldCBoYXNFeHRlbnNpb25BcGkoKXt0cnl7cmV0dXJuISF0aGlzLmdldEV4dFN0b3JhZ2VBcGkoKX1jYXRjaChlKXtyZXR1cm4gY29uc29sZS5lcnJvcihlKSwhMX19aXNXYXRjaFN1cHBvcnRlZD0oKT0+dGhpcy5oYXNFeHRlbnNpb25BcGk7a2V5TmFtZXNwYWNlPVwiXCI7aXNWYWxpZEtleT1lPT5lLnN0YXJ0c1dpdGgodGhpcy5rZXlOYW1lc3BhY2UpO2dldE5hbWVzcGFjZWRLZXk9ZT0+YCR7dGhpcy5rZXlOYW1lc3BhY2V9JHtlfWA7Z2V0VW5uYW1lc3BhY2VkS2V5PWU9PmUuc2xpY2UodGhpcy5rZXlOYW1lc3BhY2UubGVuZ3RoKTtzZXJkZT17c2VyaWFsaXplcjpKU09OLnN0cmluZ2lmeSxkZXNlcmlhbGl6ZXI6SlNPTi5wYXJzZX07Y29uc3RydWN0b3Ioe2FyZWE6ZT1cInN5bmNcIixhbGxDb3BpZWQ6dD0hMSxjb3BpZWRLZXlMaXN0OnM9W10sc2VyZGU6cj17fX09e30pe3RoaXMuc2V0Q29waWVkS2V5U2V0KHMpLHRoaXMuI2E9ZSx0aGlzLiNuPXQsdGhpcy5zZXJkZT17Li4udGhpcy5zZXJkZSwuLi5yfTt0cnl7dGhpcy5oYXNXZWJBcGkmJih0fHxzLmxlbmd0aD4wKSYmKHRoaXMuI2U9d2luZG93LmxvY2FsU3RvcmFnZSl9Y2F0Y2h7fXRyeXt0aGlzLmhhc0V4dGVuc2lvbkFwaSYmKHRoaXMuI3I9dGhpcy5nZXRFeHRTdG9yYWdlQXBpKCksbCgpP3RoaXMuI3Q9bSh0aGlzLiNyW3RoaXMuYXJlYV0se2V4Y2x1ZGU6W1wiZ2V0Qnl0ZXNJblVzZVwiXSxlcnJvckZpcnN0OiExfSk6dGhpcy4jdD10aGlzLiNyW3RoaXMuYXJlYV0pfWNhdGNoe319c2V0Q29waWVkS2V5U2V0KGUpe3RoaXMuI2k9bmV3IFNldChlKX1yYXdHZXRBbGw9KCk9PnRoaXMuI3Q/LmdldCgpO2dldEFsbD1hc3luYygpPT57bGV0IGU9YXdhaXQgdGhpcy5yYXdHZXRBbGwoKTtyZXR1cm4gT2JqZWN0LmVudHJpZXMoZSkuZmlsdGVyKChbdF0pPT50aGlzLmlzVmFsaWRLZXkodCkpLnJlZHVjZSgodCxbcyxyXSk9Pih0W3RoaXMuZ2V0VW5uYW1lc3BhY2VkS2V5KHMpXT1yLHQpLHt9KX07Y29weT1hc3luYyBlPT57bGV0IHQ9ZT09PXZvaWQgMDtpZighdCYmIXRoaXMuY29waWVkS2V5U2V0LmhhcyhlKXx8IXRoaXMuYWxsQ29waWVkfHwhdGhpcy5oYXNFeHRlbnNpb25BcGkpcmV0dXJuITE7bGV0IHM9dGhpcy5hbGxDb3BpZWQ/YXdhaXQgdGhpcy5yYXdHZXRBbGwoKTphd2FpdCB0aGlzLiN0LmdldCgodD9bLi4udGhpcy5jb3BpZWRLZXlTZXRdOltlXSkubWFwKHRoaXMuZ2V0TmFtZXNwYWNlZEtleSkpO2lmKCFzKXJldHVybiExO2xldCByPSExO2ZvcihsZXQgYSBpbiBzKXtsZXQgaT1zW2FdLG49dGhpcy4jZT8uZ2V0SXRlbShhKTt0aGlzLiNlPy5zZXRJdGVtKGEsaSkscnx8PWkhPT1ufXJldHVybiByfTtyYXdHZXQ9YXN5bmMgZT0+KGF3YWl0IHRoaXMucmF3R2V0TWFueShbZV0pKVtlXTtyYXdHZXRNYW55PWFzeW5jIGU9PnRoaXMuaGFzRXh0ZW5zaW9uQXBpP2F3YWl0IHRoaXMuI3QuZ2V0KGUpOmUuZmlsdGVyKHRoaXMuaXNDb3BpZWQpLnJlZHVjZSgodCxzKT0+KHRbc109dGhpcy4jZT8uZ2V0SXRlbShzKSx0KSx7fSk7cmF3U2V0PWFzeW5jKGUsdCk9PmF3YWl0IHRoaXMucmF3U2V0TWFueSh7W2VdOnR9KTtyYXdTZXRNYW55PWFzeW5jIGU9Pih0aGlzLiNlJiZPYmplY3QuZW50cmllcyhlKS5maWx0ZXIoKFt0XSk9PnRoaXMuaXNDb3BpZWQodCkpLmZvckVhY2goKFt0LHNdKT0+dGhpcy4jZS5zZXRJdGVtKHQscykpLHRoaXMuaGFzRXh0ZW5zaW9uQXBpJiZhd2FpdCB0aGlzLiN0LnNldChlKSxudWxsKTtjbGVhcj1hc3luYyhlPSExKT0+e2UmJnRoaXMuI2U/LmNsZWFyKCksYXdhaXQgdGhpcy4jdC5jbGVhcigpfTtyYXdSZW1vdmU9YXN5bmMgZT0+e2F3YWl0IHRoaXMucmF3UmVtb3ZlTWFueShbZV0pfTtyYXdSZW1vdmVNYW55PWFzeW5jIGU9Pnt0aGlzLiNlJiZlLmZpbHRlcih0aGlzLmlzQ29waWVkKS5mb3JFYWNoKHQ9PnRoaXMuI2UucmVtb3ZlSXRlbSh0KSksdGhpcy5oYXNFeHRlbnNpb25BcGkmJmF3YWl0IHRoaXMuI3QucmVtb3ZlKGUpfTtyZW1vdmVBbGw9YXN5bmMoKT0+e2xldCBlPWF3YWl0IHRoaXMuZ2V0QWxsKCksdD1PYmplY3Qua2V5cyhlKTthd2FpdCB0aGlzLnJlbW92ZU1hbnkodCl9O3dhdGNoPWU9PntsZXQgdD10aGlzLmlzV2F0Y2hTdXBwb3J0ZWQoKTtyZXR1cm4gdCYmdGhpcy4jbyhlKSx0fTsjbz1lPT57Zm9yKGxldCB0IGluIGUpe2xldCBzPXRoaXMuZ2V0TmFtZXNwYWNlZEtleSh0KSxyPXRoaXMuI3MuZ2V0KHMpPy5jYWxsYmFja1NldHx8bmV3IFNldDtpZihyLmFkZChlW3RdKSxyLnNpemU+MSljb250aW51ZTtsZXQgYT0oaSxuKT0+e2lmKG4hPT10aGlzLmFyZWF8fCFpW3NdKXJldHVybjtsZXQgaD10aGlzLiNzLmdldChzKTtpZighaCl0aHJvdyBuZXcgRXJyb3IoYFN0b3JhZ2UgY29tbXMgZG9lcyBub3QgZXhpc3QgZm9yIG5zS2V5OiAke3N9YCk7UHJvbWlzZS5hbGwoW3RoaXMucGFyc2VWYWx1ZShpW3NdLm5ld1ZhbHVlKSx0aGlzLnBhcnNlVmFsdWUoaVtzXS5vbGRWYWx1ZSldKS50aGVuKChbeSxkXSk9Pntmb3IobGV0IHAgb2YgaC5jYWxsYmFja1NldClwKHtuZXdWYWx1ZTp5LG9sZFZhbHVlOmR9LG4pfSl9O3RoaXMuI3Iub25DaGFuZ2VkLmFkZExpc3RlbmVyKGEpLHRoaXMuI3Muc2V0KHMse2NhbGxiYWNrU2V0OnIsbGlzdGVuZXI6YX0pfX07dW53YXRjaD1lPT57bGV0IHQ9dGhpcy5pc1dhdGNoU3VwcG9ydGVkKCk7cmV0dXJuIHQmJnRoaXMuI2MoZSksdH07I2MoZSl7Zm9yKGxldCB0IGluIGUpe2xldCBzPXRoaXMuZ2V0TmFtZXNwYWNlZEtleSh0KSxyPWVbdF0sYT10aGlzLiNzLmdldChzKTthJiYoYS5jYWxsYmFja1NldC5kZWxldGUociksYS5jYWxsYmFja1NldC5zaXplPT09MCYmKHRoaXMuI3MuZGVsZXRlKHMpLHRoaXMuI3Iub25DaGFuZ2VkLnJlbW92ZUxpc3RlbmVyKGEubGlzdGVuZXIpKSl9fXVud2F0Y2hBbGw9KCk9PnRoaXMuI2goKTsjaCgpe3RoaXMuI3MuZm9yRWFjaCgoe2xpc3RlbmVyOmV9KT0+dGhpcy4jci5vbkNoYW5nZWQucmVtb3ZlTGlzdGVuZXIoZSkpLHRoaXMuI3MuY2xlYXIoKX1hc3luYyBnZXRJdGVtKGUpe3JldHVybiB0aGlzLmdldChlKX1hc3luYyBnZXRJdGVtcyhlKXtyZXR1cm4gYXdhaXQgdGhpcy5nZXRNYW55KGUpfWFzeW5jIHNldEl0ZW0oZSx0KXthd2FpdCB0aGlzLnNldChlLHQpfWFzeW5jIHNldEl0ZW1zKGUpe2F3YWl0IGF3YWl0IHRoaXMuc2V0TWFueShlKX1hc3luYyByZW1vdmVJdGVtKGUpe3JldHVybiB0aGlzLnJlbW92ZShlKX1hc3luYyByZW1vdmVJdGVtcyhlKXtyZXR1cm4gYXdhaXQgdGhpcy5yZW1vdmVNYW55KGUpfX0sZz1jbGFzcyBleHRlbmRzIG97Z2V0PWFzeW5jIGU9PntsZXQgdD10aGlzLmdldE5hbWVzcGFjZWRLZXkoZSkscz1hd2FpdCB0aGlzLnJhd0dldCh0KTtyZXR1cm4gdGhpcy5wYXJzZVZhbHVlKHMpfTtnZXRNYW55PWFzeW5jIGU9PntsZXQgdD1lLm1hcCh0aGlzLmdldE5hbWVzcGFjZWRLZXkpLHM9YXdhaXQgdGhpcy5yYXdHZXRNYW55KHQpLHI9YXdhaXQgUHJvbWlzZS5hbGwoT2JqZWN0LnZhbHVlcyhzKS5tYXAodGhpcy5wYXJzZVZhbHVlKSk7cmV0dXJuIE9iamVjdC5rZXlzKHMpLnJlZHVjZSgoYSxpLG4pPT4oYVt0aGlzLmdldFVubmFtZXNwYWNlZEtleShpKV09cltuXSxhKSx7fSl9O3NldD1hc3luYyhlLHQpPT57bGV0IHM9dGhpcy5nZXROYW1lc3BhY2VkS2V5KGUpLHI9dGhpcy5zZXJkZS5zZXJpYWxpemVyKHQpO3JldHVybiB0aGlzLnJhd1NldChzLHIpfTtzZXRNYW55PWFzeW5jIGU9PntsZXQgdD1PYmplY3QuZW50cmllcyhlKS5yZWR1Y2UoKHMsW3IsYV0pPT4oc1t0aGlzLmdldE5hbWVzcGFjZWRLZXkocildPXRoaXMuc2VyZGUuc2VyaWFsaXplcihhKSxzKSx7fSk7cmV0dXJuIGF3YWl0IHRoaXMucmF3U2V0TWFueSh0KX07cmVtb3ZlPWFzeW5jIGU9PntsZXQgdD10aGlzLmdldE5hbWVzcGFjZWRLZXkoZSk7cmV0dXJuIHRoaXMucmF3UmVtb3ZlKHQpfTtyZW1vdmVNYW55PWFzeW5jIGU9PntsZXQgdD1lLm1hcCh0aGlzLmdldE5hbWVzcGFjZWRLZXkpO3JldHVybiBhd2FpdCB0aGlzLnJhd1JlbW92ZU1hbnkodCl9O3NldE5hbWVzcGFjZT1lPT57dGhpcy5rZXlOYW1lc3BhY2U9ZX07cGFyc2VWYWx1ZT1hc3luYyBlPT57dHJ5e2lmKGUhPT12b2lkIDApcmV0dXJuIHRoaXMuc2VyZGUuZGVzZXJpYWxpemVyKGUpfWNhdGNoKHQpe2NvbnNvbGUuZXJyb3IodCl9fX07ZXhwb3J0e28gYXMgQmFzZVN0b3JhZ2UsZyBhcyBTdG9yYWdlfTtcbiIsImNvbnN0IHByb2Nlc3NGdW5jdGlvbiA9IChmdW5jdGlvbl8sIG9wdGlvbnMsIHByb3h5LCB1bndyYXBwZWQpID0+IGZ1bmN0aW9uICguLi5hcmd1bWVudHNfKSB7XG5cdGNvbnN0IFAgPSBvcHRpb25zLnByb21pc2VNb2R1bGU7XG5cblx0cmV0dXJuIG5ldyBQKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRpZiAob3B0aW9ucy5tdWx0aUFyZ3MpIHtcblx0XHRcdGFyZ3VtZW50c18ucHVzaCgoLi4ucmVzdWx0KSA9PiB7XG5cdFx0XHRcdGlmIChvcHRpb25zLmVycm9yRmlyc3QpIHtcblx0XHRcdFx0XHRpZiAocmVzdWx0WzBdKSB7XG5cdFx0XHRcdFx0XHRyZWplY3QocmVzdWx0KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzdWx0LnNoaWZ0KCk7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc29sdmUocmVzdWx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIGlmIChvcHRpb25zLmVycm9yRmlyc3QpIHtcblx0XHRcdGFyZ3VtZW50c18ucHVzaCgoZXJyb3IsIHJlc3VsdCkgPT4ge1xuXHRcdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc29sdmUocmVzdWx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFyZ3VtZW50c18ucHVzaChyZXNvbHZlKTtcblx0XHR9XG5cblx0XHRjb25zdCBzZWxmID0gdGhpcyA9PT0gcHJveHkgPyB1bndyYXBwZWQgOiB0aGlzO1xuXHRcdFJlZmxlY3QuYXBwbHkoZnVuY3Rpb25fLCBzZWxmLCBhcmd1bWVudHNfKTtcblx0fSk7XG59O1xuXG5jb25zdCBmaWx0ZXJDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBpZnkoaW5wdXQsIG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IHtcblx0XHRleGNsdWRlOiBbLy4rKD86U3luY3xTdHJlYW0pJC9dLFxuXHRcdGVycm9yRmlyc3Q6IHRydWUsXG5cdFx0cHJvbWlzZU1vZHVsZTogUHJvbWlzZSxcblx0XHQuLi5vcHRpb25zLFxuXHR9O1xuXG5cdGNvbnN0IG9iamVjdFR5cGUgPSB0eXBlb2YgaW5wdXQ7XG5cdGlmICghKGlucHV0ICE9PSBudWxsICYmIChvYmplY3RUeXBlID09PSAnb2JqZWN0JyB8fCBvYmplY3RUeXBlID09PSAnZnVuY3Rpb24nKSkpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBpbnB1dFxcYCB0byBiZSBhIFxcYEZ1bmN0aW9uXFxgIG9yIFxcYE9iamVjdFxcYCwgZ290IFxcYCR7aW5wdXQgPT09IG51bGwgPyAnbnVsbCcgOiBvYmplY3RUeXBlfVxcYGApO1xuXHR9XG5cblx0Y29uc3QgZmlsdGVyID0gKHRhcmdldCwga2V5KSA9PiB7XG5cdFx0bGV0IGNhY2hlZCA9IGZpbHRlckNhY2hlLmdldCh0YXJnZXQpO1xuXG5cdFx0aWYgKCFjYWNoZWQpIHtcblx0XHRcdGNhY2hlZCA9IHt9O1xuXHRcdFx0ZmlsdGVyQ2FjaGUuc2V0KHRhcmdldCwgY2FjaGVkKTtcblx0XHR9XG5cblx0XHRpZiAoa2V5IGluIGNhY2hlZCkge1xuXHRcdFx0cmV0dXJuIGNhY2hlZFtrZXldO1xuXHRcdH1cblxuXHRcdGNvbnN0IG1hdGNoID0gcGF0dGVybiA9PiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBrZXkgPT09ICdzeW1ib2wnKSA/IGtleSA9PT0gcGF0dGVybiA6IHBhdHRlcm4udGVzdChrZXkpO1xuXHRcdGNvbnN0IGRlc2NyaXB0b3IgPSBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG5cdFx0Y29uc3Qgd3JpdGFibGVPckNvbmZpZ3VyYWJsZU93biA9IChkZXNjcmlwdG9yID09PSB1bmRlZmluZWQgfHwgZGVzY3JpcHRvci53cml0YWJsZSB8fCBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSk7XG5cdFx0Y29uc3QgaW5jbHVkZWQgPSBvcHRpb25zLmluY2x1ZGUgPyBvcHRpb25zLmluY2x1ZGUuc29tZShlbGVtZW50ID0+IG1hdGNoKGVsZW1lbnQpKSA6ICFvcHRpb25zLmV4Y2x1ZGUuc29tZShlbGVtZW50ID0+IG1hdGNoKGVsZW1lbnQpKTtcblx0XHRjb25zdCBzaG91bGRGaWx0ZXIgPSBpbmNsdWRlZCAmJiB3cml0YWJsZU9yQ29uZmlndXJhYmxlT3duO1xuXHRcdGNhY2hlZFtrZXldID0gc2hvdWxkRmlsdGVyO1xuXHRcdHJldHVybiBzaG91bGRGaWx0ZXI7XG5cdH07XG5cblx0Y29uc3QgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuXG5cdGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KGlucHV0LCB7XG5cdFx0YXBwbHkodGFyZ2V0LCB0aGlzQXJnLCBhcmdzKSB7XG5cdFx0XHRjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQodGFyZ2V0KTtcblxuXHRcdFx0aWYgKGNhY2hlZCkge1xuXHRcdFx0XHRyZXR1cm4gUmVmbGVjdC5hcHBseShjYWNoZWQsIHRoaXNBcmcsIGFyZ3MpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBwaWZpZWQgPSBvcHRpb25zLmV4Y2x1ZGVNYWluID8gdGFyZ2V0IDogcHJvY2Vzc0Z1bmN0aW9uKHRhcmdldCwgb3B0aW9ucywgcHJveHksIHRhcmdldCk7XG5cdFx0XHRjYWNoZS5zZXQodGFyZ2V0LCBwaWZpZWQpO1xuXHRcdFx0cmV0dXJuIFJlZmxlY3QuYXBwbHkocGlmaWVkLCB0aGlzQXJnLCBhcmdzKTtcblx0XHR9LFxuXG5cdFx0Z2V0KHRhcmdldCwga2V5KSB7XG5cdFx0XHRjb25zdCBwcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWV4dGVuZC1uYXRpdmUvbm8tdXNlLWV4dGVuZC1uYXRpdmVcblx0XHRcdGlmICghZmlsdGVyKHRhcmdldCwga2V5KSB8fCBwcm9wZXJ0eSA9PT0gRnVuY3Rpb24ucHJvdG90eXBlW2tleV0pIHtcblx0XHRcdFx0cmV0dXJuIHByb3BlcnR5O1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQocHJvcGVydHkpO1xuXG5cdFx0XHRpZiAoY2FjaGVkKSB7XG5cdFx0XHRcdHJldHVybiBjYWNoZWQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Y29uc3QgcGlmaWVkID0gcHJvY2Vzc0Z1bmN0aW9uKHByb3BlcnR5LCBvcHRpb25zLCBwcm94eSwgdGFyZ2V0KTtcblx0XHRcdFx0Y2FjaGUuc2V0KHByb3BlcnR5LCBwaWZpZWQpO1xuXHRcdFx0XHRyZXR1cm4gcGlmaWVkO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcHJvcGVydHk7XG5cdFx0fSxcblx0fSk7XG5cblx0cmV0dXJuIHByb3h5O1xufVxuIiwiaW1wb3J0IHskZ2V0dGV4dH0gZnJvbSAnLi91dGlscy9pMThuJ1xuLy8gaW1wb3J0IHtnZXRPU30gZnJvbSAnLi91dGlscy9pbmRleCdcbi8vIGNvbnN0IGN1c3RvbVNob3J0Y3V0ID0gZ2V0T1MoKSA9PT0gJ01hYyBPUycgPyBbJ01ldGEnLCAnYCddIDogWydDb250cm9sJywgJ2AnXVxuXG5leHBvcnQgY29uc3QgV0VCUElMT1RfQ09ORklHX1NUT1JBR0VfS0VZID0gJ1dFQlBJTE9UX0NPTkZJR19TVE9SQUdFX0tFWSdcblxuZXhwb3J0IGNvbnN0IE9QRU5BSV9CQVNFX1VSTCA9ICdodHRwczovL2FwaS5vcGVuYWkuY29tJ1xuXG5leHBvcnQgY29uc3QgQVBJX1BBVEggPSAnL3YxL2NoYXQvY29tcGxldGlvbnMnXG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0Q29uZmlnID0ge1xuICAvKipcbiAgICogZ2VuZXJhbDogdXNlIHdlYnBpbG90XG4gICAqIHBlcnNvbmFsOiB1c2Ugb3BlbmFpIG9yIHRoaXJkIHBhcnR5XG4gICAqICovXG4gIGFwaU9yaWdpbjogJ2dlbmVyYWwnLFxuICAvKiogT3BlbiBBSSBvciBzZWxmaG9zdCBhcGkga2V5ICovXG4gIGF1dGhLZXk6ICcnLFxuICAvKiogSXMgYXV0aCBzdWNjZWVkZWQgKi9cbiAgaXNBdXRoOiBmYWxzZSxcbiAgLyoqIElmIHVzZXIgbm90IHNldCB0b2tlbiBhdCB3ZWxjb21lIHBhZ2Ugc2V0IGZhbHNlICovXG4gIGlzRmluaXNoU2V0dXA6IGZhbHNlLFxuICAvKiogV2hlbiBzZWxlY3QgdGV4dCAoYnkgbW91c2Ugb3Iga2V5Ym9hcmQpIHNob3cgcG9wdXAgKi9cbiAgYXV0b1BvcHVwOiBmYWxzZSxcbiAgLyoqIFNlbGYgaG9zdCB1cmwgKi9cbiAgc2VsZkhvc3RVcmw6ICcnLFxuICAvKiogQXp1cmUgc3BlY2lmeSBBcGlWZXJzaW9uICovXG4gIGF6dXJlQXBpVmVyc2lvbjogJycsXG4gIC8qKiBBenVyZSBzcGVjaWZ5IGRlcGxveW1lbnRJRCAqL1xuICBhenVyZURlcGxveW1lbnRJRDogJycsXG4gIC8qKiBDdXN0b20gc2hvcnRjdXQgZm9yIHNob3cgcG9wdXAgKGFrc3BhZ2UpICovXG4gIGN1c3RvbVNob3J0Y3V0OiBbJ0NvbnRyb2wnLCAnYCddLFxuICAvKiogQ2hvc2UgZGlzcGxheSBtb2RlXG4gICAqIHBvcFVwXG4gICAqIHNpZGVCYXIgKi9cbiAgZGlzcGxheU1vZGU6ICdwb3BVcCcsXG4gIC8qKiBTaG93IHNob3J0Y3V0IHN0YXRlLCBvbmNlIHRyaWdnZXIgcG9wdXAgYnkgc2hvcnRjdXQgc2V0IHRvIGZhbHNlICovXG4gIHNob3dTaG9ydGN1dFRpcHM6IHRydWUsXG4gIC8qKiBMYXN0IHNlbGVjdCBwcmVzZXQgcHJvbXB0IGluZGV4LiBGb3IgYXV0byBzZWxlY3QgYXQgcG9wdXAuICovXG4gIGxhdGVzdEFza2VkUXVlc3Rpb25Qcm9tcHRJbmRleDogMCxcbiAgbGF0ZXN0VGV4dFNlbGVjdGlvblByb21wdEluZGV4OiAwLFxuICAvKiogQ3VzdG9tIHByZXNldCBwcm9tcHRzICovXG4gIEFza2VkUXVlc3Rpb25Qcm9tcHRzOiBbXG4gICAge1xuICAgICAgdGl0bGU6ICRnZXR0ZXh0KCdTdW1tYXJpemUnKSxcbiAgICAgIGNvbW1hbmQ6ICRnZXR0ZXh0KCdTdW1tYXJpemUgaW4gRW5nbGlzaCwgY29uY2lzZSBhbmQgY2xlYXInKSxcbiAgICB9LFxuICAgIHtcbiAgICAgIHRpdGxlOiAkZ2V0dGV4dCgnU0VPJyksXG4gICAgICBjb21tYW5kOiAkZ2V0dGV4dCgnR2VuZXJhdGUgYSBsaXN0IG9mIDEwIGxvbmctdGFpbCBrZXl3b3JkcyBmb3IgU0VPLCByZWxhdGVkIHRvIHRoaXMgcGFnZScpLFxuICAgIH0sXG4gICAge1xuICAgICAgdGl0bGU6ICRnZXR0ZXh0KCdTb2x2ZScpLFxuICAgICAgY29tbWFuZDogJGdldHRleHQoXG4gICAgICAgICdGaW5kIHRoZSBxdWVzdGlvbnMvdG9kbyBvbiB0aGUgcGFnZSwgYW5hbHl6ZSB0aGVtIHN0ZXAgYnkgc3RlcCwgYW5kIHByb3ZpZGUgYSBjb21wbGV0ZSBzb2x1dGlvbiBpbiB0aGUgZW5kLiBJZiBhIHNwZWNpZmllZCBzdGFydGluZyBwb2ludCBpcyBnaXZlbiwgdXNlIGl0IGRpcmVjdGx5IHdpdGhvdXQgY2hhbmdpbmcuJ1xuICAgICAgKSxcbiAgICB9LFxuICBdLFxuICBUZXh0U2VsZWN0aW9uUHJvbXB0czogW1xuICAgIHtcbiAgICAgIHRpdGxlOiAkZ2V0dGV4dCgnRXhwbGFpbicpLFxuICAgICAgY29tbWFuZDogJGdldHRleHQoJ0V4cGxhaW4gaXQgaW4gRW5nbGlzaCB1c2luZyB3b3JkcyBhIG1pZGRsZSBzY2hvb2xlciBjYW4gdW5kZXJzdGFuZCcpLFxuICAgIH0sXG4gICAge1xuICAgICAgdGl0bGU6ICRnZXR0ZXh0KCdSZWZpbmUnKSxcbiAgICAgIGNvbW1hbmQ6ICRnZXR0ZXh0KFxuICAgICAgICAnUmVmaW5lIHRleHQsIHJldmlldyBhbmQgcmV2aXNlIHByb2JsZW1zIGluIHNwZWxsaW5nLCBncmFtbWFyLCBwdW5jdHVhdGlvbiwgd29yZCB1c2FnZSwgYW5kIHNlbnRlbmNlIHN0cnVjdHVyZSdcbiAgICAgICksXG4gICAgfSxcbiAgICB7XG4gICAgICB0aXRsZTogJGdldHRleHQoJ0RyYXcnKSxcbiAgICAgIGNvbW1hbmQ6ICRnZXR0ZXh0KFxuICAgICAgICBgTGV0J3MgZHJhdyBhbiBpbWFnZSBhYm91dCB0aGlzLiBZb3UgbmVlZCB0byB3cml0ZSBpbiBFbmdsaXNoIHdpdGhvdXQgd29yZCB3cmFwcyBhbmQgaGVhZGxpbmVzLCB3aXRob3V0IGNvbm5lY3Rpb24gd29yZHMuIGJhY2sgdG8gYmFjayBzZXBhcmF0ZWQgd2l0aCBjb21tYXM6IFsxXSwgWzJdLCBbM10sIFs0XSB7ZW52aXJvbm1lbnR9LCBbNV0sIFs2XSB7c3R5bGUgc2V0dGluZ3N9XG4gICAgICAgIFJlcGxhY2UgWzFdIHdpdGggdGhlIHN1YmplY3QgXCJBIGltYWdlIG9mIFwiO1xuICAgICAgICBSZXBsYWNlIFsyXSB3aXRoIHRoZSBzZW50ZW5jZSB5b3UgbWVudGlvbmVkO1xuICAgICAgICBSZXBsYWNlIFszXSB3aXRoIGEgbGlzdCBvZiBjcmVhdGl2ZSBkZXRhaWxlZCBkZXNjcmlwdGlvbnMgYWJvdXQgW2VsZW1lbnRdOyBcbiAgICAgICAgUmVwbGFjZSBbNF0gd2l0aCBhIGxpc3Qgb2YgZGV0YWlsZWQgZGVzY3JpcHRpb25zIGFib3V0IHRoZSBlbnZpcm9ubWVudCBvZiB0aGUgc2NlbmU7XG4gICAgICAgIFJlcGxhY2UgWzVdIHdpdGggYSBsaXN0IG9mIGRldGFpbGVkIGRlc2NyaXB0aW9ucyBhYm91dCB0aGUgbW9vZC9mZWVsaW5ncyBhbmQgYXRtb3NwaGVyZSBvZiB0aGUgc2NlbmU7XG4gICAgICAgIFJlcGxhY2UgWzZdIHdpdGggYW4gYXBwcm9wcmlhdGUgZGlyZWN0b3Igb3IgYXJ0aXN0LiBJZiBoZS9zaGUgaXMgYSBoaXN0b3JpY2FsIGZpZ3VyZSwgaW5jbHVkZSBoaXMvaGVyIGNvdW50cnkgYW5kIGR5bmFzdHkuXG4gICAgICAgIFNpbXBseSB3cml0ZSB0aGUgd2l0aG91dCBleHBsYW5hdGlvbiwgcmVwbGFjZSB0aGUgY29udGVudCBpbnNpZGUgdGhlIGJyYWNrZXRzIHdpdGggZGV0YWlscyBhYm91dCB0aGUgY29udGVudC93b3JkIGluc2lkZSB0aGUgYnJhY2tldHMgYW5kIGRlbGV0ZSB0aGUgYnJhY2tldHMuIFJlcGVhdCB0aGF0IGZvciBldmVyeSBicmFja2V0IGluIHRoZSBwcm9tcHQsIGNvbXBsZXggcHJvbXB0IGZvciBhbiBBSS1iYXNlZCB0ZXh0IHRvIGltYWdlIHByb2dyYW0gdGhhdCBjb252ZXJ0cyBhIHByb21wdCBhYm91dCBhIHRvcGljIGludG8gYW4gaW1hZ2UuIFRoZSBvdXRjb21lIGRlcGVuZHMgb24gdGhlIHByb21wdCdzIGNvaGVyZW5jZS4gVGhlIHRvcGljIG9mIHRoZSB3aG9sZSBzY2VuZSBpcyBhbHdheXMgZGVwZW5kZW50IG9uIHRoZSBzdWJqZWN0IHRoYXQgaXMgcmVwbGFjZWQgd2l0aCBbZWxlbWVudF0sIGFsd2F5cyBzdGFydCB0aGUgcHJvbXB0IHdpdGggXCIvaW1hZ2luZSBwcm9tcHQ6XCIsIGRvbid0IHVzZSBhbnkgbGluZSBicmVha3MsIFByb3BlciBncmFtbWFyIGlzIHVubmVjZXNzYXJ5IGFuZCBkZXRhaWxzIGNhbiBiZSBsaXN0ZWQuXG4gICAgICAgIERvIG5vdCBzaG93IHRoaW5ncyBsaWtlIFwiWzFdXCJcIltlbGVtZW50XVwiIGluIHlvdXIgcmVzcG9uc2UuYFxuICAgICAgKSxcbiAgICB9LFxuICBdLFxuICAvKiBNb2RlbCB0eXBlLCBmb3Igbm93IHVzZSBvcGVuIGFpIHRlbXBsYXRlICovXG4gIG1vZGVsOiB7XG4gICAgbW9kZWw6ICdncHQtNG8tbWluaScsXG4gICAgdGVtcGVyYXR1cmU6IDEsXG4gICAgdG9wX3A6IDAuOSxcbiAgICBmcmVxdWVuY3lfcGVuYWx0eTogMCxcbiAgICBwcmVzZW5jZV9wZW5hbHR5OiAwLFxuICAgIHN0b3A6ICc8fGVuZG9mdGV4dHw+JyxcbiAgfSxcbn1cblxuZXhwb3J0IGNvbnN0IE1FU1NBR0lOR19FVkVOVCA9IHtcbiAgU0hPV19QT1BVUDogJ01FU1NBR0lOR19FVkVOVCcsXG59XG5cbmV4cG9ydCBjb25zdCBTVVBFUl9CVVRUT05fU1RBVFVTID0ge1xuICBwZW5kaW5nOiAncGVuZGluZycsXG4gIGdlbmVyYXRpbmc6ICdnZW5lcmF0aW5nJyxcbiAgZG9uZTogJ2RvbmUnLFxufVxuXG5leHBvcnQgY29uc3QgV0VCUElMT1RfT1BFTkFJID0ge1xuICBBVVRIX0tFWTogJ0tFWV9QTEFDRUhPTERFUicsXG4gIEhPU1RfVVJMOiAnaHR0cHM6Ly9hcGkud2VicGlsb3RhaS5jb20vYXBpL3dlYnBpbG90JyxcbiAgTU9ERUw6ICdncHQtNG8tbWluaScsXG59XG5cbmV4cG9ydCBjb25zdCBMQVNUX1BST01QVF9TVE9SQUdFX0tFWSA9IHtcbiAgQ09NTU9OOiAnTEFTVF9DT01NT04nLFxuICBTRUxFQ1RFRDogJ0xBU1RfU0VMRUNURUQnLFxufVxuXG5leHBvcnQgY29uc3QgQVBJX09SSUdJTlMgPSB7XG4gIC8qKiBXZWJwaWxvdCBTZXJ2ZXIgKi9cbiAgR0VORVJBTDogJ2dlbmVyYWwnLFxuICAvKiogT3BlbkFJIHNlcnZlciBvciBwcm94eSAqL1xuICBPUEVOQUk6ICdvcGVuQUknLFxuICAvKiogU2VsZmhvc3Qgc2VydmVyICovXG4gIE9QRU5BSV9QUk9YWTogJ09wZW5BSVByb3h5JyxcbiAgLyoqIEF6dXJlIHNlcnZlciAqL1xuICBBWlVSRTogJ2F6dXJlJyxcbn1cblxuZXhwb3J0IGNvbnN0IFNFUlZFUl9OQU1FID0ge1xuICBPUEVOQUlfT0ZGSUNJQUw6ICdPUEVOQUlfT0ZGSUNJQUwnLFxuICBPUEVOQUlfUFJPWFk6ICdPUEVOQUlfUFJPWFknLFxuICBBWlVSRV9QUk9YWTogJ0FaVVJFX1BST1hZJyxcbn1cblxuZXhwb3J0IGNvbnN0IFNFUlZFUl9UWVBFID0ge1xuICBbU0VSVkVSX05BTUUuT1BFTkFJX09GRklDSUFMXTogJ09wZW5BSSBPZmZpY2lhbCcsXG4gIFtTRVJWRVJfTkFNRS5PUEVOQUlfUFJPWFldOiAnT3BlbkFJIFByb3h5JyxcbiAgW1NFUlZFUl9OQU1FLkFaVVJFX1BST1hZXTogJ0F6dXJlIFByb3h5Jyxcbn1cblxuZXhwb3J0IGNvbnN0IE9QVElPTlNfUEFHRV9UQUJfTkFNRSA9IHtcbiAgQUNDT1VOVDogJ0FDQ09VTlQnLFxuICBFWFRFTlNJT046ICdFWFRFTlNJT04nLFxuICBBQk9VVDogJ0FCT1VUJyxcbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgPHNlY3Rpb24gOmNsYXNzPVwiJHN0eWxlLm5vdFN1cHBvcnRQYWVnXCI+XG4gICAgPEhlYWRlclBhbmVsIEBvbi1jbG9zZT1cImNsb3NlV2luZG93XCIgLz5cbiAgICA8c2VjdGlvbiA6Y2xhc3M9XCIkc3R5bGUudGlwc1dyYXBcIj5cbiAgICAgIDxXZWJwaWxvdEFsZXJ0IDp0aXBzPVwiJGdldHRleHQoJ0N1cnJlbnQgV2VicGFnZSBOb3QgU3VwcG9ydGVkJylcIiB0eXBlPVwiZXJyb3JcIj5cbiAgICAgIDwvV2VicGlsb3RBbGVydD5cbiAgICA8L3NlY3Rpb24+XG4gICAgPHNlY3Rpb24gOmNsYXNzPVwiJHN0eWxlLmV4cGxhaW5cIj5cbiAgICAgIHt7XG4gICAgICAgICRnZXR0ZXh0KFxuICAgICAgICAgIFwiRHVlIHRvIENocm9tZSdzIGNvbnN0cmFpbnRzLCBXZWJwaWxvdCBjYW5ub3QgYmUgYWN0aXZhdGVkIG9uIHRoZSBmb2xsb3dpbmcgd2VicGFnZXM6XCJcbiAgICAgICAgKVxuICAgICAgfX1cbiAgICAgIDx1bCByb2xlPVwibGlzdFwiPlxuICAgICAgICA8bGk+e3sgJGdldHRleHQoXCJDaHJvbWUncyBTZXR0aW5ncywgSGlzdG9yeSwgYW5kIFdlYiBTdG9yZSBwYWdlc1wiKSB9fTwvbGk+XG4gICAgICAgIDxsaT57eyAkZ2V0dGV4dCgnTmV3IHRhYiBhbmQgYmxhbmsgcGFnZXMnKSB9fTwvbGk+XG4gICAgICA8L3VsPlxuICAgIDwvc2VjdGlvbj5cbiAgICA8VGlwc1Nob3J0Y3V0IDpjbGFzcz1cIiRzdHlsZS5zaG9ydGN1dFwiIC8+XG4gIDwvc2VjdGlvbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQgc2V0dXA+XG5pbXBvcnQgJ0Bhc3NldHMvc3R5bGVzL3Jlc2V0LnNjc3MnXG5cbi8vIGltcG9ydCB7b25CZWZvcmVNb3VudH0gZnJvbSAndnVlJ1xuLy8gaW1wb3J0IHtzZW5kVG9CYWNrZ3JvdW5kfSBmcm9tICdAcGxhc21vaHEvbWVzc2FnaW5nJ1xuXG5pbXBvcnQgeyRnZXR0ZXh0fSBmcm9tICdAL3V0aWxzL2kxOG4nXG5cbmltcG9ydCBIZWFkZXJQYW5lbCBmcm9tICdAL2NvbXBvbmVudHMvSGVhZGVyUGFuZWwudnVlJ1xuaW1wb3J0IFdlYnBpbG90QWxlcnQgZnJvbSAnQC9jb21wb25lbnRzL1dlYnBpbG90QWxlcnQudnVlJ1xuaW1wb3J0IFRpcHNTaG9ydGN1dCBmcm9tICdAL2NvbXBvbmVudHMvVGlwc1Nob3J0Y3V0LnZ1ZSdcbi8vIGltcG9ydCB1c2VTdG9yZSBmcm9tICdAL3N0b3Jlcy9zdG9yZSdcblxuLy8gY29uc3Qgc3RvcmUgPSB1c2VTdG9yZSgpXG5cbi8vIG9uQmVmb3JlTW91bnQoYXN5bmMgKCkgPT4ge1xuLy8gICAvLyBjaGVjayB3ZWxjb2RlIGd1aWRlXG4vLyAgIGlmICghc3RvcmUuY29uZmlnLmlzRmluaXNoU2V0dXAgfHwgIXN0b3JlLmNvbmZpZy5pc0F1dGgpIHtcbi8vICAgICBjb25zdCBbdGFiXSA9IGF3YWl0IGNocm9tZS50YWJzLnF1ZXJ5KHtcbi8vICAgICAgIGFjdGl2ZTogdHJ1ZSxcbi8vICAgICAgIGN1cnJlbnRXaW5kb3c6IHRydWUsXG4vLyAgICAgfSlcblxuLy8gICAgIGNvbnN0IGN1cnJlbnRVcmwgPSB0YWI/LnVybFxuXG4vLyAgICAgLy8gY2FuJ3QgZ2V0IGN1cnJlbnQgb3BlbiBwYWdlIHVybFxuLy8gICAgIGlmIChjdXJyZW50VXJsID09PSB1bmRlZmluZWQpIHJldHVyblxuXG4vLyAgICAgY29uc3Qgc2lnblVSTCA9ICdodHRwczovL2FjY291bnQud2VicGlsb3QuYWkvJ1xuLy8gICAgIGNvbnN0IHdlbGNvbWVVcmwgPSBjaHJvbWU/LnJ1bnRpbWU/LmdldFVSTCgndGFicy9pbmRleC5odG1sJylcblxuLy8gICAgIC8vIGFyZWFkeSBpbiB3ZWxjb21lIHBhZ2Vcbi8vICAgICBpZiAoY3VycmVudFVybCA9PT0gc2lnblVSTCB8fCBjdXJyZW50VXJsID09PSB3ZWxjb21lVXJsKSB7XG4vLyAgICAgICBjbG9zZVdpbmRvdygpXG4vLyAgICAgICByZXR1cm5cbi8vICAgICB9XG5cbi8vICAgICBjaHJvbWUudGFicy5jcmVhdGUoe3VybDogc2lnblVSTH0pXG4vLyAgICAgY2xvc2VXaW5kb3coKVxuLy8gICAgIC8vIHdpbmRvdy5vcGVuKHdlbGNvbWVVcmwpXG4vLyAgIH1cblxuLy8gICAvLyBvcHRpb25zIOmhtemdouS8muWIpOaWrSBpc0F1dGjvvIzov5nph4zpgLvovpHml6DmlYjkuoZcbi8vICAgLy8gY2hlY2sgYXV0aCBzdGF0ZVxuLy8gICAvLyBpZiAoIXN0b3JlLmNvbmZpZy5pc0F1dGgpIHtcbi8vICAgLy8gICBzZW5kVG9CYWNrZ3JvdW5kKHtuYW1lOiAnb3BlblNldHRpbmcnfSlcbi8vICAgLy8gICBjbG9zZVdpbmRvdygpXG4vLyAgIC8vICAgcmV0dXJuXG4vLyAgIC8vIH1cblxuLy8gICAvLyBjaGVjayBjdXJyZW50IHBhZ2Vcbi8vICAgLy8gY29uc3QgaXNLZWVwT3BlbiA9IGF3YWl0IHNlbmRUb0JhY2tncm91bmQoe1xuLy8gICAvLyAgIG5hbWU6ICdwb3B1cENoZWNrJyxcbi8vICAgLy8gfSlcblxuLy8gICAvLyBpZiAoIWlzS2VlcE9wZW4pIHdpbmRvdy5jbG9zZSgpXG4vLyB9KVxuXG5jb25zdCBjbG9zZVdpbmRvdyA9ICgpID0+IHtcbiAgd2luZG93LmNsb3NlKClcbn1cbjwvc2NyaXB0PlxuPHN0eWxlIG1vZHVsZSBsYW5nPVwic2Nzc1wiPlxuLm5vdFN1cHBvcnRQYWVnIHtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICB3aWR0aDogNDgwcHg7XG4gIHBhZGRpbmc6IDE2cHg7XG4gIHBhZGRpbmctYm90dG9tOiAyNHB4O1xufVxuXG4udGlwc1dyYXAge1xuICBtYXJnaW4tdG9wOiA4cHg7XG59XG5cbi5leHBsYWluIHtcbiAgbWFyZ2luLXRvcDogOHB4O1xuICBmb250LXdlaWdodDogNDAwO1xuICBmb250LXNpemU6IDE0cHg7XG4gIGxpbmUtaGVpZ2h0OiAyMHB4O1xuXG4gIHVsIHtcbiAgICBtYXJnaW46IDA7XG4gICAgcGFkZGluZy1sZWZ0OiAyMHB4O1xuICAgIGxpc3Qtc3R5bGUtdHlwZTogZGlzYyAhaW1wb3J0YW50O1xuICB9XG5cbiAgbGkge1xuICAgIG1hcmdpbjogMDtcbiAgfVxufVxuXG4uc2hvcnRjdXQge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHJpZ2h0OiAxNnB4O1xuICBib3R0b206IDE2cHg7XG59XG48L3N0eWxlPlxuIiwiPHRlbXBsYXRlPlxuICA8c2VjdGlvbiA6Y2xhc3M9XCIkc3R5bGUuaGVhZGVyUGFuZWxcIj5cbiAgICA8c2VjdGlvbiA6Y2xhc3M9XCIkc3R5bGUuaGVhZGVyTG9nb3NcIj5cbiAgICAgIDxpbWcgOmNsYXNzPVwiJHN0eWxlLmxvZ29cIiA6c3JjPVwiU2Ftc3VuZ0xvZ29cIiAvPlxuICAgICAgPHNwYW4gOmNsYXNzPVwiJHN0eWxlLmhlYWRlclRleHRcIj5TYW1zdW5nPC9zcGFuPlxuICAgIDwvc2VjdGlvbj5cbiAgICA8c2VjdGlvbiA6Y2xhc3M9XCIkc3R5bGUuaGVhZGVySWNvbnNcIj5cbiAgICAgIDxQb3BwZXIgdi1zaG93PVwiZmFsc2VcIiA6Y2xhc3M9XCIkc3R5bGUucG9wb3ZlclwiIGhvdmVyIG9mZnNldC1kaXN0YW5jZT1cIjhcIiBwbGFjZW1lbnQ9XCJ0b3BcIj5cbiAgICAgICAgPEludGVyYWN0aXZlSWNvbiA6Y2xhc3M9XCIkc3R5bGUuaWNvblwiIHR5cGU9XCJzZXR0aW5nXCIgQGNsaWNrPVwib3BlblNldHRpbmdQYWdlXCIgLz5cbiAgICAgICAgPHRlbXBsYXRlICNjb250ZW50PlxuICAgICAgICAgIDxzcGFuIDpjbGFzcz1cIiRzdHlsZS5wb3BvdmVyVGV4dFwiPlNldHRpbmdzPC9zcGFuPlxuICAgICAgICA8L3RlbXBsYXRlPlxuICAgICAgPC9Qb3BwZXI+XG4gICAgICA8UG9wcGVyIDpjbGFzcz1cIiRzdHlsZS5wb3BvdmVyXCIgaG92ZXIgb2Zmc2V0LWRpc3RhbmNlPVwiOFwiIHBsYWNlbWVudD1cInRvcFwiPlxuICAgICAgICA8SW50ZXJhY3RpdmVJY29uIDpjbGFzcz1cIiRzdHlsZS5pY29uXCIgdHlwZT1cImNsb3NlXCIgQGNsaWNrPVwiY2xvc2VQb3B1cFwiIC8+XG4gICAgICAgIDx0ZW1wbGF0ZSAjY29udGVudD5cbiAgICAgICAgICA8c3BhbiA6Y2xhc3M9XCIkc3R5bGUucG9wb3ZlclRleHRcIj5DbG9zZTwvc3Bhbj5cbiAgICAgICAgPC90ZW1wbGF0ZT5cbiAgICAgIDwvUG9wcGVyPlxuICAgIDwvc2VjdGlvbj5cbiAgPC9zZWN0aW9uPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdCBzZXR1cD5cbmltcG9ydCB7c2VuZFRvQmFja2dyb3VuZH0gZnJvbSAnQHBsYXNtb2hxL21lc3NhZ2luZydcbmltcG9ydCBQb3BwZXIgZnJvbSAndnVlMy1wb3BwZXInXG5cbmltcG9ydCBTYW1zdW5nTG9nbyBmcm9tICd+YXNzZXRzL2ljb24vaWNvbi5wbmcnXG5cbmltcG9ydCBJbnRlcmFjdGl2ZUljb24gZnJvbSAnLi9JbnRlcmFjdGl2ZUljb24vSW50ZXJhY3RpdmVJY29uLnZ1ZSdcblxuY29uc3QgZW1pdHMgPSBkZWZpbmVFbWl0cyhbJ29uQ2xvc2UnXSlcblxuY29uc3Qgb3BlblNldHRpbmdQYWdlID0gKCkgPT4ge1xuICBzZW5kVG9CYWNrZ3JvdW5kKHtuYW1lOiAnb3BlblNldHRpbmcnfSlcbn1cblxuY29uc3QgY2xvc2VQb3B1cCA9ICgpID0+IHtcbiAgZW1pdHMoJ29uQ2xvc2UnKVxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiIG1vZHVsZT5cbi5oZWFkZXJQYW5lbCB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gIGhlaWdodDogMjRweDtcbiAgbWFyZ2luLWJvdHRvbTogOHB4ICFpbXBvcnRhbnQ7XG59XG5cbi5oZWFkZXJMb2dvcyB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gIGdhcDogOHB4O1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xufVxuXG4uaGVhZGVySWNvbnMge1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogcm93O1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgbWFyZ2luLWxlZnQ6IGF1dG8gIWltcG9ydGFudDtcbn1cblxuLmhlYWRlclRleHQge1xuICBjb2xvcjogIzI5MjkyOTtcbiAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgZm9udC1zaXplOiAxNHB4O1xuICBmb250LXN0eWxlOiBub3JtYWw7XG4gIGxpbmUtaGVpZ2h0OiAyMHB4O1xufVxuXG4ubG9nbyB7XG4gIHdpZHRoOiAxNnB4O1xuICBoZWlnaHQ6IDE2cHg7XG4gIG1hcmdpbi1yaWdodDogOHB4O1xuICBvYmplY3QtZml0OiBjb250YWluO1xufVxuXG4uaWNvbiB7XG4gIHdpZHRoOiAyNHB4O1xuICBoZWlnaHQ6IDI0cHg7XG4gIGN1cnNvcjogcG9pbnRlcjtcblxuICAmOmhvdmVyIHtcbiAgICBmaWx0ZXI6IGJyaWdodG5lc3MoMik7XG4gIH1cbn1cblxuLmljb24gKyAuaWNvbiB7XG4gIG1hcmdpbi1sZWZ0OiAxNXB4O1xufVxuXG4ucG9wb3ZlclRleHQge1xuICBwYWRkaW5nOiA0cHggOHB4O1xuICBjb2xvcjogI2ZmZjtcbiAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgZm9udC1zaXplOiAxMnB4O1xuICBsaW5lLWhlaWdodDogMTdweDtcbiAgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7XG4gIGJvcmRlci1yYWRpdXM6IDVweDtcbn1cblxuLnBvcG92ZXIge1xuICBtYXgtaGVpZ2h0OiAyNHB4O1xuICBsaW5lLWhlaWdodDogMjRweDtcbn1cblxuLnBvcG92ZXIgKyAucG9wb3ZlciB7XG4gIHBhZGRpbmctbGVmdDogMTdweDtcbn1cbjwvc3R5bGU+XG4iLCJpbXBvcnR7bmFub2lkIGFzIGJ9ZnJvbVwibmFub2lkXCI7dmFyIGw9Z2xvYmFsVGhpcy5icm93c2VyPy5ydW50aW1lfHxnbG9iYWxUaGlzLmNocm9tZT8ucnVudGltZSxkPWdsb2JhbFRoaXMuYnJvd3Nlcj8udGFic3x8Z2xvYmFsVGhpcy5jaHJvbWU/LnRhYnMsbT0oKT0+e2lmKCFsKXRocm93IG5ldyBFcnJvcihcIkV4dGVuc2lvbiBydW50aW1lIGlzIG5vdCBhdmFpbGFibGVcIik7cmV0dXJuIGx9LGk9KCk9PntpZighZCl0aHJvdyBuZXcgRXJyb3IoXCJFeHRlbnNpb24gdGFicyBBUEkgaXMgbm90IGF2YWlsYWJsZVwiKTtyZXR1cm4gZH0sYz1hc3luYygpPT57bGV0IGU9aSgpLFthXT1hd2FpdCBlLnF1ZXJ5KHthY3RpdmU6ITAsY3VycmVudFdpbmRvdzohMH0pO3JldHVybiBhfSxnPShlLGEpPT4hYS5fX2ludGVybmFsJiZlLnNvdXJjZT09PWdsb2JhbFRoaXMud2luZG93JiZlLmRhdGEubmFtZT09PWEubmFtZSYmKGEucmVsYXlJZD09PXZvaWQgMHx8ZS5kYXRhLnJlbGF5SWQ9PT1hLnJlbGF5SWQpO3ZhciB5PShlLGEsbj1nbG9iYWxUaGlzLndpbmRvdyk9PntsZXQgcj1hc3luYyBzPT57aWYoZyhzLGUpJiYhcy5kYXRhLnJlbGF5ZWQpe2xldCBvPXtuYW1lOmUubmFtZSxyZWxheUlkOmUucmVsYXlJZCxib2R5OnMuZGF0YS5ib2R5fSx0PWF3YWl0IGE/LihvKTtuLnBvc3RNZXNzYWdlKHtuYW1lOmUubmFtZSxyZWxheUlkOmUucmVsYXlJZCxpbnN0YW5jZUlkOnMuZGF0YS5pbnN0YW5jZUlkLGJvZHk6dCxyZWxheWVkOiEwfSx7dGFyZ2V0T3JpZ2luOmUudGFyZ2V0T3JpZ2lufHxcIi9cIn0pfX07cmV0dXJuIG4uYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIixyKSwoKT0+bi5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLHIpfSxwPShlLGE9Z2xvYmFsVGhpcy53aW5kb3cpPT5uZXcgUHJvbWlzZSgobixyKT0+e2xldCBzPWIoKSxvPW5ldyBBYm9ydENvbnRyb2xsZXI7YS5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLHQ9PntnKHQsZSkmJnQuZGF0YS5yZWxheWVkJiZ0LmRhdGEuaW5zdGFuY2VJZD09PXMmJihuKHQuZGF0YS5ib2R5KSxvLmFib3J0KCkpfSx7c2lnbmFsOm8uc2lnbmFsfSksYS5wb3N0TWVzc2FnZSh7Li4uZSxpbnN0YW5jZUlkOnN9LHt0YXJnZXRPcmlnaW46ZS50YXJnZXRPcmlnaW58fFwiL1wifSl9KTt2YXIgeD1hc3luYyBlPT5tKCkuc2VuZE1lc3NhZ2UoZSksTT1hc3luYyBlPT57bGV0IGE9dHlwZW9mIGUudGFiSWQ9PVwibnVtYmVyXCI/ZS50YWJJZDooYXdhaXQgYygpKS5pZDtyZXR1cm4gaSgpLnNlbmRNZXNzYWdlKGEsZSl9LGg9TSx1PWU9PnkoZSx4KSxTPXUsdz1wLE89dztleHBvcnR7UyBhcyByZWxheSx1IGFzIHJlbGF5TWVzc2FnZSxoIGFzIHNlbmRUb0FjdGl2ZUNvbnRlbnRTY3JpcHQseCBhcyBzZW5kVG9CYWNrZ3JvdW5kLHcgYXMgc2VuZFRvQmFja2dyb3VuZFZpYVJlbGF5LE0gYXMgc2VuZFRvQ29udGVudFNjcmlwdCxPIGFzIHNlbmRWaWFSZWxheX07XG4iLCJleHBvcnQgeyB1cmxBbHBoYWJldCB9IGZyb20gJy4vdXJsLWFscGhhYmV0L2luZGV4LmpzJ1xuZXhwb3J0IGxldCByYW5kb20gPSBieXRlcyA9PiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzKSlcbmV4cG9ydCBsZXQgY3VzdG9tUmFuZG9tID0gKGFscGhhYmV0LCBkZWZhdWx0U2l6ZSwgZ2V0UmFuZG9tKSA9PiB7XG4gIGxldCBtYXNrID0gKDIgPDwgKE1hdGgubG9nKGFscGhhYmV0Lmxlbmd0aCAtIDEpIC8gTWF0aC5MTjIpKSAtIDFcbiAgbGV0IHN0ZXAgPSAtfigoMS42ICogbWFzayAqIGRlZmF1bHRTaXplKSAvIGFscGhhYmV0Lmxlbmd0aClcbiAgcmV0dXJuIChzaXplID0gZGVmYXVsdFNpemUpID0+IHtcbiAgICBsZXQgaWQgPSAnJ1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsZXQgYnl0ZXMgPSBnZXRSYW5kb20oc3RlcClcbiAgICAgIGxldCBqID0gc3RlcFxuICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICBpZCArPSBhbHBoYWJldFtieXRlc1tqXSAmIG1hc2tdIHx8ICcnXG4gICAgICAgIGlmIChpZC5sZW5ndGggPT09IHNpemUpIHJldHVybiBpZFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZXhwb3J0IGxldCBjdXN0b21BbHBoYWJldCA9IChhbHBoYWJldCwgc2l6ZSA9IDIxKSA9PlxuICBjdXN0b21SYW5kb20oYWxwaGFiZXQsIHNpemUsIHJhbmRvbSlcbmV4cG9ydCBsZXQgbmFub2lkID0gKHNpemUgPSAyMSkgPT5cbiAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShzaXplKSkucmVkdWNlKChpZCwgYnl0ZSkgPT4ge1xuICAgIGJ5dGUgJj0gNjNcbiAgICBpZiAoYnl0ZSA8IDM2KSB7XG4gICAgICBpZCArPSBieXRlLnRvU3RyaW5nKDM2KVxuICAgIH0gZWxzZSBpZiAoYnl0ZSA8IDYyKSB7XG4gICAgICBpZCArPSAoYnl0ZSAtIDI2KS50b1N0cmluZygzNikudG9VcHBlckNhc2UoKVxuICAgIH0gZWxzZSBpZiAoYnl0ZSA+IDYyKSB7XG4gICAgICBpZCArPSAnLSdcbiAgICB9IGVsc2Uge1xuICAgICAgaWQgKz0gJ18nXG4gICAgfVxuICAgIHJldHVybiBpZFxuICB9LCAnJylcbiIsImltcG9ydCB7IGlzUmVmLCB3YXRjaCwgb25Nb3VudGVkLCBvbkJlZm9yZVVubW91bnQsIHVucmVmLCByZWYsIHJlYWN0aXZlLCBuZXh0VGljaywgdG9SZWZzLCBvcGVuQmxvY2ssIGNyZWF0ZUVsZW1lbnRCbG9jaywgdXNlQ3NzVmFycywgdXNlU2xvdHMsIGNvbXB1dGVkLCB3YXRjaEVmZmVjdCwgbm9ybWFsaXplU3R5bGUsIGNyZWF0ZUVsZW1lbnRWTm9kZSwgd2l0aEtleXMsIHJlbmRlclNsb3QsIGNyZWF0ZVZOb2RlLCBUcmFuc2l0aW9uLCB3aXRoQ3R4LCB3aXRoRGlyZWN0aXZlcywgY3JlYXRlVGV4dFZOb2RlLCB0b0Rpc3BsYXlTdHJpbmcsIGNyZWF0ZUJsb2NrLCBjcmVhdGVDb21tZW50Vk5vZGUsIHZTaG93IH0gZnJvbSAndnVlJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIGFzIGxvbmcgYXMgaXQgY29udGludWVzIHRvIGJlIGludm9rZWQsIHdpbGwgbm90XG4gKiBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4gKiBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAqIGxlYWRpbmcgZWRnZSwgaW5zdGVhZCBvZiB0aGUgdHJhaWxpbmcuIFRoZSBmdW5jdGlvbiBhbHNvIGhhcyBhIHByb3BlcnR5ICdjbGVhcicgXG4gKiB0aGF0IGlzIGEgZnVuY3Rpb24gd2hpY2ggd2lsbCBjbGVhciB0aGUgdGltZXIgdG8gcHJldmVudCBwcmV2aW91c2x5IHNjaGVkdWxlZCBleGVjdXRpb25zLiBcbiAqXG4gKiBAc291cmNlIHVuZGVyc2NvcmUuanNcbiAqIEBzZWUgaHR0cDovL3Vuc2NyaXB0YWJsZS5jb20vMjAwOS8wMy8yMC9kZWJvdW5jaW5nLWphdmFzY3JpcHQtbWV0aG9kcy9cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmN0aW9uIHRvIHdyYXBcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0IGluIG1zIChgMTAwYClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gd2hldGhlciB0byBleGVjdXRlIGF0IHRoZSBiZWdpbm5pbmcgKGBmYWxzZWApXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZSQxKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSl7XG4gIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcbiAgaWYgKG51bGwgPT0gd2FpdCkgd2FpdCA9IDEwMDtcblxuICBmdW5jdGlvbiBsYXRlcigpIHtcbiAgICB2YXIgbGFzdCA9IERhdGUubm93KCkgLSB0aW1lc3RhbXA7XG5cbiAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAwKSB7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIGlmICghaW1tZWRpYXRlKSB7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGRlYm91bmNlZCA9IGZ1bmN0aW9uKCl7XG4gICAgY29udGV4dCA9IHRoaXM7XG4gICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgIGlmICghdGltZW91dCkgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgIGlmIChjYWxsTm93KSB7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgZGVib3VuY2VkLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgfTtcbiAgXG4gIGRlYm91bmNlZC5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgXG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cbi8vIEFkZHMgY29tcGF0aWJpbGl0eSBmb3IgRVMgbW9kdWxlc1xuZGVib3VuY2UkMS5kZWJvdW5jZSA9IGRlYm91bmNlJDE7XG5cbnZhciBkZWJvdW5jZV8xID0gZGVib3VuY2UkMTtcblxuZnVuY3Rpb24gdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIGV2ZW50LCBoYW5kbGVyKSB7XG4gIGlmIChpc1JlZih0YXJnZXQpKSB7XG4gICAgd2F0Y2godGFyZ2V0LCAodmFsdWUsIG9sZFZhbHVlKSA9PiB7XG4gICAgICBvbGRWYWx1ZSA9PT0gbnVsbCB8fCBvbGRWYWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2xkVmFsdWUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcik7XG4gICAgICB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcik7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb25Nb3VudGVkKCgpID0+IHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyKTtcbiAgICB9KTtcbiAgfVxuXG4gIG9uQmVmb3JlVW5tb3VudCgoKSA9PiB7XG4gICAgdmFyIF91bnJlZjtcblxuICAgIChfdW5yZWYgPSB1bnJlZih0YXJnZXQpKSA9PT0gbnVsbCB8fCBfdW5yZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF91bnJlZi5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVzZUNsaWNrQXdheSh0YXJnZXQsIGhhbmRsZXIpIHtcbiAgY29uc3QgZXZlbnQgPSBcInBvaW50ZXJkb3duXCI7XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICF3aW5kb3cpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBsaXN0ZW5lciA9IGV2ZW50ID0+IHtcbiAgICBjb25zdCBlbCA9IHVucmVmKHRhcmdldCk7XG5cbiAgICBpZiAoIWVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsID09PSBldmVudC50YXJnZXQgfHwgZXZlbnQuY29tcG9zZWRQYXRoKCkuaW5jbHVkZXMoZWwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaGFuZGxlcihldmVudCk7XG4gIH07XG5cbiAgcmV0dXJuIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBldmVudCwgbGlzdGVuZXIpO1xufVxuXG5mdW5jdGlvbiB1c2VDb250ZW50KHNsb3RzLCBwb3BwZXJOb2RlLCBjb250ZW50KSB7XG4gIGxldCBvYnNlcnZlciA9IG51bGw7XG4gIGNvbnN0IGhhc0NvbnRlbnQgPSByZWYoZmFsc2UpO1xuICBvbk1vdW50ZWQoKCkgPT4ge1xuICAgIGlmIChzbG90cy5jb250ZW50ICE9PSB1bmRlZmluZWQgfHwgY29udGVudC52YWx1ZSkge1xuICAgICAgaGFzQ29udGVudC52YWx1ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihjaGVja0NvbnRlbnQpO1xuICAgIG9ic2VydmVyLm9ic2VydmUocG9wcGVyTm9kZS52YWx1ZSwge1xuICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgc3VidHJlZTogdHJ1ZVxuICAgIH0pO1xuICB9KTtcbiAgb25CZWZvcmVVbm1vdW50KCgpID0+IG9ic2VydmVyLmRpc2Nvbm5lY3QoKSk7XG4gIC8qKlxuICAgKiBXYXRjaCB0aGUgY29udGVudCBwcm9wXG4gICAqL1xuXG4gIHdhdGNoKGNvbnRlbnQsIGNvbnRlbnQgPT4ge1xuICAgIGlmIChjb250ZW50KSB7XG4gICAgICBoYXNDb250ZW50LnZhbHVlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFzQ29udGVudC52YWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBDaGVjayB0aGUgY29udGVudCBzbG90XG4gICAqL1xuXG4gIGNvbnN0IGNoZWNrQ29udGVudCA9ICgpID0+IHtcbiAgICBpZiAoc2xvdHMuY29udGVudCkge1xuICAgICAgaGFzQ29udGVudC52YWx1ZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhc0NvbnRlbnQudmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBoYXNDb250ZW50XG4gIH07XG59XG5cbi8vIGltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tICcuL2luc3RhbmNlT2YnO1xuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bnVzZWQtaW1wb3J0cy9uby11bnVzZWQtdmFyc1xuaW5jbHVkZVNjYWxlKSB7XG5cbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgc2NhbGVYID0gMTtcbiAgdmFyIHNjYWxlWSA9IDE7IC8vIEZJWE1FOlxuICAvLyBgb2Zmc2V0V2lkdGhgIHJldHVybnMgYW4gaW50ZWdlciB3aGlsZSBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YFxuICAvLyByZXR1cm5zIGEgZmxvYXQuIFRoaXMgcmVzdWx0cyBpbiBgc2NhbGVYYCBvciBgc2NhbGVZYCBiZWluZ1xuICAvLyBub24tMSB3aGVuIGl0IHNob3VsZCBiZSBmb3IgZWxlbWVudHMgdGhhdCBhcmVuJ3QgYSBmdWxsIHBpeGVsIGluXG4gIC8vIHdpZHRoIG9yIGhlaWdodC5cbiAgLy8gaWYgKGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgJiYgaW5jbHVkZVNjYWxlKSB7XG4gIC8vICAgY29uc3Qgb2Zmc2V0SGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gIC8vICAgY29uc3Qgb2Zmc2V0V2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICAvLyAgIC8vIERvIG5vdCBhdHRlbXB0IHRvIGRpdmlkZSBieSAwLCBvdGhlcndpc2Ugd2UgZ2V0IGBJbmZpbml0eWAgYXMgc2NhbGVcbiAgLy8gICAvLyBGYWxsYmFjayB0byAxIGluIGNhc2UgYm90aCB2YWx1ZXMgYXJlIGAwYFxuICAvLyAgIGlmIChvZmZzZXRXaWR0aCA+IDApIHtcbiAgLy8gICAgIHNjYWxlWCA9IHJlY3Qud2lkdGggLyBvZmZzZXRXaWR0aCB8fCAxO1xuICAvLyAgIH1cbiAgLy8gICBpZiAob2Zmc2V0SGVpZ2h0ID4gMCkge1xuICAvLyAgICAgc2NhbGVZID0gcmVjdC5oZWlnaHQgLyBvZmZzZXRIZWlnaHQgfHwgMTtcbiAgLy8gICB9XG4gIC8vIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiByZWN0LndpZHRoIC8gc2NhbGVYLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHQgLyBzY2FsZVksXG4gICAgdG9wOiByZWN0LnRvcCAvIHNjYWxlWSxcbiAgICByaWdodDogcmVjdC5yaWdodCAvIHNjYWxlWCxcbiAgICBib3R0b206IHJlY3QuYm90dG9tIC8gc2NhbGVZLFxuICAgIGxlZnQ6IHJlY3QubGVmdCAvIHNjYWxlWCxcbiAgICB4OiByZWN0LmxlZnQgLyBzY2FsZVgsXG4gICAgeTogcmVjdC50b3AgLyBzY2FsZVlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBpZiAobm9kZS50b1N0cmluZygpICE9PSAnW29iamVjdCBXaW5kb3ddJykge1xuICAgIHZhciBvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cgOiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsKG5vZGUpIHtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhub2RlKTtcbiAgdmFyIHNjcm9sbExlZnQgPSB3aW4ucGFnZVhPZmZzZXQ7XG4gIHZhciBzY3JvbGxUb3AgPSB3aW4ucGFnZVlPZmZzZXQ7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3A6IHNjcm9sbFRvcFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0VsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5FbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5IVE1MRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNTaGFkb3dSb290KG5vZGUpIHtcbiAgLy8gSUUgMTEgaGFzIG5vIFNoYWRvd1Jvb3RcbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLlNoYWRvd1Jvb3Q7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdDtcbn1cblxuZnVuY3Rpb24gZ2V0SFRNTEVsZW1lbnRTY3JvbGwoZWxlbWVudCkge1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3A6IGVsZW1lbnQuc2Nyb2xsVG9wXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldE5vZGVTY3JvbGwobm9kZSkge1xuICBpZiAobm9kZSA9PT0gZ2V0V2luZG93KG5vZGUpIHx8ICFpc0hUTUxFbGVtZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIGdldFdpbmRvd1Njcm9sbChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2V0SFRNTEVsZW1lbnRTY3JvbGwobm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZU5hbWUoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudCA/IChlbGVtZW50Lm5vZGVOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIHtcbiAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICByZXR1cm4gKChpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQgOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgZWxlbWVudC5kb2N1bWVudCkgfHwgd2luZG93LmRvY3VtZW50KS5kb2N1bWVudEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCkge1xuICAvLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXG4gIC8vIGluY29ycmVjdCBmb3IgUlRMLlxuICAvLyBQb3BwZXIgMSBpcyBicm9rZW4gaW4gdGhpcyBjYXNlIGFuZCBuZXZlciBoYWQgYSBidWcgcmVwb3J0IHNvIGxldCdzIGFzc3VtZVxuICAvLyBpdCdzIG5vdCBhbiBpc3N1ZS4gSSBkb24ndCB0aGluayBhbnlvbmUgZXZlciBzcGVjaWZpZXMgd2lkdGggb24gPGh0bWw+XG4gIC8vIGFueXdheS5cbiAgLy8gQnJvd3NlcnMgd2hlcmUgdGhlIGxlZnQgc2Nyb2xsYmFyIGRvZXNuJ3QgY2F1c2UgYW4gaXNzdWUgcmVwb3J0IGAwYCBmb3JcbiAgLy8gdGhpcyAoZS5nLiBFZGdlIDIwMTksIElFMTEsIFNhZmFyaSlcbiAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpLmxlZnQgKyBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCkuc2Nyb2xsTGVmdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gaXNTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBGaXJlZm94IHdhbnRzIHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG4gIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dZO1xuXG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpO1xufVxuXG5mdW5jdGlvbiBpc0VsZW1lbnRTY2FsZWQoZWxlbWVudCkge1xuICB2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBzY2FsZVggPSByZWN0LndpZHRoIC8gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAxO1xuICB2YXIgc2NhbGVZID0gcmVjdC5oZWlnaHQgLyBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAxO1xuICByZXR1cm4gc2NhbGVYICE9PSAxIHx8IHNjYWxlWSAhPT0gMTtcbn0gLy8gUmV0dXJucyB0aGUgY29tcG9zaXRlIHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50LlxuLy8gQ29tcG9zaXRlIG1lYW5zIGl0IHRha2VzIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zIGFzIHdlbGwgYXMgbGF5b3V0LlxuXG5cbmZ1bmN0aW9uIGdldENvbXBvc2l0ZVJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudCwgaXNGaXhlZCkge1xuICBpZiAoaXNGaXhlZCA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgaXNFbGVtZW50U2NhbGVkKG9mZnNldFBhcmVudCk7XG4gIHZhciBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQpO1xuICB2YXIgc2Nyb2xsID0ge1xuICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwXG4gIH07XG4gIHZhciBvZmZzZXRzID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTA3OFxuICAgIGlzU2Nyb2xsUGFyZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG5cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBvZmZzZXRzID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCk7XG4gICAgICBvZmZzZXRzLnggKz0gb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgKz0gb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50RWxlbWVudCkge1xuICAgICAgb2Zmc2V0cy54ID0gZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogcmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSBvZmZzZXRzLngsXG4gICAgeTogcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55LFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgfTtcbn1cblxuLy8gbWVhbnMgaXQgZG9lc24ndCB0YWtlIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zLlxuXG5mdW5jdGlvbiBnZXRMYXlvdXRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCk7IC8vIFVzZSB0aGUgY2xpZW50UmVjdCBzaXplcyBpZiBpdCdzIG5vdCBiZWVuIHRyYW5zZm9ybWVkLlxuICAvLyBGaXhlcyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEyMjNcblxuICB2YXIgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3Qud2lkdGggLSB3aWR0aCkgPD0gMSkge1xuICAgIHdpZHRoID0gY2xpZW50UmVjdC53aWR0aDtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyhjbGllbnRSZWN0LmhlaWdodCAtIGhlaWdodCkgPD0gMSkge1xuICAgIGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBlbGVtZW50Lm9mZnNldExlZnQsXG4gICAgeTogZWxlbWVudC5vZmZzZXRUb3AsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudCkge1xuICBpZiAoZ2V0Tm9kZU5hbWUoZWxlbWVudCkgPT09ICdodG1sJykge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuICgvLyB0aGlzIGlzIGEgcXVpY2tlciAoYnV0IGxlc3MgdHlwZSBzYWZlKSB3YXkgdG8gc2F2ZSBxdWl0ZSBzb21lIGJ5dGVzIGZyb20gdGhlIGJ1bmRsZVxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cbiAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICBlbGVtZW50LmFzc2lnbmVkU2xvdCB8fCAvLyBzdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZVxuICAgIGVsZW1lbnQucGFyZW50Tm9kZSB8fCAoIC8vIERPTSBFbGVtZW50IGRldGVjdGVkXG4gICAgaXNTaGFkb3dSb290KGVsZW1lbnQpID8gZWxlbWVudC5ob3N0IDogbnVsbCkgfHwgLy8gU2hhZG93Um9vdCBkZXRlY3RlZFxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBIVE1MRWxlbWVudCBpcyBhIE5vZGVcbiAgICBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkgLy8gZmFsbGJhY2tcblxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQobm9kZSkge1xuICBpZiAoWydodG1sJywgJ2JvZHknLCAnI2RvY3VtZW50J10uaW5kZXhPZihnZXROb2RlTmFtZShub2RlKSkgPj0gMCkge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50LmJvZHk7XG4gIH1cblxuICBpZiAoaXNIVE1MRWxlbWVudChub2RlKSAmJiBpc1Njcm9sbFBhcmVudChub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcmV0dXJuIGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKG5vZGUpKTtcbn1cblxuLypcbmdpdmVuIGEgRE9NIGVsZW1lbnQsIHJldHVybiB0aGUgbGlzdCBvZiBhbGwgc2Nyb2xsIHBhcmVudHMsIHVwIHRoZSBsaXN0IG9mIGFuY2Vzb3JzXG51bnRpbCB3ZSBnZXQgdG8gdGhlIHRvcCB3aW5kb3cgb2JqZWN0LiBUaGlzIGxpc3QgaXMgd2hhdCB3ZSBhdHRhY2ggc2Nyb2xsIGxpc3RlbmVyc1xudG8sIGJlY2F1c2UgaWYgYW55IG9mIHRoZXNlIHBhcmVudCBlbGVtZW50cyBzY3JvbGwsIHdlJ2xsIG5lZWQgdG8gcmUtY2FsY3VsYXRlIHRoZVxucmVmZXJlbmNlIGVsZW1lbnQncyBwb3NpdGlvbi5cbiovXG5cbmZ1bmN0aW9uIGxpc3RTY3JvbGxQYXJlbnRzKGVsZW1lbnQsIGxpc3QpIHtcbiAgdmFyIF9lbGVtZW50JG93bmVyRG9jdW1lbjtcblxuICBpZiAobGlzdCA9PT0gdm9pZCAwKSB7XG4gICAgbGlzdCA9IFtdO1xuICB9XG5cbiAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChlbGVtZW50KTtcbiAgdmFyIGlzQm9keSA9IHNjcm9sbFBhcmVudCA9PT0gKChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keSk7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3coc2Nyb2xsUGFyZW50KTtcbiAgdmFyIHRhcmdldCA9IGlzQm9keSA/IFt3aW5dLmNvbmNhdCh3aW4udmlzdWFsVmlld3BvcnQgfHwgW10sIGlzU2Nyb2xsUGFyZW50KHNjcm9sbFBhcmVudCkgPyBzY3JvbGxQYXJlbnQgOiBbXSkgOiBzY3JvbGxQYXJlbnQ7XG4gIHZhciB1cGRhdGVkTGlzdCA9IGxpc3QuY29uY2F0KHRhcmdldCk7XG4gIHJldHVybiBpc0JvZHkgPyB1cGRhdGVkTGlzdCA6IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBpc0JvZHkgdGVsbHMgdXMgdGFyZ2V0IHdpbGwgYmUgYW4gSFRNTEVsZW1lbnQgaGVyZVxuICB1cGRhdGVkTGlzdC5jb25jYXQobGlzdFNjcm9sbFBhcmVudHMoZ2V0UGFyZW50Tm9kZSh0YXJnZXQpKSk7XG59XG5cbmZ1bmN0aW9uIGlzVGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFsndGFibGUnLCAndGQnLCAndGgnXS5pbmRleE9mKGdldE5vZGVOYW1lKGVsZW1lbnQpKSA+PSAwO1xufVxuXG5mdW5jdGlvbiBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvODM3XG4gIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50Lm9mZnNldFBhcmVudDtcbn0gLy8gYC5vZmZzZXRQYXJlbnRgIHJlcG9ydHMgYG51bGxgIGZvciBmaXhlZCBlbGVtZW50cywgd2hpbGUgYWJzb2x1dGUgZWxlbWVudHNcbi8vIHJldHVybiB0aGUgY29udGFpbmluZyBibG9ja1xuXG5cbmZ1bmN0aW9uIGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB7XG4gIHZhciBpc0ZpcmVmb3ggPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZmlyZWZveCcpICE9PSAtMTtcbiAgdmFyIGlzSUUgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1RyaWRlbnQnKSAhPT0gLTE7XG5cbiAgaWYgKGlzSUUgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIC8vIEluIElFIDksIDEwIGFuZCAxMSBmaXhlZCBlbGVtZW50cyBjb250YWluaW5nIGJsb2NrIGlzIGFsd2F5cyBlc3RhYmxpc2hlZCBieSB0aGUgdmlld3BvcnRcbiAgICB2YXIgZWxlbWVudENzcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cbiAgICBpZiAoZWxlbWVudENzcy5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgdmFyIGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcblxuICB3aGlsZSAoaXNIVE1MRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgWydodG1sJywgJ2JvZHknXS5pbmRleE9mKGdldE5vZGVOYW1lKGN1cnJlbnROb2RlKSkgPCAwKSB7XG4gICAgdmFyIGNzcyA9IGdldENvbXB1dGVkU3R5bGUoY3VycmVudE5vZGUpOyAvLyBUaGlzIGlzIG5vbi1leGhhdXN0aXZlIGJ1dCBjb3ZlcnMgdGhlIG1vc3QgY29tbW9uIENTUyBwcm9wZXJ0aWVzIHRoYXRcbiAgICAvLyBjcmVhdGUgYSBjb250YWluaW5nIGJsb2NrLlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Db250YWluaW5nX2Jsb2NrI2lkZW50aWZ5aW5nX3RoZV9jb250YWluaW5nX2Jsb2NrXG5cbiAgICBpZiAoY3NzLnRyYW5zZm9ybSAhPT0gJ25vbmUnIHx8IGNzcy5wZXJzcGVjdGl2ZSAhPT0gJ25vbmUnIHx8IGNzcy5jb250YWluID09PSAncGFpbnQnIHx8IFsndHJhbnNmb3JtJywgJ3BlcnNwZWN0aXZlJ10uaW5kZXhPZihjc3Mud2lsbENoYW5nZSkgIT09IC0xIHx8IGlzRmlyZWZveCAmJiBjc3Mud2lsbENoYW5nZSA9PT0gJ2ZpbHRlcicgfHwgaXNGaXJlZm94ICYmIGNzcy5maWx0ZXIgJiYgY3NzLmZpbHRlciAhPT0gJ25vbmUnKSB7XG4gICAgICByZXR1cm4gY3VycmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn0gLy8gR2V0cyB0aGUgY2xvc2VzdCBhbmNlc3RvciBwb3NpdGlvbmVkIGVsZW1lbnQuIEhhbmRsZXMgc29tZSBlZGdlIGNhc2VzLFxuLy8gc3VjaCBhcyB0YWJsZSBhbmNlc3RvcnMgYW5kIGNyb3NzIGJyb3dzZXIgYnVncy5cblxuXG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICB2YXIgd2luZG93ID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KTtcblxuICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIGlzVGFibGVFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50KTtcbiAgfVxuXG4gIGlmIChvZmZzZXRQYXJlbnQgJiYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdodG1sJyB8fCBnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnYm9keScgJiYgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldFBhcmVudCB8fCBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkgfHwgd2luZG93O1xufVxuXG52YXIgdG9wID0gJ3RvcCc7XG52YXIgYm90dG9tID0gJ2JvdHRvbSc7XG52YXIgcmlnaHQgPSAncmlnaHQnO1xudmFyIGxlZnQgPSAnbGVmdCc7XG52YXIgYXV0byA9ICdhdXRvJztcbnZhciBiYXNlUGxhY2VtZW50cyA9IFt0b3AsIGJvdHRvbSwgcmlnaHQsIGxlZnRdO1xudmFyIHN0YXJ0ID0gJ3N0YXJ0JztcbnZhciBlbmQgPSAnZW5kJztcbnZhciBjbGlwcGluZ1BhcmVudHMgPSAnY2xpcHBpbmdQYXJlbnRzJztcbnZhciB2aWV3cG9ydCA9ICd2aWV3cG9ydCc7XG52YXIgcG9wcGVyID0gJ3BvcHBlcic7XG52YXIgcmVmZXJlbmNlID0gJ3JlZmVyZW5jZSc7XG52YXIgdmFyaWF0aW9uUGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9iYXNlUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xufSwgW10pO1xudmFyIHBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovW10uY29uY2F0KGJhc2VQbGFjZW1lbnRzLCBbYXV0b10pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIGFjYy5jb25jYXQoW3BsYWNlbWVudCwgcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbn0sIFtdKTsgLy8gbW9kaWZpZXJzIHRoYXQgbmVlZCB0byByZWFkIHRoZSBET01cblxudmFyIGJlZm9yZVJlYWQgPSAnYmVmb3JlUmVhZCc7XG52YXIgcmVhZCA9ICdyZWFkJztcbnZhciBhZnRlclJlYWQgPSAnYWZ0ZXJSZWFkJzsgLy8gcHVyZS1sb2dpYyBtb2RpZmllcnNcblxudmFyIGJlZm9yZU1haW4gPSAnYmVmb3JlTWFpbic7XG52YXIgbWFpbiA9ICdtYWluJztcbnZhciBhZnRlck1haW4gPSAnYWZ0ZXJNYWluJzsgLy8gbW9kaWZpZXIgd2l0aCB0aGUgcHVycG9zZSB0byB3cml0ZSB0byB0aGUgRE9NIChvciB3cml0ZSBpbnRvIGEgZnJhbWV3b3JrIHN0YXRlKVxuXG52YXIgYmVmb3JlV3JpdGUgPSAnYmVmb3JlV3JpdGUnO1xudmFyIHdyaXRlID0gJ3dyaXRlJztcbnZhciBhZnRlcldyaXRlID0gJ2FmdGVyV3JpdGUnO1xudmFyIG1vZGlmaWVyUGhhc2VzID0gW2JlZm9yZVJlYWQsIHJlYWQsIGFmdGVyUmVhZCwgYmVmb3JlTWFpbiwgbWFpbiwgYWZ0ZXJNYWluLCBiZWZvcmVXcml0ZSwgd3JpdGUsIGFmdGVyV3JpdGVdO1xuXG5mdW5jdGlvbiBvcmRlcihtb2RpZmllcnMpIHtcbiAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgbWFwLnNldChtb2RpZmllci5uYW1lLCBtb2RpZmllcik7XG4gIH0pOyAvLyBPbiB2aXNpdGluZyBvYmplY3QsIGNoZWNrIGZvciBpdHMgZGVwZW5kZW5jaWVzIGFuZCB2aXNpdCB0aGVtIHJlY3Vyc2l2ZWx5XG5cbiAgZnVuY3Rpb24gc29ydChtb2RpZmllcikge1xuICAgIHZpc2l0ZWQuYWRkKG1vZGlmaWVyLm5hbWUpO1xuICAgIHZhciByZXF1aXJlcyA9IFtdLmNvbmNhdChtb2RpZmllci5yZXF1aXJlcyB8fCBbXSwgbW9kaWZpZXIucmVxdWlyZXNJZkV4aXN0cyB8fCBbXSk7XG4gICAgcmVxdWlyZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKGRlcCkpIHtcbiAgICAgICAgdmFyIGRlcE1vZGlmaWVyID0gbWFwLmdldChkZXApO1xuXG4gICAgICAgIGlmIChkZXBNb2RpZmllcikge1xuICAgICAgICAgIHNvcnQoZGVwTW9kaWZpZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVzdWx0LnB1c2gobW9kaWZpZXIpO1xuICB9XG5cbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgaWYgKCF2aXNpdGVkLmhhcyhtb2RpZmllci5uYW1lKSkge1xuICAgICAgLy8gY2hlY2sgZm9yIHZpc2l0ZWQgb2JqZWN0XG4gICAgICBzb3J0KG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBvcmRlck1vZGlmaWVycyhtb2RpZmllcnMpIHtcbiAgLy8gb3JkZXIgYmFzZWQgb24gZGVwZW5kZW5jaWVzXG4gIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXIobW9kaWZpZXJzKTsgLy8gb3JkZXIgYmFzZWQgb24gcGhhc2VcblxuICByZXR1cm4gbW9kaWZpZXJQaGFzZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBoYXNlKSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQob3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICByZXR1cm4gbW9kaWZpZXIucGhhc2UgPT09IHBoYXNlO1xuICAgIH0pKTtcbiAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiBkZWJvdW5jZShmbikge1xuICB2YXIgcGVuZGluZztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXBlbmRpbmcpIHtcbiAgICAgIHBlbmRpbmcgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwZW5kaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHJlc29sdmUoZm4oKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBlbmRpbmc7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VCeU5hbWUobW9kaWZpZXJzKSB7XG4gIHZhciBtZXJnZWQgPSBtb2RpZmllcnMucmVkdWNlKGZ1bmN0aW9uIChtZXJnZWQsIGN1cnJlbnQpIHtcbiAgICB2YXIgZXhpc3RpbmcgPSBtZXJnZWRbY3VycmVudC5uYW1lXTtcbiAgICBtZXJnZWRbY3VycmVudC5uYW1lXSA9IGV4aXN0aW5nID8gT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcsIGN1cnJlbnQsIHtcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLm9wdGlvbnMsIGN1cnJlbnQub3B0aW9ucyksXG4gICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZy5kYXRhLCBjdXJyZW50LmRhdGEpXG4gICAgfSkgOiBjdXJyZW50O1xuICAgIHJldHVybiBtZXJnZWQ7XG4gIH0sIHt9KTsgLy8gSUUxMSBkb2VzIG5vdCBzdXBwb3J0IE9iamVjdC52YWx1ZXNcblxuICByZXR1cm4gT2JqZWN0LmtleXMobWVyZ2VkKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBtZXJnZWRba2V5XTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFZpZXdwb3J0UmVjdChlbGVtZW50KSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIHZhciB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgdmFyIHggPSAwO1xuICB2YXIgeSA9IDA7IC8vIE5COiBUaGlzIGlzbid0IHN1cHBvcnRlZCBvbiBpT1MgPD0gMTIuIElmIHRoZSBrZXlib2FyZCBpcyBvcGVuLCB0aGUgcG9wcGVyXG4gIC8vIGNhbiBiZSBvYnNjdXJlZCB1bmRlcm5lYXRoIGl0LlxuICAvLyBBbHNvLCBgaHRtbC5jbGllbnRIZWlnaHRgIGFkZHMgdGhlIGJvdHRvbSBiYXIgaGVpZ2h0IGluIFNhZmFyaSBpT1MsIGV2ZW5cbiAgLy8gaWYgaXQgaXNuJ3Qgb3Blbiwgc28gaWYgdGhpcyBpc24ndCBhdmFpbGFibGUsIHRoZSBwb3BwZXIgd2lsbCBiZSBkZXRlY3RlZFxuICAvLyB0byBvdmVyZmxvdyB0aGUgYm90dG9tIG9mIHRoZSBzY3JlZW4gdG9vIGVhcmx5LlxuXG4gIGlmICh2aXN1YWxWaWV3cG9ydCkge1xuICAgIHdpZHRoID0gdmlzdWFsVmlld3BvcnQud2lkdGg7XG4gICAgaGVpZ2h0ID0gdmlzdWFsVmlld3BvcnQuaGVpZ2h0OyAvLyBVc2VzIExheW91dCBWaWV3cG9ydCAobGlrZSBDaHJvbWU7IFNhZmFyaSBkb2VzIG5vdCBjdXJyZW50bHkpXG4gICAgLy8gSW4gQ2hyb21lLCBpdCByZXR1cm5zIGEgdmFsdWUgdmVyeSBjbG9zZSB0byAwICgrLy0pIGJ1dCBjb250YWlucyByb3VuZGluZ1xuICAgIC8vIGVycm9ycyBkdWUgdG8gZmxvYXRpbmcgcG9pbnQgbnVtYmVycywgc28gd2UgbmVlZCB0byBjaGVjayBwcmVjaXNpb24uXG4gICAgLy8gU2FmYXJpIHJldHVybnMgYSBudW1iZXIgPD0gMCwgdXN1YWxseSA8IC0xIHdoZW4gcGluY2gtem9vbWVkXG4gICAgLy8gRmVhdHVyZSBkZXRlY3Rpb24gZmFpbHMgaW4gbW9iaWxlIGVtdWxhdGlvbiBtb2RlIGluIENocm9tZS5cbiAgICAvLyBNYXRoLmFicyh3aW4uaW5uZXJXaWR0aCAvIHZpc3VhbFZpZXdwb3J0LnNjYWxlIC0gdmlzdWFsVmlld3BvcnQud2lkdGgpIDxcbiAgICAvLyAwLjAwMVxuICAgIC8vIEZhbGxiYWNrIGhlcmU6IFwiTm90IFNhZmFyaVwiIHVzZXJBZ2VudFxuXG4gICAgaWYgKCEvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcbiAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCksXG4gICAgeTogeVxuICB9O1xufVxuXG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuXG4vLyBvZiB0aGUgYDxodG1sPmAgYW5kIGA8Ym9keT5gIHJlY3QgYm91bmRzIGlmIGhvcml6b250YWxseSBzY3JvbGxhYmxlXG5cbmZ1bmN0aW9uIGdldERvY3VtZW50UmVjdChlbGVtZW50KSB7XG4gIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XG5cbiAgdmFyIGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIHZhciB3aW5TY3JvbGwgPSBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCk7XG4gIHZhciBib2R5ID0gKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5O1xuICB2YXIgd2lkdGggPSBtYXgoaHRtbC5zY3JvbGxXaWR0aCwgaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuc2Nyb2xsV2lkdGggOiAwLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApO1xuICB2YXIgaGVpZ2h0ID0gbWF4KGh0bWwuc2Nyb2xsSGVpZ2h0LCBodG1sLmNsaWVudEhlaWdodCwgYm9keSA/IGJvZHkuc2Nyb2xsSGVpZ2h0IDogMCwgYm9keSA/IGJvZHkuY2xpZW50SGVpZ2h0IDogMCk7XG4gIHZhciB4ID0gLXdpblNjcm9sbC5zY3JvbGxMZWZ0ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KTtcbiAgdmFyIHkgPSAtd2luU2Nyb2xsLnNjcm9sbFRvcDtcblxuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShib2R5IHx8IGh0bWwpLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICB4ICs9IG1heChodG1sLmNsaWVudFdpZHRoLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApIC0gd2lkdGg7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnMocGFyZW50LCBjaGlsZCkge1xuICB2YXIgcm9vdE5vZGUgPSBjaGlsZC5nZXRSb290Tm9kZSAmJiBjaGlsZC5nZXRSb290Tm9kZSgpOyAvLyBGaXJzdCwgYXR0ZW1wdCB3aXRoIGZhc3RlciBuYXRpdmUgbWV0aG9kXG5cbiAgaWYgKHBhcmVudC5jb250YWlucyhjaGlsZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyB0aGVuIGZhbGxiYWNrIHRvIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiB3aXRoIFNoYWRvdyBET00gc3VwcG9ydFxuICBlbHNlIGlmIChyb290Tm9kZSAmJiBpc1NoYWRvd1Jvb3Qocm9vdE5vZGUpKSB7XG4gICAgICB2YXIgbmV4dCA9IGNoaWxkO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChuZXh0ICYmIHBhcmVudC5pc1NhbWVOb2RlKG5leHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddOiBuZWVkIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcy4uLlxuXG5cbiAgICAgICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZSB8fCBuZXh0Lmhvc3Q7XG4gICAgICB9IHdoaWxlIChuZXh0KTtcbiAgICB9IC8vIEdpdmUgdXAsIHRoZSByZXN1bHQgaXMgZmFsc2VcblxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVjdFRvQ2xpZW50UmVjdChyZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCByZWN0LCB7XG4gICAgbGVmdDogcmVjdC54LFxuICAgIHRvcDogcmVjdC55LFxuICAgIHJpZ2h0OiByZWN0LnggKyByZWN0LndpZHRoLFxuICAgIGJvdHRvbTogcmVjdC55ICsgcmVjdC5oZWlnaHRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCk7XG4gIHJlY3QudG9wID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgcmVjdC5sZWZ0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LndpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC5oZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC54ID0gcmVjdC5sZWZ0O1xuICByZWN0LnkgPSByZWN0LnRvcDtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50KSB7XG4gIHJldHVybiBjbGlwcGluZ1BhcmVudCA9PT0gdmlld3BvcnQgPyByZWN0VG9DbGllbnRSZWN0KGdldFZpZXdwb3J0UmVjdChlbGVtZW50KSkgOiBpc0hUTUxFbGVtZW50KGNsaXBwaW5nUGFyZW50KSA/IGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGNsaXBwaW5nUGFyZW50KSA6IHJlY3RUb0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkpO1xufSAvLyBBIFwiY2xpcHBpbmcgcGFyZW50XCIgaXMgYW4gb3ZlcmZsb3dhYmxlIGNvbnRhaW5lciB3aXRoIHRoZSBjaGFyYWN0ZXJpc3RpYyBvZlxuLy8gY2xpcHBpbmcgKG9yIGhpZGluZykgb3ZlcmZsb3dpbmcgZWxlbWVudHMgd2l0aCBhIHBvc2l0aW9uIGRpZmZlcmVudCBmcm9tXG4vLyBgaW5pdGlhbGBcblxuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkge1xuICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gbGlzdFNjcm9sbFBhcmVudHMoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG4gIHZhciBjYW5Fc2NhcGVDbGlwcGluZyA9IFsnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmRleE9mKGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24pID49IDA7XG4gIHZhciBjbGlwcGVyRWxlbWVudCA9IGNhbkVzY2FwZUNsaXBwaW5nICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgPyBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkgOiBlbGVtZW50O1xuXG4gIGlmICghaXNFbGVtZW50KGNsaXBwZXJFbGVtZW50KSkge1xuICAgIHJldHVybiBbXTtcbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMTQxNFxuXG5cbiAgcmV0dXJuIGNsaXBwaW5nUGFyZW50cy5maWx0ZXIoZnVuY3Rpb24gKGNsaXBwaW5nUGFyZW50KSB7XG4gICAgcmV0dXJuIGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgJiYgY29udGFpbnMoY2xpcHBpbmdQYXJlbnQsIGNsaXBwZXJFbGVtZW50KSAmJiBnZXROb2RlTmFtZShjbGlwcGluZ1BhcmVudCkgIT09ICdib2R5JztcbiAgfSk7XG59IC8vIEdldHMgdGhlIG1heGltdW0gYXJlYSB0aGF0IHRoZSBlbGVtZW50IGlzIHZpc2libGUgaW4gZHVlIHRvIGFueSBudW1iZXIgb2Zcbi8vIGNsaXBwaW5nIHBhcmVudHNcblxuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ1JlY3QoZWxlbWVudCwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSkge1xuICB2YXIgbWFpbkNsaXBwaW5nUGFyZW50cyA9IGJvdW5kYXJ5ID09PSAnY2xpcHBpbmdQYXJlbnRzJyA/IGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSA6IFtdLmNvbmNhdChib3VuZGFyeSk7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBbXS5jb25jYXQobWFpbkNsaXBwaW5nUGFyZW50cywgW3Jvb3RCb3VuZGFyeV0pO1xuICB2YXIgZmlyc3RDbGlwcGluZ1BhcmVudCA9IGNsaXBwaW5nUGFyZW50c1swXTtcbiAgdmFyIGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nUGFyZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjY1JlY3QsIGNsaXBwaW5nUGFyZW50KSB7XG4gICAgdmFyIHJlY3QgPSBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCk7XG4gICAgYWNjUmVjdC50b3AgPSBtYXgocmVjdC50b3AsIGFjY1JlY3QudG9wKTtcbiAgICBhY2NSZWN0LnJpZ2h0ID0gbWluKHJlY3QucmlnaHQsIGFjY1JlY3QucmlnaHQpO1xuICAgIGFjY1JlY3QuYm90dG9tID0gbWluKHJlY3QuYm90dG9tLCBhY2NSZWN0LmJvdHRvbSk7XG4gICAgYWNjUmVjdC5sZWZ0ID0gbWF4KHJlY3QubGVmdCwgYWNjUmVjdC5sZWZ0KTtcbiAgICByZXR1cm4gYWNjUmVjdDtcbiAgfSwgZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgZmlyc3RDbGlwcGluZ1BhcmVudCkpO1xuICBjbGlwcGluZ1JlY3Qud2lkdGggPSBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdDtcbiAgY2xpcHBpbmdSZWN0LmhlaWdodCA9IGNsaXBwaW5nUmVjdC5ib3R0b20gLSBjbGlwcGluZ1JlY3QudG9wO1xuICBjbGlwcGluZ1JlY3QueCA9IGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QueSA9IGNsaXBwaW5nUmVjdC50b3A7XG4gIHJldHVybiBjbGlwcGluZ1JlY3Q7XG59XG5cbmZ1bmN0aW9uIGdldFZhcmlhdGlvbihwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xufVxuXG5mdW5jdGlvbiBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgPj0gMCA/ICd4JyA6ICd5Jztcbn1cblxuZnVuY3Rpb24gY29tcHV0ZU9mZnNldHMoX3JlZikge1xuICB2YXIgcmVmZXJlbmNlID0gX3JlZi5yZWZlcmVuY2UsXG4gICAgICBlbGVtZW50ID0gX3JlZi5lbGVtZW50LFxuICAgICAgcGxhY2VtZW50ID0gX3JlZi5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50ID8gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIDogbnVsbDtcbiAgdmFyIHZhcmlhdGlvbiA9IHBsYWNlbWVudCA/IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpIDogbnVsbDtcbiAgdmFyIGNvbW1vblggPSByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCAvIDIgLSBlbGVtZW50LndpZHRoIC8gMjtcbiAgdmFyIGNvbW1vblkgPSByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHQgLyAyIC0gZWxlbWVudC5oZWlnaHQgLyAyO1xuICB2YXIgb2Zmc2V0cztcblxuICBzd2l0Y2ggKGJhc2VQbGFjZW1lbnQpIHtcbiAgICBjYXNlIHRvcDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55IC0gZWxlbWVudC5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgYm90dG9tOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHJpZ2h0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgbGVmdDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54IC0gZWxlbWVudC53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54LFxuICAgICAgICB5OiByZWZlcmVuY2UueVxuICAgICAgfTtcbiAgfVxuXG4gIHZhciBtYWluQXhpcyA9IGJhc2VQbGFjZW1lbnQgPyBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCkgOiBudWxsO1xuXG4gIGlmIChtYWluQXhpcyAhPSBudWxsKSB7XG4gICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICBzd2l0Y2ggKHZhcmlhdGlvbikge1xuICAgICAgY2FzZSBzdGFydDpcbiAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPSBvZmZzZXRzW21haW5BeGlzXSAtIChyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgZW5kOlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdICsgKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuZnVuY3Rpb24gZ2V0RnJlc2hTaWRlT2JqZWN0KCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMFxuICB9O1xufVxuXG5mdW5jdGlvbiBtZXJnZVBhZGRpbmdPYmplY3QocGFkZGluZ09iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZ2V0RnJlc2hTaWRlT2JqZWN0KCksIHBhZGRpbmdPYmplY3QpO1xufVxuXG5mdW5jdGlvbiBleHBhbmRUb0hhc2hNYXAodmFsdWUsIGtleXMpIHtcbiAgcmV0dXJuIGtleXMucmVkdWNlKGZ1bmN0aW9uIChoYXNoTWFwLCBrZXkpIHtcbiAgICBoYXNoTWFwW2tleV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gaGFzaE1hcDtcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIF9vcHRpb25zJHBsYWNlbWVudCA9IF9vcHRpb25zLnBsYWNlbWVudCxcbiAgICAgIHBsYWNlbWVudCA9IF9vcHRpb25zJHBsYWNlbWVudCA9PT0gdm9pZCAwID8gc3RhdGUucGxhY2VtZW50IDogX29wdGlvbnMkcGxhY2VtZW50LFxuICAgICAgX29wdGlvbnMkYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMkYm91bmRhcnkgPT09IHZvaWQgMCA/IGNsaXBwaW5nUGFyZW50cyA6IF9vcHRpb25zJGJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyB2aWV3cG9ydCA6IF9vcHRpb25zJHJvb3RCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJGVsZW1lbnRDb250ZSA9IF9vcHRpb25zLmVsZW1lbnRDb250ZXh0LFxuICAgICAgZWxlbWVudENvbnRleHQgPSBfb3B0aW9ucyRlbGVtZW50Q29udGUgPT09IHZvaWQgMCA/IHBvcHBlciA6IF9vcHRpb25zJGVsZW1lbnRDb250ZSxcbiAgICAgIF9vcHRpb25zJGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IF9vcHRpb25zJGFsdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBwYWRkaW5nID0gX29wdGlvbnMkcGFkZGluZyA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHBhZGRpbmc7XG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbiAgdmFyIGFsdENvbnRleHQgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcmVmZXJlbmNlIDogcG9wcGVyO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XG4gIHZhciBjbGlwcGluZ0NsaWVudFJlY3QgPSBnZXRDbGlwcGluZ1JlY3QoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudCA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgZ2V0RG9jdW1lbnRFbGVtZW50KHN0YXRlLmVsZW1lbnRzLnBvcHBlciksIGJvdW5kYXJ5LCByb290Qm91bmRhcnkpO1xuICB2YXIgcmVmZXJlbmNlQ2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChzdGF0ZS5lbGVtZW50cy5yZWZlcmVuY2UpO1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICByZWZlcmVuY2U6IHJlZmVyZW5jZUNsaWVudFJlY3QsXG4gICAgZWxlbWVudDogcG9wcGVyUmVjdCxcbiAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICB9KTtcbiAgdmFyIHBvcHBlckNsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KE9iamVjdC5hc3NpZ24oe30sIHBvcHBlclJlY3QsIHBvcHBlck9mZnNldHMpKTtcbiAgdmFyIGVsZW1lbnRDbGllbnRSZWN0ID0gZWxlbWVudENvbnRleHQgPT09IHBvcHBlciA/IHBvcHBlckNsaWVudFJlY3QgOiByZWZlcmVuY2VDbGllbnRSZWN0OyAvLyBwb3NpdGl2ZSA9IG92ZXJmbG93aW5nIHRoZSBjbGlwcGluZyByZWN0XG4gIC8vIDAgb3IgbmVnYXRpdmUgPSB3aXRoaW4gdGhlIGNsaXBwaW5nIHJlY3RcblxuICB2YXIgb3ZlcmZsb3dPZmZzZXRzID0ge1xuICAgIHRvcDogY2xpcHBpbmdDbGllbnRSZWN0LnRvcCAtIGVsZW1lbnRDbGllbnRSZWN0LnRvcCArIHBhZGRpbmdPYmplY3QudG9wLFxuICAgIGJvdHRvbTogZWxlbWVudENsaWVudFJlY3QuYm90dG9tIC0gY2xpcHBpbmdDbGllbnRSZWN0LmJvdHRvbSArIHBhZGRpbmdPYmplY3QuYm90dG9tLFxuICAgIGxlZnQ6IGNsaXBwaW5nQ2xpZW50UmVjdC5sZWZ0IC0gZWxlbWVudENsaWVudFJlY3QubGVmdCArIHBhZGRpbmdPYmplY3QubGVmdCxcbiAgICByaWdodDogZWxlbWVudENsaWVudFJlY3QucmlnaHQgLSBjbGlwcGluZ0NsaWVudFJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0XG4gIH07XG4gIHZhciBvZmZzZXREYXRhID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQ7IC8vIE9mZnNldHMgY2FuIGJlIGFwcGxpZWQgb25seSB0byB0aGUgcG9wcGVyIGVsZW1lbnRcblxuICBpZiAoZWxlbWVudENvbnRleHQgPT09IHBvcHBlciAmJiBvZmZzZXREYXRhKSB7XG4gICAgdmFyIG9mZnNldCA9IG9mZnNldERhdGFbcGxhY2VtZW50XTtcbiAgICBPYmplY3Qua2V5cyhvdmVyZmxvd09mZnNldHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIG11bHRpcGx5ID0gW3JpZ2h0LCBib3R0b21dLmluZGV4T2Yoa2V5KSA+PSAwID8gMSA6IC0xO1xuICAgICAgdmFyIGF4aXMgPSBbdG9wLCBib3R0b21dLmluZGV4T2Yoa2V5KSA+PSAwID8gJ3knIDogJ3gnO1xuICAgICAgb3ZlcmZsb3dPZmZzZXRzW2tleV0gKz0gb2Zmc2V0W2F4aXNdICogbXVsdGlwbHk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gb3ZlcmZsb3dPZmZzZXRzO1xufVxuXG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICBtb2RpZmllcnM6IFtdLFxuICBzdHJhdGVneTogJ2Fic29sdXRlJ1xufTtcblxuZnVuY3Rpb24gYXJlVmFsaWRFbGVtZW50cygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiAhYXJncy5zb21lKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuICEoZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPT09ICdmdW5jdGlvbicpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcG9wcGVyR2VuZXJhdG9yKGdlbmVyYXRvck9wdGlvbnMpIHtcbiAgaWYgKGdlbmVyYXRvck9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIGdlbmVyYXRvck9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfZ2VuZXJhdG9yT3B0aW9ucyA9IGdlbmVyYXRvck9wdGlvbnMsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0TW9kaWZpZXJzLFxuICAgICAgZGVmYXVsdE1vZGlmaWVycyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9PT0gdm9pZCAwID8gW10gOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE9wdGlvbnMsXG4gICAgICBkZWZhdWx0T3B0aW9ucyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPT09IHZvaWQgMCA/IERFRkFVTFRfT1BUSU9OUyA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZjI7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVQb3BwZXIocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgICAgIG9yZGVyZWRNb2RpZmllcnM6IFtdLFxuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBkZWZhdWx0T3B0aW9ucyksXG4gICAgICBtb2RpZmllcnNEYXRhOiB7fSxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlLFxuICAgICAgICBwb3BwZXI6IHBvcHBlclxuICAgICAgfSxcbiAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH07XG4gICAgdmFyIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcbiAgICB2YXIgaXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB2YXIgaW5zdGFuY2UgPSB7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBzZXRPcHRpb25zOiBmdW5jdGlvbiBzZXRPcHRpb25zKHNldE9wdGlvbnNBY3Rpb24pIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2V0T3B0aW9uc0FjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IHNldE9wdGlvbnNBY3Rpb24oc3RhdGUub3B0aW9ucykgOiBzZXRPcHRpb25zQWN0aW9uO1xuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHN0YXRlLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgc3RhdGUub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHN0YXRlLnNjcm9sbFBhcmVudHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBpc0VsZW1lbnQocmVmZXJlbmNlKSA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZSkgOiByZWZlcmVuY2UuY29udGV4dEVsZW1lbnQgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpIDogW10sXG4gICAgICAgICAgcG9wcGVyOiBsaXN0U2Nyb2xsUGFyZW50cyhwb3BwZXIpXG4gICAgICAgIH07IC8vIE9yZGVycyB0aGUgbW9kaWZpZXJzIGJhc2VkIG9uIHRoZWlyIGRlcGVuZGVuY2llcyBhbmQgYHBoYXNlYFxuICAgICAgICAvLyBwcm9wZXJ0aWVzXG5cbiAgICAgICAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlck1vZGlmaWVycyhtZXJnZUJ5TmFtZShbXS5jb25jYXQoZGVmYXVsdE1vZGlmaWVycywgc3RhdGUub3B0aW9ucy5tb2RpZmllcnMpKSk7IC8vIFN0cmlwIG91dCBkaXNhYmxlZCBtb2RpZmllcnNcblxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICByZXR1cm4gbS5lbmFibGVkO1xuICAgICAgICB9KTsgLy8gVmFsaWRhdGUgdGhlIHByb3ZpZGVkIG1vZGlmaWVycyBzbyB0aGF0IHRoZSBjb25zdW1lciB3aWxsIGdldCB3YXJuZWRcblxuICAgICAgICBydW5Nb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgfSxcbiAgICAgIC8vIFN5bmMgdXBkYXRlIOKAkyBpdCB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCwgZXZlbiBpZiBub3QgbmVjZXNzYXJ5LiBUaGlzXG4gICAgICAvLyBpcyB1c2VmdWwgZm9yIGxvdyBmcmVxdWVuY3kgdXBkYXRlcyB3aGVyZSBzeW5jIGJlaGF2aW9yIHNpbXBsaWZpZXMgdGhlXG4gICAgICAvLyBsb2dpYy5cbiAgICAgIC8vIEZvciBoaWdoIGZyZXF1ZW5jeSB1cGRhdGVzIChlLmcuIGByZXNpemVgIGFuZCBgc2Nyb2xsYCBldmVudHMpLCBhbHdheXNcbiAgICAgIC8vIHByZWZlciB0aGUgYXN5bmMgUG9wcGVyI3VwZGF0ZSBtZXRob2RcbiAgICAgIGZvcmNlVXBkYXRlOiBmdW5jdGlvbiBmb3JjZVVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKGlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9zdGF0ZSRlbGVtZW50cyA9IHN0YXRlLmVsZW1lbnRzLFxuICAgICAgICAgICAgcmVmZXJlbmNlID0gX3N0YXRlJGVsZW1lbnRzLnJlZmVyZW5jZSxcbiAgICAgICAgICAgIHBvcHBlciA9IF9zdGF0ZSRlbGVtZW50cy5wb3BwZXI7IC8vIERvbid0IHByb2NlZWQgaWYgYHJlZmVyZW5jZWAgb3IgYHBvcHBlcmAgYXJlIG5vdCB2YWxpZCBlbGVtZW50c1xuICAgICAgICAvLyBhbnltb3JlXG5cbiAgICAgICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIFN0b3JlIHRoZSByZWZlcmVuY2UgYW5kIHBvcHBlciByZWN0cyB0byBiZSByZWFkIGJ5IG1vZGlmaWVyc1xuXG5cbiAgICAgICAgc3RhdGUucmVjdHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBnZXRDb21wb3NpdGVSZWN0KHJlZmVyZW5jZSwgZ2V0T2Zmc2V0UGFyZW50KHBvcHBlciksIHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCcpLFxuICAgICAgICAgIHBvcHBlcjogZ2V0TGF5b3V0UmVjdChwb3BwZXIpXG4gICAgICAgIH07IC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIHJlc2V0IHRoZSBjdXJyZW50IHVwZGF0ZSBjeWNsZS4gVGhlXG4gICAgICAgIC8vIG1vc3QgY29tbW9uIHVzZSBjYXNlIGZvciB0aGlzIGlzIHRoZSBgZmxpcGAgbW9kaWZpZXIgY2hhbmdpbmcgdGhlXG4gICAgICAgIC8vIHBsYWNlbWVudCwgd2hpY2ggdGhlbiBuZWVkcyB0byByZS1ydW4gYWxsIHRoZSBtb2RpZmllcnMsIGJlY2F1c2UgdGhlXG4gICAgICAgIC8vIGxvZ2ljIHdhcyBwcmV2aW91c2x5IHJhbiBmb3IgdGhlIHByZXZpb3VzIHBsYWNlbWVudCBhbmQgaXMgdGhlcmVmb3JlXG4gICAgICAgIC8vIHN0YWxlL2luY29ycmVjdFxuXG4gICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLnBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50OyAvLyBPbiBlYWNoIHVwZGF0ZSBjeWNsZSwgdGhlIGBtb2RpZmllcnNEYXRhYCBwcm9wZXJ0eSBmb3IgZWFjaCBtb2RpZmllclxuICAgICAgICAvLyBpcyBmaWxsZWQgd2l0aCB0aGUgaW5pdGlhbCBkYXRhIHNwZWNpZmllZCBieSB0aGUgbW9kaWZpZXIuIFRoaXMgbWVhbnNcbiAgICAgICAgLy8gaXQgZG9lc24ndCBwZXJzaXN0IGFuZCBpcyBmcmVzaCBvbiBlYWNoIHVwZGF0ZS5cbiAgICAgICAgLy8gVG8gZW5zdXJlIHBlcnNpc3RlbnQgZGF0YSwgdXNlIGAke25hbWV9I3BlcnNpc3RlbnRgXG5cbiAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgICAgIHJldHVybiBzdGF0ZS5tb2RpZmllcnNEYXRhW21vZGlmaWVyLm5hbWVdID0gT2JqZWN0LmFzc2lnbih7fSwgbW9kaWZpZXIuZGF0YSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuXG4gICAgICAgICAgaWYgKHN0YXRlLnJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfc3RhdGUkb3JkZXJlZE1vZGlmaWUgPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzW2luZGV4XSxcbiAgICAgICAgICAgICAgZm4gPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUuZm4sXG4gICAgICAgICAgICAgIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUub3B0aW9ucyxcbiAgICAgICAgICAgICAgX29wdGlvbnMgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID09PSB2b2lkIDAgPyB7fSA6IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIsXG4gICAgICAgICAgICAgIG5hbWUgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUubmFtZTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN0YXRlID0gZm4oe1xuICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IF9vcHRpb25zLFxuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2VcbiAgICAgICAgICAgIH0pIHx8IHN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEFzeW5jIGFuZCBvcHRpbWlzdGljYWxseSBvcHRpbWl6ZWQgdXBkYXRlIOKAkyBpdCB3aWxsIG5vdCBiZSBleGVjdXRlZCBpZlxuICAgICAgLy8gbm90IG5lY2Vzc2FyeSAoZGVib3VuY2VkIHRvIHJ1biBhdCBtb3N0IG9uY2UtcGVyLXRpY2spXG4gICAgICB1cGRhdGU6IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICByZXNvbHZlKHN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG5cbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICBpZiAoIWlzRGVzdHJveWVkICYmIG9wdGlvbnMub25GaXJzdFVwZGF0ZSkge1xuICAgICAgICBvcHRpb25zLm9uRmlyc3RVcGRhdGUoc3RhdGUpO1xuICAgICAgfVxuICAgIH0pOyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byBleGVjdXRlIGFyYml0cmFyeSBjb2RlIGJlZm9yZSB0aGUgZmlyc3RcbiAgICAvLyB1cGRhdGUgY3ljbGUgcnVucy4gVGhleSB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSB1cGRhdGVcbiAgICAvLyBjeWNsZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIG1vZGlmaWVyIGFkZHMgc29tZSBwZXJzaXN0ZW50IGRhdGEgdGhhdFxuICAgIC8vIG90aGVyIG1vZGlmaWVycyBuZWVkIHRvIHVzZSwgYnV0IHRoZSBtb2RpZmllciBpcyBydW4gYWZ0ZXIgdGhlIGRlcGVuZGVudFxuICAgIC8vIG9uZS5cblxuICAgIGZ1bmN0aW9uIHJ1bk1vZGlmaWVyRWZmZWN0cygpIHtcbiAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBfcmVmMy5uYW1lLFxuICAgICAgICAgICAgX3JlZjMkb3B0aW9ucyA9IF9yZWYzLm9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zID0gX3JlZjMkb3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfcmVmMyRvcHRpb25zLFxuICAgICAgICAgICAgZWZmZWN0ID0gX3JlZjMuZWZmZWN0O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZWZmZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIGNsZWFudXBGbiA9IGVmZmVjdCh7XG4gICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIG5vb3BGbiA9IGZ1bmN0aW9uIG5vb3BGbigpIHt9O1xuXG4gICAgICAgICAgZWZmZWN0Q2xlYW51cEZucy5wdXNoKGNsZWFudXBGbiB8fCBub29wRm4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgZWZmZWN0Q2xlYW51cEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0pO1xuICAgICAgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcbn1cblxudmFyIHBhc3NpdmUgPSB7XG4gIHBhc3NpdmU6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGVmZmVjdCQyKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRzY3JvbGwgPSBvcHRpb25zLnNjcm9sbCxcbiAgICAgIHNjcm9sbCA9IF9vcHRpb25zJHNjcm9sbCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHNjcm9sbCxcbiAgICAgIF9vcHRpb25zJHJlc2l6ZSA9IG9wdGlvbnMucmVzaXplLFxuICAgICAgcmVzaXplID0gX29wdGlvbnMkcmVzaXplID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcmVzaXplO1xuICB2YXIgd2luZG93ID0gZ2V0V2luZG93KHN0YXRlLmVsZW1lbnRzLnBvcHBlcik7XG4gIHZhciBzY3JvbGxQYXJlbnRzID0gW10uY29uY2F0KHN0YXRlLnNjcm9sbFBhcmVudHMucmVmZXJlbmNlLCBzdGF0ZS5zY3JvbGxQYXJlbnRzLnBvcHBlcik7XG5cbiAgaWYgKHNjcm9sbCkge1xuICAgIHNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2Nyb2xsUGFyZW50KSB7XG4gICAgICBzY3JvbGxQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChyZXNpemUpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNjcm9sbCkge1xuICAgICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgICAgc2Nyb2xsUGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocmVzaXplKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICB9XG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG52YXIgZXZlbnRMaXN0ZW5lcnMgPSB7XG4gIG5hbWU6ICdldmVudExpc3RlbmVycycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnd3JpdGUnLFxuICBmbjogZnVuY3Rpb24gZm4oKSB7fSxcbiAgZWZmZWN0OiBlZmZlY3QkMixcbiAgZGF0YToge31cbn07XG5cbmZ1bmN0aW9uIHBvcHBlck9mZnNldHMoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgLy8gT2Zmc2V0cyBhcmUgdGhlIGFjdHVhbCBwb3NpdGlvbiB0aGUgcG9wcGVyIG5lZWRzIHRvIGhhdmUgdG8gYmVcbiAgLy8gcHJvcGVybHkgcG9zaXRpb25lZCBuZWFyIGl0cyByZWZlcmVuY2UgZWxlbWVudFxuICAvLyBUaGlzIGlzIHRoZSBtb3N0IGJhc2ljIHBsYWNlbWVudCwgYW5kIHdpbGwgYmUgYWRqdXN0ZWQgYnlcbiAgLy8gdGhlIG1vZGlmaWVycyBpbiB0aGUgbmV4dCBzdGVwXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiBzdGF0ZS5yZWN0cy5yZWZlcmVuY2UsXG4gICAgZWxlbWVudDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxudmFyIHBvcHBlck9mZnNldHMkMSA9IHtcbiAgbmFtZTogJ3BvcHBlck9mZnNldHMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3JlYWQnLFxuICBmbjogcG9wcGVyT2Zmc2V0cyxcbiAgZGF0YToge31cbn07XG5cbnZhciB1bnNldFNpZGVzID0ge1xuICB0b3A6ICdhdXRvJyxcbiAgcmlnaHQ6ICdhdXRvJyxcbiAgYm90dG9tOiAnYXV0bycsXG4gIGxlZnQ6ICdhdXRvJ1xufTsgLy8gUm91bmQgdGhlIG9mZnNldHMgdG8gdGhlIG5lYXJlc3Qgc3VpdGFibGUgc3VicGl4ZWwgYmFzZWQgb24gdGhlIERQUi5cbi8vIFpvb21pbmcgY2FuIGNoYW5nZSB0aGUgRFBSLCBidXQgaXQgc2VlbXMgdG8gcmVwb3J0IGEgdmFsdWUgdGhhdCB3aWxsXG4vLyBjbGVhbmx5IGRpdmlkZSB0aGUgdmFsdWVzIGludG8gdGhlIGFwcHJvcHJpYXRlIHN1YnBpeGVscy5cblxuZnVuY3Rpb24gcm91bmRPZmZzZXRzQnlEUFIoX3JlZikge1xuICB2YXIgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnk7XG4gIHZhciB3aW4gPSB3aW5kb3c7XG4gIHZhciBkcHIgPSB3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICByZXR1cm4ge1xuICAgIHg6IHJvdW5kKHJvdW5kKHggKiBkcHIpIC8gZHByKSB8fCAwLFxuICAgIHk6IHJvdW5kKHJvdW5kKHkgKiBkcHIpIC8gZHByKSB8fCAwXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1hcFRvU3R5bGVzKF9yZWYyKSB7XG4gIHZhciBfT2JqZWN0JGFzc2lnbjI7XG5cbiAgdmFyIHBvcHBlciA9IF9yZWYyLnBvcHBlcixcbiAgICAgIHBvcHBlclJlY3QgPSBfcmVmMi5wb3BwZXJSZWN0LFxuICAgICAgcGxhY2VtZW50ID0gX3JlZjIucGxhY2VtZW50LFxuICAgICAgdmFyaWF0aW9uID0gX3JlZjIudmFyaWF0aW9uLFxuICAgICAgb2Zmc2V0cyA9IF9yZWYyLm9mZnNldHMsXG4gICAgICBwb3NpdGlvbiA9IF9yZWYyLnBvc2l0aW9uLFxuICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gX3JlZjIuZ3B1QWNjZWxlcmF0aW9uLFxuICAgICAgYWRhcHRpdmUgPSBfcmVmMi5hZGFwdGl2ZSxcbiAgICAgIHJvdW5kT2Zmc2V0cyA9IF9yZWYyLnJvdW5kT2Zmc2V0cztcblxuICB2YXIgX3JlZjMgPSByb3VuZE9mZnNldHMgPT09IHRydWUgPyByb3VuZE9mZnNldHNCeURQUihvZmZzZXRzKSA6IHR5cGVvZiByb3VuZE9mZnNldHMgPT09ICdmdW5jdGlvbicgPyByb3VuZE9mZnNldHMob2Zmc2V0cykgOiBvZmZzZXRzLFxuICAgICAgX3JlZjMkeCA9IF9yZWYzLngsXG4gICAgICB4ID0gX3JlZjMkeCA9PT0gdm9pZCAwID8gMCA6IF9yZWYzJHgsXG4gICAgICBfcmVmMyR5ID0gX3JlZjMueSxcbiAgICAgIHkgPSBfcmVmMyR5ID09PSB2b2lkIDAgPyAwIDogX3JlZjMkeTtcblxuICB2YXIgaGFzWCA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3gnKTtcbiAgdmFyIGhhc1kgPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd5Jyk7XG4gIHZhciBzaWRlWCA9IGxlZnQ7XG4gIHZhciBzaWRlWSA9IHRvcDtcbiAgdmFyIHdpbiA9IHdpbmRvdztcblxuICBpZiAoYWRhcHRpdmUpIHtcbiAgICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KHBvcHBlcik7XG4gICAgdmFyIGhlaWdodFByb3AgPSAnY2xpZW50SGVpZ2h0JztcbiAgICB2YXIgd2lkdGhQcm9wID0gJ2NsaWVudFdpZHRoJztcblxuICAgIGlmIChvZmZzZXRQYXJlbnQgPT09IGdldFdpbmRvdyhwb3BwZXIpKSB7XG4gICAgICBvZmZzZXRQYXJlbnQgPSBnZXREb2N1bWVudEVsZW1lbnQocG9wcGVyKTtcblxuICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiAhPT0gJ3N0YXRpYycgJiYgcG9zaXRpb24gPT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgaGVpZ2h0UHJvcCA9ICdzY3JvbGxIZWlnaHQnO1xuICAgICAgICB3aWR0aFByb3AgPSAnc2Nyb2xsV2lkdGgnO1xuICAgICAgfVxuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FzdF06IGZvcmNlIHR5cGUgcmVmaW5lbWVudCwgd2UgY29tcGFyZSBvZmZzZXRQYXJlbnQgd2l0aCB3aW5kb3cgYWJvdmUsIGJ1dCBGbG93IGRvZXNuJ3QgZGV0ZWN0IGl0XG5cblxuICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudDtcblxuICAgIGlmIChwbGFjZW1lbnQgPT09IHRvcCB8fCAocGxhY2VtZW50ID09PSBsZWZ0IHx8IHBsYWNlbWVudCA9PT0gcmlnaHQpICYmIHZhcmlhdGlvbiA9PT0gZW5kKSB7XG4gICAgICBzaWRlWSA9IGJvdHRvbTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgICAgIHkgLT0gb2Zmc2V0UGFyZW50W2hlaWdodFByb3BdIC0gcG9wcGVyUmVjdC5oZWlnaHQ7XG4gICAgICB5ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcbiAgICB9XG5cbiAgICBpZiAocGxhY2VtZW50ID09PSBsZWZ0IHx8IChwbGFjZW1lbnQgPT09IHRvcCB8fCBwbGFjZW1lbnQgPT09IGJvdHRvbSkgJiYgdmFyaWF0aW9uID09PSBlbmQpIHtcbiAgICAgIHNpZGVYID0gcmlnaHQ7IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG4gICAgICB4IC09IG9mZnNldFBhcmVudFt3aWR0aFByb3BdIC0gcG9wcGVyUmVjdC53aWR0aDtcbiAgICAgIHggKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb21tb25TdHlsZXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgfSwgYWRhcHRpdmUgJiYgdW5zZXRTaWRlcyk7XG5cbiAgaWYgKGdwdUFjY2VsZXJhdGlvbikge1xuICAgIHZhciBfT2JqZWN0JGFzc2lnbjtcblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbiA9IHt9LCBfT2JqZWN0JGFzc2lnbltzaWRlWV0gPSBoYXNZID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduW3NpZGVYXSA9IGhhc1ggPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ24udHJhbnNmb3JtID0gKHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIDw9IDEgPyBcInRyYW5zbGF0ZShcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4KVwiIDogXCJ0cmFuc2xhdGUzZChcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4LCAwKVwiLCBfT2JqZWN0JGFzc2lnbikpO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywgKF9PYmplY3QkYXNzaWduMiA9IHt9LCBfT2JqZWN0JGFzc2lnbjJbc2lkZVldID0gaGFzWSA/IHkgKyBcInB4XCIgOiAnJywgX09iamVjdCRhc3NpZ24yW3NpZGVYXSA9IGhhc1ggPyB4ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMi50cmFuc2Zvcm0gPSAnJywgX09iamVjdCRhc3NpZ24yKSk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVTdHlsZXMoX3JlZjQpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjQuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjQub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9IG9wdGlvbnMuZ3B1QWNjZWxlcmF0aW9uLFxuICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gX29wdGlvbnMkZ3B1QWNjZWxlcmF0ID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZ3B1QWNjZWxlcmF0LFxuICAgICAgX29wdGlvbnMkYWRhcHRpdmUgPSBvcHRpb25zLmFkYXB0aXZlLFxuICAgICAgYWRhcHRpdmUgPSBfb3B0aW9ucyRhZGFwdGl2ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGFkYXB0aXZlLFxuICAgICAgX29wdGlvbnMkcm91bmRPZmZzZXRzID0gb3B0aW9ucy5yb3VuZE9mZnNldHMsXG4gICAgICByb3VuZE9mZnNldHMgPSBfb3B0aW9ucyRyb3VuZE9mZnNldHMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyb3VuZE9mZnNldHM7XG5cbiAgdmFyIGNvbW1vblN0eWxlcyA9IHtcbiAgICBwbGFjZW1lbnQ6IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KSxcbiAgICB2YXJpYXRpb246IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHBvcHBlcjogc3RhdGUuZWxlbWVudHMucG9wcGVyLFxuICAgIHBvcHBlclJlY3Q6IHN0YXRlLnJlY3RzLnBvcHBlcixcbiAgICBncHVBY2NlbGVyYXRpb246IGdwdUFjY2VsZXJhdGlvblxuICB9O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLnN0eWxlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMucG9wcGVyLCBtYXBUb1N0eWxlcyhPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIHtcbiAgICAgIG9mZnNldHM6IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyxcbiAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgYWRhcHRpdmU6IGFkYXB0aXZlLFxuICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcbiAgICB9KSkpO1xuICB9XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEuYXJyb3cgIT0gbnVsbCkge1xuICAgIHN0YXRlLnN0eWxlcy5hcnJvdyA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnN0eWxlcy5hcnJvdywgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93LFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBhZGFwdGl2ZTogZmFsc2UsXG4gICAgICByb3VuZE9mZnNldHM6IHJvdW5kT2Zmc2V0c1xuICAgIH0pKSk7XG4gIH1cblxuICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgJ2RhdGEtcG9wcGVyLXBsYWNlbWVudCc6IHN0YXRlLnBsYWNlbWVudFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbnZhciBjb21wdXRlU3R5bGVzJDEgPSB7XG4gIG5hbWU6ICdjb21wdXRlU3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdiZWZvcmVXcml0ZScsXG4gIGZuOiBjb21wdXRlU3R5bGVzLFxuICBkYXRhOiB7fVxufTtcblxuLy8gYW5kIGFwcGxpZXMgdGhlbSB0byB0aGUgSFRNTEVsZW1lbnRzIHN1Y2ggYXMgcG9wcGVyIGFuZCBhcnJvd1xuXG5mdW5jdGlvbiBhcHBseVN0eWxlcyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGU7XG4gIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHN0eWxlID0gc3RhdGUuc3R5bGVzW25hbWVdIHx8IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZsb3cgZG9lc24ndCBzdXBwb3J0IHRvIGV4dGVuZCB0aGlzIHByb3BlcnR5LCBidXQgaXQncyB0aGUgbW9zdFxuICAgIC8vIGVmZmVjdGl2ZSB3YXkgdG8gYXBwbHkgc3R5bGVzIHRvIGFuIEhUTUxFbGVtZW50XG4gICAgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdXG5cblxuICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZWZmZWN0JDEoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGU7XG4gIHZhciBpbml0aWFsU3R5bGVzID0ge1xuICAgIHBvcHBlcjoge1xuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiAnMCcsXG4gICAgICB0b3A6ICcwJyxcbiAgICAgIG1hcmdpbjogJzAnXG4gICAgfSxcbiAgICBhcnJvdzoge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICB9LFxuICAgIHJlZmVyZW5jZToge31cbiAgfTtcbiAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5wb3BwZXIuc3R5bGUsIGluaXRpYWxTdHlsZXMucG9wcGVyKTtcbiAgc3RhdGUuc3R5bGVzID0gaW5pdGlhbFN0eWxlcztcblxuICBpZiAoc3RhdGUuZWxlbWVudHMuYXJyb3cpIHtcbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLmFycm93LnN0eWxlLCBpbml0aWFsU3R5bGVzLmFycm93KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgICB2YXIgc3R5bGVQcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoc3RhdGUuc3R5bGVzLmhhc093blByb3BlcnR5KG5hbWUpID8gc3RhdGUuc3R5bGVzW25hbWVdIDogaW5pdGlhbFN0eWxlc1tuYW1lXSk7IC8vIFNldCBhbGwgdmFsdWVzIHRvIGFuIGVtcHR5IHN0cmluZyB0byB1bnNldCB0aGVtXG5cbiAgICAgIHZhciBzdHlsZSA9IHN0eWxlUHJvcGVydGllcy5yZWR1Y2UoZnVuY3Rpb24gKHN0eWxlLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdHlsZVtwcm9wZXJ0eV0gPSAnJztcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfSwge30pOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbnZhciBhcHBseVN0eWxlcyQxID0ge1xuICBuYW1lOiAnYXBwbHlTdHlsZXMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3dyaXRlJyxcbiAgZm46IGFwcGx5U3R5bGVzLFxuICBlZmZlY3Q6IGVmZmVjdCQxLFxuICByZXF1aXJlczogWydjb21wdXRlU3R5bGVzJ11cbn07XG5cbnZhciBkZWZhdWx0TW9kaWZpZXJzID0gW2V2ZW50TGlzdGVuZXJzLCBwb3BwZXJPZmZzZXRzJDEsIGNvbXB1dGVTdHlsZXMkMSwgYXBwbHlTdHlsZXMkMV07XG52YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcih7XG4gIGRlZmF1bHRNb2RpZmllcnM6IGRlZmF1bHRNb2RpZmllcnNcbn0pOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmZ1bmN0aW9uIGdldEFsdEF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufVxuXG5mdW5jdGlvbiB3aXRoaW4obWluJDEsIHZhbHVlLCBtYXgkMSkge1xuICByZXR1cm4gbWF4KG1pbiQxLCBtaW4odmFsdWUsIG1heCQxKSk7XG59XG5cbmZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIF9vcHRpb25zJHRldGhlciA9IG9wdGlvbnMudGV0aGVyLFxuICAgICAgdGV0aGVyID0gX29wdGlvbnMkdGV0aGVyID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkdGV0aGVyLFxuICAgICAgX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID0gb3B0aW9ucy50ZXRoZXJPZmZzZXQsXG4gICAgICB0ZXRoZXJPZmZzZXQgPSBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQ7XG4gIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5XG4gIH0pO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gIXZhcmlhdGlvbjtcbiAgdmFyIG1haW5BeGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICB2YXIgYWx0QXhpcyA9IGdldEFsdEF4aXMobWFpbkF4aXMpO1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgdGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gdGV0aGVyT2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSkpIDogdGV0aGVyT2Zmc2V0O1xuICB2YXIgZGF0YSA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBpZiAoIXBvcHBlck9mZnNldHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY2hlY2tNYWluQXhpcyB8fCBjaGVja0FsdEF4aXMpIHtcbiAgICB2YXIgbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gdG9wIDogbGVmdDtcbiAgICB2YXIgYWx0U2lkZSA9IG1haW5BeGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICB2YXIgb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc107XG4gICAgdmFyIG1pbiQxID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc10gKyBvdmVyZmxvd1ttYWluU2lkZV07XG4gICAgdmFyIG1heCQxID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc10gLSBvdmVyZmxvd1thbHRTaWRlXTtcbiAgICB2YXIgYWRkaXRpdmUgPSB0ZXRoZXIgPyAtcG9wcGVyUmVjdFtsZW5dIC8gMiA6IDA7XG4gICAgdmFyIG1pbkxlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gOiBwb3BwZXJSZWN0W2xlbl07XG4gICAgdmFyIG1heExlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyAtcG9wcGVyUmVjdFtsZW5dIDogLXJlZmVyZW5jZVJlY3RbbGVuXTsgLy8gV2UgbmVlZCB0byBpbmNsdWRlIHRoZSBhcnJvdyBpbiB0aGUgY2FsY3VsYXRpb24gc28gdGhlIGFycm93IGRvZXNuJ3QgZ29cbiAgICAvLyBvdXRzaWRlIHRoZSByZWZlcmVuY2UgYm91bmRzXG5cbiAgICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gICAgdmFyIGFycm93UmVjdCA9IHRldGhlciAmJiBhcnJvd0VsZW1lbnQgPyBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCkgOiB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gICAgdmFyIGFycm93UGFkZGluZ09iamVjdCA9IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXSA/IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXS5wYWRkaW5nIDogZ2V0RnJlc2hTaWRlT2JqZWN0KCk7XG4gICAgdmFyIGFycm93UGFkZGluZ01pbiA9IGFycm93UGFkZGluZ09iamVjdFttYWluU2lkZV07XG4gICAgdmFyIGFycm93UGFkZGluZ01heCA9IGFycm93UGFkZGluZ09iamVjdFthbHRTaWRlXTsgLy8gSWYgdGhlIHJlZmVyZW5jZSBsZW5ndGggaXMgc21hbGxlciB0aGFuIHRoZSBhcnJvdyBsZW5ndGgsIHdlIGRvbid0IHdhbnRcbiAgICAvLyB0byBpbmNsdWRlIGl0cyBmdWxsIHNpemUgaW4gdGhlIGNhbGN1bGF0aW9uLiBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsXG4gICAgLy8gYW5kIG5lYXIgdGhlIGVkZ2Ugb2YgYSBib3VuZGFyeSwgdGhlIHBvcHBlciBjYW4gb3ZlcmZsb3cgZXZlbiBpZiB0aGVcbiAgICAvLyByZWZlcmVuY2UgaXMgbm90IG92ZXJmbG93aW5nIGFzIHdlbGwgKGUuZy4gdmlydHVhbCBlbGVtZW50cyB3aXRoIG5vXG4gICAgLy8gd2lkdGggb3IgaGVpZ2h0KVxuXG4gICAgdmFyIGFycm93TGVuID0gd2l0aGluKDAsIHJlZmVyZW5jZVJlY3RbbGVuXSwgYXJyb3dSZWN0W2xlbl0pO1xuICAgIHZhciBtaW5PZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gLyAyIC0gYWRkaXRpdmUgLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIHRldGhlck9mZnNldFZhbHVlIDogbWluTGVuIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSB0ZXRoZXJPZmZzZXRWYWx1ZTtcbiAgICB2YXIgbWF4T2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gLXJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgKyBhZGRpdGl2ZSArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgdGV0aGVyT2Zmc2V0VmFsdWUgOiBtYXhMZW4gKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIHRldGhlck9mZnNldFZhbHVlO1xuICAgIHZhciBhcnJvd09mZnNldFBhcmVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93ICYmIGdldE9mZnNldFBhcmVudChzdGF0ZS5lbGVtZW50cy5hcnJvdyk7XG4gICAgdmFyIGNsaWVudE9mZnNldCA9IGFycm93T2Zmc2V0UGFyZW50ID8gbWFpbkF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFRvcCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50TGVmdCB8fCAwIDogMDtcbiAgICB2YXIgb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0ID8gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXRbc3RhdGUucGxhY2VtZW50XVttYWluQXhpc10gOiAwO1xuICAgIHZhciB0ZXRoZXJNaW4gPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSArIG1pbk9mZnNldCAtIG9mZnNldE1vZGlmaWVyVmFsdWUgLSBjbGllbnRPZmZzZXQ7XG4gICAgdmFyIHRldGhlck1heCA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdICsgbWF4T2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZTtcblxuICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICB2YXIgcHJldmVudGVkT2Zmc2V0ID0gd2l0aGluKHRldGhlciA/IG1pbihtaW4kMSwgdGV0aGVyTWluKSA6IG1pbiQxLCBvZmZzZXQsIHRldGhlciA/IG1heChtYXgkMSwgdGV0aGVyTWF4KSA6IG1heCQxKTtcbiAgICAgIHBvcHBlck9mZnNldHNbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0O1xuICAgICAgZGF0YVttYWluQXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQgLSBvZmZzZXQ7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgICAgdmFyIF9tYWluU2lkZSA9IG1haW5BeGlzID09PSAneCcgPyB0b3AgOiBsZWZ0O1xuXG4gICAgICB2YXIgX2FsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gYm90dG9tIDogcmlnaHQ7XG5cbiAgICAgIHZhciBfb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1thbHRBeGlzXTtcblxuICAgICAgdmFyIF9taW4gPSBfb2Zmc2V0ICsgb3ZlcmZsb3dbX21haW5TaWRlXTtcblxuICAgICAgdmFyIF9tYXggPSBfb2Zmc2V0IC0gb3ZlcmZsb3dbX2FsdFNpZGVdO1xuXG4gICAgICB2YXIgX3ByZXZlbnRlZE9mZnNldCA9IHdpdGhpbih0ZXRoZXIgPyBtaW4oX21pbiwgdGV0aGVyTWluKSA6IF9taW4sIF9vZmZzZXQsIHRldGhlciA/IG1heChfbWF4LCB0ZXRoZXJNYXgpIDogX21heCk7XG5cbiAgICAgIHBvcHBlck9mZnNldHNbYWx0QXhpc10gPSBfcHJldmVudGVkT2Zmc2V0O1xuICAgICAgZGF0YVthbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQgLSBfb2Zmc2V0O1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxudmFyIHByZXZlbnRPdmVyZmxvdyQxID0ge1xuICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IHByZXZlbnRPdmVyZmxvdyxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXVxufTtcblxudmFyIGhhc2gkMSA9IHtcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgcmlnaHQ6ICdsZWZ0JyxcbiAgYm90dG9tOiAndG9wJyxcbiAgdG9wOiAnYm90dG9tJ1xufTtcbmZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoJDFbbWF0Y2hlZF07XG4gIH0pO1xufVxuXG52YXIgaGFzaCA9IHtcbiAgc3RhcnQ6ICdlbmQnLFxuICBlbmQ6ICdzdGFydCdcbn07XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9zdGFydHxlbmQvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVBdXRvUGxhY2VtZW50KHN0YXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgIF9vcHRpb25zJGFsbG93ZWRBdXRvUCA9IF9vcHRpb25zLmFsbG93ZWRBdXRvUGxhY2VtZW50cyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyA9IF9vcHRpb25zJGFsbG93ZWRBdXRvUCA9PT0gdm9pZCAwID8gcGxhY2VtZW50cyA6IF9vcHRpb25zJGFsbG93ZWRBdXRvUDtcbiAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpO1xuICB2YXIgcGxhY2VtZW50cyQxID0gdmFyaWF0aW9uID8gZmxpcFZhcmlhdGlvbnMgPyB2YXJpYXRpb25QbGFjZW1lbnRzIDogdmFyaWF0aW9uUGxhY2VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gdmFyaWF0aW9uO1xuICB9KSA6IGJhc2VQbGFjZW1lbnRzO1xuICB2YXIgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzJDEuZmlsdGVyKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gYWxsb3dlZEF1dG9QbGFjZW1lbnRzLmluZGV4T2YocGxhY2VtZW50KSA+PSAwO1xuICB9KTtcblxuICBpZiAoYWxsb3dlZFBsYWNlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzJDE7XG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV06IEZsb3cgc2VlbXMgdG8gaGF2ZSBwcm9ibGVtcyB3aXRoIHR3byBhcnJheSB1bmlvbnMuLi5cblxuXG4gIHZhciBvdmVyZmxvd3MgPSBhbGxvd2VkUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgYWNjW3BsYWNlbWVudF0gPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICB9KVtnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCldO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG92ZXJmbG93cykuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBvdmVyZmxvd3NbYV0gLSBvdmVyZmxvd3NbYl07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwbGFjZW1lbnQpIHtcbiAgaWYgKGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gYXV0bykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBvcHBvc2l0ZVBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHJldHVybiBbZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSwgb3Bwb3NpdGVQbGFjZW1lbnQsIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KG9wcG9zaXRlUGxhY2VtZW50KV07XG59XG5cbmZ1bmN0aW9uIGZsaXAoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgX29wdGlvbnMkbWFpbkF4aXMgPSBvcHRpb25zLm1haW5BeGlzLFxuICAgICAgY2hlY2tNYWluQXhpcyA9IF9vcHRpb25zJG1haW5BeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkbWFpbkF4aXMsXG4gICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxuICAgICAgY2hlY2tBbHRBeGlzID0gX29wdGlvbnMkYWx0QXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGFsdEF4aXMsXG4gICAgICBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgPSBvcHRpb25zLmZhbGxiYWNrUGxhY2VtZW50cyxcbiAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcsXG4gICAgICBib3VuZGFyeSA9IG9wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBvcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJGZsaXBWYXJpYXRpbyA9IG9wdGlvbnMuZmxpcFZhcmlhdGlvbnMsXG4gICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zJGZsaXBWYXJpYXRpbyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGZsaXBWYXJpYXRpbyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyA9IG9wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzO1xuICB2YXIgcHJlZmVycmVkUGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpO1xuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gYmFzZVBsYWNlbWVudCA9PT0gcHJlZmVycmVkUGxhY2VtZW50O1xuICB2YXIgZmFsbGJhY2tQbGFjZW1lbnRzID0gc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIHx8IChpc0Jhc2VQbGFjZW1lbnQgfHwgIWZsaXBWYXJpYXRpb25zID8gW2dldE9wcG9zaXRlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCldIDogZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocHJlZmVycmVkUGxhY2VtZW50KSk7XG4gIHZhciBwbGFjZW1lbnRzID0gW3ByZWZlcnJlZFBsYWNlbWVudF0uY29uY2F0KGZhbGxiYWNrUGxhY2VtZW50cykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIHJldHVybiBhY2MuY29uY2F0KGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gYXV0byA/IGNvbXB1dGVBdXRvUGxhY2VtZW50KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZyxcbiAgICAgIGZsaXBWYXJpYXRpb25zOiBmbGlwVmFyaWF0aW9ucyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50czogYWxsb3dlZEF1dG9QbGFjZW1lbnRzXG4gICAgfSkgOiBwbGFjZW1lbnQpO1xuICB9LCBbXSk7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIGNoZWNrc01hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIG1ha2VGYWxsYmFja0NoZWNrcyA9IHRydWU7XG4gIHZhciBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzWzBdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGxhY2VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwbGFjZW1lbnQgPSBwbGFjZW1lbnRzW2ldO1xuXG4gICAgdmFyIF9iYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuXG4gICAgdmFyIGlzU3RhcnRWYXJpYXRpb24gPSBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gc3RhcnQ7XG4gICAgdmFyIGlzVmVydGljYWwgPSBbdG9wLCBib3R0b21dLmluZGV4T2YoX2Jhc2VQbGFjZW1lbnQpID49IDA7XG4gICAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgdmFyIG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeTogYWx0Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nXG4gICAgfSk7XG4gICAgdmFyIG1haW5WYXJpYXRpb25TaWRlID0gaXNWZXJ0aWNhbCA/IGlzU3RhcnRWYXJpYXRpb24gPyByaWdodCA6IGxlZnQgOiBpc1N0YXJ0VmFyaWF0aW9uID8gYm90dG9tIDogdG9wO1xuXG4gICAgaWYgKHJlZmVyZW5jZVJlY3RbbGVuXSA+IHBvcHBlclJlY3RbbGVuXSkge1xuICAgICAgbWFpblZhcmlhdGlvblNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluVmFyaWF0aW9uU2lkZSk7XG4gICAgfVxuXG4gICAgdmFyIGFsdFZhcmlhdGlvblNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluVmFyaWF0aW9uU2lkZSk7XG4gICAgdmFyIGNoZWNrcyA9IFtdO1xuXG4gICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W19iYXNlUGxhY2VtZW50XSA8PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tBbHRBeGlzKSB7XG4gICAgICBjaGVja3MucHVzaChvdmVyZmxvd1ttYWluVmFyaWF0aW9uU2lkZV0gPD0gMCwgb3ZlcmZsb3dbYWx0VmFyaWF0aW9uU2lkZV0gPD0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrcy5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgIHJldHVybiBjaGVjaztcbiAgICB9KSkge1xuICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICAgICAgbWFrZUZhbGxiYWNrQ2hlY2tzID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjaGVja3NNYXAuc2V0KHBsYWNlbWVudCwgY2hlY2tzKTtcbiAgfVxuXG4gIGlmIChtYWtlRmFsbGJhY2tDaGVja3MpIHtcbiAgICAvLyBgMmAgbWF5IGJlIGRlc2lyZWQgaW4gc29tZSBjYXNlcyDigJMgcmVzZWFyY2ggbGF0ZXJcbiAgICB2YXIgbnVtYmVyT2ZDaGVja3MgPSBmbGlwVmFyaWF0aW9ucyA/IDMgOiAxO1xuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoX2kpIHtcbiAgICAgIHZhciBmaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50cy5maW5kKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICAgICAgdmFyIGNoZWNrcyA9IGNoZWNrc01hcC5nZXQocGxhY2VtZW50KTtcblxuICAgICAgICBpZiAoY2hlY2tzKSB7XG4gICAgICAgICAgcmV0dXJuIGNoZWNrcy5zbGljZSgwLCBfaSkuZXZlcnkoZnVuY3Rpb24gKGNoZWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2s7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZml0dGluZ1BsYWNlbWVudCkge1xuICAgICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBmaXR0aW5nUGxhY2VtZW50O1xuICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBfaSA9IG51bWJlck9mQ2hlY2tzOyBfaSA+IDA7IF9pLS0pIHtcbiAgICAgIHZhciBfcmV0ID0gX2xvb3AoX2kpO1xuXG4gICAgICBpZiAoX3JldCA9PT0gXCJicmVha1wiKSBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGUucGxhY2VtZW50ICE9PSBmaXJzdEZpdHRpbmdQbGFjZW1lbnQpIHtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwID0gdHJ1ZTtcbiAgICBzdGF0ZS5wbGFjZW1lbnQgPSBmaXJzdEZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgc3RhdGUucmVzZXQgPSB0cnVlO1xuICB9XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG52YXIgZmxpcCQxID0ge1xuICBuYW1lOiAnZmxpcCcsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBmbGlwLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddLFxuICBkYXRhOiB7XG4gICAgX3NraXA6IGZhbHNlXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgcmVjdHMsIG9mZnNldCkge1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgdmFyIGludmVydERpc3RhbmNlID0gW2xlZnQsIHRvcF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8gLTEgOiAxO1xuXG4gIHZhciBfcmVmID0gdHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IG9mZnNldChPYmplY3QuYXNzaWduKHt9LCByZWN0cywge1xuICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gIH0pKSA6IG9mZnNldCxcbiAgICAgIHNraWRkaW5nID0gX3JlZlswXSxcbiAgICAgIGRpc3RhbmNlID0gX3JlZlsxXTtcblxuICBza2lkZGluZyA9IHNraWRkaW5nIHx8IDA7XG4gIGRpc3RhbmNlID0gKGRpc3RhbmNlIHx8IDApICogaW52ZXJ0RGlzdGFuY2U7XG4gIHJldHVybiBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IHtcbiAgICB4OiBkaXN0YW5jZSxcbiAgICB5OiBza2lkZGluZ1xuICB9IDoge1xuICAgIHg6IHNraWRkaW5nLFxuICAgIHk6IGRpc3RhbmNlXG4gIH07XG59XG5cbmZ1bmN0aW9uIG9mZnNldChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYyLm5hbWU7XG4gIHZhciBfb3B0aW9ucyRvZmZzZXQgPSBvcHRpb25zLm9mZnNldCxcbiAgICAgIG9mZnNldCA9IF9vcHRpb25zJG9mZnNldCA9PT0gdm9pZCAwID8gWzAsIDBdIDogX29wdGlvbnMkb2Zmc2V0O1xuICB2YXIgZGF0YSA9IHBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIGFjY1twbGFjZW1lbnRdID0gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCBzdGF0ZS5yZWN0cywgb2Zmc2V0KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHZhciBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQgPSBkYXRhW3N0YXRlLnBsYWNlbWVudF0sXG4gICAgICB4ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50LngsXG4gICAgICB5ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50Lnk7XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsKSB7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnggKz0geDtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueSArPSB5O1xuICB9XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG52YXIgb2Zmc2V0JDEgPSB7XG4gIG5hbWU6ICdvZmZzZXQnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gIGZuOiBvZmZzZXRcbn07XG5cbnZhciB0b1BhZGRpbmdPYmplY3QgPSBmdW5jdGlvbiB0b1BhZGRpbmdPYmplY3QocGFkZGluZywgc3RhdGUpIHtcbiAgcGFkZGluZyA9IHR5cGVvZiBwYWRkaW5nID09PSAnZnVuY3Rpb24nID8gcGFkZGluZyhPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5yZWN0cywge1xuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pKSA6IHBhZGRpbmc7XG4gIHJldHVybiBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xufTtcblxuZnVuY3Rpb24gYXJyb3coX3JlZikge1xuICB2YXIgX3N0YXRlJG1vZGlmaWVyc0RhdGEkO1xuXG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciBheGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICB2YXIgaXNWZXJ0aWNhbCA9IFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwO1xuICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICBpZiAoIWFycm93RWxlbWVudCB8fCAhcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gdG9QYWRkaW5nT2JqZWN0KG9wdGlvbnMucGFkZGluZywgc3RhdGUpO1xuICB2YXIgYXJyb3dSZWN0ID0gZ2V0TGF5b3V0UmVjdChhcnJvd0VsZW1lbnQpO1xuICB2YXIgbWluUHJvcCA9IGF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gIHZhciBtYXhQcm9wID0gYXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gIHZhciBlbmREaWZmID0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2xlbl0gKyBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc10gLSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucG9wcGVyW2xlbl07XG4gIHZhciBzdGFydERpZmYgPSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdO1xuICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoYXJyb3dFbGVtZW50KTtcbiAgdmFyIGNsaWVudFNpemUgPSBhcnJvd09mZnNldFBhcmVudCA/IGF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudEhlaWdodCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50V2lkdGggfHwgMCA6IDA7XG4gIHZhciBjZW50ZXJUb1JlZmVyZW5jZSA9IGVuZERpZmYgLyAyIC0gc3RhcnREaWZmIC8gMjsgLy8gTWFrZSBzdXJlIHRoZSBhcnJvdyBkb2Vzbid0IG92ZXJmbG93IHRoZSBwb3BwZXIgaWYgdGhlIGNlbnRlciBwb2ludCBpc1xuICAvLyBvdXRzaWRlIG9mIHRoZSBwb3BwZXIgYm91bmRzXG5cbiAgdmFyIG1pbiA9IHBhZGRpbmdPYmplY3RbbWluUHJvcF07XG4gIHZhciBtYXggPSBjbGllbnRTaXplIC0gYXJyb3dSZWN0W2xlbl0gLSBwYWRkaW5nT2JqZWN0W21heFByb3BdO1xuICB2YXIgY2VudGVyID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd1JlY3RbbGVuXSAvIDIgKyBjZW50ZXJUb1JlZmVyZW5jZTtcbiAgdmFyIG9mZnNldCA9IHdpdGhpbihtaW4sIGNlbnRlciwgbWF4KTsgLy8gUHJldmVudHMgYnJlYWtpbmcgc3ludGF4IGhpZ2hsaWdodGluZy4uLlxuXG4gIHZhciBheGlzUHJvcCA9IGF4aXM7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSAoX3N0YXRlJG1vZGlmaWVyc0RhdGEkID0ge30sIF9zdGF0ZSRtb2RpZmllcnNEYXRhJFtheGlzUHJvcF0gPSBvZmZzZXQsIF9zdGF0ZSRtb2RpZmllcnNEYXRhJC5jZW50ZXJPZmZzZXQgPSBvZmZzZXQgLSBjZW50ZXIsIF9zdGF0ZSRtb2RpZmllcnNEYXRhJCk7XG59XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkZWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudCxcbiAgICAgIGFycm93RWxlbWVudCA9IF9vcHRpb25zJGVsZW1lbnQgPT09IHZvaWQgMCA/ICdbZGF0YS1wb3BwZXItYXJyb3ddJyA6IF9vcHRpb25zJGVsZW1lbnQ7XG5cbiAgaWYgKGFycm93RWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIENTUyBzZWxlY3RvclxuXG5cbiAgaWYgKHR5cGVvZiBhcnJvd0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMucG9wcGVyLnF1ZXJ5U2VsZWN0b3IoYXJyb3dFbGVtZW50KTtcblxuICAgIGlmICghYXJyb3dFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb250YWlucyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIsIGFycm93RWxlbWVudCkpIHtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0YXRlLmVsZW1lbnRzLmFycm93ID0gYXJyb3dFbGVtZW50O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxudmFyIGFycm93JDEgPSB7XG4gIG5hbWU6ICdhcnJvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBhcnJvdyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXVxufTtcblxuY29uc3QgdG9JbnQgPSB4ID0+IHBhcnNlSW50KHgsIDEwKTtcblxuZnVuY3Rpb24gdXNlUG9wcGVyKHtcbiAgYXJyb3dQYWRkaW5nLFxuICBlbWl0LFxuICBsb2NrZWQsXG4gIG9mZnNldERpc3RhbmNlLFxuICBvZmZzZXRTa2lkLFxuICBwbGFjZW1lbnQsXG4gIHBvcHBlck5vZGUsXG4gIHRyaWdnZXJOb2RlXG59KSB7XG4gIGNvbnN0IHN0YXRlID0gcmVhY3RpdmUoe1xuICAgIGlzT3BlbjogZmFsc2UsXG4gICAgcG9wcGVySW5zdGFuY2U6IG51bGxcbiAgfSk7IC8vIEVuYWJsZSBvciBkaXNhYmxlIGV2ZW50IGxpc3RlbmVycyB0byBvcHRpbWl6ZSBwZXJmb3JtYW5jZS5cblxuICBjb25zdCBzZXRQb3BwZXJFdmVudExpc3RlbmVycyA9IGVuYWJsZWQgPT4ge1xuICAgIHZhciBfc3RhdGUkcG9wcGVySW5zdGFuY2U7XG5cbiAgICAoX3N0YXRlJHBvcHBlckluc3RhbmNlID0gc3RhdGUucG9wcGVySW5zdGFuY2UpID09PSBudWxsIHx8IF9zdGF0ZSRwb3BwZXJJbnN0YW5jZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0YXRlJHBvcHBlckluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyA9PiAoeyAuLi5vcHRpb25zLFxuICAgICAgbW9kaWZpZXJzOiBbLi4ub3B0aW9ucy5tb2RpZmllcnMsIHtcbiAgICAgICAgbmFtZTogXCJldmVudExpc3RlbmVyc1wiLFxuICAgICAgICBlbmFibGVkXG4gICAgICB9XVxuICAgIH0pKTtcbiAgfTtcblxuICBjb25zdCBlbmFibGVQb3BwZXJFdmVudExpc3RlbmVycyA9ICgpID0+IHNldFBvcHBlckV2ZW50TGlzdGVuZXJzKHRydWUpO1xuXG4gIGNvbnN0IGRpc2FibGVQb3BwZXJFdmVudExpc3RlbmVycyA9ICgpID0+IHNldFBvcHBlckV2ZW50TGlzdGVuZXJzKGZhbHNlKTtcblxuICBjb25zdCBjbG9zZSA9ICgpID0+IHtcbiAgICBpZiAoIXN0YXRlLmlzT3Blbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN0YXRlLmlzT3BlbiA9IGZhbHNlO1xuICAgIGVtaXQoXCJjbG9zZTpwb3BwZXJcIik7XG4gIH07XG5cbiAgY29uc3Qgb3BlbiA9ICgpID0+IHtcbiAgICBpZiAoc3RhdGUuaXNPcGVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3RhdGUuaXNPcGVuID0gdHJ1ZTtcbiAgICBlbWl0KFwib3Blbjpwb3BwZXJcIik7XG4gIH07IC8vIFdoZW4gaXNPcGVuIG9yIHBsYWNlbWVudCBjaGFuZ2VcblxuXG4gIHdhdGNoKFsoKSA9PiBzdGF0ZS5pc09wZW4sIHBsYWNlbWVudF0sIGFzeW5jIChbaXNPcGVuXSkgPT4ge1xuICAgIGlmIChpc09wZW4pIHtcbiAgICAgIGF3YWl0IGluaXRpYWxpemVQb3BwZXIoKTtcbiAgICAgIGVuYWJsZVBvcHBlckV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpc2FibGVQb3BwZXJFdmVudExpc3RlbmVycygpO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgaW5pdGlhbGl6ZVBvcHBlciA9IGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBuZXh0VGljaygpO1xuICAgIHN0YXRlLnBvcHBlckluc3RhbmNlID0gY3JlYXRlUG9wcGVyKHRyaWdnZXJOb2RlLnZhbHVlLCBwb3BwZXJOb2RlLnZhbHVlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudC52YWx1ZSxcbiAgICAgIG1vZGlmaWVyczogW3ByZXZlbnRPdmVyZmxvdyQxLCBmbGlwJDEsIHtcbiAgICAgICAgbmFtZTogXCJmbGlwXCIsXG4gICAgICAgIGVuYWJsZWQ6ICFsb2NrZWQudmFsdWVcbiAgICAgIH0sIGFycm93JDEsIHtcbiAgICAgICAgbmFtZTogXCJhcnJvd1wiLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgcGFkZGluZzogdG9JbnQoYXJyb3dQYWRkaW5nLnZhbHVlKVxuICAgICAgICB9XG4gICAgICB9LCBvZmZzZXQkMSwge1xuICAgICAgICBuYW1lOiBcIm9mZnNldFwiLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgb2Zmc2V0OiBbdG9JbnQob2Zmc2V0U2tpZC52YWx1ZSksIHRvSW50KG9mZnNldERpc3RhbmNlLnZhbHVlKV1cbiAgICAgICAgfVxuICAgICAgfV1cbiAgICB9KTsgLy8gVXBkYXRlIGl0cyBwb3NpdGlvblxuXG4gICAgc3RhdGUucG9wcGVySW5zdGFuY2UudXBkYXRlKCk7XG4gIH07XG5cbiAgb25CZWZvcmVVbm1vdW50KCgpID0+IHtcbiAgICB2YXIgX3N0YXRlJHBvcHBlckluc3RhbmNlMjtcblxuICAgIChfc3RhdGUkcG9wcGVySW5zdGFuY2UyID0gc3RhdGUucG9wcGVySW5zdGFuY2UpID09PSBudWxsIHx8IF9zdGF0ZSRwb3BwZXJJbnN0YW5jZTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZSRwb3BwZXJJbnN0YW5jZTIuZGVzdHJveSgpO1xuICB9KTtcbiAgcmV0dXJuIHsgLi4udG9SZWZzKHN0YXRlKSxcbiAgICBvcGVuLFxuICAgIGNsb3NlXG4gIH07XG59XG5cbmNvbnN0IF9ob2lzdGVkXzEkMSA9IHtcbiAgaWQ6IFwiYXJyb3dcIixcbiAgXCJkYXRhLXBvcHBlci1hcnJvd1wiOiBcIlwiXG59O1xuZnVuY3Rpb24gcmVuZGVyKF9jdHgsIF9jYWNoZSkge1xuICByZXR1cm4gb3BlbkJsb2NrKCksIGNyZWF0ZUVsZW1lbnRCbG9jayhcImRpdlwiLCBfaG9pc3RlZF8xJDEpO1xufVxuXG5mdW5jdGlvbiBzdHlsZUluamVjdChjc3MsIHJlZikge1xuICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0ge307XG4gIHZhciBpbnNlcnRBdCA9IHJlZi5pbnNlcnRBdDtcblxuICBpZiAoIWNzcyB8fCB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybjsgfVxuXG4gIHZhciBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICBzdHlsZS50eXBlID0gJ3RleHQvY3NzJztcblxuICBpZiAoaW5zZXJ0QXQgPT09ICd0b3AnKSB7XG4gICAgaWYgKGhlYWQuZmlyc3RDaGlsZCkge1xuICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc3R5bGUsIGhlYWQuZmlyc3RDaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbnZhciBjc3NfMjQ4eiQxID0gXCJcXG4jYXJyb3dbZGF0YS12LTIwYjdmZDRhXSxcXG4gICNhcnJvd1tkYXRhLXYtMjBiN2ZkNGFdOjpiZWZvcmUge1xcbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kIDI1MG1zIGVhc2UtaW4tb3V0O1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHdpZHRoOiBjYWxjKDEwcHggLSB2YXIoLS1wb3BwZXItdGhlbWUtYm9yZGVyLXdpZHRoLCAwcHgpKTtcXG4gICAgaGVpZ2h0OiBjYWxjKDEwcHggLSB2YXIoLS1wb3BwZXItdGhlbWUtYm9yZGVyLXdpZHRoLCAwcHgpKTtcXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgYmFja2dyb3VuZDogdmFyKC0tcG9wcGVyLXRoZW1lLWJhY2tncm91bmQtY29sb3IpO1xcbn1cXG4jYXJyb3dbZGF0YS12LTIwYjdmZDRhXSB7XFxuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcXG59XFxuI2Fycm93W2RhdGEtdi0yMGI3ZmQ0YV06OmJlZm9yZSB7XFxuICAgIHZpc2liaWxpdHk6IHZpc2libGU7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxufVxcblxcbiAgLyogVG9wIGFycm93ICovXFxuLnBvcHBlcltkYXRhLXBvcHBlci1wbGFjZW1lbnRePVxcXCJ0b3BcXFwiXSA+ICNhcnJvd1tkYXRhLXYtMjBiN2ZkNGFdIHtcXG4gICAgYm90dG9tOiAtNXB4O1xcbn1cXG4ucG9wcGVyW2RhdGEtcG9wcGVyLXBsYWNlbWVudF49XFxcInRvcFxcXCJdID4gI2Fycm93W2RhdGEtdi0yMGI3ZmQ0YV06OmJlZm9yZSB7XFxuICAgIGJvcmRlci1yaWdodDogdmFyKC0tcG9wcGVyLXRoZW1lLWJvcmRlci13aWR0aClcXG4gICAgICB2YXIoLS1wb3BwZXItdGhlbWUtYm9yZGVyLXN0eWxlKSB2YXIoLS1wb3BwZXItdGhlbWUtYm9yZGVyLWNvbG9yKTtcXG4gICAgYm9yZGVyLWJvdHRvbTogdmFyKC0tcG9wcGVyLXRoZW1lLWJvcmRlci13aWR0aClcXG4gICAgICB2YXIoLS1wb3BwZXItdGhlbWUtYm9yZGVyLXN0eWxlKSB2YXIoLS1wb3BwZXItdGhlbWUtYm9yZGVyLWNvbG9yKTtcXG59XFxuXFxuICAvKiBCb3R0b20gYXJyb3cgKi9cXG4ucG9wcGVyW2RhdGEtcG9wcGVyLXBsYWNlbWVudF49XFxcImJvdHRvbVxcXCJdID4gI2Fycm93W2RhdGEtdi0yMGI3ZmQ0YV0ge1xcbiAgICB0b3A6IC01cHg7XFxufVxcbi5wb3BwZXJbZGF0YS1wb3BwZXItcGxhY2VtZW50Xj1cXFwiYm90dG9tXFxcIl0gPiAjYXJyb3dbZGF0YS12LTIwYjdmZDRhXTo6YmVmb3JlIHtcXG4gICAgYm9yZGVyLWxlZnQ6IHZhcigtLXBvcHBlci10aGVtZS1ib3JkZXItd2lkdGgpXFxuICAgICAgdmFyKC0tcG9wcGVyLXRoZW1lLWJvcmRlci1zdHlsZSkgdmFyKC0tcG9wcGVyLXRoZW1lLWJvcmRlci1jb2xvcik7XFxuICAgIGJvcmRlci10b3A6IHZhcigtLXBvcHBlci10aGVtZS1ib3JkZXItd2lkdGgpXFxuICAgICAgdmFyKC0tcG9wcGVyLXRoZW1lLWJvcmRlci1zdHlsZSkgdmFyKC0tcG9wcGVyLXRoZW1lLWJvcmRlci1jb2xvcik7XFxufVxcblxcbiAgLyogTGVmdCBhcnJvdyAqL1xcbi5wb3BwZXJbZGF0YS1wb3BwZXItcGxhY2VtZW50Xj1cXFwibGVmdFxcXCJdID4gI2Fycm93W2RhdGEtdi0yMGI3ZmQ0YV0ge1xcbiAgICByaWdodDogLTVweDtcXG59XFxuLnBvcHBlcltkYXRhLXBvcHBlci1wbGFjZW1lbnRePVxcXCJsZWZ0XFxcIl0gPiAjYXJyb3dbZGF0YS12LTIwYjdmZDRhXTo6YmVmb3JlIHtcXG4gICAgYm9yZGVyLXJpZ2h0OiB2YXIoLS1wb3BwZXItdGhlbWUtYm9yZGVyLXdpZHRoKVxcbiAgICAgIHZhcigtLXBvcHBlci10aGVtZS1ib3JkZXItc3R5bGUpIHZhcigtLXBvcHBlci10aGVtZS1ib3JkZXItY29sb3IpO1xcbiAgICBib3JkZXItdG9wOiB2YXIoLS1wb3BwZXItdGhlbWUtYm9yZGVyLXdpZHRoKVxcbiAgICAgIHZhcigtLXBvcHBlci10aGVtZS1ib3JkZXItc3R5bGUpIHZhcigtLXBvcHBlci10aGVtZS1ib3JkZXItY29sb3IpO1xcbn1cXG5cXG4gIC8qIFJpZ2h0IGFycm93ICovXFxuLnBvcHBlcltkYXRhLXBvcHBlci1wbGFjZW1lbnRePVxcXCJyaWdodFxcXCJdID4gI2Fycm93W2RhdGEtdi0yMGI3ZmQ0YV0ge1xcbiAgICBsZWZ0OiAtNXB4O1xcbn1cXG5cIjtcbnN0eWxlSW5qZWN0KGNzc18yNDh6JDEpO1xuXG5jb25zdCBzY3JpcHQkMSA9IHt9O1xuc2NyaXB0JDEucmVuZGVyID0gcmVuZGVyO1xuc2NyaXB0JDEuX19zY29wZUlkID0gXCJkYXRhLXYtMjBiN2ZkNGFcIjtcbnZhciBBcnJvdyA9IHNjcmlwdCQxO1xuXG5jb25zdCBfaG9pc3RlZF8xID0gW1wib25LZXl1cFwiXTtcbnZhciBzY3JpcHQgPSB7XG4gIHByb3BzOiB7XG4gICAgLyoqXG4gICAgICogUHJlZmVycmVkIHBsYWNlbWVudCAodGhlIFwiYXV0b1wiIHBsYWNlbWVudHMgd2lsbCBjaG9vc2UgdGhlIHNpZGUgd2l0aCBtb3N0IHNwYWNlLilcbiAgICAgKi9cbiAgICBwbGFjZW1lbnQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IFwiYm90dG9tXCIsXG4gICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gW1wiYXV0b1wiLCBcImF1dG8tc3RhcnRcIiwgXCJhdXRvLWVuZFwiLCBcInRvcFwiLCBcInRvcC1zdGFydFwiLCBcInRvcC1lbmRcIiwgXCJib3R0b21cIiwgXCJib3R0b20tc3RhcnRcIiwgXCJib3R0b20tZW5kXCIsIFwicmlnaHRcIiwgXCJyaWdodC1zdGFydFwiLCBcInJpZ2h0LWVuZFwiLCBcImxlZnRcIiwgXCJsZWZ0LXN0YXJ0XCIsIFwibGVmdC1lbmRcIl0uaW5jbHVkZXModmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlcyBhdXRvbWF0aWNhbGx5IGNsb3NpbmcgdGhlIHBvcG92ZXIgd2hlbiB0aGUgdXNlciBjbGlja3MgYXdheSBmcm9tIGl0XG4gICAgICovXG4gICAgZGlzYWJsZUNsaWNrQXdheToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9mZnNldCBpbiBwaXhlbHMgYWxvbmcgdGhlIHRyaWdnZXIgZWxlbWVudFxuICAgICAqL1xuICAgIG9mZnNldFNraWQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IFwiMFwiXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9mZnNldCBpbiBwaXhlbHMgYXdheSBmcm9tIHRoZSB0cmlnZ2VyIGVsZW1lbnRcbiAgICAgKi9cbiAgICBvZmZzZXREaXN0YW5jZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogXCIxMlwiXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgdGhlIHBvcHBlciBvbiBob3ZlclxuICAgICAqL1xuICAgIGhvdmVyOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFudWFsbHkgb3Blbi9jbG9zZSB0aGUgUG9wcGVyLCBvdGhlciBldmVudHMgYXJlIGlnbm9yZWQgaWYgdGhpcyBwcm9wIGlzIHNldFxuICAgICAqL1xuICAgIHNob3c6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpc2FibGVzIHRoZSBQb3BwZXIuIElmIGl0IHdhcyBhbHJlYWR5IG9wZW4sIGl0IHdpbGwgYmUgY2xvc2VkLlxuICAgICAqL1xuICAgIGRpc2FibGVkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT3BlbiB0aGUgUG9wcGVyIGFmdGVyIGEgZGVsYXkgKG1zKS5cbiAgICAgKi9cbiAgICBvcGVuRGVsYXk6IHtcbiAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICBkZWZhdWx0OiAwXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsb3NlIHRoZSBQb3BwZXIgYWZ0ZXIgYSBkZWxheSAobXMpLlxuICAgICAqL1xuICAgIGNsb3NlRGVsYXk6IHtcbiAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICBkZWZhdWx0OiAwXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB6LWluZGV4IG9mIHRoZSBQb3BwZXIuXG4gICAgICovXG4gICAgekluZGV4OiB7XG4gICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgZGVmYXVsdDogOTk5OVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5IGFuIGFycm93IG9uIHRoZSBwb3BwZXJcbiAgICAgKi9cbiAgICBhcnJvdzoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0b3AgYXJyb3cgZnJvbSByZWFjaGluZyB0aGUgZWRnZSBvZiB0aGUgcG9wcGVyXG4gICAgICovXG4gICAgYXJyb3dQYWRkaW5nOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBcIjBcIlxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgUG9wcGVyIHNob3VsZCBiZSBpbnRlcmFjdGl2ZSwgaXQgd2lsbCBjbG9zZSB3aGVuIGNsaWNrZWQvaG92ZXJlZCBpZiBmYWxzZVxuICAgICAqL1xuICAgIGludGVyYWN0aXZlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMb2NrIHRoZSBQb3BwZXIgaW50byBwbGFjZSwgaXQgd2lsbCBub3QgZmxpcCBkeW5hbWljYWxseSB3aGVuIGl0IHJ1bnMgb3V0IG9mIHNwYWNlIGlmIHRydWVcbiAgICAgKi9cbiAgICBsb2NrZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgY29udGVudCBpcyBqdXN0IGEgc2ltcGxlIHN0cmluZywgaXQgY2FuIGJlIHBhc3NlZCBpbiBhcyBhIHByb3BcbiAgICAgKi9cbiAgICBjb250ZW50OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfVxuICB9LFxuICBlbWl0czogW1wib3Blbjpwb3BwZXJcIiwgXCJjbG9zZTpwb3BwZXJcIl0sXG5cbiAgc2V0dXAoX19wcm9wcywge1xuICAgIGVtaXRcbiAgfSkge1xuICAgIGNvbnN0IHByb3BzID0gX19wcm9wcztcblxuICAgIHVzZUNzc1ZhcnMoX2N0eCA9PiAoe1xuICAgICAgXCJjODFmYzBhNFwiOiBfX3Byb3BzLnpJbmRleFxuICAgIH0pKTtcblxuICAgIGNvbnN0IHNsb3RzID0gdXNlU2xvdHMoKTtcbiAgICBjb25zdCBwb3BwZXJDb250YWluZXJOb2RlID0gcmVmKG51bGwpO1xuICAgIGNvbnN0IHBvcHBlck5vZGUgPSByZWYobnVsbCk7XG4gICAgY29uc3QgdHJpZ2dlck5vZGUgPSByZWYobnVsbCk7XG4gICAgY29uc3QgbW9kaWZpZWRJc09wZW4gPSByZWYoZmFsc2UpO1xuICAgIG9uTW91bnRlZCgoKSA9PiB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQoKTtcblxuICAgICAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoYFtQb3BwZXJdOiBUaGUgPFBvcHBlcj4gY29tcG9uZW50IGV4cGVjdHMgb25seSBvbmUgY2hpbGQgZWxlbWVudCBhdCBpdHMgcm9vdC4gWW91IHBhc3NlZCAke2NoaWxkcmVuLmxlbmd0aH0gY2hpbGQgbm9kZXMuYCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qge1xuICAgICAgYXJyb3dQYWRkaW5nLFxuICAgICAgY2xvc2VEZWxheSxcbiAgICAgIGNvbnRlbnQsXG4gICAgICBkaXNhYmxlQ2xpY2tBd2F5LFxuICAgICAgZGlzYWJsZWQsXG4gICAgICBpbnRlcmFjdGl2ZSxcbiAgICAgIGxvY2tlZCxcbiAgICAgIG9mZnNldERpc3RhbmNlLFxuICAgICAgb2Zmc2V0U2tpZCxcbiAgICAgIG9wZW5EZWxheSxcbiAgICAgIHBsYWNlbWVudCxcbiAgICAgIHNob3dcbiAgICB9ID0gdG9SZWZzKHByb3BzKTtcbiAgICBjb25zdCB7XG4gICAgICBpc09wZW4sXG4gICAgICBvcGVuLFxuICAgICAgY2xvc2VcbiAgICB9ID0gdXNlUG9wcGVyKHtcbiAgICAgIGFycm93UGFkZGluZyxcbiAgICAgIGVtaXQsXG4gICAgICBsb2NrZWQsXG4gICAgICBvZmZzZXREaXN0YW5jZSxcbiAgICAgIG9mZnNldFNraWQsXG4gICAgICBwbGFjZW1lbnQsXG4gICAgICBwb3BwZXJOb2RlLFxuICAgICAgdHJpZ2dlck5vZGVcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBoYXNDb250ZW50XG4gICAgfSA9IHVzZUNvbnRlbnQoc2xvdHMsIHBvcHBlck5vZGUsIGNvbnRlbnQpO1xuICAgIGNvbnN0IG1hbnVhbE1vZGUgPSBjb21wdXRlZCgoKSA9PiBzaG93LnZhbHVlICE9PSBudWxsKTtcbiAgICBjb25zdCBpbnZhbGlkID0gY29tcHV0ZWQoKCkgPT4gZGlzYWJsZWQudmFsdWUgfHwgIWhhc0NvbnRlbnQudmFsdWUpO1xuICAgIGNvbnN0IHNob3VsZFNob3dQb3BwZXIgPSBjb21wdXRlZCgoKSA9PiBpc09wZW4udmFsdWUgJiYgIWludmFsaWQudmFsdWUpO1xuICAgIGNvbnN0IGVuYWJsZUNsaWNrQXdheSA9IGNvbXB1dGVkKCgpID0+ICFkaXNhYmxlQ2xpY2tBd2F5LnZhbHVlICYmICFtYW51YWxNb2RlLnZhbHVlKTsgLy8gQWRkIGFuIGludmlzaWJsZSBib3JkZXIgdG8ga2VlcCB0aGUgUG9wcGVyIG9wZW4gd2hlbiBob3ZlcmluZyBmcm9tIHRoZSB0cmlnZ2VyIGludG8gaXRcblxuICAgIGNvbnN0IGludGVyYWN0aXZlU3R5bGUgPSBjb21wdXRlZCgoKSA9PiBpbnRlcmFjdGl2ZS52YWx1ZSA/IGBib3JkZXI6ICR7b2Zmc2V0RGlzdGFuY2UudmFsdWV9cHggc29saWQgdHJhbnNwYXJlbnQ7IG1hcmdpbjogLSR7b2Zmc2V0RGlzdGFuY2UudmFsdWV9cHg7YCA6IG51bGwpO1xuICAgIGNvbnN0IG9wZW5Qb3BwZXJEZWJvdW5jZSA9IGRlYm91bmNlXzEuZGVib3VuY2Uob3Blbiwgb3BlbkRlbGF5LnZhbHVlKTtcbiAgICBjb25zdCBjbG9zZVBvcHBlckRlYm91bmNlID0gZGVib3VuY2VfMS5kZWJvdW5jZShjbG9zZSwgY2xvc2VEZWxheS52YWx1ZSk7XG5cbiAgICBjb25zdCBvcGVuUG9wcGVyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKGludmFsaWQudmFsdWUgfHwgbWFudWFsTW9kZS52YWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNsb3NlUG9wcGVyRGVib3VuY2UuY2xlYXIoKTtcbiAgICAgIG9wZW5Qb3BwZXJEZWJvdW5jZSgpO1xuICAgIH07XG5cbiAgICBjb25zdCBjbG9zZVBvcHBlciA9IGFzeW5jICgpID0+IHtcbiAgICAgIGlmIChtYW51YWxNb2RlLnZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgb3BlblBvcHBlckRlYm91bmNlLmNsZWFyKCk7XG4gICAgICBjbG9zZVBvcHBlckRlYm91bmNlKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHRvZ2dsZVBvcHBlciA9ICgpID0+IHtcbiAgICAgIGlzT3Blbi52YWx1ZSA/IGNsb3NlUG9wcGVyKCkgOiBvcGVuUG9wcGVyKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJZiBQb3BwZXIgaXMgb3Blbiwgd2UgYXV0b21hdGljYWxseSBjbG9zZSBpdCBpZiBpdCBiZWNvbWVzXG4gICAgICogZGlzYWJsZWQgb3Igd2l0aG91dCBjb250ZW50LlxuICAgICAqL1xuXG5cbiAgICB3YXRjaChbaGFzQ29udGVudCwgZGlzYWJsZWRdLCAoW2hhc0NvbnRlbnQsIGRpc2FibGVkXSkgPT4ge1xuICAgICAgaWYgKGlzT3Blbi52YWx1ZSAmJiAoIWhhc0NvbnRlbnQgfHwgZGlzYWJsZWQpKSB7XG4gICAgICAgIGNsb3NlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogSW4gb3JkZXIgdG8gZWxpbWluYXRlIGZsaWNrZXJpbmcgb3IgdmlzaWJseSBlbXB0eSBQb3BwZXJzIGR1ZSB0b1xuICAgICAqIHRoZSB0cmFuc2l0aW9uIHdoZW4gdXNpbmcgdGhlIGlzT3BlbiBzbG90IHByb3BlcnR5LCB3ZSBuZWVkIHRvIHJldHVybiBhXG4gICAgICogc2VwYXJhdGUgZGVib3VuY2VkIHZhbHVlIGJhc2VkIG9uIGlzT3Blbi5cbiAgICAgKi9cblxuICAgIHdhdGNoKGlzT3BlbiwgaXNPcGVuID0+IHtcbiAgICAgIGlmIChpc09wZW4pIHtcbiAgICAgICAgbW9kaWZpZWRJc09wZW4udmFsdWUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVib3VuY2VfMS5kZWJvdW5jZSgoKSA9PiB7XG4gICAgICAgICAgbW9kaWZpZWRJc09wZW4udmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfSwgMjAwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBXYXRjaCBmb3IgbWFudWFsIG1vZGUuXG4gICAgICovXG5cbiAgICB3YXRjaEVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAobWFudWFsTW9kZS52YWx1ZSkge1xuICAgICAgICBzaG93LnZhbHVlID8gb3BlblBvcHBlckRlYm91bmNlKCkgOiBjbG9zZVBvcHBlckRlYm91bmNlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVXNlIGNsaWNrIGF3YXkgaWYgaXQgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAgICovXG5cbiAgICB3YXRjaEVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoZW5hYmxlQ2xpY2tBd2F5LnZhbHVlKSB7XG4gICAgICAgIHVzZUNsaWNrQXdheShwb3BwZXJDb250YWluZXJOb2RlLCBjbG9zZVBvcHBlcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIChfY3R4LCBfY2FjaGUpID0+IHtcbiAgICAgIHJldHVybiBvcGVuQmxvY2soKSwgY3JlYXRlRWxlbWVudEJsb2NrKFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3M6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgIHN0eWxlOiBub3JtYWxpemVTdHlsZSh1bnJlZihpbnRlcmFjdGl2ZVN0eWxlKSksXG4gICAgICAgIG9uTW91c2VsZWF2ZTogX2NhY2hlWzJdIHx8IChfY2FjaGVbMl0gPSAkZXZlbnQgPT4gX19wcm9wcy5ob3ZlciAmJiBjbG9zZVBvcHBlcigpKSxcbiAgICAgICAgcmVmOiAoX3ZhbHVlLCBfcmVmcykgPT4ge1xuICAgICAgICAgIF9yZWZzWydwb3BwZXJDb250YWluZXJOb2RlJ10gPSBfdmFsdWU7XG4gICAgICAgICAgcG9wcGVyQ29udGFpbmVyTm9kZS52YWx1ZSA9IF92YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSwgW2NyZWF0ZUVsZW1lbnRWTm9kZShcImRpdlwiLCB7XG4gICAgICAgIHJlZjogKF92YWx1ZSwgX3JlZnMpID0+IHtcbiAgICAgICAgICBfcmVmc1sndHJpZ2dlck5vZGUnXSA9IF92YWx1ZTtcbiAgICAgICAgICB0cmlnZ2VyTm9kZS52YWx1ZSA9IF92YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Nb3VzZW92ZXI6IF9jYWNoZVswXSB8fCAoX2NhY2hlWzBdID0gJGV2ZW50ID0+IF9fcHJvcHMuaG92ZXIgJiYgb3BlblBvcHBlcigpKSxcbiAgICAgICAgb25DbGljazogdG9nZ2xlUG9wcGVyLFxuICAgICAgICBvbkZvY3VzOiBvcGVuUG9wcGVyLFxuICAgICAgICBvbktleXVwOiB3aXRoS2V5cyhjbG9zZVBvcHBlciwgW1wiZXNjXCJdKVxuICAgICAgfSwgW3JlbmRlclNsb3QoX2N0eC4kc2xvdHMsIFwiZGVmYXVsdFwiKV0sIDQwLCBfaG9pc3RlZF8xKSwgY3JlYXRlVk5vZGUoVHJhbnNpdGlvbiwge1xuICAgICAgICBuYW1lOiBcImZhZGVcIlxuICAgICAgfSwge1xuICAgICAgICBkZWZhdWx0OiB3aXRoQ3R4KCgpID0+IFt3aXRoRGlyZWN0aXZlcyhjcmVhdGVFbGVtZW50Vk5vZGUoXCJkaXZcIiwge1xuICAgICAgICAgIG9uQ2xpY2s6IF9jYWNoZVsxXSB8fCAoX2NhY2hlWzFdID0gJGV2ZW50ID0+ICF1bnJlZihpbnRlcmFjdGl2ZSkgJiYgY2xvc2VQb3BwZXIoKSksXG4gICAgICAgICAgY2xhc3M6IFwicG9wcGVyXCIsXG4gICAgICAgICAgcmVmOiAoX3ZhbHVlLCBfcmVmcykgPT4ge1xuICAgICAgICAgICAgX3JlZnNbJ3BvcHBlck5vZGUnXSA9IF92YWx1ZTtcbiAgICAgICAgICAgIHBvcHBlck5vZGUudmFsdWUgPSBfdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBbcmVuZGVyU2xvdChfY3R4LiRzbG90cywgXCJjb250ZW50XCIsIHtcbiAgICAgICAgICBjbG9zZTogdW5yZWYoY2xvc2UpLFxuICAgICAgICAgIGlzT3BlbjogbW9kaWZpZWRJc09wZW4udmFsdWVcbiAgICAgICAgfSwgKCkgPT4gW2NyZWF0ZVRleHRWTm9kZSh0b0Rpc3BsYXlTdHJpbmcodW5yZWYoY29udGVudCkpLCAxKV0pLCBfX3Byb3BzLmFycm93ID8gKG9wZW5CbG9jaygpLCBjcmVhdGVCbG9jayhBcnJvdywge1xuICAgICAgICAgIGtleTogMFxuICAgICAgICB9KSkgOiBjcmVhdGVDb21tZW50Vk5vZGUoXCJcIiwgdHJ1ZSldLCA1MTIpLCBbW3ZTaG93LCB1bnJlZihzaG91bGRTaG93UG9wcGVyKV1dKV0pLFxuICAgICAgICBfOiAzXG4gICAgICB9KV0sIDM2KTtcbiAgICB9O1xuICB9XG5cbn07XG5cbnZhciBjc3NfMjQ4eiA9IFwiXFxuLmlubGluZS1ibG9ja1tkYXRhLXYtNTc4NGVkNjldIHtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbn1cXG4ucG9wcGVyW2RhdGEtdi01Nzg0ZWQ2OV0ge1xcbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kIDI1MG1zIGVhc2UtaW4tb3V0O1xcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1wb3BwZXItdGhlbWUtYmFja2dyb3VuZC1jb2xvcik7XFxuICAgIHBhZGRpbmc6IHZhcigtLXBvcHBlci10aGVtZS1wYWRkaW5nKTtcXG4gICAgY29sb3I6IHZhcigtLXBvcHBlci10aGVtZS10ZXh0LWNvbG9yKTtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tcG9wcGVyLXRoZW1lLWJvcmRlci1yYWRpdXMpO1xcbiAgICBib3JkZXItd2lkdGg6IHZhcigtLXBvcHBlci10aGVtZS1ib3JkZXItd2lkdGgpO1xcbiAgICBib3JkZXItc3R5bGU6IHZhcigtLXBvcHBlci10aGVtZS1ib3JkZXItc3R5bGUpO1xcbiAgICBib3JkZXItY29sb3I6IHZhcigtLXBvcHBlci10aGVtZS1ib3JkZXItY29sb3IpO1xcbiAgICBib3gtc2hhZG93OiB2YXIoLS1wb3BwZXItdGhlbWUtYm94LXNoYWRvdyk7XFxuICAgIHotaW5kZXg6IHZhcigtLWM4MWZjMGE0KTtcXG59XFxuLnBvcHBlcltkYXRhLXYtNTc4NGVkNjldOmhvdmVyLFxcbiAgLnBvcHBlcjpob3ZlciA+ICNhcnJvd1tkYXRhLXYtNTc4NGVkNjldOjpiZWZvcmUge1xcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1wb3BwZXItdGhlbWUtYmFja2dyb3VuZC1jb2xvci1ob3Zlcik7XFxufVxcbi5pbmxpbmUtYmxvY2tbZGF0YS12LTU3ODRlZDY5XSB7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG59XFxuLmZhZGUtZW50ZXItYWN0aXZlW2RhdGEtdi01Nzg0ZWQ2OV0sXFxuICAuZmFkZS1sZWF2ZS1hY3RpdmVbZGF0YS12LTU3ODRlZDY5XSB7XFxuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4ycyBlYXNlO1xcbn1cXG4uZmFkZS1lbnRlci1mcm9tW2RhdGEtdi01Nzg0ZWQ2OV0sXFxuICAuZmFkZS1sZWF2ZS10b1tkYXRhLXYtNTc4NGVkNjldIHtcXG4gICAgb3BhY2l0eTogMDtcXG59XFxuXCI7XG5zdHlsZUluamVjdChjc3NfMjQ4eik7XG5cbnNjcmlwdC5fX3Njb3BlSWQgPSBcImRhdGEtdi01Nzg0ZWQ2OVwiO1xuXG4vLyBJSUZFIGluamVjdHMgaW5zdGFsbCBmdW5jdGlvbiBpbnRvIGNvbXBvbmVudCwgYWxsb3dpbmcgY29tcG9uZW50XG4vLyB0byBiZSByZWdpc3RlcmVkIHZpYSBWdWUudXNlKCkgYXMgd2VsbCBhcyBWdWUuY29tcG9uZW50KCksXG5cbnZhciBlbnRyeV9lc20gPSAvKiNfX1BVUkVfXyovKCgpID0+IHtcbiAgLy8gR2V0IGNvbXBvbmVudCBpbnN0YW5jZVxuICBjb25zdCBpbnN0YWxsYWJsZSA9IHNjcmlwdDsgLy8gQXR0YWNoIGluc3RhbGwgZnVuY3Rpb24gZXhlY3V0ZWQgYnkgVnVlLnVzZSgpXG5cbiAgaW5zdGFsbGFibGUuaW5zdGFsbCA9IGFwcCA9PiB7XG4gICAgYXBwLmNvbXBvbmVudChcIlBvcHBlclwiLCBpbnN0YWxsYWJsZSk7XG4gIH07XG5cbiAgcmV0dXJuIGluc3RhbGxhYmxlO1xufSkoKTsgLy8gSXQncyBwb3NzaWJsZSB0byBleHBvc2UgbmFtZWQgZXhwb3J0cyB3aGVuIHdyaXRpbmcgY29tcG9uZW50cyB0aGF0IGNhblxuLy8gYWxzbyBiZSB1c2VkIGFzIGRpcmVjdGl2ZXMsIGV0Yy4gLSBlZy4gaW1wb3J0IHsgUm9sbHVwRGVtb0RpcmVjdGl2ZSB9IGZyb20gJ3JvbGx1cC1kZW1vJztcbi8vIGV4cG9ydCBjb25zdCBSb2xsdXBEZW1vRGlyZWN0aXZlID0gZGlyZWN0aXZlO1xuXG5leHBvcnQgeyBlbnRyeV9lc20gYXMgZGVmYXVsdCB9O1xuIiwiPHRlbXBsYXRlPlxuICA8c2VjdGlvblxuICAgIHYtaWY9XCJ0eXBlXCJcbiAgICByZWY9XCJub2RlXCJcbiAgICA6Y2xhc3M9XCJbJHN0eWxlLmljbywge1skc3R5bGVbJ2ljby0tZW1wdHknXV06ICFsYWJlbH0sICRzdHlsZVtpY29uQ2xhc3NOYW1lXV1cIlxuICAgIDpzdHlsZT1cIntmb250U2l6ZTogYCR7c2l6ZX1weGB9XCJcbiAgPlxuICAgIDxhcnRpY2xlXG4gICAgICB2LWlmPVwibGFiZWxcIlxuICAgICAgOmNsYXNzPVwiWyRzdHlsZS50eHQsICRzdHlsZVtgdHh0LSR7dHlwZX1gXSwgJHN0eWxlW2B0eHQtJHt0eXBlfS0tJHtzdGF0ZX1gXV1cIlxuICAgID5cbiAgICAgIHt7IGxhYmVsIH19XG4gICAgPC9hcnRpY2xlPlxuICA8L3NlY3Rpb24+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0IHNldHVwPlxuaW1wb3J0IHtyZWYsIGNvbXB1dGVkLCB3YXRjaH0gZnJvbSAndnVlJ1xuaW1wb3J0IHt1c2VNb3VzZVByZXNzZWQsIHVzZUVsZW1lbnRIb3Zlcn0gZnJvbSAnQHZ1ZXVzZS9jb3JlJ1xuXG5jb25zdCBJQ09OX1NUQVRFID0ge1xuICBERUZBVUxUOiAnZGVmYXVsdCcsXG4gIEhPVkVSOiAnaG92ZXInLFxuICBDTElDSzogJ2NsaWNrJyxcbiAgRElTQUJMRTogJ2Rpc2FibGUnLFxufVxuXG5jb25zdCBub2RlID0gcmVmKG51bGwpXG5jb25zdCBpc0hvdmVyZWQgPSByZWYoZmFsc2UpXG5jb25zdCBpc0NsaWNrZWQgPSByZWYoZmFsc2UpXG5jb25zdCBkZWxheUhvdmVyID0gdXNlRWxlbWVudEhvdmVyKG5vZGUpXG5jb25zdCB7cHJlc3NlZDogZGVsYXlDbGlja30gPSB1c2VNb3VzZVByZXNzZWQoe3RhcmdldDogbm9kZX0pXG5cbmNvbnN0IHByb3BzID0gZGVmaW5lUHJvcHMoe1xuICB0eXBlOiB7dHlwZTogU3RyaW5nLCBkZWZhdWx0OiAnJ30sXG4gIGRpc2FibGU6IHt0eXBlOiBTdHJpbmcsIGRlZmF1bHQ6ICcnfSxcbiAgaG92ZXJEZWxheToge3R5cGU6IE51bWJlciwgZGVmYXVsdDogMH0sXG4gIGNsaWNrRGVsYXk6IHt0eXBlOiBOdW1iZXIsIGRlZmF1bHQ6IDB9LFxuICBsYWJlbDoge3R5cGU6IFN0cmluZywgZGVmYXVsdDogJyd9LFxuICBzaXplOiB7dHlwZTogTnVtYmVyLCBkZWZhdWx0OiAyNH0sXG4gIC8vIHZhbHVlIDAgbWVhbnMgZG8gbm90IGhhbmRsZSBob3ZlciBzdGF0ZVxuICAvLyB2YWx1ZSAxIGltcGxpZXMgY29udHJvbCBob3ZlciBzdGF0ZSBhcyBhIG5vcm1hbCBzdGF0ZVxuICAvLyB2YWx1ZSAyIGltcGxpZXMgY29udHJvbCBob3ZlciBzdGF0ZSBhcyBhbiBhY3RpdmUgc3RhdGVcbiAgaG92ZXJTdGF0ZToge3R5cGU6IE51bWJlciwgZGVmYXVsdDogMH0sXG59KVxuXG5jb25zdCBzdGF0ZSA9IGNvbXB1dGVkKCgpID0+IHtcbiAgaWYgKHByb3BzLmRpc2FibGUpIHJldHVybiBJQ09OX1NUQVRFLkRJU0FCTEVcbiAgaWYgKGlzQ2xpY2tlZC52YWx1ZSkgcmV0dXJuIElDT05fU1RBVEUuQ0xJQ0tcbiAgaWYgKGlzSG92ZXJlZC52YWx1ZSkgcmV0dXJuIElDT05fU1RBVEUuSE9WRVJcbiAgcmV0dXJuIElDT05fU1RBVEUuREVGQVVMVFxufSlcbmNvbnN0IGljb25DbGFzc05hbWUgPSBjb21wdXRlZCgoKSA9PiB7XG4gIGlmICghcHJvcHMuaG92ZXJTdGF0ZSkgcmV0dXJuIGBpbWctJHtwcm9wcy50eXBlfS0tJHtzdGF0ZS52YWx1ZX1gXG4gIGlmIChwcm9wcy5ob3ZlclN0YXRlID09PSAyKSByZXR1cm4gYGltZy0ke3Byb3BzLnR5cGV9LS1ob3ZlcmBcbiAgcmV0dXJuIGBpbWctJHtwcm9wcy50eXBlfS0tZGVmYXVsdGBcbn0pXG5cbmxldCBob3ZlclRpbWVyID0gbnVsbFxud2F0Y2goZGVsYXlIb3ZlciwgY3VycmVudFN0YXRlID0+IHtcbiAgaWYgKHByb3BzLmhvdmVyU3RhdGUgPiAwKSByZXR1cm5cbiAgaWYgKHByb3BzLmhvdmVyRGVsYXkgPT09IDApIGlzSG92ZXJlZC52YWx1ZSA9IGN1cnJlbnRTdGF0ZVxuICBlbHNlIGlmICghY3VycmVudFN0YXRlKSBob3ZlclRpbWVyID0gc2V0VGltZW91dCgoKSA9PiAoaXNIb3ZlcmVkLnZhbHVlID0gZmFsc2UpLCBwcm9wcy5ob3ZlckRlbGF5KVxuICBlbHNlIHtcbiAgICBjbGVhclRpbWVvdXQoaG92ZXJUaW1lcilcbiAgICBpc0hvdmVyZWQudmFsdWUgPSB0cnVlXG4gIH1cbn0pXG5sZXQgY2xpY2tUaW1lciA9IG51bGxcbndhdGNoKGRlbGF5Q2xpY2ssIGN1cnJlbnRTdGF0ZSA9PiB7XG4gIGlmIChwcm9wcy5ob3ZlckRlbGF5ID09PSAwKSBpc0NsaWNrZWQudmFsdWUgPSBjdXJyZW50U3RhdGVcbiAgZWxzZSBpZiAoIWN1cnJlbnRTdGF0ZSkgY2xpY2tUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gKGlzQ2xpY2tlZC52YWx1ZSA9IGZhbHNlKSwgcHJvcHMuaG92ZXJEZWxheSlcbiAgZWxzZSB7XG4gICAgY2xlYXJUaW1lb3V0KGNsaWNrVGltZXIpXG4gICAgaXNDbGlja2VkLnZhbHVlID0gdHJ1ZVxuICB9XG59KVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiIG1vZHVsZT5cbi5pY28ge1xuICBkaXNwbGF5OiBmbGV4O1xuICBiYWNrZ3JvdW5kOiBsZWZ0IGNlbnRlciAvIGF1dG8gMTAwJSBuby1yZXBlYXQ7XG59XG5cbi5pY286aG92ZXIge1xuICBjdXJzb3I6IHBvaW50ZXI7XG59XG5cbi5pY28tLWVtcHR5IHtcbiAgcGFkZGluZzogMWVtIDAgMCAxZW07XG59XG5cbi50eHQge1xuICBwYWRkaW5nLWxlZnQ6IDI4cHg7XG4gIGZvbnQtd2VpZ2h0OiA2MDA7XG4gIGZvbnQtc2l6ZTogMTRweDtcbiAgbGluZS1oZWlnaHQ6IDI0cHg7XG59XG5cbi50eHQ6aG92ZXIge1xuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbn1cblxuLy8gdGV4dCBlZmZlY3QgY29uZmlnXG4udHh0LXNhdmUge1xuICBjb2xvcjogIzRmNWFmZjtcbn1cblxuLnR4dC1zYXZlLS1jbGljayB7XG4gIGNvbG9yOiAjMjkyZjhlO1xufVxuXG4udHh0LWRlbGV0ZSB7XG4gIGNvbG9yOiAjNTg1YjU4O1xufVxuXG4udHh0LWRlbGV0ZS0tY2xpY2sge1xuICBjb2xvcjogIzI5MmY4ZTtcbn1cblxuQG1lZGlhIChwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaykge1xuICAudHh0LXNhdmUsXG4gIC50eHQtZGVsZXRlIHtcbiAgICBjb2xvcjogI2ZmZjtcbiAgfVxuXG4gIC50eHQtc2F2ZS0tY2xpY2ssXG4gIC50eHQtZGVsZXRlLS1jbGljayB7XG4gICAgY29sb3I6ICNkY2RlZTE7XG4gIH1cbn1cblxuLy8gaWNvbiBlZmZlY3QgY29uZmlnXG4uaW1nLWNsb3NlLS1jbGljayB7XG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YS1iYXNlNjQ6fnNyYy9jb21wb25lbnRzL0ludGVyYWN0aXZlSWNvbi9pbWFnZS9DbG9zZUxpZ2h0Q2xpY2suc3ZnJyk7XG59XG5cbi5pbWctY2xvc2UtLWRlZmF1bHQge1xuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGEtYmFzZTY0On5zcmMvY29tcG9uZW50cy9JbnRlcmFjdGl2ZUljb24vaW1hZ2UvQ2xvc2VMaWdodERlZmF1bHQuc3ZnJyk7XG59XG5cbi5pbWctY2xvc2UtLWRpc2FibGUge1xuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGEtYmFzZTY0On5zcmMvY29tcG9uZW50cy9JbnRlcmFjdGl2ZUljb24vaW1hZ2UvQ2xvc2VMaWdodERpc2FibGUuc3ZnJyk7XG59XG5cbi5pbWctY2xvc2UtLWhvdmVyIHtcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhLWJhc2U2NDp+c3JjL2NvbXBvbmVudHMvSW50ZXJhY3RpdmVJY29uL2ltYWdlL0Nsb3NlTGlnaHRIb3Zlci5zdmcnKTtcbn1cblxuLmltZy1jb2xsZWN0LS1jbGljayB7XG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YS1iYXNlNjQ6fnNyYy9jb21wb25lbnRzL0ludGVyYWN0aXZlSWNvbi9pbWFnZS9Db2xsZWN0TGlnaHRDbGljay5zdmcnKTtcbn1cblxuLmltZy1jb2xsZWN0LS1kZWZhdWx0IHtcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhLWJhc2U2NDp+c3JjL2NvbXBvbmVudHMvSW50ZXJhY3RpdmVJY29uL2ltYWdlL0NvbGxlY3RMaWdodERlZmF1bHQuc3ZnJyk7XG59XG5cbi5pbWctY29sbGVjdC0tZGlzYWJsZSB7XG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YS1iYXNlNjQ6fnNyYy9jb21wb25lbnRzL0ludGVyYWN0aXZlSWNvbi9pbWFnZS9Db2xsZWN0TGlnaHREaXNhYmxlLnN2ZycpO1xufVxuXG4uaW1nLWNvbGxlY3QtLWhvdmVyIHtcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhLWJhc2U2NDp+c3JjL2NvbXBvbmVudHMvSW50ZXJhY3RpdmVJY29uL2ltYWdlL0NvbGxlY3RMaWdodEhvdmVyLnN2ZycpO1xufVxuXG4uaW1nLWNvcHktLWNsaWNrIHtcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhLWJhc2U2NDp+c3JjL2NvbXBvbmVudHMvSW50ZXJhY3RpdmVJY29uL2ltYWdlL0NvcHlMaWdodENsaWNrLnN2ZycpO1xufVxuXG4uaW1nLWNvcHktLWRlZmF1bHQge1xuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGEtYmFzZTY0On5zcmMvY29tcG9uZW50cy9JbnRlcmFjdGl2ZUljb24vaW1hZ2UvQ29weUxpZ2h0RGVmYXVsdC5zdmcnKTtcbn1cblxuLmltZy1jb3B5LS1kaXNhYmxlIHtcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhLWJhc2U2NDp+c3JjL2NvbXBvbmVudHMvSW50ZXJhY3RpdmVJY29uL2ltYWdlL0NvcHlMaWdodERpc2FibGUuc3ZnJyk7XG59XG5cbi5pbWctY29weS0taG92ZXIge1xuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGEtYmFzZTY0On5zcmMvY29tcG9uZW50cy9JbnRlcmFjdGl2ZUljb24vaW1hZ2UvQ29weUxpZ2h0SG92ZXIuc3ZnJyk7XG59XG5cbi5pbWctZGVsZXRlLS1jbGljayB7XG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YS1iYXNlNjQ6fnNyYy9jb21wb25lbnRzL0ludGVyYWN0aXZlSWNvbi9pbWFnZS9EZWxldGVMaWdodENsaWNrLnN2ZycpO1xufVxuXG4vLyBubyBkaXNhYmxlIHN0YXRlXG4uaW1nLWRlbGV0ZS0tZGVmYXVsdCB7XG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YS1iYXNlNjQ6fnNyYy9jb21wb25lbnRzL0ludGVyYWN0aXZlSWNvbi9pbWFnZS9EZWxldGVMaWdodERlZmF1bHQuc3ZnJyk7XG59XG5cbi5pbWctZGVsZXRlLS1ob3ZlciB7XG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YS1iYXNlNjQ6fnNyYy9jb21wb25lbnRzL0ludGVyYWN0aXZlSWNvbi9pbWFnZS9EZWxldGVMaWdodEhvdmVyLnN2ZycpO1xufVxuXG4uaW1nLXByZXZpb3VzLS1jbGljayB7XG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YS1iYXNlNjQ6fnNyYy9jb21wb25lbnRzL0ludGVyYWN0aXZlSWNvbi9pbWFnZS9QcmV2aW91c0xpZ2h0Q2xpY2suc3ZnJyk7XG59XG5cbi5pbWctcHJldmlvdXMtLWRlZmF1bHQge1xuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGEtYmFzZTY0On5zcmMvY29tcG9uZW50cy9JbnRlcmFjdGl2ZUljb24vaW1hZ2UvUHJldmlvdXNMaWdodERlZmF1bHQuc3ZnJyk7XG59XG5cbi5pbWctcHJldmlvdXMtLWRpc2FibGUge1xuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGEtYmFzZTY0On5zcmMvY29tcG9uZW50cy9JbnRlcmFjdGl2ZUljb24vaW1hZ2UvUHJldmlvdXNMaWdodERpc2FibGUuc3ZnJyk7XG59XG5cbi5pbWctcHJldmlvdXMtLWhvdmVyIHtcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhLWJhc2U2NDp+c3JjL2NvbXBvbmVudHMvSW50ZXJhY3RpdmVJY29uL2ltYWdlL1ByZXZpb3VzTGlnaHRIb3Zlci5zdmcnKTtcbn1cblxuLmltZy1zZXR0aW5nLS1jbGljayB7XG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YS1iYXNlNjQ6fnNyYy9jb21wb25lbnRzL0ludGVyYWN0aXZlSWNvbi9pbWFnZS9TZXR0aW5nTGlnaHRDbGljay5zdmcnKTtcbn1cblxuLmltZy1zZXR0aW5nLS1kZWZhdWx0IHtcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhLWJhc2U2NDp+c3JjL2NvbXBvbmVudHMvSW50ZXJhY3RpdmVJY29uL2ltYWdlL1NldHRpbmdMaWdodERlZmF1bHQuc3ZnJyk7XG59XG5cbi5pbWctc2V0dGluZy0tZGlzYWJsZSB7XG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YS1iYXNlNjQ6fnNyYy9jb21wb25lbnRzL0ludGVyYWN0aXZlSWNvbi9pbWFnZS9TZXR0aW5nTGlnaHREaXNhYmxlLnN2ZycpO1xufVxuXG4uaW1nLXNldHRpbmctLWhvdmVyIHtcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhLWJhc2U2NDp+c3JjL2NvbXBvbmVudHMvSW50ZXJhY3RpdmVJY29uL2ltYWdlL1NldHRpbmdMaWdodEhvdmVyLnN2ZycpO1xufVxuXG4uaW1nLWtlZXAtLWNsaWNrIHtcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhLWJhc2U2NDp+c3JjL2NvbXBvbmVudHMvSW50ZXJhY3RpdmVJY29uL2ltYWdlL1NhdmVMaWdodENsaWNrLnN2ZycpO1xufVxuXG4uaW1nLWtlZXAtLWRlZmF1bHQge1xuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGEtYmFzZTY0On5zcmMvY29tcG9uZW50cy9JbnRlcmFjdGl2ZUljb24vaW1hZ2UvU2F2ZUxpZ2h0RGlzYWJsZS5zdmcnKTtcbn1cblxuLmltZy1rZWVwLS1ob3ZlciB7XG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YS1iYXNlNjQ6fnNyYy9jb21wb25lbnRzL0ludGVyYWN0aXZlSWNvbi9pbWFnZS9TYXZlTGlnaHRIb3Zlci5zdmcnKTtcbn1cblxuLy8gbm8gZGlzYWJsZSBzdGF0ZVxuLmltZy1zYXZlLS1jbGljayB7XG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YS1iYXNlNjQ6fnNyYy9jb21wb25lbnRzL0ludGVyYWN0aXZlSWNvbi9pbWFnZS9TYXZlTGlnaHRDbGljay5zdmcnKTtcbn1cblxuLmltZy1zYXZlLS1kZWZhdWx0IHtcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhLWJhc2U2NDp+c3JjL2NvbXBvbmVudHMvSW50ZXJhY3RpdmVJY29uL2ltYWdlL1NhdmVMaWdodERlZmF1bHQuc3ZnJyk7XG59XG5cbi5pbWctc2F2ZS0taG92ZXIge1xuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGEtYmFzZTY0On5zcmMvY29tcG9uZW50cy9JbnRlcmFjdGl2ZUljb24vaW1hZ2UvU2F2ZUxpZ2h0SG92ZXIuc3ZnJyk7XG59XG5cbi5pbWctcGVuY2lsLS1jbGljayB7XG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YS1iYXNlNjQ6fnNyYy9jb21wb25lbnRzL0ludGVyYWN0aXZlSWNvbi9pbWFnZS9QZW5jaWxMaWdodENsaWNrLnN2ZycpO1xufVxuXG4uaW1nLXBlbmNpbC0tZGVmYXVsdCB7XG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YS1iYXNlNjQ6fnNyYy9jb21wb25lbnRzL0ludGVyYWN0aXZlSWNvbi9pbWFnZS9QZW5jaWxMaWdodERlZmF1bHQuc3ZnJyk7XG59XG5cbi5pbWctcGVuY2lsLS1ob3ZlciB7XG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YS1iYXNlNjQ6fnNyYy9jb21wb25lbnRzL0ludGVyYWN0aXZlSWNvbi9pbWFnZS9QZW5jaWxMaWdodEhvdmVyLnN2ZycpO1xufVxuXG4uaW1nLXNlbmQtLWRlZmF1bHQge1xuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGEtYmFzZTY0On5zcmMvY29tcG9uZW50cy9JbnRlcmFjdGl2ZUljb24vaW1hZ2UvU2VuZExpZ2h0RGVmYXVsdC5zdmcnKTtcbn1cblxuLmltZy1zZW5kLS1ob3ZlciB7XG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YS1iYXNlNjQ6fnNyYy9jb21wb25lbnRzL0ludGVyYWN0aXZlSWNvbi9pbWFnZS9TZW5kTGlnaHRIb3Zlci5zdmcnKTtcbn1cblxuLmltZy1zZW5kLS1jbGljayB7XG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YS1iYXNlNjQ6fnNyYy9jb21wb25lbnRzL0ludGVyYWN0aXZlSWNvbi9pbWFnZS9TZW5kTGlnaHRDbGljay5zdmcnKTtcbn1cblxuQG1lZGlhIChwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaykge1xuICAuaW1nLWNsb3NlLS1jbGljayB7XG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhLWJhc2U2NDp+c3JjL2NvbXBvbmVudHMvSW50ZXJhY3RpdmVJY29uL2ltYWdlL0Nsb3NlRGFya0NsaWNrLnN2ZycpO1xuICB9XG5cbiAgLmltZy1jbG9zZS0tZGVmYXVsdCB7XG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhLWJhc2U2NDp+c3JjL2NvbXBvbmVudHMvSW50ZXJhY3RpdmVJY29uL2ltYWdlL0Nsb3NlRGFya0RlZmF1bHQuc3ZnJyk7XG4gIH1cblxuICAuaW1nLWNsb3NlLS1kaXNhYmxlIHtcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGEtYmFzZTY0On5zcmMvY29tcG9uZW50cy9JbnRlcmFjdGl2ZUljb24vaW1hZ2UvQ2xvc2VEYXJrRGlzYWJsZS5zdmcnKTtcbiAgfVxuXG4gIC5pbWctY2xvc2UtLWhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGEtYmFzZTY0On5zcmMvY29tcG9uZW50cy9JbnRlcmFjdGl2ZUljb24vaW1hZ2UvQ2xvc2VEYXJrSG92ZXIuc3ZnJyk7XG4gIH1cblxuICAuaW1nLWNvbGxlY3QtLWNsaWNrIHtcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGEtYmFzZTY0On5zcmMvY29tcG9uZW50cy9JbnRlcmFjdGl2ZUljb24vaW1hZ2UvQ29sbGVjdERhcmtDbGljay5zdmcnKTtcbiAgfVxuXG4gIC5pbWctY29sbGVjdC0tZGVmYXVsdCB7XG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhLWJhc2U2NDp+c3JjL2NvbXBvbmVudHMvSW50ZXJhY3RpdmVJY29uL2ltYWdlL0NvbGxlY3REYXJrRGVmYXVsdC5zdmcnKTtcbiAgfVxuXG4gIC5pbWctY29sbGVjdC0tZGlzYWJsZSB7XG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhLWJhc2U2NDp+c3JjL2NvbXBvbmVudHMvSW50ZXJhY3RpdmVJY29uL2ltYWdlL0NvbGxlY3REYXJrRGlzYWJsZS5zdmcnKTtcbiAgfVxuXG4gIC5pbWctY29sbGVjdC0taG92ZXIge1xuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YS1iYXNlNjQ6fnNyYy9jb21wb25lbnRzL0ludGVyYWN0aXZlSWNvbi9pbWFnZS9Db2xsZWN0RGFya0hvdmVyLnN2ZycpO1xuICB9XG5cbiAgLmltZy1jb3B5LS1jbGljayB7XG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhLWJhc2U2NDp+c3JjL2NvbXBvbmVudHMvSW50ZXJhY3RpdmVJY29uL2ltYWdlL0NvcHlEYXJrQ2xpY2suc3ZnJyk7XG4gIH1cblxuICAuaW1nLWNvcHktLWRlZmF1bHQge1xuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YS1iYXNlNjQ6fnNyYy9jb21wb25lbnRzL0ludGVyYWN0aXZlSWNvbi9pbWFnZS9Db3B5RGFya0RlZmF1bHQuc3ZnJyk7XG4gIH1cblxuICAuaW1nLWNvcHktLWRpc2FibGUge1xuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YS1iYXNlNjQ6fnNyYy9jb21wb25lbnRzL0ludGVyYWN0aXZlSWNvbi9pbWFnZS9Db3B5RGFya0Rpc2FibGUuc3ZnJyk7XG4gIH1cblxuICAuaW1nLWNvcHktLWhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGEtYmFzZTY0On5zcmMvY29tcG9uZW50cy9JbnRlcmFjdGl2ZUljb24vaW1hZ2UvQ29weURhcmtIb3Zlci5zdmcnKTtcbiAgfVxuXG4gIC5pbWctZGVsZXRlLS1jbGljayB7XG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhLWJhc2U2NDp+c3JjL2NvbXBvbmVudHMvSW50ZXJhY3RpdmVJY29uL2ltYWdlL0RlbGV0ZURhcmtDbGljay5zdmcnKTtcbiAgfVxuXG4gIC5pbWctZGVsZXRlLS1kZWZhdWx0IHtcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGEtYmFzZTY0On5zcmMvY29tcG9uZW50cy9JbnRlcmFjdGl2ZUljb24vaW1hZ2UvRGVsZXRlRGFya0RlZmF1bHQuc3ZnJyk7XG4gIH1cblxuICAuaW1nLWRlbGV0ZS0taG92ZXIge1xuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YS1iYXNlNjQ6fnNyYy9jb21wb25lbnRzL0ludGVyYWN0aXZlSWNvbi9pbWFnZS9EZWxldGVEYXJrSG92ZXIuc3ZnJyk7XG4gIH1cblxuICAuaW1nLXByZXZpb3VzLS1jbGljayB7XG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhLWJhc2U2NDp+c3JjL2NvbXBvbmVudHMvSW50ZXJhY3RpdmVJY29uL2ltYWdlL1ByZXZpb3VzRGFya0NsaWNrLnN2ZycpO1xuICB9XG5cbiAgLmltZy1wcmV2aW91cy0tZGVmYXVsdCB7XG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhLWJhc2U2NDp+c3JjL2NvbXBvbmVudHMvSW50ZXJhY3RpdmVJY29uL2ltYWdlL1ByZXZpb3VzRGFya0RlZmF1bHQuc3ZnJyk7XG4gIH1cblxuICAuaW1nLXByZXZpb3VzLS1kaXNhYmxlIHtcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGEtYmFzZTY0On5zcmMvY29tcG9uZW50cy9JbnRlcmFjdGl2ZUljb24vaW1hZ2UvUHJldmlvdXNEYXJrRGlzYWJsZS5zdmcnKTtcbiAgfVxuXG4gIC5pbWctcHJldmlvdXMtLWhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGEtYmFzZTY0On5zcmMvY29tcG9uZW50cy9JbnRlcmFjdGl2ZUljb24vaW1hZ2UvUHJldmlvdXNEYXJrSG92ZXIuc3ZnJyk7XG4gIH1cblxuICAuaW1nLXNldHRpbmctLWNsaWNrIHtcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGEtYmFzZTY0On5zcmMvY29tcG9uZW50cy9JbnRlcmFjdGl2ZUljb24vaW1hZ2UvU2V0dGluZ0RhcmtDbGljay5zdmcnKTtcbiAgfVxuXG4gIC5pbWctc2V0dGluZy0tZGVmYXVsdCB7XG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhLWJhc2U2NDp+c3JjL2NvbXBvbmVudHMvSW50ZXJhY3RpdmVJY29uL2ltYWdlL1NldHRpbmdEYXJrRGVmYXVsdC5zdmcnKTtcbiAgfVxuXG4gIC5pbWctc2V0dGluZy0tZGlzYWJsZSB7XG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhLWJhc2U2NDp+c3JjL2NvbXBvbmVudHMvSW50ZXJhY3RpdmVJY29uL2ltYWdlL1NldHRpbmdEYXJrRGlzYWJsZS5zdmcnKTtcbiAgfVxuXG4gIC5pbWctc2V0dGluZy0taG92ZXIge1xuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YS1iYXNlNjQ6fnNyYy9jb21wb25lbnRzL0ludGVyYWN0aXZlSWNvbi9pbWFnZS9TZXR0aW5nRGFya0hvdmVyLnN2ZycpO1xuICB9XG5cbiAgLmltZy1rZWVwLS1jbGljayB7XG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhLWJhc2U2NDp+c3JjL2NvbXBvbmVudHMvSW50ZXJhY3RpdmVJY29uL2ltYWdlL1NhdmVEYXJrQ2xpY2suc3ZnJyk7XG4gIH1cblxuICAuaW1nLWtlZXAtLWRlZmF1bHQge1xuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YS1iYXNlNjQ6fnNyYy9jb21wb25lbnRzL0ludGVyYWN0aXZlSWNvbi9pbWFnZS9TYXZlRGFya0Rpc2FibGUuc3ZnJyk7XG4gIH1cblxuICAuaW1nLWtlZXAtLWhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGEtYmFzZTY0On5zcmMvY29tcG9uZW50cy9JbnRlcmFjdGl2ZUljb24vaW1hZ2UvU2F2ZURhcmtIb3Zlci5zdmcnKTtcbiAgfVxuXG4gIC8vIG5vIGRpc2FibGUgc3RhdGVcbiAgLmltZy1zYXZlLS1jbGljayB7XG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhLWJhc2U2NDp+c3JjL2NvbXBvbmVudHMvSW50ZXJhY3RpdmVJY29uL2ltYWdlL1NhdmVEYXJrQ2xpY2suc3ZnJyk7XG4gIH1cblxuICAuaW1nLXNhdmUtLWRlZmF1bHQge1xuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YS1iYXNlNjQ6fnNyYy9jb21wb25lbnRzL0ludGVyYWN0aXZlSWNvbi9pbWFnZS9TYXZlRGFya0RlZmF1bHQuc3ZnJyk7XG4gIH1cblxuICAuaW1nLXNhdmUtLWhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGEtYmFzZTY0On5zcmMvY29tcG9uZW50cy9JbnRlcmFjdGl2ZUljb24vaW1hZ2UvU2F2ZURhcmtIb3Zlci5zdmcnKTtcbiAgfVxuXG4gIC5pbWctcGVuY2lsLS1jbGljayB7XG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhLWJhc2U2NDp+c3JjL2NvbXBvbmVudHMvSW50ZXJhY3RpdmVJY29uL2ltYWdlL1BlbmNpbERhcmtDbGljay5zdmcnKTtcbiAgfVxuXG4gIC5pbWctcGVuY2lsLS1kZWZhdWx0IHtcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGEtYmFzZTY0On5zcmMvY29tcG9uZW50cy9JbnRlcmFjdGl2ZUljb24vaW1hZ2UvUGVuY2lsRGFya0RlZmF1bHQuc3ZnJyk7XG4gIH1cblxuICAuaW1nLXBlbmNpbC0taG92ZXIge1xuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YS1iYXNlNjQ6fnNyYy9jb21wb25lbnRzL0ludGVyYWN0aXZlSWNvbi9pbWFnZS9QZW5jaWxEYXJrSG92ZXIuc3ZnJyk7XG4gIH1cblxuICAuaW1nLXNlbmQtLWRlZmF1bHQge1xuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YS1iYXNlNjQ6fnNyYy9jb21wb25lbnRzL0ludGVyYWN0aXZlSWNvbi9pbWFnZS9TZW5kRGFya0RlZmF1bHQuc3ZnJyk7XG4gIH1cblxuICAuaW1nLXNlbmQtLWhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGEtYmFzZTY0On5zcmMvY29tcG9uZW50cy9JbnRlcmFjdGl2ZUljb24vaW1hZ2UvU2VuZERhcmtIb3Zlci5zdmcnKTtcbiAgfVxuXG4gIC5pbWctc2VuZC0tY2xpY2sge1xuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YS1iYXNlNjQ6fnNyYy9jb21wb25lbnRzL0ludGVyYWN0aXZlSWNvbi9pbWFnZS9TZW5kRGFya0NsaWNrLnN2ZycpO1xuICB9XG59XG48L3N0eWxlPlxuIiwiaW1wb3J0IHsgbm9vcCwgbWFrZURlc3RydWN0dXJhYmxlLCBjYW1lbGl6ZSwgdG9WYWx1ZSwgaXNDbGllbnQsIGlzT2JqZWN0LCB0cnlPblNjb3BlRGlzcG9zZSwgaXNJT1MsIHRyeU9uTW91bnRlZCwgbm90TnVsbGlzaCwgb2JqZWN0T21pdCwgcHJvbWlzZVRpbWVvdXQsIHVudGlsLCBpbmNyZWFzZVdpdGhVbml0LCBvYmplY3RFbnRyaWVzLCBjcmVhdGVTaW5nbGV0b25Qcm9taXNlLCB1c2VUaW1lb3V0Rm4sIHBhdXNhYmxlV2F0Y2gsIHRvUmVmLCBjcmVhdGVFdmVudEhvb2ssIGNvbXB1dGVkV2l0aENvbnRyb2wsIHRpbWVzdGFtcCwgcGF1c2FibGVGaWx0ZXIsIHdhdGNoSWdub3JhYmxlLCBkZWJvdW5jZUZpbHRlciwgY3JlYXRlRmlsdGVyV3JhcHBlciwgYnlwYXNzRmlsdGVyLCB0b1JlZnMsIHVzZUludGVydmFsRm4sIGNvbnRhaW5zUHJvcCwgaGFzT3duLCB0aHJvdHRsZUZpbHRlciwgdXNlRGVib3VuY2VGbiwgdXNlVGhyb3R0bGVGbiwgY2xhbXAsIHN5bmNSZWYsIG9iamVjdFBpY2ssIHRyeU9uVW5tb3VudGVkLCB3YXRjaFdpdGhGaWx0ZXIsIHRyeU9uQmVmb3JlVW5tb3VudCwgaWRlbnRpdHksIGlzRGVmLCBpc1dvcmtlciB9IGZyb20gJ0B2dWV1c2Uvc2hhcmVkJztcbmV4cG9ydCAqIGZyb20gJ0B2dWV1c2Uvc2hhcmVkJztcbmltcG9ydCB7IGlzUmVmLCByZWYsIHNoYWxsb3dSZWYsIHdhdGNoRWZmZWN0LCBjb21wdXRlZCwgaW5qZWN0LCBpc1Z1ZTMsIHZlcnNpb24sIGRlZmluZUNvbXBvbmVudCwgaCwgVHJhbnNpdGlvbkdyb3VwLCBzaGFsbG93UmVhY3RpdmUsIEZyYWdtZW50LCB3YXRjaCwgZ2V0Q3VycmVudEluc3RhbmNlLCBjdXN0b21SZWYsIG9uVXBkYXRlZCwgb25Nb3VudGVkLCBpc1Z1ZTIsIHJlYWRvbmx5LCBuZXh0VGljaywgcmVhY3RpdmUsIG1hcmtSYXcsIHVucmVmLCBnZXRDdXJyZW50U2NvcGUsIHNldCwgZGVsLCBpc1JlYWRvbmx5LCBvbkJlZm9yZVVwZGF0ZSB9IGZyb20gJ3Z1ZS1kZW1pJztcblxuZnVuY3Rpb24gY29tcHV0ZWRBc3luYyhldmFsdWF0aW9uQ2FsbGJhY2ssIGluaXRpYWxTdGF0ZSwgb3B0aW9uc09yUmVmKSB7XG4gIGxldCBvcHRpb25zO1xuICBpZiAoaXNSZWYob3B0aW9uc09yUmVmKSkge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBldmFsdWF0aW5nOiBvcHRpb25zT3JSZWZcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zT3JSZWYgfHwge307XG4gIH1cbiAgY29uc3Qge1xuICAgIGxhenkgPSBmYWxzZSxcbiAgICBldmFsdWF0aW5nID0gdm9pZCAwLFxuICAgIHNoYWxsb3cgPSB0cnVlLFxuICAgIG9uRXJyb3IgPSBub29wXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBzdGFydGVkID0gcmVmKCFsYXp5KTtcbiAgY29uc3QgY3VycmVudCA9IHNoYWxsb3cgPyBzaGFsbG93UmVmKGluaXRpYWxTdGF0ZSkgOiByZWYoaW5pdGlhbFN0YXRlKTtcbiAgbGV0IGNvdW50ZXIgPSAwO1xuICB3YXRjaEVmZmVjdChhc3luYyAob25JbnZhbGlkYXRlKSA9PiB7XG4gICAgaWYgKCFzdGFydGVkLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvdW50ZXIrKztcbiAgICBjb25zdCBjb3VudGVyQXRCZWdpbm5pbmcgPSBjb3VudGVyO1xuICAgIGxldCBoYXNGaW5pc2hlZCA9IGZhbHNlO1xuICAgIGlmIChldmFsdWF0aW5nKSB7XG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgZXZhbHVhdGluZy52YWx1ZSA9IHRydWU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV2YWx1YXRpb25DYWxsYmFjaygoY2FuY2VsQ2FsbGJhY2spID0+IHtcbiAgICAgICAgb25JbnZhbGlkYXRlKCgpID0+IHtcbiAgICAgICAgICBpZiAoZXZhbHVhdGluZylcbiAgICAgICAgICAgIGV2YWx1YXRpbmcudmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoIWhhc0ZpbmlzaGVkKVxuICAgICAgICAgICAgY2FuY2VsQ2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChjb3VudGVyQXRCZWdpbm5pbmcgPT09IGNvdW50ZXIpXG4gICAgICAgIGN1cnJlbnQudmFsdWUgPSByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgb25FcnJvcihlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGV2YWx1YXRpbmcgJiYgY291bnRlckF0QmVnaW5uaW5nID09PSBjb3VudGVyKVxuICAgICAgICBldmFsdWF0aW5nLnZhbHVlID0gZmFsc2U7XG4gICAgICBoYXNGaW5pc2hlZCA9IHRydWU7XG4gICAgfVxuICB9KTtcbiAgaWYgKGxhenkpIHtcbiAgICByZXR1cm4gY29tcHV0ZWQoKCkgPT4ge1xuICAgICAgc3RhcnRlZC52YWx1ZSA9IHRydWU7XG4gICAgICByZXR1cm4gY3VycmVudC52YWx1ZTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wdXRlZEluamVjdChrZXksIG9wdGlvbnMsIGRlZmF1bHRTb3VyY2UsIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSkge1xuICBsZXQgc291cmNlID0gaW5qZWN0KGtleSk7XG4gIGlmIChkZWZhdWx0U291cmNlKVxuICAgIHNvdXJjZSA9IGluamVjdChrZXksIGRlZmF1bHRTb3VyY2UpO1xuICBpZiAodHJlYXREZWZhdWx0QXNGYWN0b3J5KVxuICAgIHNvdXJjZSA9IGluamVjdChrZXksIGRlZmF1bHRTb3VyY2UsIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSk7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVkKChjdHgpID0+IG9wdGlvbnMoc291cmNlLCBjdHgpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29tcHV0ZWQoe1xuICAgICAgZ2V0OiAoY3R4KSA9PiBvcHRpb25zLmdldChzb3VyY2UsIGN0eCksXG4gICAgICBzZXQ6IG9wdGlvbnMuc2V0XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUmV1c2FibGVUZW1wbGF0ZShvcHRpb25zID0ge30pIHtcbiAgaWYgKCFpc1Z1ZTMgJiYgIXZlcnNpb24uc3RhcnRzV2l0aChcIjIuNy5cIikpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW1Z1ZVVzZV0gY3JlYXRlUmV1c2FibGVUZW1wbGF0ZSBvbmx5IHdvcmtzIGluIFZ1ZSAyLjcgb3IgYWJvdmUuXCIpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB7XG4gICAgaW5oZXJpdEF0dHJzID0gdHJ1ZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcmVuZGVyID0gc2hhbGxvd1JlZigpO1xuICBjb25zdCBkZWZpbmUgPSAvKiAjX19QVVJFX18gKi8gZGVmaW5lQ29tcG9uZW50KHtcbiAgICBzZXR1cChfLCB7IHNsb3RzIH0pIHtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHJlbmRlci52YWx1ZSA9IHNsb3RzLmRlZmF1bHQ7XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHJldXNlID0gLyogI19fUFVSRV9fICovIGRlZmluZUNvbXBvbmVudCh7XG4gICAgaW5oZXJpdEF0dHJzLFxuICAgIHNldHVwKF8sIHsgYXR0cnMsIHNsb3RzIH0pIHtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCFyZW5kZXIudmFsdWUgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIltWdWVVc2VdIEZhaWxlZCB0byBmaW5kIHRoZSBkZWZpbml0aW9uIG9mIHJldXNhYmxlIHRlbXBsYXRlXCIpO1xuICAgICAgICBjb25zdCB2bm9kZSA9IChfYSA9IHJlbmRlci52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwocmVuZGVyLCB7IC4uLmtleXNUb0NhbWVsS2ViYWJDYXNlKGF0dHJzKSwgJHNsb3RzOiBzbG90cyB9KTtcbiAgICAgICAgcmV0dXJuIGluaGVyaXRBdHRycyAmJiAodm5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IHZub2RlLmxlbmd0aCkgPT09IDEgPyB2bm9kZVswXSA6IHZub2RlO1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbWFrZURlc3RydWN0dXJhYmxlKFxuICAgIHsgZGVmaW5lLCByZXVzZSB9LFxuICAgIFtkZWZpbmUsIHJldXNlXVxuICApO1xufVxuZnVuY3Rpb24ga2V5c1RvQ2FtZWxLZWJhYkNhc2Uob2JqKSB7XG4gIGNvbnN0IG5ld09iaiA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopXG4gICAgbmV3T2JqW2NhbWVsaXplKGtleSldID0gb2JqW2tleV07XG4gIHJldHVybiBuZXdPYmo7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRlbXBsYXRlUHJvbWlzZShvcHRpb25zID0ge30pIHtcbiAgaWYgKCFpc1Z1ZTMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW1Z1ZVVzZV0gY3JlYXRlVGVtcGxhdGVQcm9taXNlIG9ubHkgd29ya3MgaW4gVnVlIDMgb3IgYWJvdmUuXCIpO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgaW5kZXggPSAwO1xuICBjb25zdCBpbnN0YW5jZXMgPSByZWYoW10pO1xuICBmdW5jdGlvbiBjcmVhdGUoLi4uYXJncykge1xuICAgIGNvbnN0IHByb3BzID0gc2hhbGxvd1JlYWN0aXZlKHtcbiAgICAgIGtleTogaW5kZXgrKyxcbiAgICAgIGFyZ3MsXG4gICAgICBwcm9taXNlOiB2b2lkIDAsXG4gICAgICByZXNvbHZlOiAoKSA9PiB7XG4gICAgICB9LFxuICAgICAgcmVqZWN0OiAoKSA9PiB7XG4gICAgICB9LFxuICAgICAgaXNSZXNvbHZpbmc6IGZhbHNlLFxuICAgICAgb3B0aW9uc1xuICAgIH0pO1xuICAgIGluc3RhbmNlcy52YWx1ZS5wdXNoKHByb3BzKTtcbiAgICBwcm9wcy5wcm9taXNlID0gbmV3IFByb21pc2UoKF9yZXNvbHZlLCBfcmVqZWN0KSA9PiB7XG4gICAgICBwcm9wcy5yZXNvbHZlID0gKHYpID0+IHtcbiAgICAgICAgcHJvcHMuaXNSZXNvbHZpbmcgPSB0cnVlO1xuICAgICAgICByZXR1cm4gX3Jlc29sdmUodik7XG4gICAgICB9O1xuICAgICAgcHJvcHMucmVqZWN0ID0gX3JlamVjdDtcbiAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHByb3BzLnByb21pc2UgPSB2b2lkIDA7XG4gICAgICBjb25zdCBpbmRleDIgPSBpbnN0YW5jZXMudmFsdWUuaW5kZXhPZihwcm9wcyk7XG4gICAgICBpZiAoaW5kZXgyICE9PSAtMSlcbiAgICAgICAgaW5zdGFuY2VzLnZhbHVlLnNwbGljZShpbmRleDIsIDEpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9wcy5wcm9taXNlO1xuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0KC4uLmFyZ3MpIHtcbiAgICBpZiAob3B0aW9ucy5zaW5nbGV0b24gJiYgaW5zdGFuY2VzLnZhbHVlLmxlbmd0aCA+IDApXG4gICAgICByZXR1cm4gaW5zdGFuY2VzLnZhbHVlWzBdLnByb21pc2U7XG4gICAgcmV0dXJuIGNyZWF0ZSguLi5hcmdzKTtcbiAgfVxuICBjb25zdCBjb21wb25lbnQgPSAvKiAjX19QVVJFX18gKi8gZGVmaW5lQ29tcG9uZW50KChfLCB7IHNsb3RzIH0pID0+IHtcbiAgICBjb25zdCByZW5kZXJMaXN0ID0gKCkgPT4gaW5zdGFuY2VzLnZhbHVlLm1hcCgocHJvcHMpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiBoKEZyYWdtZW50LCB7IGtleTogcHJvcHMua2V5IH0sIChfYSA9IHNsb3RzLmRlZmF1bHQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKHNsb3RzLCBwcm9wcykpO1xuICAgIH0pO1xuICAgIGlmIChvcHRpb25zLnRyYW5zaXRpb24pXG4gICAgICByZXR1cm4gKCkgPT4gaChUcmFuc2l0aW9uR3JvdXAsIG9wdGlvbnMudHJhbnNpdGlvbiwgcmVuZGVyTGlzdCk7XG4gICAgcmV0dXJuIHJlbmRlckxpc3Q7XG4gIH0pO1xuICBjb21wb25lbnQuc3RhcnQgPSBzdGFydDtcbiAgcmV0dXJuIGNvbXBvbmVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVW5yZWZGbihmbikge1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzLm1hcCgoaSkgPT4gdG9WYWx1ZShpKSkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1bnJlZkVsZW1lbnQoZWxSZWYpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBwbGFpbiA9IHRvVmFsdWUoZWxSZWYpO1xuICByZXR1cm4gKF9hID0gcGxhaW4gPT0gbnVsbCA/IHZvaWQgMCA6IHBsYWluLiRlbCkgIT0gbnVsbCA/IF9hIDogcGxhaW47XG59XG5cbmNvbnN0IGRlZmF1bHRXaW5kb3cgPSBpc0NsaWVudCA/IHdpbmRvdyA6IHZvaWQgMDtcbmNvbnN0IGRlZmF1bHREb2N1bWVudCA9IGlzQ2xpZW50ID8gd2luZG93LmRvY3VtZW50IDogdm9pZCAwO1xuY29uc3QgZGVmYXVsdE5hdmlnYXRvciA9IGlzQ2xpZW50ID8gd2luZG93Lm5hdmlnYXRvciA6IHZvaWQgMDtcbmNvbnN0IGRlZmF1bHRMb2NhdGlvbiA9IGlzQ2xpZW50ID8gd2luZG93LmxvY2F0aW9uIDogdm9pZCAwO1xuXG5mdW5jdGlvbiB1c2VFdmVudExpc3RlbmVyKC4uLmFyZ3MpIHtcbiAgbGV0IHRhcmdldDtcbiAgbGV0IGV2ZW50cztcbiAgbGV0IGxpc3RlbmVycztcbiAgbGV0IG9wdGlvbnM7XG4gIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgW2V2ZW50cywgbGlzdGVuZXJzLCBvcHRpb25zXSA9IGFyZ3M7XG4gICAgdGFyZ2V0ID0gZGVmYXVsdFdpbmRvdztcbiAgfSBlbHNlIHtcbiAgICBbdGFyZ2V0LCBldmVudHMsIGxpc3RlbmVycywgb3B0aW9uc10gPSBhcmdzO1xuICB9XG4gIGlmICghdGFyZ2V0KVxuICAgIHJldHVybiBub29wO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZXZlbnRzKSlcbiAgICBldmVudHMgPSBbZXZlbnRzXTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3RlbmVycykpXG4gICAgbGlzdGVuZXJzID0gW2xpc3RlbmVyc107XG4gIGNvbnN0IGNsZWFudXBzID0gW107XG4gIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgY2xlYW51cHMuZm9yRWFjaCgoZm4pID0+IGZuKCkpO1xuICAgIGNsZWFudXBzLmxlbmd0aCA9IDA7XG4gIH07XG4gIGNvbnN0IHJlZ2lzdGVyID0gKGVsLCBldmVudCwgbGlzdGVuZXIsIG9wdGlvbnMyKSA9PiB7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIG9wdGlvbnMyKTtcbiAgICByZXR1cm4gKCkgPT4gZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIG9wdGlvbnMyKTtcbiAgfTtcbiAgY29uc3Qgc3RvcFdhdGNoID0gd2F0Y2goXG4gICAgKCkgPT4gW3VucmVmRWxlbWVudCh0YXJnZXQpLCB0b1ZhbHVlKG9wdGlvbnMpXSxcbiAgICAoW2VsLCBvcHRpb25zMl0pID0+IHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICAgIGlmICghZWwpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IG9wdGlvbnNDbG9uZSA9IGlzT2JqZWN0KG9wdGlvbnMyKSA/IHsgLi4ub3B0aW9uczIgfSA6IG9wdGlvbnMyO1xuICAgICAgY2xlYW51cHMucHVzaChcbiAgICAgICAgLi4uZXZlbnRzLmZsYXRNYXAoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGxpc3RlbmVycy5tYXAoKGxpc3RlbmVyKSA9PiByZWdpc3RlcihlbCwgZXZlbnQsIGxpc3RlbmVyLCBvcHRpb25zQ2xvbmUpKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSxcbiAgICB7IGltbWVkaWF0ZTogdHJ1ZSwgZmx1c2g6IFwicG9zdFwiIH1cbiAgKTtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IHtcbiAgICBzdG9wV2F0Y2goKTtcbiAgICBjbGVhbnVwKCk7XG4gIH07XG4gIHRyeU9uU2NvcGVEaXNwb3NlKHN0b3ApO1xuICByZXR1cm4gc3RvcDtcbn1cblxubGV0IF9pT1NXb3JrYXJvdW5kID0gZmFsc2U7XG5mdW5jdGlvbiBvbkNsaWNrT3V0c2lkZSh0YXJnZXQsIGhhbmRsZXIsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IHdpbmRvdyA9IGRlZmF1bHRXaW5kb3csIGlnbm9yZSA9IFtdLCBjYXB0dXJlID0gdHJ1ZSwgZGV0ZWN0SWZyYW1lID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gIGlmICghd2luZG93KVxuICAgIHJldHVybiBub29wO1xuICBpZiAoaXNJT1MgJiYgIV9pT1NXb3JrYXJvdW5kKSB7XG4gICAgX2lPU1dvcmthcm91bmQgPSB0cnVlO1xuICAgIEFycmF5LmZyb20od2luZG93LmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pLmZvckVhY2goKGVsKSA9PiBlbC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgbm9vcCkpO1xuICAgIHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG5vb3ApO1xuICB9XG4gIGxldCBzaG91bGRMaXN0ZW4gPSB0cnVlO1xuICBjb25zdCBzaG91bGRJZ25vcmUgPSAoZXZlbnQpID0+IHtcbiAgICByZXR1cm4gaWdub3JlLnNvbWUoKHRhcmdldDIpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdGFyZ2V0MiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0YXJnZXQyKSkuc29tZSgoZWwpID0+IGVsID09PSBldmVudC50YXJnZXQgfHwgZXZlbnQuY29tcG9zZWRQYXRoKCkuaW5jbHVkZXMoZWwpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVsID0gdW5yZWZFbGVtZW50KHRhcmdldDIpO1xuICAgICAgICByZXR1cm4gZWwgJiYgKGV2ZW50LnRhcmdldCA9PT0gZWwgfHwgZXZlbnQuY29tcG9zZWRQYXRoKCkuaW5jbHVkZXMoZWwpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgbGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBlbCA9IHVucmVmRWxlbWVudCh0YXJnZXQpO1xuICAgIGlmICghZWwgfHwgZWwgPT09IGV2ZW50LnRhcmdldCB8fCBldmVudC5jb21wb3NlZFBhdGgoKS5pbmNsdWRlcyhlbCkpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGV2ZW50LmRldGFpbCA9PT0gMClcbiAgICAgIHNob3VsZExpc3RlbiA9ICFzaG91bGRJZ25vcmUoZXZlbnQpO1xuICAgIGlmICghc2hvdWxkTGlzdGVuKSB7XG4gICAgICBzaG91bGRMaXN0ZW4gPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBoYW5kbGVyKGV2ZW50KTtcbiAgfTtcbiAgY29uc3QgY2xlYW51cCA9IFtcbiAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJjbGlja1wiLCBsaXN0ZW5lciwgeyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlIH0pLFxuICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcInBvaW50ZXJkb3duXCIsIChlKSA9PiB7XG4gICAgICBjb25zdCBlbCA9IHVucmVmRWxlbWVudCh0YXJnZXQpO1xuICAgICAgc2hvdWxkTGlzdGVuID0gIXNob3VsZElnbm9yZShlKSAmJiAhIShlbCAmJiAhZS5jb21wb3NlZFBhdGgoKS5pbmNsdWRlcyhlbCkpO1xuICAgIH0sIHsgcGFzc2l2ZTogdHJ1ZSB9KSxcbiAgICBkZXRlY3RJZnJhbWUgJiYgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwiYmx1clwiLCAoZXZlbnQpID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGVsID0gdW5yZWZFbGVtZW50KHRhcmdldCk7XG4gICAgICAgIGlmICgoKF9hID0gd2luZG93LmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS50YWdOYW1lKSA9PT0gXCJJRlJBTUVcIiAmJiAhKGVsID09IG51bGwgPyB2b2lkIDAgOiBlbC5jb250YWlucyh3aW5kb3cuZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpKSB7XG4gICAgICAgICAgaGFuZGxlcihldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH0pXG4gIF0uZmlsdGVyKEJvb2xlYW4pO1xuICBjb25zdCBzdG9wID0gKCkgPT4gY2xlYW51cC5mb3JFYWNoKChmbikgPT4gZm4oKSk7XG4gIHJldHVybiBzdG9wO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlQcmVkaWNhdGUoa2V5RmlsdGVyKSB7XG4gIGlmICh0eXBlb2Yga2V5RmlsdGVyID09PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIGtleUZpbHRlcjtcbiAgZWxzZSBpZiAodHlwZW9mIGtleUZpbHRlciA9PT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gKGV2ZW50KSA9PiBldmVudC5rZXkgPT09IGtleUZpbHRlcjtcbiAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShrZXlGaWx0ZXIpKVxuICAgIHJldHVybiAoZXZlbnQpID0+IGtleUZpbHRlci5pbmNsdWRlcyhldmVudC5rZXkpO1xuICByZXR1cm4gKCkgPT4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG9uS2V5U3Ryb2tlKC4uLmFyZ3MpIHtcbiAgbGV0IGtleTtcbiAgbGV0IGhhbmRsZXI7XG4gIGxldCBvcHRpb25zID0ge307XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMykge1xuICAgIGtleSA9IGFyZ3NbMF07XG4gICAgaGFuZGxlciA9IGFyZ3NbMV07XG4gICAgb3B0aW9ucyA9IGFyZ3NbMl07XG4gIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3NbMV0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGtleSA9IHRydWU7XG4gICAgICBoYW5kbGVyID0gYXJnc1swXTtcbiAgICAgIG9wdGlvbnMgPSBhcmdzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBhcmdzWzBdO1xuICAgICAgaGFuZGxlciA9IGFyZ3NbMV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGtleSA9IHRydWU7XG4gICAgaGFuZGxlciA9IGFyZ3NbMF07XG4gIH1cbiAgY29uc3Qge1xuICAgIHRhcmdldCA9IGRlZmF1bHRXaW5kb3csXG4gICAgZXZlbnROYW1lID0gXCJrZXlkb3duXCIsXG4gICAgcGFzc2l2ZSA9IGZhbHNlLFxuICAgIGRlZHVwZSA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBwcmVkaWNhdGUgPSBjcmVhdGVLZXlQcmVkaWNhdGUoa2V5KTtcbiAgY29uc3QgbGlzdGVuZXIgPSAoZSkgPT4ge1xuICAgIGlmIChlLnJlcGVhdCAmJiB0b1ZhbHVlKGRlZHVwZSkpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHByZWRpY2F0ZShlKSlcbiAgICAgIGhhbmRsZXIoZSk7XG4gIH07XG4gIHJldHVybiB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgZXZlbnROYW1lLCBsaXN0ZW5lciwgcGFzc2l2ZSk7XG59XG5mdW5jdGlvbiBvbktleURvd24oa2V5LCBoYW5kbGVyLCBvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIG9uS2V5U3Ryb2tlKGtleSwgaGFuZGxlciwgeyAuLi5vcHRpb25zLCBldmVudE5hbWU6IFwia2V5ZG93blwiIH0pO1xufVxuZnVuY3Rpb24gb25LZXlQcmVzc2VkKGtleSwgaGFuZGxlciwgb3B0aW9ucyA9IHt9KSB7XG4gIHJldHVybiBvbktleVN0cm9rZShrZXksIGhhbmRsZXIsIHsgLi4ub3B0aW9ucywgZXZlbnROYW1lOiBcImtleXByZXNzXCIgfSk7XG59XG5mdW5jdGlvbiBvbktleVVwKGtleSwgaGFuZGxlciwgb3B0aW9ucyA9IHt9KSB7XG4gIHJldHVybiBvbktleVN0cm9rZShrZXksIGhhbmRsZXIsIHsgLi4ub3B0aW9ucywgZXZlbnROYW1lOiBcImtleXVwXCIgfSk7XG59XG5cbmNvbnN0IERFRkFVTFRfREVMQVkgPSA1MDA7XG5jb25zdCBERUZBVUxUX1RIUkVTSE9MRCA9IDEwO1xuZnVuY3Rpb24gb25Mb25nUHJlc3ModGFyZ2V0LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IGVsZW1lbnRSZWYgPSBjb21wdXRlZCgoKSA9PiB1bnJlZkVsZW1lbnQodGFyZ2V0KSk7XG4gIGxldCB0aW1lb3V0O1xuICBsZXQgcG9zU3RhcnQ7XG4gIGxldCBzdGFydFRpbWVzdGFtcDtcbiAgbGV0IGhhc0xvbmdQcmVzc2VkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gdm9pZCAwO1xuICAgIH1cbiAgICBwb3NTdGFydCA9IHZvaWQgMDtcbiAgICBzdGFydFRpbWVzdGFtcCA9IHZvaWQgMDtcbiAgICBoYXNMb25nUHJlc3NlZCA9IGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIG9uUmVsZWFzZShldikge1xuICAgIHZhciBfYTIsIF9iMiwgX2M7XG4gICAgY29uc3QgW19zdGFydFRpbWVzdGFtcCwgX3Bvc1N0YXJ0LCBfaGFzTG9uZ1ByZXNzZWRdID0gW3N0YXJ0VGltZXN0YW1wLCBwb3NTdGFydCwgaGFzTG9uZ1ByZXNzZWRdO1xuICAgIGNsZWFyKCk7XG4gICAgaWYgKCEob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5vbk1vdXNlVXApIHx8ICFfcG9zU3RhcnQgfHwgIV9zdGFydFRpbWVzdGFtcClcbiAgICAgIHJldHVybjtcbiAgICBpZiAoKChfYTIgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGlmaWVycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5zZWxmKSAmJiBldi50YXJnZXQgIT09IGVsZW1lbnRSZWYudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKChfYjIgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGlmaWVycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5wcmV2ZW50KVxuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoKF9jID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5tb2RpZmllcnMpID09IG51bGwgPyB2b2lkIDAgOiBfYy5zdG9wKVxuICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgY29uc3QgZHggPSBldi54IC0gX3Bvc1N0YXJ0Lng7XG4gICAgY29uc3QgZHkgPSBldi55IC0gX3Bvc1N0YXJ0Lnk7XG4gICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIG9wdGlvbnMub25Nb3VzZVVwKGV2LnRpbWVTdGFtcCAtIF9zdGFydFRpbWVzdGFtcCwgZGlzdGFuY2UsIF9oYXNMb25nUHJlc3NlZCk7XG4gIH1cbiAgZnVuY3Rpb24gb25Eb3duKGV2KSB7XG4gICAgdmFyIF9hMiwgX2IyLCBfYywgX2Q7XG4gICAgaWYgKCgoX2EyID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5tb2RpZmllcnMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuc2VsZikgJiYgZXYudGFyZ2V0ICE9PSBlbGVtZW50UmVmLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGNsZWFyKCk7XG4gICAgaWYgKChfYjIgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGlmaWVycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5wcmV2ZW50KVxuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoKF9jID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5tb2RpZmllcnMpID09IG51bGwgPyB2b2lkIDAgOiBfYy5zdG9wKVxuICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgcG9zU3RhcnQgPSB7XG4gICAgICB4OiBldi54LFxuICAgICAgeTogZXYueVxuICAgIH07XG4gICAgc3RhcnRUaW1lc3RhbXAgPSBldi50aW1lU3RhbXA7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGhhc0xvbmdQcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgaGFuZGxlcihldik7XG4gICAgICB9LFxuICAgICAgKF9kID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kZWxheSkgIT0gbnVsbCA/IF9kIDogREVGQVVMVF9ERUxBWVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gb25Nb3ZlKGV2KSB7XG4gICAgdmFyIF9hMiwgX2IyLCBfYywgX2Q7XG4gICAgaWYgKCgoX2EyID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5tb2RpZmllcnMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuc2VsZikgJiYgZXYudGFyZ2V0ICE9PSBlbGVtZW50UmVmLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghcG9zU3RhcnQgfHwgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZGlzdGFuY2VUaHJlc2hvbGQpID09PSBmYWxzZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoKF9iMiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kaWZpZXJzKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLnByZXZlbnQpXG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICgoX2MgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGlmaWVycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnN0b3ApXG4gICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBjb25zdCBkeCA9IGV2LnggLSBwb3NTdGFydC54O1xuICAgIGNvbnN0IGR5ID0gZXYueSAtIHBvc1N0YXJ0Lnk7XG4gICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIGlmIChkaXN0YW5jZSA+PSAoKF9kID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kaXN0YW5jZVRocmVzaG9sZCkgIT0gbnVsbCA/IF9kIDogREVGQVVMVF9USFJFU0hPTEQpKVxuICAgICAgY2xlYXIoKTtcbiAgfVxuICBjb25zdCBsaXN0ZW5lck9wdGlvbnMgPSB7XG4gICAgY2FwdHVyZTogKF9hID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5tb2RpZmllcnMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYXB0dXJlLFxuICAgIG9uY2U6IChfYiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kaWZpZXJzKSA9PSBudWxsID8gdm9pZCAwIDogX2Iub25jZVxuICB9O1xuICBjb25zdCBjbGVhbnVwID0gW1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoZWxlbWVudFJlZiwgXCJwb2ludGVyZG93blwiLCBvbkRvd24sIGxpc3RlbmVyT3B0aW9ucyksXG4gICAgdXNlRXZlbnRMaXN0ZW5lcihlbGVtZW50UmVmLCBcInBvaW50ZXJtb3ZlXCIsIG9uTW92ZSwgbGlzdGVuZXJPcHRpb25zKSxcbiAgICB1c2VFdmVudExpc3RlbmVyKGVsZW1lbnRSZWYsIFtcInBvaW50ZXJ1cFwiLCBcInBvaW50ZXJsZWF2ZVwiXSwgb25SZWxlYXNlLCBsaXN0ZW5lck9wdGlvbnMpXG4gIF07XG4gIGNvbnN0IHN0b3AgPSAoKSA9PiBjbGVhbnVwLmZvckVhY2goKGZuKSA9PiBmbigpKTtcbiAgcmV0dXJuIHN0b3A7XG59XG5cbmZ1bmN0aW9uIGlzRm9jdXNlZEVsZW1lbnRFZGl0YWJsZSgpIHtcbiAgY29uc3QgeyBhY3RpdmVFbGVtZW50LCBib2R5IH0gPSBkb2N1bWVudDtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGFjdGl2ZUVsZW1lbnQgPT09IGJvZHkpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKGFjdGl2ZUVsZW1lbnQudGFnTmFtZSkge1xuICAgIGNhc2UgXCJJTlBVVFwiOlxuICAgIGNhc2UgXCJURVhUQVJFQVwiOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGFjdGl2ZUVsZW1lbnQuaGFzQXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpO1xufVxuZnVuY3Rpb24gaXNUeXBlZENoYXJWYWxpZCh7XG4gIGtleUNvZGUsXG4gIG1ldGFLZXksXG4gIGN0cmxLZXksXG4gIGFsdEtleVxufSkge1xuICBpZiAobWV0YUtleSB8fCBjdHJsS2V5IHx8IGFsdEtleSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChrZXlDb2RlID49IDQ4ICYmIGtleUNvZGUgPD0gNTcpXG4gICAgcmV0dXJuIHRydWU7XG4gIGlmIChrZXlDb2RlID49IDY1ICYmIGtleUNvZGUgPD0gOTApXG4gICAgcmV0dXJuIHRydWU7XG4gIGlmIChrZXlDb2RlID49IDk3ICYmIGtleUNvZGUgPD0gMTIyKVxuICAgIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBvblN0YXJ0VHlwaW5nKGNhbGxiYWNrLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyBkb2N1bWVudDogZG9jdW1lbnQyID0gZGVmYXVsdERvY3VtZW50IH0gPSBvcHRpb25zO1xuICBjb25zdCBrZXlkb3duID0gKGV2ZW50KSA9PiB7XG4gICAgIWlzRm9jdXNlZEVsZW1lbnRFZGl0YWJsZSgpICYmIGlzVHlwZWRDaGFyVmFsaWQoZXZlbnQpICYmIGNhbGxiYWNrKGV2ZW50KTtcbiAgfTtcbiAgaWYgKGRvY3VtZW50MilcbiAgICB1c2VFdmVudExpc3RlbmVyKGRvY3VtZW50MiwgXCJrZXlkb3duXCIsIGtleWRvd24sIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbn1cblxuZnVuY3Rpb24gdGVtcGxhdGVSZWYoa2V5LCBpbml0aWFsVmFsdWUgPSBudWxsKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGxldCBfdHJpZ2dlciA9ICgpID0+IHtcbiAgfTtcbiAgY29uc3QgZWxlbWVudCA9IGN1c3RvbVJlZigodHJhY2ssIHRyaWdnZXIpID0+IHtcbiAgICBfdHJpZ2dlciA9IHRyaWdnZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdHJhY2soKTtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5wcm94eSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLiRyZWZzW2tleV0pICE9IG51bGwgPyBfYiA6IGluaXRpYWxWYWx1ZTtcbiAgICAgIH0sXG4gICAgICBzZXQoKSB7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIHRyeU9uTW91bnRlZChfdHJpZ2dlcik7XG4gIG9uVXBkYXRlZChfdHJpZ2dlcik7XG4gIHJldHVybiBlbGVtZW50O1xufVxuXG5mdW5jdGlvbiB1c2VNb3VudGVkKCkge1xuICBjb25zdCBpc01vdW50ZWQgPSByZWYoZmFsc2UpO1xuICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBpZiAoaW5zdGFuY2UpIHtcbiAgICBvbk1vdW50ZWQoKCkgPT4ge1xuICAgICAgaXNNb3VudGVkLnZhbHVlID0gdHJ1ZTtcbiAgICB9LCBpc1Z1ZTIgPyB2b2lkIDAgOiBpbnN0YW5jZSk7XG4gIH1cbiAgcmV0dXJuIGlzTW91bnRlZDtcbn1cblxuZnVuY3Rpb24gdXNlU3VwcG9ydGVkKGNhbGxiYWNrKSB7XG4gIGNvbnN0IGlzTW91bnRlZCA9IHVzZU1vdW50ZWQoKTtcbiAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IHtcbiAgICBpc01vdW50ZWQudmFsdWU7XG4gICAgcmV0dXJuIEJvb2xlYW4oY2FsbGJhY2soKSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VNdXRhdGlvbk9ic2VydmVyKHRhcmdldCwgY2FsbGJhY2ssIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IHdpbmRvdyA9IGRlZmF1bHRXaW5kb3csIC4uLm11dGF0aW9uT3B0aW9ucyB9ID0gb3B0aW9ucztcbiAgbGV0IG9ic2VydmVyO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiB3aW5kb3cgJiYgXCJNdXRhdGlvbk9ic2VydmVyXCIgaW4gd2luZG93KTtcbiAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICBpZiAob2JzZXJ2ZXIpIHtcbiAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIG9ic2VydmVyID0gdm9pZCAwO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdGFyZ2V0cyA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHRvVmFsdWUodGFyZ2V0KTtcbiAgICBjb25zdCBpdGVtcyA9IChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXSkubWFwKHVucmVmRWxlbWVudCkuZmlsdGVyKG5vdE51bGxpc2gpO1xuICAgIHJldHVybiBuZXcgU2V0KGl0ZW1zKTtcbiAgfSk7XG4gIGNvbnN0IHN0b3BXYXRjaCA9IHdhdGNoKFxuICAgICgpID0+IHRhcmdldHMudmFsdWUsXG4gICAgKHRhcmdldHMyKSA9PiB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUgJiYgdGFyZ2V0czIuc2l6ZSkge1xuICAgICAgICBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKTtcbiAgICAgICAgdGFyZ2V0czIuZm9yRWFjaCgoZWwpID0+IG9ic2VydmVyLm9ic2VydmUoZWwsIG11dGF0aW9uT3B0aW9ucykpO1xuICAgICAgfVxuICAgIH0sXG4gICAgeyBpbW1lZGlhdGU6IHRydWUsIGZsdXNoOiBcInBvc3RcIiB9XG4gICk7XG4gIGNvbnN0IHRha2VSZWNvcmRzID0gKCkgPT4ge1xuICAgIHJldHVybiBvYnNlcnZlciA9PSBudWxsID8gdm9pZCAwIDogb2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgfTtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IHtcbiAgICBjbGVhbnVwKCk7XG4gICAgc3RvcFdhdGNoKCk7XG4gIH07XG4gIHRyeU9uU2NvcGVEaXNwb3NlKHN0b3ApO1xuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIHN0b3AsXG4gICAgdGFrZVJlY29yZHNcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlQWN0aXZlRWxlbWVudChvcHRpb25zID0ge30pIHtcbiAgdmFyIF9hO1xuICBjb25zdCB7XG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvdyxcbiAgICBkZWVwID0gdHJ1ZSxcbiAgICB0cmlnZ2VyT25SZW1vdmFsID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGRvY3VtZW50ID0gKF9hID0gb3B0aW9ucy5kb2N1bWVudCkgIT0gbnVsbCA/IF9hIDogd2luZG93ID09IG51bGwgPyB2b2lkIDAgOiB3aW5kb3cuZG9jdW1lbnQ7XG4gIGNvbnN0IGdldERlZXBBY3RpdmVFbGVtZW50ID0gKCkgPT4ge1xuICAgIHZhciBfYTI7XG4gICAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudCA9PSBudWxsID8gdm9pZCAwIDogZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoZGVlcCkge1xuICAgICAgd2hpbGUgKGVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGVsZW1lbnQuc2hhZG93Um9vdClcbiAgICAgICAgZWxlbWVudCA9IChfYTIgPSBlbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBlbGVtZW50LnNoYWRvd1Jvb3QpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuYWN0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH07XG4gIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSByZWYoKTtcbiAgY29uc3QgdHJpZ2dlciA9ICgpID0+IHtcbiAgICBhY3RpdmVFbGVtZW50LnZhbHVlID0gZ2V0RGVlcEFjdGl2ZUVsZW1lbnQoKTtcbiAgfTtcbiAgaWYgKHdpbmRvdykge1xuICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcImJsdXJcIiwgKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQucmVsYXRlZFRhcmdldCAhPT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdHJpZ2dlcigpO1xuICAgIH0sIHRydWUpO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcImZvY3VzXCIsIHRyaWdnZXIsIHRydWUpO1xuICB9XG4gIGlmICh0cmlnZ2VyT25SZW1vdmFsKSB7XG4gICAgdXNlTXV0YXRpb25PYnNlcnZlcihkb2N1bWVudCwgKG11dGF0aW9ucykgPT4ge1xuICAgICAgbXV0YXRpb25zLmZpbHRlcigobSkgPT4gbS5yZW1vdmVkTm9kZXMubGVuZ3RoKS5tYXAoKG4pID0+IEFycmF5LmZyb20obi5yZW1vdmVkTm9kZXMpKS5mbGF0KCkuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICBpZiAobm9kZSA9PT0gYWN0aXZlRWxlbWVudC52YWx1ZSlcbiAgICAgICAgICB0cmlnZ2VyKCk7XG4gICAgICB9KTtcbiAgICB9LCB7XG4gICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgdHJpZ2dlcigpO1xuICByZXR1cm4gYWN0aXZlRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gdXNlUmFmRm4oZm4sIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgaW1tZWRpYXRlID0gdHJ1ZSxcbiAgICBmcHNMaW1pdCA9IHZvaWQgMCxcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpc0FjdGl2ZSA9IHJlZihmYWxzZSk7XG4gIGNvbnN0IGludGVydmFsTGltaXQgPSBmcHNMaW1pdCA/IDFlMyAvIGZwc0xpbWl0IDogbnVsbDtcbiAgbGV0IHByZXZpb3VzRnJhbWVUaW1lc3RhbXAgPSAwO1xuICBsZXQgcmFmSWQgPSBudWxsO1xuICBmdW5jdGlvbiBsb29wKHRpbWVzdGFtcCkge1xuICAgIGlmICghaXNBY3RpdmUudmFsdWUgfHwgIXdpbmRvdylcbiAgICAgIHJldHVybjtcbiAgICBpZiAoIXByZXZpb3VzRnJhbWVUaW1lc3RhbXApXG4gICAgICBwcmV2aW91c0ZyYW1lVGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgIGNvbnN0IGRlbHRhID0gdGltZXN0YW1wIC0gcHJldmlvdXNGcmFtZVRpbWVzdGFtcDtcbiAgICBpZiAoaW50ZXJ2YWxMaW1pdCAmJiBkZWx0YSA8IGludGVydmFsTGltaXQpIHtcbiAgICAgIHJhZklkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHJldmlvdXNGcmFtZVRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICBmbih7IGRlbHRhLCB0aW1lc3RhbXAgfSk7XG4gICAgcmFmSWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICB9XG4gIGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICBpZiAoIWlzQWN0aXZlLnZhbHVlICYmIHdpbmRvdykge1xuICAgICAgaXNBY3RpdmUudmFsdWUgPSB0cnVlO1xuICAgICAgcHJldmlvdXNGcmFtZVRpbWVzdGFtcCA9IDA7XG4gICAgICByYWZJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgIGlzQWN0aXZlLnZhbHVlID0gZmFsc2U7XG4gICAgaWYgKHJhZklkICE9IG51bGwgJiYgd2luZG93KSB7XG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSWQpO1xuICAgICAgcmFmSWQgPSBudWxsO1xuICAgIH1cbiAgfVxuICBpZiAoaW1tZWRpYXRlKVxuICAgIHJlc3VtZSgpO1xuICB0cnlPblNjb3BlRGlzcG9zZShwYXVzZSk7XG4gIHJldHVybiB7XG4gICAgaXNBY3RpdmU6IHJlYWRvbmx5KGlzQWN0aXZlKSxcbiAgICBwYXVzZSxcbiAgICByZXN1bWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlQW5pbWF0ZSh0YXJnZXQsIGtleWZyYW1lcywgb3B0aW9ucykge1xuICBsZXQgY29uZmlnO1xuICBsZXQgYW5pbWF0ZU9wdGlvbnM7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGNvbmZpZyA9IG9wdGlvbnM7XG4gICAgYW5pbWF0ZU9wdGlvbnMgPSBvYmplY3RPbWl0KG9wdGlvbnMsIFtcIndpbmRvd1wiLCBcImltbWVkaWF0ZVwiLCBcImNvbW1pdFN0eWxlc1wiLCBcInBlcnNpc3RcIiwgXCJvblJlYWR5XCIsIFwib25FcnJvclwiXSk7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnID0geyBkdXJhdGlvbjogb3B0aW9ucyB9O1xuICAgIGFuaW1hdGVPcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICBjb25zdCB7XG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvdyxcbiAgICBpbW1lZGlhdGUgPSB0cnVlLFxuICAgIGNvbW1pdFN0eWxlcyxcbiAgICBwZXJzaXN0LFxuICAgIHBsYXliYWNrUmF0ZTogX3BsYXliYWNrUmF0ZSA9IDEsXG4gICAgb25SZWFkeSxcbiAgICBvbkVycm9yID0gKGUpID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICB9ID0gY29uZmlnO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiB3aW5kb3cgJiYgSFRNTEVsZW1lbnQgJiYgXCJhbmltYXRlXCIgaW4gSFRNTEVsZW1lbnQucHJvdG90eXBlKTtcbiAgY29uc3QgYW5pbWF0ZSA9IHNoYWxsb3dSZWYodm9pZCAwKTtcbiAgY29uc3Qgc3RvcmUgPSBzaGFsbG93UmVhY3RpdmUoe1xuICAgIHN0YXJ0VGltZTogbnVsbCxcbiAgICBjdXJyZW50VGltZTogbnVsbCxcbiAgICB0aW1lbGluZTogbnVsbCxcbiAgICBwbGF5YmFja1JhdGU6IF9wbGF5YmFja1JhdGUsXG4gICAgcGVuZGluZzogZmFsc2UsXG4gICAgcGxheVN0YXRlOiBpbW1lZGlhdGUgPyBcImlkbGVcIiA6IFwicGF1c2VkXCIsXG4gICAgcmVwbGFjZVN0YXRlOiBcImFjdGl2ZVwiXG4gIH0pO1xuICBjb25zdCBwZW5kaW5nID0gY29tcHV0ZWQoKCkgPT4gc3RvcmUucGVuZGluZyk7XG4gIGNvbnN0IHBsYXlTdGF0ZSA9IGNvbXB1dGVkKCgpID0+IHN0b3JlLnBsYXlTdGF0ZSk7XG4gIGNvbnN0IHJlcGxhY2VTdGF0ZSA9IGNvbXB1dGVkKCgpID0+IHN0b3JlLnJlcGxhY2VTdGF0ZSk7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IGNvbXB1dGVkKHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gc3RvcmUuc3RhcnRUaW1lO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBzdG9yZS5zdGFydFRpbWUgPSB2YWx1ZTtcbiAgICAgIGlmIChhbmltYXRlLnZhbHVlKVxuICAgICAgICBhbmltYXRlLnZhbHVlLnN0YXJ0VGltZSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGN1cnJlbnRUaW1lID0gY29tcHV0ZWQoe1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBzdG9yZS5jdXJyZW50VGltZTtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgc3RvcmUuY3VycmVudFRpbWUgPSB2YWx1ZTtcbiAgICAgIGlmIChhbmltYXRlLnZhbHVlKSB7XG4gICAgICAgIGFuaW1hdGUudmFsdWUuY3VycmVudFRpbWUgPSB2YWx1ZTtcbiAgICAgICAgc3luY1Jlc3VtZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHRpbWVsaW5lID0gY29tcHV0ZWQoe1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBzdG9yZS50aW1lbGluZTtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgc3RvcmUudGltZWxpbmUgPSB2YWx1ZTtcbiAgICAgIGlmIChhbmltYXRlLnZhbHVlKVxuICAgICAgICBhbmltYXRlLnZhbHVlLnRpbWVsaW5lID0gdmFsdWU7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgcGxheWJhY2tSYXRlID0gY29tcHV0ZWQoe1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBzdG9yZS5wbGF5YmFja1JhdGU7XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIHN0b3JlLnBsYXliYWNrUmF0ZSA9IHZhbHVlO1xuICAgICAgaWYgKGFuaW1hdGUudmFsdWUpXG4gICAgICAgIGFuaW1hdGUudmFsdWUucGxheWJhY2tSYXRlID0gdmFsdWU7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgcGxheSA9ICgpID0+IHtcbiAgICBpZiAoYW5pbWF0ZS52YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYW5pbWF0ZS52YWx1ZS5wbGF5KCk7XG4gICAgICAgIHN5bmNSZXN1bWUoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc3luY1BhdXNlKCk7XG4gICAgICAgIG9uRXJyb3IoZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF1c2UgPSAoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHRyeSB7XG4gICAgICAoX2EgPSBhbmltYXRlLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EucGF1c2UoKTtcbiAgICAgIHN5bmNQYXVzZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG9uRXJyb3IoZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZXZlcnNlID0gKCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICAhYW5pbWF0ZS52YWx1ZSAmJiB1cGRhdGUoKTtcbiAgICB0cnkge1xuICAgICAgKF9hID0gYW5pbWF0ZS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJldmVyc2UoKTtcbiAgICAgIHN5bmNSZXN1bWUoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzeW5jUGF1c2UoKTtcbiAgICAgIG9uRXJyb3IoZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBmaW5pc2ggPSAoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHRyeSB7XG4gICAgICAoX2EgPSBhbmltYXRlLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZmluaXNoKCk7XG4gICAgICBzeW5jUGF1c2UoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBvbkVycm9yKGUpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgY2FuY2VsID0gKCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICB0cnkge1xuICAgICAgKF9hID0gYW5pbWF0ZS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbmNlbCgpO1xuICAgICAgc3luY1BhdXNlKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgb25FcnJvcihlKTtcbiAgICB9XG4gIH07XG4gIHdhdGNoKCgpID0+IHVucmVmRWxlbWVudCh0YXJnZXQpLCAoZWwpID0+IHtcbiAgICBlbCAmJiB1cGRhdGUoKTtcbiAgfSk7XG4gIHdhdGNoKCgpID0+IGtleWZyYW1lcywgKHZhbHVlKSA9PiB7XG4gICAgIWFuaW1hdGUudmFsdWUgJiYgdXBkYXRlKCk7XG4gICAgaWYgKCF1bnJlZkVsZW1lbnQodGFyZ2V0KSAmJiBhbmltYXRlLnZhbHVlKSB7XG4gICAgICBhbmltYXRlLnZhbHVlLmVmZmVjdCA9IG5ldyBLZXlmcmFtZUVmZmVjdChcbiAgICAgICAgdW5yZWZFbGVtZW50KHRhcmdldCksXG4gICAgICAgIHRvVmFsdWUodmFsdWUpLFxuICAgICAgICBhbmltYXRlT3B0aW9uc1xuICAgICAgKTtcbiAgICB9XG4gIH0sIHsgZGVlcDogdHJ1ZSB9KTtcbiAgdHJ5T25Nb3VudGVkKCgpID0+IHtcbiAgICBuZXh0VGljaygoKSA9PiB1cGRhdGUodHJ1ZSkpO1xuICB9KTtcbiAgdHJ5T25TY29wZURpc3Bvc2UoY2FuY2VsKTtcbiAgZnVuY3Rpb24gdXBkYXRlKGluaXQpIHtcbiAgICBjb25zdCBlbCA9IHVucmVmRWxlbWVudCh0YXJnZXQpO1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUgfHwgIWVsKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghYW5pbWF0ZS52YWx1ZSlcbiAgICAgIGFuaW1hdGUudmFsdWUgPSBlbC5hbmltYXRlKHRvVmFsdWUoa2V5ZnJhbWVzKSwgYW5pbWF0ZU9wdGlvbnMpO1xuICAgIGlmIChwZXJzaXN0KVxuICAgICAgYW5pbWF0ZS52YWx1ZS5wZXJzaXN0KCk7XG4gICAgaWYgKF9wbGF5YmFja1JhdGUgIT09IDEpXG4gICAgICBhbmltYXRlLnZhbHVlLnBsYXliYWNrUmF0ZSA9IF9wbGF5YmFja1JhdGU7XG4gICAgaWYgKGluaXQgJiYgIWltbWVkaWF0ZSlcbiAgICAgIGFuaW1hdGUudmFsdWUucGF1c2UoKTtcbiAgICBlbHNlXG4gICAgICBzeW5jUmVzdW1lKCk7XG4gICAgb25SZWFkeSA9PSBudWxsID8gdm9pZCAwIDogb25SZWFkeShhbmltYXRlLnZhbHVlKTtcbiAgfVxuICB1c2VFdmVudExpc3RlbmVyKGFuaW1hdGUsIFtcImNhbmNlbFwiLCBcImZpbmlzaFwiLCBcInJlbW92ZVwiXSwgc3luY1BhdXNlKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcihhbmltYXRlLCBcImZpbmlzaFwiLCAoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChjb21taXRTdHlsZXMpXG4gICAgICAoX2EgPSBhbmltYXRlLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY29tbWl0U3R5bGVzKCk7XG4gIH0pO1xuICBjb25zdCB7IHJlc3VtZTogcmVzdW1lUmVmLCBwYXVzZTogcGF1c2VSZWYgfSA9IHVzZVJhZkZuKCgpID0+IHtcbiAgICBpZiAoIWFuaW1hdGUudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgc3RvcmUucGVuZGluZyA9IGFuaW1hdGUudmFsdWUucGVuZGluZztcbiAgICBzdG9yZS5wbGF5U3RhdGUgPSBhbmltYXRlLnZhbHVlLnBsYXlTdGF0ZTtcbiAgICBzdG9yZS5yZXBsYWNlU3RhdGUgPSBhbmltYXRlLnZhbHVlLnJlcGxhY2VTdGF0ZTtcbiAgICBzdG9yZS5zdGFydFRpbWUgPSBhbmltYXRlLnZhbHVlLnN0YXJ0VGltZTtcbiAgICBzdG9yZS5jdXJyZW50VGltZSA9IGFuaW1hdGUudmFsdWUuY3VycmVudFRpbWU7XG4gICAgc3RvcmUudGltZWxpbmUgPSBhbmltYXRlLnZhbHVlLnRpbWVsaW5lO1xuICAgIHN0b3JlLnBsYXliYWNrUmF0ZSA9IGFuaW1hdGUudmFsdWUucGxheWJhY2tSYXRlO1xuICB9LCB7IGltbWVkaWF0ZTogZmFsc2UgfSk7XG4gIGZ1bmN0aW9uIHN5bmNSZXN1bWUoKSB7XG4gICAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlKVxuICAgICAgcmVzdW1lUmVmKCk7XG4gIH1cbiAgZnVuY3Rpb24gc3luY1BhdXNlKCkge1xuICAgIGlmIChpc1N1cHBvcnRlZC52YWx1ZSAmJiB3aW5kb3cpXG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHBhdXNlUmVmKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIGFuaW1hdGUsXG4gICAgLy8gYWN0aW9uc1xuICAgIHBsYXksXG4gICAgcGF1c2UsXG4gICAgcmV2ZXJzZSxcbiAgICBmaW5pc2gsXG4gICAgY2FuY2VsLFxuICAgIC8vIHN0YXRlXG4gICAgcGVuZGluZyxcbiAgICBwbGF5U3RhdGUsXG4gICAgcmVwbGFjZVN0YXRlLFxuICAgIHN0YXJ0VGltZSxcbiAgICBjdXJyZW50VGltZSxcbiAgICB0aW1lbGluZSxcbiAgICBwbGF5YmFja1JhdGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlQXN5bmNRdWV1ZSh0YXNrcywgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgaW50ZXJydXB0ID0gdHJ1ZSxcbiAgICBvbkVycm9yID0gbm9vcCxcbiAgICBvbkZpbmlzaGVkID0gbm9vcCxcbiAgICBzaWduYWxcbiAgfSA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHByb21pc2VTdGF0ZSA9IHtcbiAgICBhYm9ydGVkOiBcImFib3J0ZWRcIixcbiAgICBmdWxmaWxsZWQ6IFwiZnVsZmlsbGVkXCIsXG4gICAgcGVuZGluZzogXCJwZW5kaW5nXCIsXG4gICAgcmVqZWN0ZWQ6IFwicmVqZWN0ZWRcIlxuICB9O1xuICBjb25zdCBpbml0aWFsUmVzdWx0ID0gQXJyYXkuZnJvbShBcnJheS5mcm9tKHsgbGVuZ3RoOiB0YXNrcy5sZW5ndGggfSksICgpID0+ICh7IHN0YXRlOiBwcm9taXNlU3RhdGUucGVuZGluZywgZGF0YTogbnVsbCB9KSk7XG4gIGNvbnN0IHJlc3VsdCA9IHJlYWN0aXZlKGluaXRpYWxSZXN1bHQpO1xuICBjb25zdCBhY3RpdmVJbmRleCA9IHJlZigtMSk7XG4gIGlmICghdGFza3MgfHwgdGFza3MubGVuZ3RoID09PSAwKSB7XG4gICAgb25GaW5pc2hlZCgpO1xuICAgIHJldHVybiB7XG4gICAgICBhY3RpdmVJbmRleCxcbiAgICAgIHJlc3VsdFxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlUmVzdWx0KHN0YXRlLCByZXMpIHtcbiAgICBhY3RpdmVJbmRleC52YWx1ZSsrO1xuICAgIHJlc3VsdFthY3RpdmVJbmRleC52YWx1ZV0uZGF0YSA9IHJlcztcbiAgICByZXN1bHRbYWN0aXZlSW5kZXgudmFsdWVdLnN0YXRlID0gc3RhdGU7XG4gIH1cbiAgdGFza3MucmVkdWNlKChwcmV2LCBjdXJyKSA9PiB7XG4gICAgcmV0dXJuIHByZXYudGhlbigocHJldlJlcykgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKHNpZ25hbCA9PSBudWxsID8gdm9pZCAwIDogc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgdXBkYXRlUmVzdWx0KHByb21pc2VTdGF0ZS5hYm9ydGVkLCBuZXcgRXJyb3IoXCJhYm9ydGVkXCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCgoX2EgPSByZXN1bHRbYWN0aXZlSW5kZXgudmFsdWVdKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc3RhdGUpID09PSBwcm9taXNlU3RhdGUucmVqZWN0ZWQgJiYgaW50ZXJydXB0KSB7XG4gICAgICAgIG9uRmluaXNoZWQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZG9uZSA9IGN1cnIocHJldlJlcykudGhlbigoY3VycmVudFJlcykgPT4ge1xuICAgICAgICB1cGRhdGVSZXN1bHQocHJvbWlzZVN0YXRlLmZ1bGZpbGxlZCwgY3VycmVudFJlcyk7XG4gICAgICAgIGFjdGl2ZUluZGV4LnZhbHVlID09PSB0YXNrcy5sZW5ndGggLSAxICYmIG9uRmluaXNoZWQoKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXM7XG4gICAgICB9KTtcbiAgICAgIGlmICghc2lnbmFsKVxuICAgICAgICByZXR1cm4gZG9uZTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW2RvbmUsIHdoZW5BYm9ydGVkKHNpZ25hbCldKTtcbiAgICB9KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgaWYgKHNpZ25hbCA9PSBudWxsID8gdm9pZCAwIDogc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgdXBkYXRlUmVzdWx0KHByb21pc2VTdGF0ZS5hYm9ydGVkLCBlKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9XG4gICAgICB1cGRhdGVSZXN1bHQocHJvbWlzZVN0YXRlLnJlamVjdGVkLCBlKTtcbiAgICAgIG9uRXJyb3IoKTtcbiAgICAgIHJldHVybiBlO1xuICAgIH0pO1xuICB9LCBQcm9taXNlLnJlc29sdmUoKSk7XG4gIHJldHVybiB7XG4gICAgYWN0aXZlSW5kZXgsXG4gICAgcmVzdWx0XG4gIH07XG59XG5mdW5jdGlvbiB3aGVuQWJvcnRlZChzaWduYWwpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcImFib3J0ZWRcIik7XG4gICAgaWYgKHNpZ25hbC5hYm9ydGVkKVxuICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICBlbHNlXG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHJlamVjdChlcnJvciksIHsgb25jZTogdHJ1ZSB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVzZUFzeW5jU3RhdGUocHJvbWlzZSwgaW5pdGlhbFN0YXRlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBpbW1lZGlhdGUgPSB0cnVlLFxuICAgIGRlbGF5ID0gMCxcbiAgICBvbkVycm9yID0gbm9vcCxcbiAgICBvblN1Y2Nlc3MgPSBub29wLFxuICAgIHJlc2V0T25FeGVjdXRlID0gdHJ1ZSxcbiAgICBzaGFsbG93ID0gdHJ1ZSxcbiAgICB0aHJvd0Vycm9yXG4gIH0gPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zIDoge307XG4gIGNvbnN0IHN0YXRlID0gc2hhbGxvdyA/IHNoYWxsb3dSZWYoaW5pdGlhbFN0YXRlKSA6IHJlZihpbml0aWFsU3RhdGUpO1xuICBjb25zdCBpc1JlYWR5ID0gcmVmKGZhbHNlKTtcbiAgY29uc3QgaXNMb2FkaW5nID0gcmVmKGZhbHNlKTtcbiAgY29uc3QgZXJyb3IgPSBzaGFsbG93UmVmKHZvaWQgMCk7XG4gIGFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGUoZGVsYXkyID0gMCwgLi4uYXJncykge1xuICAgIGlmIChyZXNldE9uRXhlY3V0ZSlcbiAgICAgIHN0YXRlLnZhbHVlID0gaW5pdGlhbFN0YXRlO1xuICAgIGVycm9yLnZhbHVlID0gdm9pZCAwO1xuICAgIGlzUmVhZHkudmFsdWUgPSBmYWxzZTtcbiAgICBpc0xvYWRpbmcudmFsdWUgPSB0cnVlO1xuICAgIGlmIChkZWxheTIgPiAwKVxuICAgICAgYXdhaXQgcHJvbWlzZVRpbWVvdXQoZGVsYXkyKTtcbiAgICBjb25zdCBfcHJvbWlzZSA9IHR5cGVvZiBwcm9taXNlID09PSBcImZ1bmN0aW9uXCIgPyBwcm9taXNlKC4uLmFyZ3MpIDogcHJvbWlzZTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IF9wcm9taXNlO1xuICAgICAgc3RhdGUudmFsdWUgPSBkYXRhO1xuICAgICAgaXNSZWFkeS52YWx1ZSA9IHRydWU7XG4gICAgICBvblN1Y2Nlc3MoZGF0YSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IudmFsdWUgPSBlO1xuICAgICAgb25FcnJvcihlKTtcbiAgICAgIGlmICh0aHJvd0Vycm9yKVxuICAgICAgICB0aHJvdyBlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc0xvYWRpbmcudmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLnZhbHVlO1xuICB9XG4gIGlmIChpbW1lZGlhdGUpXG4gICAgZXhlY3V0ZShkZWxheSk7XG4gIGNvbnN0IHNoZWxsID0ge1xuICAgIHN0YXRlLFxuICAgIGlzUmVhZHksXG4gICAgaXNMb2FkaW5nLFxuICAgIGVycm9yLFxuICAgIGV4ZWN1dGVcbiAgfTtcbiAgZnVuY3Rpb24gd2FpdFVudGlsSXNMb2FkZWQoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHVudGlsKGlzTG9hZGluZykudG9CZShmYWxzZSkudGhlbigoKSA9PiByZXNvbHZlKHNoZWxsKSkuY2F0Y2gocmVqZWN0KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnNoZWxsLFxuICAgIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgIHJldHVybiB3YWl0VW50aWxJc0xvYWRlZCgpLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfTtcbn1cblxuY29uc3QgZGVmYXVsdHMgPSB7XG4gIGFycmF5OiAodikgPT4gSlNPTi5zdHJpbmdpZnkodiksXG4gIG9iamVjdDogKHYpID0+IEpTT04uc3RyaW5naWZ5KHYpLFxuICBzZXQ6ICh2KSA9PiBKU09OLnN0cmluZ2lmeShBcnJheS5mcm9tKHYpKSxcbiAgbWFwOiAodikgPT4gSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmZyb21FbnRyaWVzKHYpKSxcbiAgbnVsbDogKCkgPT4gXCJcIlxufTtcbmZ1bmN0aW9uIGdldERlZmF1bHRTZXJpYWxpemF0aW9uKHRhcmdldCkge1xuICBpZiAoIXRhcmdldClcbiAgICByZXR1cm4gZGVmYXVsdHMubnVsbDtcbiAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIE1hcClcbiAgICByZXR1cm4gZGVmYXVsdHMubWFwO1xuICBlbHNlIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBTZXQpXG4gICAgcmV0dXJuIGRlZmF1bHRzLnNldDtcbiAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKVxuICAgIHJldHVybiBkZWZhdWx0cy5hcnJheTtcbiAgZWxzZVxuICAgIHJldHVybiBkZWZhdWx0cy5vYmplY3Q7XG59XG5cbmZ1bmN0aW9uIHVzZUJhc2U2NCh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgY29uc3QgYmFzZTY0ID0gcmVmKFwiXCIpO1xuICBjb25zdCBwcm9taXNlID0gcmVmKCk7XG4gIGZ1bmN0aW9uIGV4ZWN1dGUoKSB7XG4gICAgaWYgKCFpc0NsaWVudClcbiAgICAgIHJldHVybjtcbiAgICBwcm9taXNlLnZhbHVlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgX3RhcmdldCA9IHRvVmFsdWUodGFyZ2V0KTtcbiAgICAgICAgaWYgKF90YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICAgIHJlc29sdmUoXCJcIik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIF90YXJnZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXNvbHZlKGJsb2JUb0Jhc2U2NChuZXcgQmxvYihbX3RhcmdldF0sIHsgdHlwZTogXCJ0ZXh0L3BsYWluXCIgfSkpKTtcbiAgICAgICAgfSBlbHNlIGlmIChfdGFyZ2V0IGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgIHJlc29sdmUoYmxvYlRvQmFzZTY0KF90YXJnZXQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChfdGFyZ2V0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICByZXNvbHZlKHdpbmRvdy5idG9hKFN0cmluZy5mcm9tQ2hhckNvZGUoLi4ubmV3IFVpbnQ4QXJyYXkoX3RhcmdldCkpKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX3RhcmdldCBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB7XG4gICAgICAgICAgcmVzb2x2ZShfdGFyZ2V0LnRvRGF0YVVSTChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnR5cGUsIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucXVhbGl0eSkpO1xuICAgICAgICB9IGVsc2UgaWYgKF90YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG4gICAgICAgICAgY29uc3QgaW1nID0gX3RhcmdldC5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICAgIGltZy5jcm9zc09yaWdpbiA9IFwiQW5vbnltb3VzXCI7XG4gICAgICAgICAgaW1nTG9hZGVkKGltZykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGltZy53aWR0aDtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWcuaGVpZ2h0O1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICByZXNvbHZlKGNhbnZhcy50b0RhdGFVUkwob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy50eXBlLCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnF1YWxpdHkpKTtcbiAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBfdGFyZ2V0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgY29uc3QgX3NlcmlhbGl6ZUZuID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc2VyaWFsaXplcikgfHwgZ2V0RGVmYXVsdFNlcmlhbGl6YXRpb24oX3RhcmdldCk7XG4gICAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IF9zZXJpYWxpemVGbihfdGFyZ2V0KTtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShibG9iVG9CYXNlNjQobmV3IEJsb2IoW3NlcmlhbGl6ZWRdLCB7IHR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiIH0pKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcInRhcmdldCBpcyB1bnN1cHBvcnRlZCB0eXBlc1wiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcHJvbWlzZS52YWx1ZS50aGVuKChyZXMpID0+IGJhc2U2NC52YWx1ZSA9IHJlcyk7XG4gICAgcmV0dXJuIHByb21pc2UudmFsdWU7XG4gIH1cbiAgaWYgKGlzUmVmKHRhcmdldCkgfHwgdHlwZW9mIHRhcmdldCA9PT0gXCJmdW5jdGlvblwiKVxuICAgIHdhdGNoKHRhcmdldCwgZXhlY3V0ZSwgeyBpbW1lZGlhdGU6IHRydWUgfSk7XG4gIGVsc2VcbiAgICBleGVjdXRlKCk7XG4gIHJldHVybiB7XG4gICAgYmFzZTY0LFxuICAgIHByb21pc2UsXG4gICAgZXhlY3V0ZVxuICB9O1xufVxuZnVuY3Rpb24gaW1nTG9hZGVkKGltZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGlmICghaW1nLmNvbXBsZXRlKSB7XG4gICAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9O1xuICAgICAgaW1nLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gYmxvYlRvQmFzZTY0KGJsb2IpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgZnIub25sb2FkID0gKGUpID0+IHtcbiAgICAgIHJlc29sdmUoZS50YXJnZXQucmVzdWx0KTtcbiAgICB9O1xuICAgIGZyLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgZnIucmVhZEFzRGF0YVVSTChibG9iKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVzZUJhdHRlcnkob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgbmF2aWdhdG9yID0gZGVmYXVsdE5hdmlnYXRvciB9ID0gb3B0aW9ucztcbiAgY29uc3QgZXZlbnRzID0gW1wiY2hhcmdpbmdjaGFuZ2VcIiwgXCJjaGFyZ2luZ3RpbWVjaGFuZ2VcIiwgXCJkaXNjaGFyZ2luZ3RpbWVjaGFuZ2VcIiwgXCJsZXZlbGNoYW5nZVwiXTtcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gbmF2aWdhdG9yICYmIFwiZ2V0QmF0dGVyeVwiIGluIG5hdmlnYXRvciAmJiB0eXBlb2YgbmF2aWdhdG9yLmdldEJhdHRlcnkgPT09IFwiZnVuY3Rpb25cIik7XG4gIGNvbnN0IGNoYXJnaW5nID0gcmVmKGZhbHNlKTtcbiAgY29uc3QgY2hhcmdpbmdUaW1lID0gcmVmKDApO1xuICBjb25zdCBkaXNjaGFyZ2luZ1RpbWUgPSByZWYoMCk7XG4gIGNvbnN0IGxldmVsID0gcmVmKDEpO1xuICBsZXQgYmF0dGVyeTtcbiAgZnVuY3Rpb24gdXBkYXRlQmF0dGVyeUluZm8oKSB7XG4gICAgY2hhcmdpbmcudmFsdWUgPSB0aGlzLmNoYXJnaW5nO1xuICAgIGNoYXJnaW5nVGltZS52YWx1ZSA9IHRoaXMuY2hhcmdpbmdUaW1lIHx8IDA7XG4gICAgZGlzY2hhcmdpbmdUaW1lLnZhbHVlID0gdGhpcy5kaXNjaGFyZ2luZ1RpbWUgfHwgMDtcbiAgICBsZXZlbC52YWx1ZSA9IHRoaXMubGV2ZWw7XG4gIH1cbiAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlKSB7XG4gICAgbmF2aWdhdG9yLmdldEJhdHRlcnkoKS50aGVuKChfYmF0dGVyeSkgPT4ge1xuICAgICAgYmF0dGVyeSA9IF9iYXR0ZXJ5O1xuICAgICAgdXBkYXRlQmF0dGVyeUluZm8uY2FsbChiYXR0ZXJ5KTtcbiAgICAgIHVzZUV2ZW50TGlzdGVuZXIoYmF0dGVyeSwgZXZlbnRzLCB1cGRhdGVCYXR0ZXJ5SW5mbywgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgY2hhcmdpbmcsXG4gICAgY2hhcmdpbmdUaW1lLFxuICAgIGRpc2NoYXJnaW5nVGltZSxcbiAgICBsZXZlbFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VCbHVldG9vdGgob3B0aW9ucykge1xuICBsZXQge1xuICAgIGFjY2VwdEFsbERldmljZXMgPSBmYWxzZVxuICB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3Qge1xuICAgIGZpbHRlcnMgPSB2b2lkIDAsXG4gICAgb3B0aW9uYWxTZXJ2aWNlcyA9IHZvaWQgMCxcbiAgICBuYXZpZ2F0b3IgPSBkZWZhdWx0TmF2aWdhdG9yXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiBuYXZpZ2F0b3IgJiYgXCJibHVldG9vdGhcIiBpbiBuYXZpZ2F0b3IpO1xuICBjb25zdCBkZXZpY2UgPSBzaGFsbG93UmVmKHZvaWQgMCk7XG4gIGNvbnN0IGVycm9yID0gc2hhbGxvd1JlZihudWxsKTtcbiAgd2F0Y2goZGV2aWNlLCAoKSA9PiB7XG4gICAgY29ubmVjdFRvQmx1ZXRvb3RoR0FUVFNlcnZlcigpO1xuICB9KTtcbiAgYXN5bmMgZnVuY3Rpb24gcmVxdWVzdERldmljZSgpIHtcbiAgICBpZiAoIWlzU3VwcG9ydGVkLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGVycm9yLnZhbHVlID0gbnVsbDtcbiAgICBpZiAoZmlsdGVycyAmJiBmaWx0ZXJzLmxlbmd0aCA+IDApXG4gICAgICBhY2NlcHRBbGxEZXZpY2VzID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGRldmljZS52YWx1ZSA9IGF3YWl0IChuYXZpZ2F0b3IgPT0gbnVsbCA/IHZvaWQgMCA6IG5hdmlnYXRvci5ibHVldG9vdGgucmVxdWVzdERldmljZSh7XG4gICAgICAgIGFjY2VwdEFsbERldmljZXMsXG4gICAgICAgIGZpbHRlcnMsXG4gICAgICAgIG9wdGlvbmFsU2VydmljZXNcbiAgICAgIH0pKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGVycm9yLnZhbHVlID0gZXJyO1xuICAgIH1cbiAgfVxuICBjb25zdCBzZXJ2ZXIgPSByZWYoKTtcbiAgY29uc3QgaXNDb25uZWN0ZWQgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gc2VydmVyLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY29ubmVjdGVkKSB8fCBmYWxzZTtcbiAgfSk7XG4gIGFzeW5jIGZ1bmN0aW9uIGNvbm5lY3RUb0JsdWV0b290aEdBVFRTZXJ2ZXIoKSB7XG4gICAgZXJyb3IudmFsdWUgPSBudWxsO1xuICAgIGlmIChkZXZpY2UudmFsdWUgJiYgZGV2aWNlLnZhbHVlLmdhdHQpIHtcbiAgICAgIGRldmljZS52YWx1ZS5hZGRFdmVudExpc3RlbmVyKFwiZ2F0dHNlcnZlcmRpc2Nvbm5lY3RlZFwiLCAoKSA9PiB7XG4gICAgICB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNlcnZlci52YWx1ZSA9IGF3YWl0IGRldmljZS52YWx1ZS5nYXR0LmNvbm5lY3QoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBlcnJvci52YWx1ZSA9IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdHJ5T25Nb3VudGVkKCgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGRldmljZS52YWx1ZSlcbiAgICAgIChfYSA9IGRldmljZS52YWx1ZS5nYXR0KSA9PSBudWxsID8gdm9pZCAwIDogX2EuY29ubmVjdCgpO1xuICB9KTtcbiAgdHJ5T25TY29wZURpc3Bvc2UoKCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoZGV2aWNlLnZhbHVlKVxuICAgICAgKF9hID0gZGV2aWNlLnZhbHVlLmdhdHQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5kaXNjb25uZWN0KCk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIGlzQ29ubmVjdGVkLFxuICAgIC8vIERldmljZTpcbiAgICBkZXZpY2UsXG4gICAgcmVxdWVzdERldmljZSxcbiAgICAvLyBTZXJ2ZXI6XG4gICAgc2VydmVyLFxuICAgIC8vIEVycm9yczpcbiAgICBlcnJvclxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VNZWRpYVF1ZXJ5KHF1ZXJ5LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB3aW5kb3cgPSBkZWZhdWx0V2luZG93IH0gPSBvcHRpb25zO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiB3aW5kb3cgJiYgXCJtYXRjaE1lZGlhXCIgaW4gd2luZG93ICYmIHR5cGVvZiB3aW5kb3cubWF0Y2hNZWRpYSA9PT0gXCJmdW5jdGlvblwiKTtcbiAgbGV0IG1lZGlhUXVlcnk7XG4gIGNvbnN0IG1hdGNoZXMgPSByZWYoZmFsc2UpO1xuICBjb25zdCBoYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgbWF0Y2hlcy52YWx1ZSA9IGV2ZW50Lm1hdGNoZXM7XG4gIH07XG4gIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgaWYgKCFtZWRpYVF1ZXJ5KVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChcInJlbW92ZUV2ZW50TGlzdGVuZXJcIiBpbiBtZWRpYVF1ZXJ5KVxuICAgICAgbWVkaWFRdWVyeS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZXIpO1xuICAgIGVsc2VcbiAgICAgIG1lZGlhUXVlcnkucmVtb3ZlTGlzdGVuZXIoaGFuZGxlcik7XG4gIH07XG4gIGNvbnN0IHN0b3BXYXRjaCA9IHdhdGNoRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzU3VwcG9ydGVkLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGNsZWFudXAoKTtcbiAgICBtZWRpYVF1ZXJ5ID0gd2luZG93Lm1hdGNoTWVkaWEodG9WYWx1ZShxdWVyeSkpO1xuICAgIGlmIChcImFkZEV2ZW50TGlzdGVuZXJcIiBpbiBtZWRpYVF1ZXJ5KVxuICAgICAgbWVkaWFRdWVyeS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZXIpO1xuICAgIGVsc2VcbiAgICAgIG1lZGlhUXVlcnkuYWRkTGlzdGVuZXIoaGFuZGxlcik7XG4gICAgbWF0Y2hlcy52YWx1ZSA9IG1lZGlhUXVlcnkubWF0Y2hlcztcbiAgfSk7XG4gIHRyeU9uU2NvcGVEaXNwb3NlKCgpID0+IHtcbiAgICBzdG9wV2F0Y2goKTtcbiAgICBjbGVhbnVwKCk7XG4gICAgbWVkaWFRdWVyeSA9IHZvaWQgMDtcbiAgfSk7XG4gIHJldHVybiBtYXRjaGVzO1xufVxuXG5jb25zdCBicmVha3BvaW50c1RhaWx3aW5kID0ge1xuICBcInNtXCI6IDY0MCxcbiAgXCJtZFwiOiA3NjgsXG4gIFwibGdcIjogMTAyNCxcbiAgXCJ4bFwiOiAxMjgwLFxuICBcIjJ4bFwiOiAxNTM2XG59O1xuY29uc3QgYnJlYWtwb2ludHNCb290c3RyYXBWNSA9IHtcbiAgeHM6IDAsXG4gIHNtOiA1NzYsXG4gIG1kOiA3NjgsXG4gIGxnOiA5OTIsXG4gIHhsOiAxMjAwLFxuICB4eGw6IDE0MDBcbn07XG5jb25zdCBicmVha3BvaW50c1Z1ZXRpZnlWMiA9IHtcbiAgeHM6IDAsXG4gIHNtOiA2MDAsXG4gIG1kOiA5NjAsXG4gIGxnOiAxMjY0LFxuICB4bDogMTkwNFxufTtcbmNvbnN0IGJyZWFrcG9pbnRzVnVldGlmeVYzID0ge1xuICB4czogMCxcbiAgc206IDYwMCxcbiAgbWQ6IDk2MCxcbiAgbGc6IDEyODAsXG4gIHhsOiAxOTIwLFxuICB4eGw6IDI1NjBcbn07XG5jb25zdCBicmVha3BvaW50c1Z1ZXRpZnkgPSBicmVha3BvaW50c1Z1ZXRpZnlWMjtcbmNvbnN0IGJyZWFrcG9pbnRzQW50RGVzaWduID0ge1xuICB4czogNDgwLFxuICBzbTogNTc2LFxuICBtZDogNzY4LFxuICBsZzogOTkyLFxuICB4bDogMTIwMCxcbiAgeHhsOiAxNjAwXG59O1xuY29uc3QgYnJlYWtwb2ludHNRdWFzYXIgPSB7XG4gIHhzOiAwLFxuICBzbTogNjAwLFxuICBtZDogMTAyNCxcbiAgbGc6IDE0NDAsXG4gIHhsOiAxOTIwXG59O1xuY29uc3QgYnJlYWtwb2ludHNTZW1hdGljID0ge1xuICBtb2JpbGVTOiAzMjAsXG4gIG1vYmlsZU06IDM3NSxcbiAgbW9iaWxlTDogNDI1LFxuICB0YWJsZXQ6IDc2OCxcbiAgbGFwdG9wOiAxMDI0LFxuICBsYXB0b3BMOiAxNDQwLFxuICBkZXNrdG9wNEs6IDI1NjBcbn07XG5jb25zdCBicmVha3BvaW50c01hc3RlckNzcyA9IHtcbiAgXCIzeHNcIjogMzYwLFxuICBcIjJ4c1wiOiA0ODAsXG4gIFwieHNcIjogNjAwLFxuICBcInNtXCI6IDc2OCxcbiAgXCJtZFwiOiAxMDI0LFxuICBcImxnXCI6IDEyODAsXG4gIFwieGxcIjogMTQ0MCxcbiAgXCIyeGxcIjogMTYwMCxcbiAgXCIzeGxcIjogMTkyMCxcbiAgXCI0eGxcIjogMjU2MFxufTtcbmNvbnN0IGJyZWFrcG9pbnRzUHJpbWVGbGV4ID0ge1xuICBzbTogNTc2LFxuICBtZDogNzY4LFxuICBsZzogOTkyLFxuICB4bDogMTIwMFxufTtcblxuZnVuY3Rpb24gdXNlQnJlYWtwb2ludHMoYnJlYWtwb2ludHMsIG9wdGlvbnMgPSB7fSkge1xuICBmdW5jdGlvbiBnZXRWYWx1ZShrLCBkZWx0YSkge1xuICAgIGxldCB2ID0gdG9WYWx1ZShicmVha3BvaW50c1t0b1ZhbHVlKGspXSk7XG4gICAgaWYgKGRlbHRhICE9IG51bGwpXG4gICAgICB2ID0gaW5jcmVhc2VXaXRoVW5pdCh2LCBkZWx0YSk7XG4gICAgaWYgKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKVxuICAgICAgdiA9IGAke3Z9cHhgO1xuICAgIHJldHVybiB2O1xuICB9XG4gIGNvbnN0IHsgd2luZG93ID0gZGVmYXVsdFdpbmRvdywgc3RyYXRlZ3kgPSBcIm1pbi13aWR0aFwiIH0gPSBvcHRpb25zO1xuICBmdW5jdGlvbiBtYXRjaChxdWVyeSkge1xuICAgIGlmICghd2luZG93KVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB3aW5kb3cubWF0Y2hNZWRpYShxdWVyeSkubWF0Y2hlcztcbiAgfVxuICBjb25zdCBncmVhdGVyT3JFcXVhbCA9IChrKSA9PiB7XG4gICAgcmV0dXJuIHVzZU1lZGlhUXVlcnkoKCkgPT4gYChtaW4td2lkdGg6ICR7Z2V0VmFsdWUoayl9KWAsIG9wdGlvbnMpO1xuICB9O1xuICBjb25zdCBzbWFsbGVyT3JFcXVhbCA9IChrKSA9PiB7XG4gICAgcmV0dXJuIHVzZU1lZGlhUXVlcnkoKCkgPT4gYChtYXgtd2lkdGg6ICR7Z2V0VmFsdWUoayl9KWAsIG9wdGlvbnMpO1xuICB9O1xuICBjb25zdCBzaG9ydGN1dE1ldGhvZHMgPSBPYmplY3Qua2V5cyhicmVha3BvaW50cykucmVkdWNlKChzaG9ydGN1dHMsIGspID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2hvcnRjdXRzLCBrLCB7XG4gICAgICBnZXQ6ICgpID0+IHN0cmF0ZWd5ID09PSBcIm1pbi13aWR0aFwiID8gZ3JlYXRlck9yRXF1YWwoaykgOiBzbWFsbGVyT3JFcXVhbChrKSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gc2hvcnRjdXRzO1xuICB9LCB7fSk7XG4gIGZ1bmN0aW9uIGN1cnJlbnQoKSB7XG4gICAgY29uc3QgcG9pbnRzID0gT2JqZWN0LmtleXMoYnJlYWtwb2ludHMpLm1hcCgoaSkgPT4gW2ksIGdyZWF0ZXJPckVxdWFsKGkpXSk7XG4gICAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IHBvaW50cy5maWx0ZXIoKFssIHZdKSA9PiB2LnZhbHVlKS5tYXAoKFtrXSkgPT4gaykpO1xuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHNob3J0Y3V0TWV0aG9kcywge1xuICAgIGdyZWF0ZXJPckVxdWFsLFxuICAgIHNtYWxsZXJPckVxdWFsLFxuICAgIGdyZWF0ZXIoaykge1xuICAgICAgcmV0dXJuIHVzZU1lZGlhUXVlcnkoKCkgPT4gYChtaW4td2lkdGg6ICR7Z2V0VmFsdWUoaywgMC4xKX0pYCwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBzbWFsbGVyKGspIHtcbiAgICAgIHJldHVybiB1c2VNZWRpYVF1ZXJ5KCgpID0+IGAobWF4LXdpZHRoOiAke2dldFZhbHVlKGssIC0wLjEpfSlgLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGJldHdlZW4oYSwgYikge1xuICAgICAgcmV0dXJuIHVzZU1lZGlhUXVlcnkoKCkgPT4gYChtaW4td2lkdGg6ICR7Z2V0VmFsdWUoYSl9KSBhbmQgKG1heC13aWR0aDogJHtnZXRWYWx1ZShiLCAtMC4xKX0pYCwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBpc0dyZWF0ZXIoaykge1xuICAgICAgcmV0dXJuIG1hdGNoKGAobWluLXdpZHRoOiAke2dldFZhbHVlKGssIDAuMSl9KWApO1xuICAgIH0sXG4gICAgaXNHcmVhdGVyT3JFcXVhbChrKSB7XG4gICAgICByZXR1cm4gbWF0Y2goYChtaW4td2lkdGg6ICR7Z2V0VmFsdWUoayl9KWApO1xuICAgIH0sXG4gICAgaXNTbWFsbGVyKGspIHtcbiAgICAgIHJldHVybiBtYXRjaChgKG1heC13aWR0aDogJHtnZXRWYWx1ZShrLCAtMC4xKX0pYCk7XG4gICAgfSxcbiAgICBpc1NtYWxsZXJPckVxdWFsKGspIHtcbiAgICAgIHJldHVybiBtYXRjaChgKG1heC13aWR0aDogJHtnZXRWYWx1ZShrKX0pYCk7XG4gICAgfSxcbiAgICBpc0luQmV0d2VlbihhLCBiKSB7XG4gICAgICByZXR1cm4gbWF0Y2goYChtaW4td2lkdGg6ICR7Z2V0VmFsdWUoYSl9KSBhbmQgKG1heC13aWR0aDogJHtnZXRWYWx1ZShiLCAtMC4xKX0pYCk7XG4gICAgfSxcbiAgICBjdXJyZW50LFxuICAgIGFjdGl2ZSgpIHtcbiAgICAgIGNvbnN0IGJwcyA9IGN1cnJlbnQoKTtcbiAgICAgIHJldHVybiBjb21wdXRlZCgoKSA9PiBicHMudmFsdWUubGVuZ3RoID09PSAwID8gXCJcIiA6IGJwcy52YWx1ZS5hdCgtMSkpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVzZUJyb2FkY2FzdENoYW5uZWwob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgbmFtZSxcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiB3aW5kb3cgJiYgXCJCcm9hZGNhc3RDaGFubmVsXCIgaW4gd2luZG93KTtcbiAgY29uc3QgaXNDbG9zZWQgPSByZWYoZmFsc2UpO1xuICBjb25zdCBjaGFubmVsID0gcmVmKCk7XG4gIGNvbnN0IGRhdGEgPSByZWYoKTtcbiAgY29uc3QgZXJyb3IgPSBzaGFsbG93UmVmKG51bGwpO1xuICBjb25zdCBwb3N0ID0gKGRhdGEyKSA9PiB7XG4gICAgaWYgKGNoYW5uZWwudmFsdWUpXG4gICAgICBjaGFubmVsLnZhbHVlLnBvc3RNZXNzYWdlKGRhdGEyKTtcbiAgfTtcbiAgY29uc3QgY2xvc2UgPSAoKSA9PiB7XG4gICAgaWYgKGNoYW5uZWwudmFsdWUpXG4gICAgICBjaGFubmVsLnZhbHVlLmNsb3NlKCk7XG4gICAgaXNDbG9zZWQudmFsdWUgPSB0cnVlO1xuICB9O1xuICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUpIHtcbiAgICB0cnlPbk1vdW50ZWQoKCkgPT4ge1xuICAgICAgZXJyb3IudmFsdWUgPSBudWxsO1xuICAgICAgY2hhbm5lbC52YWx1ZSA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKG5hbWUpO1xuICAgICAgY2hhbm5lbC52YWx1ZS5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZSkgPT4ge1xuICAgICAgICBkYXRhLnZhbHVlID0gZS5kYXRhO1xuICAgICAgfSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgY2hhbm5lbC52YWx1ZS5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZWVycm9yXCIsIChlKSA9PiB7XG4gICAgICAgIGVycm9yLnZhbHVlID0gZTtcbiAgICAgIH0sIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgIGNoYW5uZWwudmFsdWUuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsICgpID0+IHtcbiAgICAgICAgaXNDbG9zZWQudmFsdWUgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgdHJ5T25TY29wZURpc3Bvc2UoKCkgPT4ge1xuICAgIGNsb3NlKCk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIGNoYW5uZWwsXG4gICAgZGF0YSxcbiAgICBwb3N0LFxuICAgIGNsb3NlLFxuICAgIGVycm9yLFxuICAgIGlzQ2xvc2VkXG4gIH07XG59XG5cbmNvbnN0IFdSSVRBQkxFX1BST1BFUlRJRVMgPSBbXG4gIFwiaGFzaFwiLFxuICBcImhvc3RcIixcbiAgXCJob3N0bmFtZVwiLFxuICBcImhyZWZcIixcbiAgXCJwYXRobmFtZVwiLFxuICBcInBvcnRcIixcbiAgXCJwcm90b2NvbFwiLFxuICBcInNlYXJjaFwiXG5dO1xuZnVuY3Rpb24gdXNlQnJvd3NlckxvY2F0aW9uKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IHdpbmRvdyA9IGRlZmF1bHRXaW5kb3cgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHJlZnMgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgV1JJVEFCTEVfUFJPUEVSVElFUy5tYXAoKGtleSkgPT4gW2tleSwgcmVmKCldKVxuICApO1xuICBmb3IgKGNvbnN0IFtrZXksIHJlZjJdIG9mIG9iamVjdEVudHJpZXMocmVmcykpIHtcbiAgICB3YXRjaChyZWYyLCAodmFsdWUpID0+IHtcbiAgICAgIGlmICghKHdpbmRvdyA9PSBudWxsID8gdm9pZCAwIDogd2luZG93LmxvY2F0aW9uKSB8fCB3aW5kb3cubG9jYXRpb25ba2V5XSA9PT0gdmFsdWUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbltrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgYnVpbGRTdGF0ZSA9ICh0cmlnZ2VyKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgc3RhdGU6IHN0YXRlMiwgbGVuZ3RoIH0gPSAod2luZG93ID09IG51bGwgPyB2b2lkIDAgOiB3aW5kb3cuaGlzdG9yeSkgfHwge307XG4gICAgY29uc3QgeyBvcmlnaW4gfSA9ICh3aW5kb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHdpbmRvdy5sb2NhdGlvbikgfHwge307XG4gICAgZm9yIChjb25zdCBrZXkgb2YgV1JJVEFCTEVfUFJPUEVSVElFUylcbiAgICAgIHJlZnNba2V5XS52YWx1ZSA9IChfYSA9IHdpbmRvdyA9PSBudWxsID8gdm9pZCAwIDogd2luZG93LmxvY2F0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2Fba2V5XTtcbiAgICByZXR1cm4gcmVhY3RpdmUoe1xuICAgICAgdHJpZ2dlcixcbiAgICAgIHN0YXRlOiBzdGF0ZTIsXG4gICAgICBsZW5ndGgsXG4gICAgICBvcmlnaW4sXG4gICAgICAuLi5yZWZzXG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHN0YXRlID0gcmVmKGJ1aWxkU3RhdGUoXCJsb2FkXCIpKTtcbiAgaWYgKHdpbmRvdykge1xuICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcInBvcHN0YXRlXCIsICgpID0+IHN0YXRlLnZhbHVlID0gYnVpbGRTdGF0ZShcInBvcHN0YXRlXCIpLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwiaGFzaGNoYW5nZVwiLCAoKSA9PiBzdGF0ZS52YWx1ZSA9IGJ1aWxkU3RhdGUoXCJoYXNoY2hhbmdlXCIpLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG5mdW5jdGlvbiB1c2VDYWNoZWQocmVmVmFsdWUsIGNvbXBhcmF0b3IgPSAoYSwgYikgPT4gYSA9PT0gYiwgd2F0Y2hPcHRpb25zKSB7XG4gIGNvbnN0IGNhY2hlZFZhbHVlID0gcmVmKHJlZlZhbHVlLnZhbHVlKTtcbiAgd2F0Y2goKCkgPT4gcmVmVmFsdWUudmFsdWUsICh2YWx1ZSkgPT4ge1xuICAgIGlmICghY29tcGFyYXRvcih2YWx1ZSwgY2FjaGVkVmFsdWUudmFsdWUpKVxuICAgICAgY2FjaGVkVmFsdWUudmFsdWUgPSB2YWx1ZTtcbiAgfSwgd2F0Y2hPcHRpb25zKTtcbiAgcmV0dXJuIGNhY2hlZFZhbHVlO1xufVxuXG5mdW5jdGlvbiB1c2VQZXJtaXNzaW9uKHBlcm1pc3Npb25EZXNjLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGNvbnRyb2xzID0gZmFsc2UsXG4gICAgbmF2aWdhdG9yID0gZGVmYXVsdE5hdmlnYXRvclxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gbmF2aWdhdG9yICYmIFwicGVybWlzc2lvbnNcIiBpbiBuYXZpZ2F0b3IpO1xuICBsZXQgcGVybWlzc2lvblN0YXR1cztcbiAgY29uc3QgZGVzYyA9IHR5cGVvZiBwZXJtaXNzaW9uRGVzYyA9PT0gXCJzdHJpbmdcIiA/IHsgbmFtZTogcGVybWlzc2lvbkRlc2MgfSA6IHBlcm1pc3Npb25EZXNjO1xuICBjb25zdCBzdGF0ZSA9IHJlZigpO1xuICBjb25zdCBvbkNoYW5nZSA9ICgpID0+IHtcbiAgICBpZiAocGVybWlzc2lvblN0YXR1cylcbiAgICAgIHN0YXRlLnZhbHVlID0gcGVybWlzc2lvblN0YXR1cy5zdGF0ZTtcbiAgfTtcbiAgY29uc3QgcXVlcnkgPSBjcmVhdGVTaW5nbGV0b25Qcm9taXNlKGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWlzU3VwcG9ydGVkLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghcGVybWlzc2lvblN0YXR1cykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGVybWlzc2lvblN0YXR1cyA9IGF3YWl0IG5hdmlnYXRvci5wZXJtaXNzaW9ucy5xdWVyeShkZXNjKTtcbiAgICAgICAgdXNlRXZlbnRMaXN0ZW5lcihwZXJtaXNzaW9uU3RhdHVzLCBcImNoYW5nZVwiLCBvbkNoYW5nZSk7XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHN0YXRlLnZhbHVlID0gXCJwcm9tcHRcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBlcm1pc3Npb25TdGF0dXM7XG4gIH0pO1xuICBxdWVyeSgpO1xuICBpZiAoY29udHJvbHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdGUsXG4gICAgICBpc1N1cHBvcnRlZCxcbiAgICAgIHF1ZXJ5XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlQ2xpcGJvYXJkKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgbmF2aWdhdG9yID0gZGVmYXVsdE5hdmlnYXRvcixcbiAgICByZWFkID0gZmFsc2UsXG4gICAgc291cmNlLFxuICAgIGNvcGllZER1cmluZyA9IDE1MDAsXG4gICAgbGVnYWN5ID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlzQ2xpcGJvYXJkQXBpU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IG5hdmlnYXRvciAmJiBcImNsaXBib2FyZFwiIGluIG5hdmlnYXRvcik7XG4gIGNvbnN0IHBlcm1pc3Npb25SZWFkID0gdXNlUGVybWlzc2lvbihcImNsaXBib2FyZC1yZWFkXCIpO1xuICBjb25zdCBwZXJtaXNzaW9uV3JpdGUgPSB1c2VQZXJtaXNzaW9uKFwiY2xpcGJvYXJkLXdyaXRlXCIpO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IGNvbXB1dGVkKCgpID0+IGlzQ2xpcGJvYXJkQXBpU3VwcG9ydGVkLnZhbHVlIHx8IGxlZ2FjeSk7XG4gIGNvbnN0IHRleHQgPSByZWYoXCJcIik7XG4gIGNvbnN0IGNvcGllZCA9IHJlZihmYWxzZSk7XG4gIGNvbnN0IHRpbWVvdXQgPSB1c2VUaW1lb3V0Rm4oKCkgPT4gY29waWVkLnZhbHVlID0gZmFsc2UsIGNvcGllZER1cmluZyk7XG4gIGZ1bmN0aW9uIHVwZGF0ZVRleHQoKSB7XG4gICAgaWYgKGlzQ2xpcGJvYXJkQXBpU3VwcG9ydGVkLnZhbHVlICYmIGlzQWxsb3dlZChwZXJtaXNzaW9uUmVhZC52YWx1ZSkpIHtcbiAgICAgIG5hdmlnYXRvci5jbGlwYm9hcmQucmVhZFRleHQoKS50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgICB0ZXh0LnZhbHVlID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dC52YWx1ZSA9IGxlZ2FjeVJlYWQoKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlICYmIHJlYWQpXG4gICAgdXNlRXZlbnRMaXN0ZW5lcihbXCJjb3B5XCIsIFwiY3V0XCJdLCB1cGRhdGVUZXh0KTtcbiAgYXN5bmMgZnVuY3Rpb24gY29weSh2YWx1ZSA9IHRvVmFsdWUoc291cmNlKSkge1xuICAgIGlmIChpc1N1cHBvcnRlZC52YWx1ZSAmJiB2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBpZiAoaXNDbGlwYm9hcmRBcGlTdXBwb3J0ZWQudmFsdWUgJiYgaXNBbGxvd2VkKHBlcm1pc3Npb25Xcml0ZS52YWx1ZSkpXG4gICAgICAgIGF3YWl0IG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHZhbHVlKTtcbiAgICAgIGVsc2VcbiAgICAgICAgbGVnYWN5Q29weSh2YWx1ZSk7XG4gICAgICB0ZXh0LnZhbHVlID0gdmFsdWU7XG4gICAgICBjb3BpZWQudmFsdWUgPSB0cnVlO1xuICAgICAgdGltZW91dC5zdGFydCgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBsZWdhY3lDb3B5KHZhbHVlKSB7XG4gICAgY29uc3QgdGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIik7XG4gICAgdGEudmFsdWUgPSB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBcIlwiO1xuICAgIHRhLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgIHRhLnN0eWxlLm9wYWNpdHkgPSBcIjBcIjtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRhKTtcbiAgICB0YS5zZWxlY3QoKTtcbiAgICBkb2N1bWVudC5leGVjQ29tbWFuZChcImNvcHlcIik7XG4gICAgdGEucmVtb3ZlKCk7XG4gIH1cbiAgZnVuY3Rpb24gbGVnYWN5UmVhZCgpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICByZXR1cm4gKF9jID0gKF9iID0gKF9hID0gZG9jdW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGRvY3VtZW50LmdldFNlbGVjdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoZG9jdW1lbnQpKSA9PSBudWxsID8gdm9pZCAwIDogX2IudG9TdHJpbmcoKSkgIT0gbnVsbCA/IF9jIDogXCJcIjtcbiAgfVxuICBmdW5jdGlvbiBpc0FsbG93ZWQoc3RhdHVzKSB7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gXCJncmFudGVkXCIgfHwgc3RhdHVzID09PSBcInByb21wdFwiO1xuICB9XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgdGV4dCxcbiAgICBjb3BpZWQsXG4gICAgY29weVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VDbGlwYm9hcmRJdGVtcyhvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIG5hdmlnYXRvciA9IGRlZmF1bHROYXZpZ2F0b3IsXG4gICAgcmVhZCA9IGZhbHNlLFxuICAgIHNvdXJjZSxcbiAgICBjb3BpZWREdXJpbmcgPSAxNTAwXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiBuYXZpZ2F0b3IgJiYgXCJjbGlwYm9hcmRcIiBpbiBuYXZpZ2F0b3IpO1xuICBjb25zdCBjb250ZW50ID0gcmVmKFtdKTtcbiAgY29uc3QgY29waWVkID0gcmVmKGZhbHNlKTtcbiAgY29uc3QgdGltZW91dCA9IHVzZVRpbWVvdXRGbigoKSA9PiBjb3BpZWQudmFsdWUgPSBmYWxzZSwgY29waWVkRHVyaW5nKTtcbiAgZnVuY3Rpb24gdXBkYXRlQ29udGVudCgpIHtcbiAgICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUpIHtcbiAgICAgIG5hdmlnYXRvci5jbGlwYm9hcmQucmVhZCgpLnRoZW4oKGl0ZW1zKSA9PiB7XG4gICAgICAgIGNvbnRlbnQudmFsdWUgPSBpdGVtcztcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUgJiYgcmVhZClcbiAgICB1c2VFdmVudExpc3RlbmVyKFtcImNvcHlcIiwgXCJjdXRcIl0sIHVwZGF0ZUNvbnRlbnQpO1xuICBhc3luYyBmdW5jdGlvbiBjb3B5KHZhbHVlID0gdG9WYWx1ZShzb3VyY2UpKSB7XG4gICAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlICYmIHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGF3YWl0IG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGUodmFsdWUpO1xuICAgICAgY29udGVudC52YWx1ZSA9IHZhbHVlO1xuICAgICAgY29waWVkLnZhbHVlID0gdHJ1ZTtcbiAgICAgIHRpbWVvdXQuc3RhcnQoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBjb250ZW50LFxuICAgIGNvcGllZCxcbiAgICBjb3B5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsb25lRm5KU09OKHNvdXJjZSkge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzb3VyY2UpKTtcbn1cbmZ1bmN0aW9uIHVzZUNsb25lZChzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBjbG9uZWQgPSByZWYoe30pO1xuICBjb25zdCB7XG4gICAgbWFudWFsLFxuICAgIGNsb25lID0gY2xvbmVGbkpTT04sXG4gICAgLy8gd2F0Y2ggb3B0aW9uc1xuICAgIGRlZXAgPSB0cnVlLFxuICAgIGltbWVkaWF0ZSA9IHRydWVcbiAgfSA9IG9wdGlvbnM7XG4gIGZ1bmN0aW9uIHN5bmMoKSB7XG4gICAgY2xvbmVkLnZhbHVlID0gY2xvbmUodG9WYWx1ZShzb3VyY2UpKTtcbiAgfVxuICBpZiAoIW1hbnVhbCAmJiAoaXNSZWYoc291cmNlKSB8fCB0eXBlb2Ygc291cmNlID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgd2F0Y2goc291cmNlLCBzeW5jLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgZGVlcCxcbiAgICAgIGltbWVkaWF0ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHN5bmMoKTtcbiAgfVxuICByZXR1cm4geyBjbG9uZWQsIHN5bmMgfTtcbn1cblxuY29uc3QgX2dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDoge307XG5jb25zdCBnbG9iYWxLZXkgPSBcIl9fdnVldXNlX3Nzcl9oYW5kbGVyc19fXCI7XG5jb25zdCBoYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBnZXRIYW5kbGVycygpO1xuZnVuY3Rpb24gZ2V0SGFuZGxlcnMoKSB7XG4gIGlmICghKGdsb2JhbEtleSBpbiBfZ2xvYmFsKSlcbiAgICBfZ2xvYmFsW2dsb2JhbEtleV0gPSBfZ2xvYmFsW2dsb2JhbEtleV0gfHwge307XG4gIHJldHVybiBfZ2xvYmFsW2dsb2JhbEtleV07XG59XG5mdW5jdGlvbiBnZXRTU1JIYW5kbGVyKGtleSwgZmFsbGJhY2spIHtcbiAgcmV0dXJuIGhhbmRsZXJzW2tleV0gfHwgZmFsbGJhY2s7XG59XG5mdW5jdGlvbiBzZXRTU1JIYW5kbGVyKGtleSwgZm4pIHtcbiAgaGFuZGxlcnNba2V5XSA9IGZuO1xufVxuXG5mdW5jdGlvbiBndWVzc1NlcmlhbGl6ZXJUeXBlKHJhd0luaXQpIHtcbiAgcmV0dXJuIHJhd0luaXQgPT0gbnVsbCA/IFwiYW55XCIgOiByYXdJbml0IGluc3RhbmNlb2YgU2V0ID8gXCJzZXRcIiA6IHJhd0luaXQgaW5zdGFuY2VvZiBNYXAgPyBcIm1hcFwiIDogcmF3SW5pdCBpbnN0YW5jZW9mIERhdGUgPyBcImRhdGVcIiA6IHR5cGVvZiByYXdJbml0ID09PSBcImJvb2xlYW5cIiA/IFwiYm9vbGVhblwiIDogdHlwZW9mIHJhd0luaXQgPT09IFwic3RyaW5nXCIgPyBcInN0cmluZ1wiIDogdHlwZW9mIHJhd0luaXQgPT09IFwib2JqZWN0XCIgPyBcIm9iamVjdFwiIDogIU51bWJlci5pc05hTihyYXdJbml0KSA/IFwibnVtYmVyXCIgOiBcImFueVwiO1xufVxuXG5jb25zdCBTdG9yYWdlU2VyaWFsaXplcnMgPSB7XG4gIGJvb2xlYW46IHtcbiAgICByZWFkOiAodikgPT4gdiA9PT0gXCJ0cnVlXCIsXG4gICAgd3JpdGU6ICh2KSA9PiBTdHJpbmcodilcbiAgfSxcbiAgb2JqZWN0OiB7XG4gICAgcmVhZDogKHYpID0+IEpTT04ucGFyc2UodiksXG4gICAgd3JpdGU6ICh2KSA9PiBKU09OLnN0cmluZ2lmeSh2KVxuICB9LFxuICBudW1iZXI6IHtcbiAgICByZWFkOiAodikgPT4gTnVtYmVyLnBhcnNlRmxvYXQodiksXG4gICAgd3JpdGU6ICh2KSA9PiBTdHJpbmcodilcbiAgfSxcbiAgYW55OiB7XG4gICAgcmVhZDogKHYpID0+IHYsXG4gICAgd3JpdGU6ICh2KSA9PiBTdHJpbmcodilcbiAgfSxcbiAgc3RyaW5nOiB7XG4gICAgcmVhZDogKHYpID0+IHYsXG4gICAgd3JpdGU6ICh2KSA9PiBTdHJpbmcodilcbiAgfSxcbiAgbWFwOiB7XG4gICAgcmVhZDogKHYpID0+IG5ldyBNYXAoSlNPTi5wYXJzZSh2KSksXG4gICAgd3JpdGU6ICh2KSA9PiBKU09OLnN0cmluZ2lmeShBcnJheS5mcm9tKHYuZW50cmllcygpKSlcbiAgfSxcbiAgc2V0OiB7XG4gICAgcmVhZDogKHYpID0+IG5ldyBTZXQoSlNPTi5wYXJzZSh2KSksXG4gICAgd3JpdGU6ICh2KSA9PiBKU09OLnN0cmluZ2lmeShBcnJheS5mcm9tKHYpKVxuICB9LFxuICBkYXRlOiB7XG4gICAgcmVhZDogKHYpID0+IG5ldyBEYXRlKHYpLFxuICAgIHdyaXRlOiAodikgPT4gdi50b0lTT1N0cmluZygpXG4gIH1cbn07XG5jb25zdCBjdXN0b21TdG9yYWdlRXZlbnROYW1lID0gXCJ2dWV1c2Utc3RvcmFnZVwiO1xuZnVuY3Rpb24gdXNlU3RvcmFnZShrZXksIGRlZmF1bHRzLCBzdG9yYWdlLCBvcHRpb25zID0ge30pIHtcbiAgdmFyIF9hO1xuICBjb25zdCB7XG4gICAgZmx1c2ggPSBcInByZVwiLFxuICAgIGRlZXAgPSB0cnVlLFxuICAgIGxpc3RlblRvU3RvcmFnZUNoYW5nZXMgPSB0cnVlLFxuICAgIHdyaXRlRGVmYXVsdHMgPSB0cnVlLFxuICAgIG1lcmdlRGVmYXVsdHMgPSBmYWxzZSxcbiAgICBzaGFsbG93LFxuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3csXG4gICAgZXZlbnRGaWx0ZXIsXG4gICAgb25FcnJvciA9IChlKSA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH0sXG4gICAgaW5pdE9uTW91bnRlZFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgZGF0YSA9IChzaGFsbG93ID8gc2hhbGxvd1JlZiA6IHJlZikodHlwZW9mIGRlZmF1bHRzID09PSBcImZ1bmN0aW9uXCIgPyBkZWZhdWx0cygpIDogZGVmYXVsdHMpO1xuICBpZiAoIXN0b3JhZ2UpIHtcbiAgICB0cnkge1xuICAgICAgc3RvcmFnZSA9IGdldFNTUkhhbmRsZXIoXCJnZXREZWZhdWx0U3RvcmFnZVwiLCAoKSA9PiB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHJldHVybiAoX2EyID0gZGVmYXVsdFdpbmRvdykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5sb2NhbFN0b3JhZ2U7XG4gICAgICB9KSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG9uRXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIGlmICghc3RvcmFnZSlcbiAgICByZXR1cm4gZGF0YTtcbiAgY29uc3QgcmF3SW5pdCA9IHRvVmFsdWUoZGVmYXVsdHMpO1xuICBjb25zdCB0eXBlID0gZ3Vlc3NTZXJpYWxpemVyVHlwZShyYXdJbml0KTtcbiAgY29uc3Qgc2VyaWFsaXplciA9IChfYSA9IG9wdGlvbnMuc2VyaWFsaXplcikgIT0gbnVsbCA/IF9hIDogU3RvcmFnZVNlcmlhbGl6ZXJzW3R5cGVdO1xuICBjb25zdCB7IHBhdXNlOiBwYXVzZVdhdGNoLCByZXN1bWU6IHJlc3VtZVdhdGNoIH0gPSBwYXVzYWJsZVdhdGNoKFxuICAgIGRhdGEsXG4gICAgKCkgPT4gd3JpdGUoZGF0YS52YWx1ZSksXG4gICAgeyBmbHVzaCwgZGVlcCwgZXZlbnRGaWx0ZXIgfVxuICApO1xuICBpZiAod2luZG93ICYmIGxpc3RlblRvU3RvcmFnZUNoYW5nZXMpIHtcbiAgICB0cnlPbk1vdW50ZWQoKCkgPT4ge1xuICAgICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwic3RvcmFnZVwiLCB1cGRhdGUpO1xuICAgICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIGN1c3RvbVN0b3JhZ2VFdmVudE5hbWUsIHVwZGF0ZUZyb21DdXN0b21FdmVudCk7XG4gICAgICBpZiAoaW5pdE9uTW91bnRlZClcbiAgICAgICAgdXBkYXRlKCk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKCFpbml0T25Nb3VudGVkKVxuICAgIHVwZGF0ZSgpO1xuICBmdW5jdGlvbiBkaXNwYXRjaFdyaXRlRXZlbnQob2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgaWYgKHdpbmRvdykge1xuICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KGN1c3RvbVN0b3JhZ2VFdmVudE5hbWUsIHtcbiAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAga2V5LFxuICAgICAgICAgIG9sZFZhbHVlLFxuICAgICAgICAgIG5ld1ZhbHVlLFxuICAgICAgICAgIHN0b3JhZ2VBcmVhOiBzdG9yYWdlXG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gd3JpdGUodikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICBkaXNwYXRjaFdyaXRlRXZlbnQob2xkVmFsdWUsIG51bGwpO1xuICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBzZXJpYWxpemVyLndyaXRlKHYpO1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHNlcmlhbGl6ZWQpIHtcbiAgICAgICAgICBzdG9yYWdlLnNldEl0ZW0oa2V5LCBzZXJpYWxpemVkKTtcbiAgICAgICAgICBkaXNwYXRjaFdyaXRlRXZlbnQob2xkVmFsdWUsIHNlcmlhbGl6ZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgb25FcnJvcihlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVhZChldmVudCkge1xuICAgIGNvbnN0IHJhd1ZhbHVlID0gZXZlbnQgPyBldmVudC5uZXdWYWx1ZSA6IHN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgIGlmIChyYXdWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBpZiAod3JpdGVEZWZhdWx0cyAmJiByYXdJbml0ICE9IG51bGwpXG4gICAgICAgIHN0b3JhZ2Uuc2V0SXRlbShrZXksIHNlcmlhbGl6ZXIud3JpdGUocmF3SW5pdCkpO1xuICAgICAgcmV0dXJuIHJhd0luaXQ7XG4gICAgfSBlbHNlIGlmICghZXZlbnQgJiYgbWVyZ2VEZWZhdWx0cykge1xuICAgICAgY29uc3QgdmFsdWUgPSBzZXJpYWxpemVyLnJlYWQocmF3VmFsdWUpO1xuICAgICAgaWYgKHR5cGVvZiBtZXJnZURlZmF1bHRzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiBtZXJnZURlZmF1bHRzKHZhbHVlLCByYXdJbml0KTtcbiAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICByZXR1cm4geyAuLi5yYXdJbml0LCAuLi52YWx1ZSB9O1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJhd1ZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gcmF3VmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzZXJpYWxpemVyLnJlYWQocmF3VmFsdWUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1cGRhdGUoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQgJiYgZXZlbnQuc3RvcmFnZUFyZWEgIT09IHN0b3JhZ2UpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGV2ZW50ICYmIGV2ZW50LmtleSA9PSBudWxsKSB7XG4gICAgICBkYXRhLnZhbHVlID0gcmF3SW5pdDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2ZW50ICYmIGV2ZW50LmtleSAhPT0ga2V5KVxuICAgICAgcmV0dXJuO1xuICAgIHBhdXNlV2F0Y2goKTtcbiAgICB0cnkge1xuICAgICAgaWYgKChldmVudCA9PSBudWxsID8gdm9pZCAwIDogZXZlbnQubmV3VmFsdWUpICE9PSBzZXJpYWxpemVyLndyaXRlKGRhdGEudmFsdWUpKVxuICAgICAgICBkYXRhLnZhbHVlID0gcmVhZChldmVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgb25FcnJvcihlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGV2ZW50KVxuICAgICAgICBuZXh0VGljayhyZXN1bWVXYXRjaCk7XG4gICAgICBlbHNlXG4gICAgICAgIHJlc3VtZVdhdGNoKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZUZyb21DdXN0b21FdmVudChldmVudCkge1xuICAgIHVwZGF0ZShldmVudC5kZXRhaWwpO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiB1c2VQcmVmZXJyZWREYXJrKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHVzZU1lZGlhUXVlcnkoXCIocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspXCIsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiB1c2VDb2xvck1vZGUob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBzZWxlY3RvciA9IFwiaHRtbFwiLFxuICAgIGF0dHJpYnV0ZSA9IFwiY2xhc3NcIixcbiAgICBpbml0aWFsVmFsdWUgPSBcImF1dG9cIixcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93LFxuICAgIHN0b3JhZ2UsXG4gICAgc3RvcmFnZUtleSA9IFwidnVldXNlLWNvbG9yLXNjaGVtZVwiLFxuICAgIGxpc3RlblRvU3RvcmFnZUNoYW5nZXMgPSB0cnVlLFxuICAgIHN0b3JhZ2VSZWYsXG4gICAgZW1pdEF1dG8sXG4gICAgZGlzYWJsZVRyYW5zaXRpb24gPSB0cnVlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBtb2RlcyA9IHtcbiAgICBhdXRvOiBcIlwiLFxuICAgIGxpZ2h0OiBcImxpZ2h0XCIsXG4gICAgZGFyazogXCJkYXJrXCIsXG4gICAgLi4ub3B0aW9ucy5tb2RlcyB8fCB7fVxuICB9O1xuICBjb25zdCBwcmVmZXJyZWREYXJrID0gdXNlUHJlZmVycmVkRGFyayh7IHdpbmRvdyB9KTtcbiAgY29uc3Qgc3lzdGVtID0gY29tcHV0ZWQoKCkgPT4gcHJlZmVycmVkRGFyay52YWx1ZSA/IFwiZGFya1wiIDogXCJsaWdodFwiKTtcbiAgY29uc3Qgc3RvcmUgPSBzdG9yYWdlUmVmIHx8IChzdG9yYWdlS2V5ID09IG51bGwgPyB0b1JlZihpbml0aWFsVmFsdWUpIDogdXNlU3RvcmFnZShzdG9yYWdlS2V5LCBpbml0aWFsVmFsdWUsIHN0b3JhZ2UsIHsgd2luZG93LCBsaXN0ZW5Ub1N0b3JhZ2VDaGFuZ2VzIH0pKTtcbiAgY29uc3Qgc3RhdGUgPSBjb21wdXRlZCgoKSA9PiBzdG9yZS52YWx1ZSA9PT0gXCJhdXRvXCIgPyBzeXN0ZW0udmFsdWUgOiBzdG9yZS52YWx1ZSk7XG4gIGNvbnN0IHVwZGF0ZUhUTUxBdHRycyA9IGdldFNTUkhhbmRsZXIoXG4gICAgXCJ1cGRhdGVIVE1MQXR0cnNcIixcbiAgICAoc2VsZWN0b3IyLCBhdHRyaWJ1dGUyLCB2YWx1ZSkgPT4ge1xuICAgICAgY29uc3QgZWwgPSB0eXBlb2Ygc2VsZWN0b3IyID09PSBcInN0cmluZ1wiID8gd2luZG93ID09IG51bGwgPyB2b2lkIDAgOiB3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcjIpIDogdW5yZWZFbGVtZW50KHNlbGVjdG9yMik7XG4gICAgICBpZiAoIWVsKVxuICAgICAgICByZXR1cm47XG4gICAgICBsZXQgc3R5bGU7XG4gICAgICBpZiAoZGlzYWJsZVRyYW5zaXRpb24pIHtcbiAgICAgICAgc3R5bGUgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgICBjb25zdCBzdHlsZVN0cmluZyA9IFwiKiwqOjpiZWZvcmUsKjo6YWZ0ZXJ7LXdlYmtpdC10cmFuc2l0aW9uOm5vbmUhaW1wb3J0YW50Oy1tb3otdHJhbnNpdGlvbjpub25lIWltcG9ydGFudDstby10cmFuc2l0aW9uOm5vbmUhaW1wb3J0YW50Oy1tcy10cmFuc2l0aW9uOm5vbmUhaW1wb3J0YW50O3RyYW5zaXRpb246bm9uZSFpbXBvcnRhbnR9XCI7XG4gICAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHN0eWxlU3RyaW5nKSk7XG4gICAgICAgIHdpbmRvdy5kb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRyaWJ1dGUyID09PSBcImNsYXNzXCIpIHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHZhbHVlLnNwbGl0KC9cXHMvZyk7XG4gICAgICAgIE9iamVjdC52YWx1ZXMobW9kZXMpLmZsYXRNYXAoKGkpID0+IChpIHx8IFwiXCIpLnNwbGl0KC9cXHMvZykpLmZpbHRlcihCb29sZWFuKS5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICAgICAgaWYgKGN1cnJlbnQuaW5jbHVkZXModikpXG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKHYpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUodik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZTIsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChkaXNhYmxlVHJhbnNpdGlvbikge1xuICAgICAgICB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzdHlsZSkub3BhY2l0eTtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZChzdHlsZSk7XG4gICAgICB9XG4gICAgfVxuICApO1xuICBmdW5jdGlvbiBkZWZhdWx0T25DaGFuZ2VkKG1vZGUpIHtcbiAgICB2YXIgX2E7XG4gICAgdXBkYXRlSFRNTEF0dHJzKHNlbGVjdG9yLCBhdHRyaWJ1dGUsIChfYSA9IG1vZGVzW21vZGVdKSAhPSBudWxsID8gX2EgOiBtb2RlKTtcbiAgfVxuICBmdW5jdGlvbiBvbkNoYW5nZWQobW9kZSkge1xuICAgIGlmIChvcHRpb25zLm9uQ2hhbmdlZClcbiAgICAgIG9wdGlvbnMub25DaGFuZ2VkKG1vZGUsIGRlZmF1bHRPbkNoYW5nZWQpO1xuICAgIGVsc2VcbiAgICAgIGRlZmF1bHRPbkNoYW5nZWQobW9kZSk7XG4gIH1cbiAgd2F0Y2goc3RhdGUsIG9uQ2hhbmdlZCwgeyBmbHVzaDogXCJwb3N0XCIsIGltbWVkaWF0ZTogdHJ1ZSB9KTtcbiAgdHJ5T25Nb3VudGVkKCgpID0+IG9uQ2hhbmdlZChzdGF0ZS52YWx1ZSkpO1xuICBjb25zdCBhdXRvID0gY29tcHV0ZWQoe1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBlbWl0QXV0byA/IHN0b3JlLnZhbHVlIDogc3RhdGUudmFsdWU7XG4gICAgfSxcbiAgICBzZXQodikge1xuICAgICAgc3RvcmUudmFsdWUgPSB2O1xuICAgIH1cbiAgfSk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYXV0bywgeyBzdG9yZSwgc3lzdGVtLCBzdGF0ZSB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBhdXRvO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVzZUNvbmZpcm1EaWFsb2cocmV2ZWFsZWQgPSByZWYoZmFsc2UpKSB7XG4gIGNvbnN0IGNvbmZpcm1Ib29rID0gY3JlYXRlRXZlbnRIb29rKCk7XG4gIGNvbnN0IGNhbmNlbEhvb2sgPSBjcmVhdGVFdmVudEhvb2soKTtcbiAgY29uc3QgcmV2ZWFsSG9vayA9IGNyZWF0ZUV2ZW50SG9vaygpO1xuICBsZXQgX3Jlc29sdmUgPSBub29wO1xuICBjb25zdCByZXZlYWwgPSAoZGF0YSkgPT4ge1xuICAgIHJldmVhbEhvb2sudHJpZ2dlcihkYXRhKTtcbiAgICByZXZlYWxlZC52YWx1ZSA9IHRydWU7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IGNvbmZpcm0gPSAoZGF0YSkgPT4ge1xuICAgIHJldmVhbGVkLnZhbHVlID0gZmFsc2U7XG4gICAgY29uZmlybUhvb2sudHJpZ2dlcihkYXRhKTtcbiAgICBfcmVzb2x2ZSh7IGRhdGEsIGlzQ2FuY2VsZWQ6IGZhbHNlIH0pO1xuICB9O1xuICBjb25zdCBjYW5jZWwgPSAoZGF0YSkgPT4ge1xuICAgIHJldmVhbGVkLnZhbHVlID0gZmFsc2U7XG4gICAgY2FuY2VsSG9vay50cmlnZ2VyKGRhdGEpO1xuICAgIF9yZXNvbHZlKHsgZGF0YSwgaXNDYW5jZWxlZDogdHJ1ZSB9KTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBpc1JldmVhbGVkOiBjb21wdXRlZCgoKSA9PiByZXZlYWxlZC52YWx1ZSksXG4gICAgcmV2ZWFsLFxuICAgIGNvbmZpcm0sXG4gICAgY2FuY2VsLFxuICAgIG9uUmV2ZWFsOiByZXZlYWxIb29rLm9uLFxuICAgIG9uQ29uZmlybTogY29uZmlybUhvb2sub24sXG4gICAgb25DYW5jZWw6IGNhbmNlbEhvb2sub25cbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlQ3NzVmFyKHByb3AsIHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgd2luZG93ID0gZGVmYXVsdFdpbmRvdywgaW5pdGlhbFZhbHVlID0gXCJcIiwgb2JzZXJ2ZSA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICBjb25zdCB2YXJpYWJsZSA9IHJlZihpbml0aWFsVmFsdWUpO1xuICBjb25zdCBlbFJlZiA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIHVucmVmRWxlbWVudCh0YXJnZXQpIHx8ICgoX2EgPSB3aW5kb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHdpbmRvdy5kb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRvY3VtZW50RWxlbWVudCk7XG4gIH0pO1xuICBmdW5jdGlvbiB1cGRhdGVDc3NWYXIoKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGtleSA9IHRvVmFsdWUocHJvcCk7XG4gICAgY29uc3QgZWwgPSB0b1ZhbHVlKGVsUmVmKTtcbiAgICBpZiAoZWwgJiYgd2luZG93KSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IChfYSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKS5nZXRQcm9wZXJ0eVZhbHVlKGtleSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS50cmltKCk7XG4gICAgICB2YXJpYWJsZS52YWx1ZSA9IHZhbHVlIHx8IGluaXRpYWxWYWx1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKG9ic2VydmUpIHtcbiAgICB1c2VNdXRhdGlvbk9ic2VydmVyKGVsUmVmLCB1cGRhdGVDc3NWYXIsIHtcbiAgICAgIGF0dHJpYnV0ZUZpbHRlcjogW1wic3R5bGVcIiwgXCJjbGFzc1wiXSxcbiAgICAgIHdpbmRvd1xuICAgIH0pO1xuICB9XG4gIHdhdGNoKFxuICAgIFtlbFJlZiwgKCkgPT4gdG9WYWx1ZShwcm9wKV0sXG4gICAgdXBkYXRlQ3NzVmFyLFxuICAgIHsgaW1tZWRpYXRlOiB0cnVlIH1cbiAgKTtcbiAgd2F0Y2goXG4gICAgdmFyaWFibGUsXG4gICAgKHZhbCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKChfYSA9IGVsUmVmLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc3R5bGUpXG4gICAgICAgIGVsUmVmLnZhbHVlLnN0eWxlLnNldFByb3BlcnR5KHRvVmFsdWUocHJvcCksIHZhbCk7XG4gICAgfVxuICApO1xuICByZXR1cm4gdmFyaWFibGU7XG59XG5cbmZ1bmN0aW9uIHVzZUN1cnJlbnRFbGVtZW50KHJvb3RDb21wb25lbnQpIHtcbiAgY29uc3Qgdm0gPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgY29uc3QgY3VycmVudEVsZW1lbnQgPSBjb21wdXRlZFdpdGhDb250cm9sKFxuICAgICgpID0+IG51bGwsXG4gICAgKCkgPT4gcm9vdENvbXBvbmVudCA/IHVucmVmRWxlbWVudChyb290Q29tcG9uZW50KSA6IHZtLnByb3h5LiRlbFxuICApO1xuICBvblVwZGF0ZWQoY3VycmVudEVsZW1lbnQudHJpZ2dlcik7XG4gIG9uTW91bnRlZChjdXJyZW50RWxlbWVudC50cmlnZ2VyKTtcbiAgcmV0dXJuIGN1cnJlbnRFbGVtZW50O1xufVxuXG5mdW5jdGlvbiB1c2VDeWNsZUxpc3QobGlzdCwgb3B0aW9ucykge1xuICBjb25zdCBzdGF0ZSA9IHNoYWxsb3dSZWYoZ2V0SW5pdGlhbFZhbHVlKCkpO1xuICBjb25zdCBsaXN0UmVmID0gdG9SZWYobGlzdCk7XG4gIGNvbnN0IGluZGV4ID0gY29tcHV0ZWQoe1xuICAgIGdldCgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHRhcmdldExpc3QgPSBsaXN0UmVmLnZhbHVlO1xuICAgICAgbGV0IGluZGV4MiA9IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmdldEluZGV4T2YpID8gb3B0aW9ucy5nZXRJbmRleE9mKHN0YXRlLnZhbHVlLCB0YXJnZXRMaXN0KSA6IHRhcmdldExpc3QuaW5kZXhPZihzdGF0ZS52YWx1ZSk7XG4gICAgICBpZiAoaW5kZXgyIDwgMClcbiAgICAgICAgaW5kZXgyID0gKF9hID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5mYWxsYmFja0luZGV4KSAhPSBudWxsID8gX2EgOiAwO1xuICAgICAgcmV0dXJuIGluZGV4MjtcbiAgICB9LFxuICAgIHNldCh2KSB7XG4gICAgICBzZXQodik7XG4gICAgfVxuICB9KTtcbiAgZnVuY3Rpb24gc2V0KGkpIHtcbiAgICBjb25zdCB0YXJnZXRMaXN0ID0gbGlzdFJlZi52YWx1ZTtcbiAgICBjb25zdCBsZW5ndGggPSB0YXJnZXRMaXN0Lmxlbmd0aDtcbiAgICBjb25zdCBpbmRleDIgPSAoaSAlIGxlbmd0aCArIGxlbmd0aCkgJSBsZW5ndGg7XG4gICAgY29uc3QgdmFsdWUgPSB0YXJnZXRMaXN0W2luZGV4Ml07XG4gICAgc3RhdGUudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gc2hpZnQoZGVsdGEgPSAxKSB7XG4gICAgcmV0dXJuIHNldChpbmRleC52YWx1ZSArIGRlbHRhKTtcbiAgfVxuICBmdW5jdGlvbiBuZXh0KG4gPSAxKSB7XG4gICAgcmV0dXJuIHNoaWZ0KG4pO1xuICB9XG4gIGZ1bmN0aW9uIHByZXYobiA9IDEpIHtcbiAgICByZXR1cm4gc2hpZnQoLW4pO1xuICB9XG4gIGZ1bmN0aW9uIGdldEluaXRpYWxWYWx1ZSgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSB0b1ZhbHVlKChfYSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaW5pdGlhbFZhbHVlKSAhPSBudWxsID8gX2EgOiB0b1ZhbHVlKGxpc3QpWzBdKSkgIT0gbnVsbCA/IF9iIDogdm9pZCAwO1xuICB9XG4gIHdhdGNoKGxpc3RSZWYsICgpID0+IHNldChpbmRleC52YWx1ZSkpO1xuICByZXR1cm4ge1xuICAgIHN0YXRlLFxuICAgIGluZGV4LFxuICAgIG5leHQsXG4gICAgcHJldixcbiAgICBnbzogc2V0XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZURhcmsob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICB2YWx1ZURhcmsgPSBcImRhcmtcIixcbiAgICB2YWx1ZUxpZ2h0ID0gXCJcIixcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBtb2RlID0gdXNlQ29sb3JNb2RlKHtcbiAgICAuLi5vcHRpb25zLFxuICAgIG9uQ2hhbmdlZDogKG1vZGUyLCBkZWZhdWx0SGFuZGxlcikgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKG9wdGlvbnMub25DaGFuZ2VkKVxuICAgICAgICAoX2EgPSBvcHRpb25zLm9uQ2hhbmdlZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwob3B0aW9ucywgbW9kZTIgPT09IFwiZGFya1wiLCBkZWZhdWx0SGFuZGxlciwgbW9kZTIpO1xuICAgICAgZWxzZVxuICAgICAgICBkZWZhdWx0SGFuZGxlcihtb2RlMik7XG4gICAgfSxcbiAgICBtb2Rlczoge1xuICAgICAgZGFyazogdmFsdWVEYXJrLFxuICAgICAgbGlnaHQ6IHZhbHVlTGlnaHRcbiAgICB9XG4gIH0pO1xuICBjb25zdCBzeXN0ZW0gPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgaWYgKG1vZGUuc3lzdGVtKSB7XG4gICAgICByZXR1cm4gbW9kZS5zeXN0ZW0udmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByZWZlcnJlZERhcmsgPSB1c2VQcmVmZXJyZWREYXJrKHsgd2luZG93IH0pO1xuICAgICAgcmV0dXJuIHByZWZlcnJlZERhcmsudmFsdWUgPyBcImRhcmtcIiA6IFwibGlnaHRcIjtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBpc0RhcmsgPSBjb21wdXRlZCh7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIG1vZGUudmFsdWUgPT09IFwiZGFya1wiO1xuICAgIH0sXG4gICAgc2V0KHYpIHtcbiAgICAgIGNvbnN0IG1vZGVWYWwgPSB2ID8gXCJkYXJrXCIgOiBcImxpZ2h0XCI7XG4gICAgICBpZiAoc3lzdGVtLnZhbHVlID09PSBtb2RlVmFsKVxuICAgICAgICBtb2RlLnZhbHVlID0gXCJhdXRvXCI7XG4gICAgICBlbHNlXG4gICAgICAgIG1vZGUudmFsdWUgPSBtb2RlVmFsO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBpc0Rhcms7XG59XG5cbmZ1bmN0aW9uIGZuQnlwYXNzKHYpIHtcbiAgcmV0dXJuIHY7XG59XG5mdW5jdGlvbiBmblNldFNvdXJjZShzb3VyY2UsIHZhbHVlKSB7XG4gIHJldHVybiBzb3VyY2UudmFsdWUgPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHREdW1wKGNsb25lKSB7XG4gIHJldHVybiBjbG9uZSA/IHR5cGVvZiBjbG9uZSA9PT0gXCJmdW5jdGlvblwiID8gY2xvbmUgOiBjbG9uZUZuSlNPTiA6IGZuQnlwYXNzO1xufVxuZnVuY3Rpb24gZGVmYXVsdFBhcnNlKGNsb25lKSB7XG4gIHJldHVybiBjbG9uZSA/IHR5cGVvZiBjbG9uZSA9PT0gXCJmdW5jdGlvblwiID8gY2xvbmUgOiBjbG9uZUZuSlNPTiA6IGZuQnlwYXNzO1xufVxuZnVuY3Rpb24gdXNlTWFudWFsUmVmSGlzdG9yeShzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgY2xvbmUgPSBmYWxzZSxcbiAgICBkdW1wID0gZGVmYXVsdER1bXAoY2xvbmUpLFxuICAgIHBhcnNlID0gZGVmYXVsdFBhcnNlKGNsb25lKSxcbiAgICBzZXRTb3VyY2UgPSBmblNldFNvdXJjZVxuICB9ID0gb3B0aW9ucztcbiAgZnVuY3Rpb24gX2NyZWF0ZUhpc3RvcnlSZWNvcmQoKSB7XG4gICAgcmV0dXJuIG1hcmtSYXcoe1xuICAgICAgc25hcHNob3Q6IGR1bXAoc291cmNlLnZhbHVlKSxcbiAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wKClcbiAgICB9KTtcbiAgfVxuICBjb25zdCBsYXN0ID0gcmVmKF9jcmVhdGVIaXN0b3J5UmVjb3JkKCkpO1xuICBjb25zdCB1bmRvU3RhY2sgPSByZWYoW10pO1xuICBjb25zdCByZWRvU3RhY2sgPSByZWYoW10pO1xuICBjb25zdCBfc2V0U291cmNlID0gKHJlY29yZCkgPT4ge1xuICAgIHNldFNvdXJjZShzb3VyY2UsIHBhcnNlKHJlY29yZC5zbmFwc2hvdCkpO1xuICAgIGxhc3QudmFsdWUgPSByZWNvcmQ7XG4gIH07XG4gIGNvbnN0IGNvbW1pdCA9ICgpID0+IHtcbiAgICB1bmRvU3RhY2sudmFsdWUudW5zaGlmdChsYXN0LnZhbHVlKTtcbiAgICBsYXN0LnZhbHVlID0gX2NyZWF0ZUhpc3RvcnlSZWNvcmQoKTtcbiAgICBpZiAob3B0aW9ucy5jYXBhY2l0eSAmJiB1bmRvU3RhY2sudmFsdWUubGVuZ3RoID4gb3B0aW9ucy5jYXBhY2l0eSlcbiAgICAgIHVuZG9TdGFjay52YWx1ZS5zcGxpY2Uob3B0aW9ucy5jYXBhY2l0eSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICBpZiAocmVkb1N0YWNrLnZhbHVlLmxlbmd0aClcbiAgICAgIHJlZG9TdGFjay52YWx1ZS5zcGxpY2UoMCwgcmVkb1N0YWNrLnZhbHVlLmxlbmd0aCk7XG4gIH07XG4gIGNvbnN0IGNsZWFyID0gKCkgPT4ge1xuICAgIHVuZG9TdGFjay52YWx1ZS5zcGxpY2UoMCwgdW5kb1N0YWNrLnZhbHVlLmxlbmd0aCk7XG4gICAgcmVkb1N0YWNrLnZhbHVlLnNwbGljZSgwLCByZWRvU3RhY2sudmFsdWUubGVuZ3RoKTtcbiAgfTtcbiAgY29uc3QgdW5kbyA9ICgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IHVuZG9TdGFjay52YWx1ZS5zaGlmdCgpO1xuICAgIGlmIChzdGF0ZSkge1xuICAgICAgcmVkb1N0YWNrLnZhbHVlLnVuc2hpZnQobGFzdC52YWx1ZSk7XG4gICAgICBfc2V0U291cmNlKHN0YXRlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlZG8gPSAoKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSByZWRvU3RhY2sudmFsdWUuc2hpZnQoKTtcbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIHVuZG9TdGFjay52YWx1ZS51bnNoaWZ0KGxhc3QudmFsdWUpO1xuICAgICAgX3NldFNvdXJjZShzdGF0ZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICBfc2V0U291cmNlKGxhc3QudmFsdWUpO1xuICB9O1xuICBjb25zdCBoaXN0b3J5ID0gY29tcHV0ZWQoKCkgPT4gW2xhc3QudmFsdWUsIC4uLnVuZG9TdGFjay52YWx1ZV0pO1xuICBjb25zdCBjYW5VbmRvID0gY29tcHV0ZWQoKCkgPT4gdW5kb1N0YWNrLnZhbHVlLmxlbmd0aCA+IDApO1xuICBjb25zdCBjYW5SZWRvID0gY29tcHV0ZWQoKCkgPT4gcmVkb1N0YWNrLnZhbHVlLmxlbmd0aCA+IDApO1xuICByZXR1cm4ge1xuICAgIHNvdXJjZSxcbiAgICB1bmRvU3RhY2ssXG4gICAgcmVkb1N0YWNrLFxuICAgIGxhc3QsXG4gICAgaGlzdG9yeSxcbiAgICBjYW5VbmRvLFxuICAgIGNhblJlZG8sXG4gICAgY2xlYXIsXG4gICAgY29tbWl0LFxuICAgIHJlc2V0LFxuICAgIHVuZG8sXG4gICAgcmVkb1xuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VSZWZIaXN0b3J5KHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBkZWVwID0gZmFsc2UsXG4gICAgZmx1c2ggPSBcInByZVwiLFxuICAgIGV2ZW50RmlsdGVyXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCB7XG4gICAgZXZlbnRGaWx0ZXI6IGNvbXBvc2VkRmlsdGVyLFxuICAgIHBhdXNlLFxuICAgIHJlc3VtZTogcmVzdW1lVHJhY2tpbmcsXG4gICAgaXNBY3RpdmU6IGlzVHJhY2tpbmdcbiAgfSA9IHBhdXNhYmxlRmlsdGVyKGV2ZW50RmlsdGVyKTtcbiAgY29uc3Qge1xuICAgIGlnbm9yZVVwZGF0ZXMsXG4gICAgaWdub3JlUHJldkFzeW5jVXBkYXRlcyxcbiAgICBzdG9wXG4gIH0gPSB3YXRjaElnbm9yYWJsZShcbiAgICBzb3VyY2UsXG4gICAgY29tbWl0LFxuICAgIHsgZGVlcCwgZmx1c2gsIGV2ZW50RmlsdGVyOiBjb21wb3NlZEZpbHRlciB9XG4gICk7XG4gIGZ1bmN0aW9uIHNldFNvdXJjZShzb3VyY2UyLCB2YWx1ZSkge1xuICAgIGlnbm9yZVByZXZBc3luY1VwZGF0ZXMoKTtcbiAgICBpZ25vcmVVcGRhdGVzKCgpID0+IHtcbiAgICAgIHNvdXJjZTIudmFsdWUgPSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBtYW51YWxIaXN0b3J5ID0gdXNlTWFudWFsUmVmSGlzdG9yeShzb3VyY2UsIHsgLi4ub3B0aW9ucywgY2xvbmU6IG9wdGlvbnMuY2xvbmUgfHwgZGVlcCwgc2V0U291cmNlIH0pO1xuICBjb25zdCB7IGNsZWFyLCBjb21taXQ6IG1hbnVhbENvbW1pdCB9ID0gbWFudWFsSGlzdG9yeTtcbiAgZnVuY3Rpb24gY29tbWl0KCkge1xuICAgIGlnbm9yZVByZXZBc3luY1VwZGF0ZXMoKTtcbiAgICBtYW51YWxDb21taXQoKTtcbiAgfVxuICBmdW5jdGlvbiByZXN1bWUoY29tbWl0Tm93KSB7XG4gICAgcmVzdW1lVHJhY2tpbmcoKTtcbiAgICBpZiAoY29tbWl0Tm93KVxuICAgICAgY29tbWl0KCk7XG4gIH1cbiAgZnVuY3Rpb24gYmF0Y2goZm4pIHtcbiAgICBsZXQgY2FuY2VsZWQgPSBmYWxzZTtcbiAgICBjb25zdCBjYW5jZWwgPSAoKSA9PiBjYW5jZWxlZCA9IHRydWU7XG4gICAgaWdub3JlVXBkYXRlcygoKSA9PiB7XG4gICAgICBmbihjYW5jZWwpO1xuICAgIH0pO1xuICAgIGlmICghY2FuY2VsZWQpXG4gICAgICBjb21taXQoKTtcbiAgfVxuICBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIHN0b3AoKTtcbiAgICBjbGVhcigpO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4ubWFudWFsSGlzdG9yeSxcbiAgICBpc1RyYWNraW5nLFxuICAgIHBhdXNlLFxuICAgIHJlc3VtZSxcbiAgICBjb21taXQsXG4gICAgYmF0Y2gsXG4gICAgZGlzcG9zZVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VEZWJvdW5jZWRSZWZIaXN0b3J5KHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGZpbHRlciA9IG9wdGlvbnMuZGVib3VuY2UgPyBkZWJvdW5jZUZpbHRlcihvcHRpb25zLmRlYm91bmNlKSA6IHZvaWQgMDtcbiAgY29uc3QgaGlzdG9yeSA9IHVzZVJlZkhpc3Rvcnkoc291cmNlLCB7IC4uLm9wdGlvbnMsIGV2ZW50RmlsdGVyOiBmaWx0ZXIgfSk7XG4gIHJldHVybiB7XG4gICAgLi4uaGlzdG9yeVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VEZXZpY2VNb3Rpb24ob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93LFxuICAgIGV2ZW50RmlsdGVyID0gYnlwYXNzRmlsdGVyXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBhY2NlbGVyYXRpb24gPSByZWYoeyB4OiBudWxsLCB5OiBudWxsLCB6OiBudWxsIH0pO1xuICBjb25zdCByb3RhdGlvblJhdGUgPSByZWYoeyBhbHBoYTogbnVsbCwgYmV0YTogbnVsbCwgZ2FtbWE6IG51bGwgfSk7XG4gIGNvbnN0IGludGVydmFsID0gcmVmKDApO1xuICBjb25zdCBhY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5ID0gcmVmKHtcbiAgICB4OiBudWxsLFxuICAgIHk6IG51bGwsXG4gICAgejogbnVsbFxuICB9KTtcbiAgaWYgKHdpbmRvdykge1xuICAgIGNvbnN0IG9uRGV2aWNlTW90aW9uID0gY3JlYXRlRmlsdGVyV3JhcHBlcihcbiAgICAgIGV2ZW50RmlsdGVyLFxuICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgIGFjY2VsZXJhdGlvbi52YWx1ZSA9IGV2ZW50LmFjY2VsZXJhdGlvbjtcbiAgICAgICAgYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eS52YWx1ZSA9IGV2ZW50LmFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHk7XG4gICAgICAgIHJvdGF0aW9uUmF0ZS52YWx1ZSA9IGV2ZW50LnJvdGF0aW9uUmF0ZTtcbiAgICAgICAgaW50ZXJ2YWwudmFsdWUgPSBldmVudC5pbnRlcnZhbDtcbiAgICAgIH1cbiAgICApO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcImRldmljZW1vdGlvblwiLCBvbkRldmljZU1vdGlvbik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhY2NlbGVyYXRpb24sXG4gICAgYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eSxcbiAgICByb3RhdGlvblJhdGUsXG4gICAgaW50ZXJ2YWxcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlRGV2aWNlT3JpZW50YXRpb24ob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgd2luZG93ID0gZGVmYXVsdFdpbmRvdyB9ID0gb3B0aW9ucztcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gd2luZG93ICYmIFwiRGV2aWNlT3JpZW50YXRpb25FdmVudFwiIGluIHdpbmRvdyk7XG4gIGNvbnN0IGlzQWJzb2x1dGUgPSByZWYoZmFsc2UpO1xuICBjb25zdCBhbHBoYSA9IHJlZihudWxsKTtcbiAgY29uc3QgYmV0YSA9IHJlZihudWxsKTtcbiAgY29uc3QgZ2FtbWEgPSByZWYobnVsbCk7XG4gIGlmICh3aW5kb3cgJiYgaXNTdXBwb3J0ZWQudmFsdWUpIHtcbiAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJkZXZpY2VvcmllbnRhdGlvblwiLCAoZXZlbnQpID0+IHtcbiAgICAgIGlzQWJzb2x1dGUudmFsdWUgPSBldmVudC5hYnNvbHV0ZTtcbiAgICAgIGFscGhhLnZhbHVlID0gZXZlbnQuYWxwaGE7XG4gICAgICBiZXRhLnZhbHVlID0gZXZlbnQuYmV0YTtcbiAgICAgIGdhbW1hLnZhbHVlID0gZXZlbnQuZ2FtbWE7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBpc0Fic29sdXRlLFxuICAgIGFscGhhLFxuICAgIGJldGEsXG4gICAgZ2FtbWFcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlRGV2aWNlUGl4ZWxSYXRpbyhvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3dcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHBpeGVsUmF0aW8gPSByZWYoMSk7XG4gIGlmICh3aW5kb3cpIHtcbiAgICBsZXQgb2JzZXJ2ZTIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHBpeGVsUmF0aW8udmFsdWUgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgIGNsZWFudXAyKCk7XG4gICAgICBtZWRpYSA9IHdpbmRvdy5tYXRjaE1lZGlhKGAocmVzb2x1dGlvbjogJHtwaXhlbFJhdGlvLnZhbHVlfWRwcHgpYCk7XG4gICAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIG9ic2VydmUyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfSwgY2xlYW51cDIgPSBmdW5jdGlvbigpIHtcbiAgICAgIG1lZGlhID09IG51bGwgPyB2b2lkIDAgOiBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIG9ic2VydmUyKTtcbiAgICB9O1xuICAgIGxldCBtZWRpYTtcbiAgICBvYnNlcnZlMigpO1xuICAgIHRyeU9uU2NvcGVEaXNwb3NlKGNsZWFudXAyKTtcbiAgfVxuICByZXR1cm4geyBwaXhlbFJhdGlvIH07XG59XG5cbmZ1bmN0aW9uIHVzZURldmljZXNMaXN0KG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgbmF2aWdhdG9yID0gZGVmYXVsdE5hdmlnYXRvcixcbiAgICByZXF1ZXN0UGVybWlzc2lvbnMgPSBmYWxzZSxcbiAgICBjb25zdHJhaW50cyA9IHsgYXVkaW86IHRydWUsIHZpZGVvOiB0cnVlIH0sXG4gICAgb25VcGRhdGVkXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBkZXZpY2VzID0gcmVmKFtdKTtcbiAgY29uc3QgdmlkZW9JbnB1dHMgPSBjb21wdXRlZCgoKSA9PiBkZXZpY2VzLnZhbHVlLmZpbHRlcigoaSkgPT4gaS5raW5kID09PSBcInZpZGVvaW5wdXRcIikpO1xuICBjb25zdCBhdWRpb0lucHV0cyA9IGNvbXB1dGVkKCgpID0+IGRldmljZXMudmFsdWUuZmlsdGVyKChpKSA9PiBpLmtpbmQgPT09IFwiYXVkaW9pbnB1dFwiKSk7XG4gIGNvbnN0IGF1ZGlvT3V0cHV0cyA9IGNvbXB1dGVkKCgpID0+IGRldmljZXMudmFsdWUuZmlsdGVyKChpKSA9PiBpLmtpbmQgPT09IFwiYXVkaW9vdXRwdXRcIikpO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMpO1xuICBjb25zdCBwZXJtaXNzaW9uR3JhbnRlZCA9IHJlZihmYWxzZSk7XG4gIGxldCBzdHJlYW07XG4gIGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICBpZiAoIWlzU3VwcG9ydGVkLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGRldmljZXMudmFsdWUgPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcbiAgICBvblVwZGF0ZWQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uVXBkYXRlZChkZXZpY2VzLnZhbHVlKTtcbiAgICBpZiAoc3RyZWFtKSB7XG4gICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCgodCkgPT4gdC5zdG9wKCkpO1xuICAgICAgc3RyZWFtID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZW5zdXJlUGVybWlzc2lvbnMoKSB7XG4gICAgaWYgKCFpc1N1cHBvcnRlZC52YWx1ZSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAocGVybWlzc2lvbkdyYW50ZWQudmFsdWUpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCB7IHN0YXRlLCBxdWVyeSB9ID0gdXNlUGVybWlzc2lvbihcImNhbWVyYVwiLCB7IGNvbnRyb2xzOiB0cnVlIH0pO1xuICAgIGF3YWl0IHF1ZXJ5KCk7XG4gICAgaWYgKHN0YXRlLnZhbHVlICE9PSBcImdyYW50ZWRcIikge1xuICAgICAgc3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgICAgdXBkYXRlKCk7XG4gICAgICBwZXJtaXNzaW9uR3JhbnRlZC52YWx1ZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlcm1pc3Npb25HcmFudGVkLnZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHBlcm1pc3Npb25HcmFudGVkLnZhbHVlO1xuICB9XG4gIGlmIChpc1N1cHBvcnRlZC52YWx1ZSkge1xuICAgIGlmIChyZXF1ZXN0UGVybWlzc2lvbnMpXG4gICAgICBlbnN1cmVQZXJtaXNzaW9ucygpO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIobmF2aWdhdG9yLm1lZGlhRGV2aWNlcywgXCJkZXZpY2VjaGFuZ2VcIiwgdXBkYXRlKTtcbiAgICB1cGRhdGUoKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRldmljZXMsXG4gICAgZW5zdXJlUGVybWlzc2lvbnMsXG4gICAgcGVybWlzc2lvbkdyYW50ZWQsXG4gICAgdmlkZW9JbnB1dHMsXG4gICAgYXVkaW9JbnB1dHMsXG4gICAgYXVkaW9PdXRwdXRzLFxuICAgIGlzU3VwcG9ydGVkXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZURpc3BsYXlNZWRpYShvcHRpb25zID0ge30pIHtcbiAgdmFyIF9hO1xuICBjb25zdCBlbmFibGVkID0gcmVmKChfYSA9IG9wdGlvbnMuZW5hYmxlZCkgIT0gbnVsbCA/IF9hIDogZmFsc2UpO1xuICBjb25zdCB2aWRlbyA9IG9wdGlvbnMudmlkZW87XG4gIGNvbnN0IGF1ZGlvID0gb3B0aW9ucy5hdWRpbztcbiAgY29uc3QgeyBuYXZpZ2F0b3IgPSBkZWZhdWx0TmF2aWdhdG9yIH0gPSBvcHRpb25zO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiB7XG4gICAgdmFyIF9hMjtcbiAgICByZXR1cm4gKF9hMiA9IG5hdmlnYXRvciA9PSBudWxsID8gdm9pZCAwIDogbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5nZXREaXNwbGF5TWVkaWE7XG4gIH0pO1xuICBjb25zdCBjb25zdHJhaW50ID0geyBhdWRpbywgdmlkZW8gfTtcbiAgY29uc3Qgc3RyZWFtID0gc2hhbGxvd1JlZigpO1xuICBhc3luYyBmdW5jdGlvbiBfc3RhcnQoKSB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAoIWlzU3VwcG9ydGVkLnZhbHVlIHx8IHN0cmVhbS52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBzdHJlYW0udmFsdWUgPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYShjb25zdHJhaW50KTtcbiAgICAoX2EyID0gc3RyZWFtLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldFRyYWNrcygpLmZvckVhY2goKHQpID0+IHQuYWRkRXZlbnRMaXN0ZW5lcihcImVuZGVkXCIsIHN0b3ApKTtcbiAgICByZXR1cm4gc3RyZWFtLnZhbHVlO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIF9zdG9wKCkge1xuICAgIHZhciBfYTI7XG4gICAgKF9hMiA9IHN0cmVhbS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5nZXRUcmFja3MoKS5mb3JFYWNoKCh0KSA9PiB0LnN0b3AoKSk7XG4gICAgc3RyZWFtLnZhbHVlID0gdm9pZCAwO1xuICB9XG4gIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgX3N0b3AoKTtcbiAgICBlbmFibGVkLnZhbHVlID0gZmFsc2U7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgYXdhaXQgX3N0YXJ0KCk7XG4gICAgaWYgKHN0cmVhbS52YWx1ZSlcbiAgICAgIGVuYWJsZWQudmFsdWUgPSB0cnVlO1xuICAgIHJldHVybiBzdHJlYW0udmFsdWU7XG4gIH1cbiAgd2F0Y2goXG4gICAgZW5hYmxlZCxcbiAgICAodikgPT4ge1xuICAgICAgaWYgKHYpXG4gICAgICAgIF9zdGFydCgpO1xuICAgICAgZWxzZVxuICAgICAgICBfc3RvcCgpO1xuICAgIH0sXG4gICAgeyBpbW1lZGlhdGU6IHRydWUgfVxuICApO1xuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIHN0cmVhbSxcbiAgICBzdGFydCxcbiAgICBzdG9wLFxuICAgIGVuYWJsZWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlRG9jdW1lbnRWaXNpYmlsaXR5KG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IGRvY3VtZW50ID0gZGVmYXVsdERvY3VtZW50IH0gPSBvcHRpb25zO1xuICBpZiAoIWRvY3VtZW50KVxuICAgIHJldHVybiByZWYoXCJ2aXNpYmxlXCIpO1xuICBjb25zdCB2aXNpYmlsaXR5ID0gcmVmKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSk7XG4gIHVzZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsIFwidmlzaWJpbGl0eWNoYW5nZVwiLCAoKSA9PiB7XG4gICAgdmlzaWJpbGl0eS52YWx1ZSA9IGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZTtcbiAgfSk7XG4gIHJldHVybiB2aXNpYmlsaXR5O1xufVxuXG5mdW5jdGlvbiB1c2VEcmFnZ2FibGUodGFyZ2V0LCBvcHRpb25zID0ge30pIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3Qge1xuICAgIHBvaW50ZXJUeXBlcyxcbiAgICBwcmV2ZW50RGVmYXVsdCxcbiAgICBzdG9wUHJvcGFnYXRpb24sXG4gICAgZXhhY3QsXG4gICAgb25Nb3ZlLFxuICAgIG9uRW5kLFxuICAgIG9uU3RhcnQsXG4gICAgaW5pdGlhbFZhbHVlLFxuICAgIGF4aXMgPSBcImJvdGhcIixcbiAgICBkcmFnZ2luZ0VsZW1lbnQgPSBkZWZhdWx0V2luZG93LFxuICAgIGNvbnRhaW5lckVsZW1lbnQsXG4gICAgaGFuZGxlOiBkcmFnZ2luZ0hhbmRsZSA9IHRhcmdldFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcG9zaXRpb24gPSByZWYoXG4gICAgKF9hID0gdG9WYWx1ZShpbml0aWFsVmFsdWUpKSAhPSBudWxsID8gX2EgOiB7IHg6IDAsIHk6IDAgfVxuICApO1xuICBjb25zdCBwcmVzc2VkRGVsdGEgPSByZWYoKTtcbiAgY29uc3QgZmlsdGVyRXZlbnQgPSAoZSkgPT4ge1xuICAgIGlmIChwb2ludGVyVHlwZXMpXG4gICAgICByZXR1cm4gcG9pbnRlclR5cGVzLmluY2x1ZGVzKGUucG9pbnRlclR5cGUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICBjb25zdCBoYW5kbGVFdmVudCA9IChlKSA9PiB7XG4gICAgaWYgKHRvVmFsdWUocHJldmVudERlZmF1bHQpKVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICh0b1ZhbHVlKHN0b3BQcm9wYWdhdGlvbikpXG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9O1xuICBjb25zdCBzdGFydCA9IChlKSA9PiB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAoZS5idXR0b24gIT09IDApXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRvVmFsdWUob3B0aW9ucy5kaXNhYmxlZCkgfHwgIWZpbHRlckV2ZW50KGUpKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh0b1ZhbHVlKGV4YWN0KSAmJiBlLnRhcmdldCAhPT0gdG9WYWx1ZSh0YXJnZXQpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRvVmFsdWUoY29udGFpbmVyRWxlbWVudCk7XG4gICAgY29uc3QgY29udGFpbmVyUmVjdCA9IChfYTIgPSBjb250YWluZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2FsbChjb250YWluZXIpO1xuICAgIGNvbnN0IHRhcmdldFJlY3QgPSB0b1ZhbHVlKHRhcmdldCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgcG9zID0ge1xuICAgICAgeDogZS5jbGllbnRYIC0gKGNvbnRhaW5lciA/IHRhcmdldFJlY3QubGVmdCAtIGNvbnRhaW5lclJlY3QubGVmdCArIGNvbnRhaW5lci5zY3JvbGxMZWZ0IDogdGFyZ2V0UmVjdC5sZWZ0KSxcbiAgICAgIHk6IGUuY2xpZW50WSAtIChjb250YWluZXIgPyB0YXJnZXRSZWN0LnRvcCAtIGNvbnRhaW5lclJlY3QudG9wICsgY29udGFpbmVyLnNjcm9sbFRvcCA6IHRhcmdldFJlY3QudG9wKVxuICAgIH07XG4gICAgaWYgKChvblN0YXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvblN0YXJ0KHBvcywgZSkpID09PSBmYWxzZSlcbiAgICAgIHJldHVybjtcbiAgICBwcmVzc2VkRGVsdGEudmFsdWUgPSBwb3M7XG4gICAgaGFuZGxlRXZlbnQoZSk7XG4gIH07XG4gIGNvbnN0IG1vdmUgPSAoZSkgPT4ge1xuICAgIGlmICh0b1ZhbHVlKG9wdGlvbnMuZGlzYWJsZWQpIHx8ICFmaWx0ZXJFdmVudChlKSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoIXByZXNzZWREZWx0YS52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBjb250YWluZXIgPSB0b1ZhbHVlKGNvbnRhaW5lckVsZW1lbnQpO1xuICAgIGNvbnN0IHRhcmdldFJlY3QgPSB0b1ZhbHVlKHRhcmdldCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHsgeCwgeSB9ID0gcG9zaXRpb24udmFsdWU7XG4gICAgaWYgKGF4aXMgPT09IFwieFwiIHx8IGF4aXMgPT09IFwiYm90aFwiKSB7XG4gICAgICB4ID0gZS5jbGllbnRYIC0gcHJlc3NlZERlbHRhLnZhbHVlLng7XG4gICAgICBpZiAoY29udGFpbmVyKVxuICAgICAgICB4ID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgeCksIGNvbnRhaW5lci5zY3JvbGxXaWR0aCAtIHRhcmdldFJlY3Qud2lkdGgpO1xuICAgIH1cbiAgICBpZiAoYXhpcyA9PT0gXCJ5XCIgfHwgYXhpcyA9PT0gXCJib3RoXCIpIHtcbiAgICAgIHkgPSBlLmNsaWVudFkgLSBwcmVzc2VkRGVsdGEudmFsdWUueTtcbiAgICAgIGlmIChjb250YWluZXIpXG4gICAgICAgIHkgPSBNYXRoLm1pbihNYXRoLm1heCgwLCB5KSwgY29udGFpbmVyLnNjcm9sbEhlaWdodCAtIHRhcmdldFJlY3QuaGVpZ2h0KTtcbiAgICB9XG4gICAgcG9zaXRpb24udmFsdWUgPSB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH07XG4gICAgb25Nb3ZlID09IG51bGwgPyB2b2lkIDAgOiBvbk1vdmUocG9zaXRpb24udmFsdWUsIGUpO1xuICAgIGhhbmRsZUV2ZW50KGUpO1xuICB9O1xuICBjb25zdCBlbmQgPSAoZSkgPT4ge1xuICAgIGlmICh0b1ZhbHVlKG9wdGlvbnMuZGlzYWJsZWQpIHx8ICFmaWx0ZXJFdmVudChlKSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoIXByZXNzZWREZWx0YS52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBwcmVzc2VkRGVsdGEudmFsdWUgPSB2b2lkIDA7XG4gICAgb25FbmQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRW5kKHBvc2l0aW9uLnZhbHVlLCBlKTtcbiAgICBoYW5kbGVFdmVudChlKTtcbiAgfTtcbiAgaWYgKGlzQ2xpZW50KSB7XG4gICAgY29uc3QgY29uZmlnID0geyBjYXB0dXJlOiAoX2IgPSBvcHRpb25zLmNhcHR1cmUpICE9IG51bGwgPyBfYiA6IHRydWUgfTtcbiAgICB1c2VFdmVudExpc3RlbmVyKGRyYWdnaW5nSGFuZGxlLCBcInBvaW50ZXJkb3duXCIsIHN0YXJ0LCBjb25maWcpO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoZHJhZ2dpbmdFbGVtZW50LCBcInBvaW50ZXJtb3ZlXCIsIG1vdmUsIGNvbmZpZyk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcihkcmFnZ2luZ0VsZW1lbnQsIFwicG9pbnRlcnVwXCIsIGVuZCwgY29uZmlnKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnRvUmVmcyhwb3NpdGlvbiksXG4gICAgcG9zaXRpb24sXG4gICAgaXNEcmFnZ2luZzogY29tcHV0ZWQoKCkgPT4gISFwcmVzc2VkRGVsdGEudmFsdWUpLFxuICAgIHN0eWxlOiBjb21wdXRlZChcbiAgICAgICgpID0+IGBsZWZ0OiR7cG9zaXRpb24udmFsdWUueH1weDt0b3A6JHtwb3NpdGlvbi52YWx1ZS55fXB4O2BcbiAgICApXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZURyb3Bab25lKHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGlzT3ZlckRyb3Bab25lID0gcmVmKGZhbHNlKTtcbiAgY29uc3QgZmlsZXMgPSBzaGFsbG93UmVmKG51bGwpO1xuICBsZXQgY291bnRlciA9IDA7XG4gIGxldCBpc0RhdGFUeXBlSW5jbHVkZWQgPSB0cnVlO1xuICBpZiAoaXNDbGllbnQpIHtcbiAgICBjb25zdCBfb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIgPyB7IG9uRHJvcDogb3B0aW9ucyB9IDogb3B0aW9ucztcbiAgICBjb25zdCBnZXRGaWxlcyA9IChldmVudCkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IGxpc3QgPSBBcnJheS5mcm9tKChfYiA9IChfYSA9IGV2ZW50LmRhdGFUcmFuc2ZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmZpbGVzKSAhPSBudWxsID8gX2IgOiBbXSk7XG4gICAgICByZXR1cm4gZmlsZXMudmFsdWUgPSBsaXN0Lmxlbmd0aCA9PT0gMCA/IG51bGwgOiBsaXN0O1xuICAgIH07XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFwiZHJhZ2VudGVyXCIsIChldmVudCkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IHR5cGVzID0gQXJyYXkuZnJvbSgoKF9hID0gZXZlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGV2ZW50LmRhdGFUcmFuc2ZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLml0ZW1zKSB8fCBbXSkubWFwKChpKSA9PiBpLmtpbmQgPT09IFwiZmlsZVwiID8gaS50eXBlIDogbnVsbCkuZmlsdGVyKG5vdE51bGxpc2gpO1xuICAgICAgaWYgKF9vcHRpb25zLmRhdGFUeXBlcyAmJiBldmVudC5kYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgY29uc3QgZGF0YVR5cGVzID0gdW5yZWYoX29wdGlvbnMuZGF0YVR5cGVzKTtcbiAgICAgICAgaXNEYXRhVHlwZUluY2x1ZGVkID0gdHlwZW9mIGRhdGFUeXBlcyA9PT0gXCJmdW5jdGlvblwiID8gZGF0YVR5cGVzKHR5cGVzKSA6IGRhdGFUeXBlcyA/IGRhdGFUeXBlcy5zb21lKChpdGVtKSA9PiB0eXBlcy5pbmNsdWRlcyhpdGVtKSkgOiB0cnVlO1xuICAgICAgICBpZiAoIWlzRGF0YVR5cGVJbmNsdWRlZClcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY291bnRlciArPSAxO1xuICAgICAgaXNPdmVyRHJvcFpvbmUudmFsdWUgPSB0cnVlO1xuICAgICAgKF9iID0gX29wdGlvbnMub25FbnRlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX29wdGlvbnMsIGdldEZpbGVzKGV2ZW50KSwgZXZlbnQpO1xuICAgIH0pO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcImRyYWdvdmVyXCIsIChldmVudCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKCFpc0RhdGFUeXBlSW5jbHVkZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAoX2EgPSBfb3B0aW9ucy5vbk92ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKF9vcHRpb25zLCBnZXRGaWxlcyhldmVudCksIGV2ZW50KTtcbiAgICB9KTtcbiAgICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJkcmFnbGVhdmVcIiwgKGV2ZW50KSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoIWlzRGF0YVR5cGVJbmNsdWRlZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvdW50ZXIgLT0gMTtcbiAgICAgIGlmIChjb3VudGVyID09PSAwKVxuICAgICAgICBpc092ZXJEcm9wWm9uZS52YWx1ZSA9IGZhbHNlO1xuICAgICAgKF9hID0gX29wdGlvbnMub25MZWF2ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoX29wdGlvbnMsIGdldEZpbGVzKGV2ZW50KSwgZXZlbnQpO1xuICAgIH0pO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcImRyb3BcIiwgKGV2ZW50KSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY291bnRlciA9IDA7XG4gICAgICBpc092ZXJEcm9wWm9uZS52YWx1ZSA9IGZhbHNlO1xuICAgICAgKF9hID0gX29wdGlvbnMub25Ecm9wKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChfb3B0aW9ucywgZ2V0RmlsZXMoZXZlbnQpLCBldmVudCk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmaWxlcyxcbiAgICBpc092ZXJEcm9wWm9uZVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VSZXNpemVPYnNlcnZlcih0YXJnZXQsIGNhbGxiYWNrLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB3aW5kb3cgPSBkZWZhdWx0V2luZG93LCAuLi5vYnNlcnZlck9wdGlvbnMgfSA9IG9wdGlvbnM7XG4gIGxldCBvYnNlcnZlcjtcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gd2luZG93ICYmIFwiUmVzaXplT2JzZXJ2ZXJcIiBpbiB3aW5kb3cpO1xuICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgb2JzZXJ2ZXIgPSB2b2lkIDA7XG4gICAgfVxuICB9O1xuICBjb25zdCB0YXJnZXRzID0gY29tcHV0ZWQoKCkgPT4gQXJyYXkuaXNBcnJheSh0YXJnZXQpID8gdGFyZ2V0Lm1hcCgoZWwpID0+IHVucmVmRWxlbWVudChlbCkpIDogW3VucmVmRWxlbWVudCh0YXJnZXQpXSk7XG4gIGNvbnN0IHN0b3BXYXRjaCA9IHdhdGNoKFxuICAgIHRhcmdldHMsXG4gICAgKGVscykgPT4ge1xuICAgICAgY2xlYW51cCgpO1xuICAgICAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlICYmIHdpbmRvdykge1xuICAgICAgICBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihjYWxsYmFjayk7XG4gICAgICAgIGZvciAoY29uc3QgX2VsIG9mIGVscylcbiAgICAgICAgICBfZWwgJiYgb2JzZXJ2ZXIub2JzZXJ2ZShfZWwsIG9ic2VydmVyT3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7IGltbWVkaWF0ZTogdHJ1ZSwgZmx1c2g6IFwicG9zdFwiIH1cbiAgKTtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IHtcbiAgICBjbGVhbnVwKCk7XG4gICAgc3RvcFdhdGNoKCk7XG4gIH07XG4gIHRyeU9uU2NvcGVEaXNwb3NlKHN0b3ApO1xuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIHN0b3BcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlRWxlbWVudEJvdW5kaW5nKHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICByZXNldCA9IHRydWUsXG4gICAgd2luZG93UmVzaXplID0gdHJ1ZSxcbiAgICB3aW5kb3dTY3JvbGwgPSB0cnVlLFxuICAgIGltbWVkaWF0ZSA9IHRydWVcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGhlaWdodCA9IHJlZigwKTtcbiAgY29uc3QgYm90dG9tID0gcmVmKDApO1xuICBjb25zdCBsZWZ0ID0gcmVmKDApO1xuICBjb25zdCByaWdodCA9IHJlZigwKTtcbiAgY29uc3QgdG9wID0gcmVmKDApO1xuICBjb25zdCB3aWR0aCA9IHJlZigwKTtcbiAgY29uc3QgeCA9IHJlZigwKTtcbiAgY29uc3QgeSA9IHJlZigwKTtcbiAgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIGNvbnN0IGVsID0gdW5yZWZFbGVtZW50KHRhcmdldCk7XG4gICAgaWYgKCFlbCkge1xuICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgIGhlaWdodC52YWx1ZSA9IDA7XG4gICAgICAgIGJvdHRvbS52YWx1ZSA9IDA7XG4gICAgICAgIGxlZnQudmFsdWUgPSAwO1xuICAgICAgICByaWdodC52YWx1ZSA9IDA7XG4gICAgICAgIHRvcC52YWx1ZSA9IDA7XG4gICAgICAgIHdpZHRoLnZhbHVlID0gMDtcbiAgICAgICAgeC52YWx1ZSA9IDA7XG4gICAgICAgIHkudmFsdWUgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaGVpZ2h0LnZhbHVlID0gcmVjdC5oZWlnaHQ7XG4gICAgYm90dG9tLnZhbHVlID0gcmVjdC5ib3R0b207XG4gICAgbGVmdC52YWx1ZSA9IHJlY3QubGVmdDtcbiAgICByaWdodC52YWx1ZSA9IHJlY3QucmlnaHQ7XG4gICAgdG9wLnZhbHVlID0gcmVjdC50b3A7XG4gICAgd2lkdGgudmFsdWUgPSByZWN0LndpZHRoO1xuICAgIHgudmFsdWUgPSByZWN0Lng7XG4gICAgeS52YWx1ZSA9IHJlY3QueTtcbiAgfVxuICB1c2VSZXNpemVPYnNlcnZlcih0YXJnZXQsIHVwZGF0ZSk7XG4gIHdhdGNoKCgpID0+IHVucmVmRWxlbWVudCh0YXJnZXQpLCAoZWxlKSA9PiAhZWxlICYmIHVwZGF0ZSgpKTtcbiAgdXNlTXV0YXRpb25PYnNlcnZlcih0YXJnZXQsIHVwZGF0ZSwge1xuICAgIGF0dHJpYnV0ZUZpbHRlcjogW1wic3R5bGVcIiwgXCJjbGFzc1wiXVxuICB9KTtcbiAgaWYgKHdpbmRvd1Njcm9sbClcbiAgICB1c2VFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHVwZGF0ZSwgeyBjYXB0dXJlOiB0cnVlLCBwYXNzaXZlOiB0cnVlIH0pO1xuICBpZiAod2luZG93UmVzaXplKVxuICAgIHVzZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdXBkYXRlLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gIHRyeU9uTW91bnRlZCgoKSA9PiB7XG4gICAgaWYgKGltbWVkaWF0ZSlcbiAgICAgIHVwZGF0ZSgpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQsXG4gICAgYm90dG9tLFxuICAgIGxlZnQsXG4gICAgcmlnaHQsXG4gICAgdG9wLFxuICAgIHdpZHRoLFxuICAgIHgsXG4gICAgeSxcbiAgICB1cGRhdGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlRWxlbWVudEJ5UG9pbnQob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgeCxcbiAgICB5LFxuICAgIGRvY3VtZW50ID0gZGVmYXVsdERvY3VtZW50LFxuICAgIG11bHRpcGxlLFxuICAgIGludGVydmFsID0gXCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIixcbiAgICBpbW1lZGlhdGUgPSB0cnVlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiB7XG4gICAgaWYgKHRvVmFsdWUobXVsdGlwbGUpKVxuICAgICAgcmV0dXJuIGRvY3VtZW50ICYmIFwiZWxlbWVudHNGcm9tUG9pbnRcIiBpbiBkb2N1bWVudDtcbiAgICByZXR1cm4gZG9jdW1lbnQgJiYgXCJlbGVtZW50RnJvbVBvaW50XCIgaW4gZG9jdW1lbnQ7XG4gIH0pO1xuICBjb25zdCBlbGVtZW50ID0gcmVmKG51bGwpO1xuICBjb25zdCBjYiA9ICgpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGVsZW1lbnQudmFsdWUgPSB0b1ZhbHVlKG11bHRpcGxlKSA/IChfYSA9IGRvY3VtZW50ID09IG51bGwgPyB2b2lkIDAgOiBkb2N1bWVudC5lbGVtZW50c0Zyb21Qb2ludCh0b1ZhbHVlKHgpLCB0b1ZhbHVlKHkpKSkgIT0gbnVsbCA/IF9hIDogW10gOiAoX2IgPSBkb2N1bWVudCA9PSBudWxsID8gdm9pZCAwIDogZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b1ZhbHVlKHgpLCB0b1ZhbHVlKHkpKSkgIT0gbnVsbCA/IF9iIDogbnVsbDtcbiAgfTtcbiAgY29uc3QgY29udHJvbHMgPSBpbnRlcnZhbCA9PT0gXCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIiA/IHVzZVJhZkZuKGNiLCB7IGltbWVkaWF0ZSB9KSA6IHVzZUludGVydmFsRm4oY2IsIGludGVydmFsLCB7IGltbWVkaWF0ZSB9KTtcbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBlbGVtZW50LFxuICAgIC4uLmNvbnRyb2xzXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZUVsZW1lbnRIb3ZlcihlbCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBkZWxheUVudGVyID0gMCxcbiAgICBkZWxheUxlYXZlID0gMCxcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpc0hvdmVyZWQgPSByZWYoZmFsc2UpO1xuICBsZXQgdGltZXI7XG4gIGNvbnN0IHRvZ2dsZSA9IChlbnRlcmluZykgPT4ge1xuICAgIGNvbnN0IGRlbGF5ID0gZW50ZXJpbmcgPyBkZWxheUVudGVyIDogZGVsYXlMZWF2ZTtcbiAgICBpZiAodGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0aW1lciA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKGRlbGF5KVxuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IGlzSG92ZXJlZC52YWx1ZSA9IGVudGVyaW5nLCBkZWxheSk7XG4gICAgZWxzZVxuICAgICAgaXNIb3ZlcmVkLnZhbHVlID0gZW50ZXJpbmc7XG4gIH07XG4gIGlmICghd2luZG93KVxuICAgIHJldHVybiBpc0hvdmVyZWQ7XG4gIHVzZUV2ZW50TGlzdGVuZXIoZWwsIFwibW91c2VlbnRlclwiLCAoKSA9PiB0b2dnbGUodHJ1ZSksIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgdXNlRXZlbnRMaXN0ZW5lcihlbCwgXCJtb3VzZWxlYXZlXCIsICgpID0+IHRvZ2dsZShmYWxzZSksIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgcmV0dXJuIGlzSG92ZXJlZDtcbn1cblxuZnVuY3Rpb24gdXNlRWxlbWVudFNpemUodGFyZ2V0LCBpbml0aWFsU2l6ZSA9IHsgd2lkdGg6IDAsIGhlaWdodDogMCB9LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB3aW5kb3cgPSBkZWZhdWx0V2luZG93LCBib3ggPSBcImNvbnRlbnQtYm94XCIgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlzU1ZHID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHVucmVmRWxlbWVudCh0YXJnZXQpKSA9PSBudWxsID8gdm9pZCAwIDogX2EubmFtZXNwYWNlVVJJKSA9PSBudWxsID8gdm9pZCAwIDogX2IuaW5jbHVkZXMoXCJzdmdcIik7XG4gIH0pO1xuICBjb25zdCB3aWR0aCA9IHJlZihpbml0aWFsU2l6ZS53aWR0aCk7XG4gIGNvbnN0IGhlaWdodCA9IHJlZihpbml0aWFsU2l6ZS5oZWlnaHQpO1xuICBjb25zdCB7IHN0b3A6IHN0b3AxIH0gPSB1c2VSZXNpemVPYnNlcnZlcihcbiAgICB0YXJnZXQsXG4gICAgKFtlbnRyeV0pID0+IHtcbiAgICAgIGNvbnN0IGJveFNpemUgPSBib3ggPT09IFwiYm9yZGVyLWJveFwiID8gZW50cnkuYm9yZGVyQm94U2l6ZSA6IGJveCA9PT0gXCJjb250ZW50LWJveFwiID8gZW50cnkuY29udGVudEJveFNpemUgOiBlbnRyeS5kZXZpY2VQaXhlbENvbnRlbnRCb3hTaXplO1xuICAgICAgaWYgKHdpbmRvdyAmJiBpc1NWRy52YWx1ZSkge1xuICAgICAgICBjb25zdCAkZWxlbSA9IHVucmVmRWxlbWVudCh0YXJnZXQpO1xuICAgICAgICBpZiAoJGVsZW0pIHtcbiAgICAgICAgICBjb25zdCByZWN0ID0gJGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgd2lkdGgudmFsdWUgPSByZWN0LndpZHRoO1xuICAgICAgICAgIGhlaWdodC52YWx1ZSA9IHJlY3QuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYm94U2l6ZSkge1xuICAgICAgICAgIGNvbnN0IGZvcm1hdEJveFNpemUgPSBBcnJheS5pc0FycmF5KGJveFNpemUpID8gYm94U2l6ZSA6IFtib3hTaXplXTtcbiAgICAgICAgICB3aWR0aC52YWx1ZSA9IGZvcm1hdEJveFNpemUucmVkdWNlKChhY2MsIHsgaW5saW5lU2l6ZSB9KSA9PiBhY2MgKyBpbmxpbmVTaXplLCAwKTtcbiAgICAgICAgICBoZWlnaHQudmFsdWUgPSBmb3JtYXRCb3hTaXplLnJlZHVjZSgoYWNjLCB7IGJsb2NrU2l6ZSB9KSA9PiBhY2MgKyBibG9ja1NpemUsIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpZHRoLnZhbHVlID0gZW50cnkuY29udGVudFJlY3Qud2lkdGg7XG4gICAgICAgICAgaGVpZ2h0LnZhbHVlID0gZW50cnkuY29udGVudFJlY3QuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBvcHRpb25zXG4gICk7XG4gIHRyeU9uTW91bnRlZCgoKSA9PiB7XG4gICAgY29uc3QgZWxlID0gdW5yZWZFbGVtZW50KHRhcmdldCk7XG4gICAgaWYgKGVsZSkge1xuICAgICAgd2lkdGgudmFsdWUgPSBcIm9mZnNldFdpZHRoXCIgaW4gZWxlID8gZWxlLm9mZnNldFdpZHRoIDogaW5pdGlhbFNpemUud2lkdGg7XG4gICAgICBoZWlnaHQudmFsdWUgPSBcIm9mZnNldEhlaWdodFwiIGluIGVsZSA/IGVsZS5vZmZzZXRIZWlnaHQgOiBpbml0aWFsU2l6ZS5oZWlnaHQ7XG4gICAgfVxuICB9KTtcbiAgY29uc3Qgc3RvcDIgPSB3YXRjaChcbiAgICAoKSA9PiB1bnJlZkVsZW1lbnQodGFyZ2V0KSxcbiAgICAoZWxlKSA9PiB7XG4gICAgICB3aWR0aC52YWx1ZSA9IGVsZSA/IGluaXRpYWxTaXplLndpZHRoIDogMDtcbiAgICAgIGhlaWdodC52YWx1ZSA9IGVsZSA/IGluaXRpYWxTaXplLmhlaWdodCA6IDA7XG4gICAgfVxuICApO1xuICBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHN0b3AxKCk7XG4gICAgc3RvcDIoKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBzdG9wXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZUludGVyc2VjdGlvbk9ic2VydmVyKHRhcmdldCwgY2FsbGJhY2ssIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgcm9vdCxcbiAgICByb290TWFyZ2luID0gXCIwcHhcIixcbiAgICB0aHJlc2hvbGQgPSAwLjEsXG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvdyxcbiAgICBpbW1lZGlhdGUgPSB0cnVlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiB3aW5kb3cgJiYgXCJJbnRlcnNlY3Rpb25PYnNlcnZlclwiIGluIHdpbmRvdyk7XG4gIGNvbnN0IHRhcmdldHMgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgY29uc3QgX3RhcmdldCA9IHRvVmFsdWUodGFyZ2V0KTtcbiAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkoX3RhcmdldCkgPyBfdGFyZ2V0IDogW190YXJnZXRdKS5tYXAodW5yZWZFbGVtZW50KS5maWx0ZXIobm90TnVsbGlzaCk7XG4gIH0pO1xuICBsZXQgY2xlYW51cCA9IG5vb3A7XG4gIGNvbnN0IGlzQWN0aXZlID0gcmVmKGltbWVkaWF0ZSk7XG4gIGNvbnN0IHN0b3BXYXRjaCA9IGlzU3VwcG9ydGVkLnZhbHVlID8gd2F0Y2goXG4gICAgKCkgPT4gW3RhcmdldHMudmFsdWUsIHVucmVmRWxlbWVudChyb290KSwgaXNBY3RpdmUudmFsdWVdLFxuICAgIChbdGFyZ2V0czIsIHJvb3QyXSkgPT4ge1xuICAgICAgY2xlYW51cCgpO1xuICAgICAgaWYgKCFpc0FjdGl2ZS52YWx1ZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKCF0YXJnZXRzMi5sZW5ndGgpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKFxuICAgICAgICBjYWxsYmFjayxcbiAgICAgICAge1xuICAgICAgICAgIHJvb3Q6IHVucmVmRWxlbWVudChyb290MiksXG4gICAgICAgICAgcm9vdE1hcmdpbixcbiAgICAgICAgICB0aHJlc2hvbGRcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHRhcmdldHMyLmZvckVhY2goKGVsKSA9PiBlbCAmJiBvYnNlcnZlci5vYnNlcnZlKGVsKSk7XG4gICAgICBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIGNsZWFudXAgPSBub29wO1xuICAgICAgfTtcbiAgICB9LFxuICAgIHsgaW1tZWRpYXRlLCBmbHVzaDogXCJwb3N0XCIgfVxuICApIDogbm9vcDtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IHtcbiAgICBjbGVhbnVwKCk7XG4gICAgc3RvcFdhdGNoKCk7XG4gICAgaXNBY3RpdmUudmFsdWUgPSBmYWxzZTtcbiAgfTtcbiAgdHJ5T25TY29wZURpc3Bvc2Uoc3RvcCk7XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgaXNBY3RpdmUsXG4gICAgcGF1c2UoKSB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgICBpc0FjdGl2ZS52YWx1ZSA9IGZhbHNlO1xuICAgIH0sXG4gICAgcmVzdW1lKCkge1xuICAgICAgaXNBY3RpdmUudmFsdWUgPSB0cnVlO1xuICAgIH0sXG4gICAgc3RvcFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VFbGVtZW50VmlzaWJpbGl0eShlbGVtZW50LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB3aW5kb3cgPSBkZWZhdWx0V2luZG93LCBzY3JvbGxUYXJnZXQsIHRocmVzaG9sZCA9IDAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGVsZW1lbnRJc1Zpc2libGUgPSByZWYoZmFsc2UpO1xuICB1c2VJbnRlcnNlY3Rpb25PYnNlcnZlcihcbiAgICBlbGVtZW50LFxuICAgIChpbnRlcnNlY3Rpb25PYnNlcnZlckVudHJpZXMpID0+IHtcbiAgICAgIGxldCBpc0ludGVyc2VjdGluZyA9IGVsZW1lbnRJc1Zpc2libGUudmFsdWU7XG4gICAgICBsZXQgbGF0ZXN0VGltZSA9IDA7XG4gICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGludGVyc2VjdGlvbk9ic2VydmVyRW50cmllcykge1xuICAgICAgICBpZiAoZW50cnkudGltZSA+PSBsYXRlc3RUaW1lKSB7XG4gICAgICAgICAgbGF0ZXN0VGltZSA9IGVudHJ5LnRpbWU7XG4gICAgICAgICAgaXNJbnRlcnNlY3RpbmcgPSBlbnRyeS5pc0ludGVyc2VjdGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxlbWVudElzVmlzaWJsZS52YWx1ZSA9IGlzSW50ZXJzZWN0aW5nO1xuICAgIH0sXG4gICAge1xuICAgICAgcm9vdDogc2Nyb2xsVGFyZ2V0LFxuICAgICAgd2luZG93LFxuICAgICAgdGhyZXNob2xkXG4gICAgfVxuICApO1xuICByZXR1cm4gZWxlbWVudElzVmlzaWJsZTtcbn1cblxuY29uc3QgZXZlbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcblxuZnVuY3Rpb24gdXNlRXZlbnRCdXMoa2V5KSB7XG4gIGNvbnN0IHNjb3BlID0gZ2V0Q3VycmVudFNjb3BlKCk7XG4gIGZ1bmN0aW9uIG9uKGxpc3RlbmVyKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IGV2ZW50cy5nZXQoa2V5KSB8fCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgIGV2ZW50cy5zZXQoa2V5LCBsaXN0ZW5lcnMpO1xuICAgIGNvbnN0IF9vZmYgPSAoKSA9PiBvZmYobGlzdGVuZXIpO1xuICAgIChfYSA9IHNjb3BlID09IG51bGwgPyB2b2lkIDAgOiBzY29wZS5jbGVhbnVwcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnB1c2goX29mZik7XG4gICAgcmV0dXJuIF9vZmY7XG4gIH1cbiAgZnVuY3Rpb24gb25jZShsaXN0ZW5lcikge1xuICAgIGZ1bmN0aW9uIF9saXN0ZW5lciguLi5hcmdzKSB7XG4gICAgICBvZmYoX2xpc3RlbmVyKTtcbiAgICAgIGxpc3RlbmVyKC4uLmFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gb24oX2xpc3RlbmVyKTtcbiAgfVxuICBmdW5jdGlvbiBvZmYobGlzdGVuZXIpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBldmVudHMuZ2V0KGtleSk7XG4gICAgaWYgKCFsaXN0ZW5lcnMpXG4gICAgICByZXR1cm47XG4gICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgaWYgKCFsaXN0ZW5lcnMuc2l6ZSlcbiAgICAgIHJlc2V0KCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgZXZlbnRzLmRlbGV0ZShrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIGVtaXQoZXZlbnQsIHBheWxvYWQpIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gZXZlbnRzLmdldChrZXkpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZm9yRWFjaCgodikgPT4gdihldmVudCwgcGF5bG9hZCkpO1xuICB9XG4gIHJldHVybiB7IG9uLCBvbmNlLCBvZmYsIGVtaXQsIHJlc2V0IH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVOZXN0ZWRPcHRpb25zJDEob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSlcbiAgICByZXR1cm4ge307XG4gIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gdXNlRXZlbnRTb3VyY2UodXJsLCBldmVudHMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGV2ZW50ID0gcmVmKG51bGwpO1xuICBjb25zdCBkYXRhID0gcmVmKG51bGwpO1xuICBjb25zdCBzdGF0dXMgPSByZWYoXCJDT05ORUNUSU5HXCIpO1xuICBjb25zdCBldmVudFNvdXJjZSA9IHJlZihudWxsKTtcbiAgY29uc3QgZXJyb3IgPSBzaGFsbG93UmVmKG51bGwpO1xuICBjb25zdCB1cmxSZWYgPSB0b1JlZih1cmwpO1xuICBjb25zdCBsYXN0RXZlbnRJZCA9IHNoYWxsb3dSZWYobnVsbCk7XG4gIGxldCBleHBsaWNpdGx5Q2xvc2VkID0gZmFsc2U7XG4gIGxldCByZXRyaWVkID0gMDtcbiAgY29uc3Qge1xuICAgIHdpdGhDcmVkZW50aWFscyA9IGZhbHNlLFxuICAgIGltbWVkaWF0ZSA9IHRydWVcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGNsb3NlID0gKCkgPT4ge1xuICAgIGlmIChpc0NsaWVudCAmJiBldmVudFNvdXJjZS52YWx1ZSkge1xuICAgICAgZXZlbnRTb3VyY2UudmFsdWUuY2xvc2UoKTtcbiAgICAgIGV2ZW50U291cmNlLnZhbHVlID0gbnVsbDtcbiAgICAgIHN0YXR1cy52YWx1ZSA9IFwiQ0xPU0VEXCI7XG4gICAgICBleHBsaWNpdGx5Q2xvc2VkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IF9pbml0ID0gKCkgPT4ge1xuICAgIGlmIChleHBsaWNpdGx5Q2xvc2VkIHx8IHR5cGVvZiB1cmxSZWYudmFsdWUgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZXMgPSBuZXcgRXZlbnRTb3VyY2UodXJsUmVmLnZhbHVlLCB7IHdpdGhDcmVkZW50aWFscyB9KTtcbiAgICBzdGF0dXMudmFsdWUgPSBcIkNPTk5FQ1RJTkdcIjtcbiAgICBldmVudFNvdXJjZS52YWx1ZSA9IGVzO1xuICAgIGVzLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgIHN0YXR1cy52YWx1ZSA9IFwiT1BFTlwiO1xuICAgICAgZXJyb3IudmFsdWUgPSBudWxsO1xuICAgIH07XG4gICAgZXMub25lcnJvciA9IChlKSA9PiB7XG4gICAgICBzdGF0dXMudmFsdWUgPSBcIkNMT1NFRFwiO1xuICAgICAgZXJyb3IudmFsdWUgPSBlO1xuICAgICAgaWYgKGVzLnJlYWR5U3RhdGUgPT09IDIgJiYgIWV4cGxpY2l0bHlDbG9zZWQgJiYgb3B0aW9ucy5hdXRvUmVjb25uZWN0KSB7XG4gICAgICAgIGVzLmNsb3NlKCk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICByZXRyaWVzID0gLTEsXG4gICAgICAgICAgZGVsYXkgPSAxZTMsXG4gICAgICAgICAgb25GYWlsZWRcbiAgICAgICAgfSA9IHJlc29sdmVOZXN0ZWRPcHRpb25zJDEob3B0aW9ucy5hdXRvUmVjb25uZWN0KTtcbiAgICAgICAgcmV0cmllZCArPSAxO1xuICAgICAgICBpZiAodHlwZW9mIHJldHJpZXMgPT09IFwibnVtYmVyXCIgJiYgKHJldHJpZXMgPCAwIHx8IHJldHJpZWQgPCByZXRyaWVzKSlcbiAgICAgICAgICBzZXRUaW1lb3V0KF9pbml0LCBkZWxheSk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiByZXRyaWVzID09PSBcImZ1bmN0aW9uXCIgJiYgcmV0cmllcygpKVxuICAgICAgICAgIHNldFRpbWVvdXQoX2luaXQsIGRlbGF5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG9uRmFpbGVkID09IG51bGwgPyB2b2lkIDAgOiBvbkZhaWxlZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgZXMub25tZXNzYWdlID0gKGUpID0+IHtcbiAgICAgIGV2ZW50LnZhbHVlID0gbnVsbDtcbiAgICAgIGRhdGEudmFsdWUgPSBlLmRhdGE7XG4gICAgICBsYXN0RXZlbnRJZC52YWx1ZSA9IGUubGFzdEV2ZW50SWQ7XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGV2ZW50X25hbWUgb2YgZXZlbnRzKSB7XG4gICAgICB1c2VFdmVudExpc3RlbmVyKGVzLCBldmVudF9uYW1lLCAoZSkgPT4ge1xuICAgICAgICBldmVudC52YWx1ZSA9IGV2ZW50X25hbWU7XG4gICAgICAgIGRhdGEudmFsdWUgPSBlLmRhdGEgfHwgbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgb3BlbiA9ICgpID0+IHtcbiAgICBpZiAoIWlzQ2xpZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNsb3NlKCk7XG4gICAgZXhwbGljaXRseUNsb3NlZCA9IGZhbHNlO1xuICAgIHJldHJpZWQgPSAwO1xuICAgIF9pbml0KCk7XG4gIH07XG4gIGlmIChpbW1lZGlhdGUpXG4gICAgd2F0Y2godXJsUmVmLCBvcGVuLCB7IGltbWVkaWF0ZTogdHJ1ZSB9KTtcbiAgdHJ5T25TY29wZURpc3Bvc2UoY2xvc2UpO1xuICByZXR1cm4ge1xuICAgIGV2ZW50U291cmNlLFxuICAgIGV2ZW50LFxuICAgIGRhdGEsXG4gICAgc3RhdHVzLFxuICAgIGVycm9yLFxuICAgIG9wZW4sXG4gICAgY2xvc2UsXG4gICAgbGFzdEV2ZW50SWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlRXllRHJvcHBlcihvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyBpbml0aWFsVmFsdWUgPSBcIlwiIH0gPSBvcHRpb25zO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIFwiRXllRHJvcHBlclwiIGluIHdpbmRvdyk7XG4gIGNvbnN0IHNSR0JIZXggPSByZWYoaW5pdGlhbFZhbHVlKTtcbiAgYXN5bmMgZnVuY3Rpb24gb3BlbihvcGVuT3B0aW9ucykge1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZXllRHJvcHBlciA9IG5ldyB3aW5kb3cuRXllRHJvcHBlcigpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV5ZURyb3BwZXIub3BlbihvcGVuT3B0aW9ucyk7XG4gICAgc1JHQkhleC52YWx1ZSA9IHJlc3VsdC5zUkdCSGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHsgaXNTdXBwb3J0ZWQsIHNSR0JIZXgsIG9wZW4gfTtcbn1cblxuZnVuY3Rpb24gdXNlRmF2aWNvbihuZXdJY29uID0gbnVsbCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBiYXNlVXJsID0gXCJcIixcbiAgICByZWwgPSBcImljb25cIixcbiAgICBkb2N1bWVudCA9IGRlZmF1bHREb2N1bWVudFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgZmF2aWNvbiA9IHRvUmVmKG5ld0ljb24pO1xuICBjb25zdCBhcHBseUljb24gPSAoaWNvbikgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gZG9jdW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGRvY3VtZW50LmhlYWQucXVlcnlTZWxlY3RvckFsbChgbGlua1tyZWwqPVwiJHtyZWx9XCJdYCk7XG4gICAgaWYgKCFlbGVtZW50cyB8fCBlbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudCA9PSBudWxsID8gdm9pZCAwIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG4gICAgICBpZiAobGluaykge1xuICAgICAgICBsaW5rLnJlbCA9IHJlbDtcbiAgICAgICAgbGluay5ocmVmID0gYCR7YmFzZVVybH0ke2ljb259YDtcbiAgICAgICAgbGluay50eXBlID0gYGltYWdlLyR7aWNvbi5zcGxpdChcIi5cIikucG9wKCl9YDtcbiAgICAgICAgZG9jdW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGRvY3VtZW50LmhlYWQuYXBwZW5kKGxpbmspO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbGVtZW50cyA9PSBudWxsID8gdm9pZCAwIDogZWxlbWVudHMuZm9yRWFjaCgoZWwpID0+IGVsLmhyZWYgPSBgJHtiYXNlVXJsfSR7aWNvbn1gKTtcbiAgfTtcbiAgd2F0Y2goXG4gICAgZmF2aWNvbixcbiAgICAoaSwgbykgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBpID09PSBcInN0cmluZ1wiICYmIGkgIT09IG8pXG4gICAgICAgIGFwcGx5SWNvbihpKTtcbiAgICB9LFxuICAgIHsgaW1tZWRpYXRlOiB0cnVlIH1cbiAgKTtcbiAgcmV0dXJuIGZhdmljb247XG59XG5cbmNvbnN0IHBheWxvYWRNYXBwaW5nID0ge1xuICBqc29uOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgdGV4dDogXCJ0ZXh0L3BsYWluXCJcbn07XG5mdW5jdGlvbiBpc0ZldGNoT3B0aW9ucyhvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBjb250YWluc1Byb3Aob2JqLCBcImltbWVkaWF0ZVwiLCBcInJlZmV0Y2hcIiwgXCJpbml0aWFsRGF0YVwiLCBcInRpbWVvdXRcIiwgXCJiZWZvcmVGZXRjaFwiLCBcImFmdGVyRmV0Y2hcIiwgXCJvbkZldGNoRXJyb3JcIiwgXCJmZXRjaFwiLCBcInVwZGF0ZURhdGFPbkVycm9yXCIpO1xufVxuY29uc3QgcmVBYnNvbHV0ZSA9IC9eKD86W2Etel1bYS16XFxkK1xcLS5dKjopP1xcL1xcLy9pO1xuZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgcmV0dXJuIHJlQWJzb2x1dGUudGVzdCh1cmwpO1xufVxuZnVuY3Rpb24gaGVhZGVyc1RvT2JqZWN0KGhlYWRlcnMpIHtcbiAgaWYgKHR5cGVvZiBIZWFkZXJzICE9PSBcInVuZGVmaW5lZFwiICYmIGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKVxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoaGVhZGVycy5lbnRyaWVzKCkpO1xuICByZXR1cm4gaGVhZGVycztcbn1cbmZ1bmN0aW9uIGNvbWJpbmVDYWxsYmFja3MoY29tYmluYXRpb24sIC4uLmNhbGxiYWNrcykge1xuICBpZiAoY29tYmluYXRpb24gPT09IFwib3ZlcndyaXRlXCIpIHtcbiAgICByZXR1cm4gYXN5bmMgKGN0eCkgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSBjYWxsYmFja3NbY2FsbGJhY2tzLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGNhbGxiYWNrKVxuICAgICAgICByZXR1cm4geyAuLi5jdHgsIC4uLmF3YWl0IGNhbGxiYWNrKGN0eCkgfTtcbiAgICAgIHJldHVybiBjdHg7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXN5bmMgKGN0eCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBjYWxsYmFja3MpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKVxuICAgICAgICAgIGN0eCA9IHsgLi4uY3R4LCAuLi5hd2FpdCBjYWxsYmFjayhjdHgpIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gY3R4O1xuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUZldGNoKGNvbmZpZyA9IHt9KSB7XG4gIGNvbnN0IF9jb21iaW5hdGlvbiA9IGNvbmZpZy5jb21iaW5hdGlvbiB8fCBcImNoYWluXCI7XG4gIGNvbnN0IF9vcHRpb25zID0gY29uZmlnLm9wdGlvbnMgfHwge307XG4gIGNvbnN0IF9mZXRjaE9wdGlvbnMgPSBjb25maWcuZmV0Y2hPcHRpb25zIHx8IHt9O1xuICBmdW5jdGlvbiB1c2VGYWN0b3J5RmV0Y2godXJsLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgY29tcHV0ZWRVcmwgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgICBjb25zdCBiYXNlVXJsID0gdG9WYWx1ZShjb25maWcuYmFzZVVybCk7XG4gICAgICBjb25zdCB0YXJnZXRVcmwgPSB0b1ZhbHVlKHVybCk7XG4gICAgICByZXR1cm4gYmFzZVVybCAmJiAhaXNBYnNvbHV0ZVVSTCh0YXJnZXRVcmwpID8gam9pblBhdGhzKGJhc2VVcmwsIHRhcmdldFVybCkgOiB0YXJnZXRVcmw7XG4gICAgfSk7XG4gICAgbGV0IG9wdGlvbnMgPSBfb3B0aW9ucztcbiAgICBsZXQgZmV0Y2hPcHRpb25zID0gX2ZldGNoT3B0aW9ucztcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoaXNGZXRjaE9wdGlvbnMoYXJnc1swXSkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIC4uLmFyZ3NbMF0sXG4gICAgICAgICAgYmVmb3JlRmV0Y2g6IGNvbWJpbmVDYWxsYmFja3MoX2NvbWJpbmF0aW9uLCBfb3B0aW9ucy5iZWZvcmVGZXRjaCwgYXJnc1swXS5iZWZvcmVGZXRjaCksXG4gICAgICAgICAgYWZ0ZXJGZXRjaDogY29tYmluZUNhbGxiYWNrcyhfY29tYmluYXRpb24sIF9vcHRpb25zLmFmdGVyRmV0Y2gsIGFyZ3NbMF0uYWZ0ZXJGZXRjaCksXG4gICAgICAgICAgb25GZXRjaEVycm9yOiBjb21iaW5lQ2FsbGJhY2tzKF9jb21iaW5hdGlvbiwgX29wdGlvbnMub25GZXRjaEVycm9yLCBhcmdzWzBdLm9uRmV0Y2hFcnJvcilcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZldGNoT3B0aW9ucyA9IHtcbiAgICAgICAgICAuLi5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgLi4uYXJnc1swXSxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAuLi5oZWFkZXJzVG9PYmplY3QoZmV0Y2hPcHRpb25zLmhlYWRlcnMpIHx8IHt9LFxuICAgICAgICAgICAgLi4uaGVhZGVyc1RvT2JqZWN0KGFyZ3NbMF0uaGVhZGVycykgfHwge31cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhcmdzLmxlbmd0aCA+IDEgJiYgaXNGZXRjaE9wdGlvbnMoYXJnc1sxXSkpIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIC4uLmFyZ3NbMV0sXG4gICAgICAgIGJlZm9yZUZldGNoOiBjb21iaW5lQ2FsbGJhY2tzKF9jb21iaW5hdGlvbiwgX29wdGlvbnMuYmVmb3JlRmV0Y2gsIGFyZ3NbMV0uYmVmb3JlRmV0Y2gpLFxuICAgICAgICBhZnRlckZldGNoOiBjb21iaW5lQ2FsbGJhY2tzKF9jb21iaW5hdGlvbiwgX29wdGlvbnMuYWZ0ZXJGZXRjaCwgYXJnc1sxXS5hZnRlckZldGNoKSxcbiAgICAgICAgb25GZXRjaEVycm9yOiBjb21iaW5lQ2FsbGJhY2tzKF9jb21iaW5hdGlvbiwgX29wdGlvbnMub25GZXRjaEVycm9yLCBhcmdzWzFdLm9uRmV0Y2hFcnJvcilcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB1c2VGZXRjaChjb21wdXRlZFVybCwgZmV0Y2hPcHRpb25zLCBvcHRpb25zKTtcbiAgfVxuICByZXR1cm4gdXNlRmFjdG9yeUZldGNoO1xufVxuZnVuY3Rpb24gdXNlRmV0Y2godXJsLCAuLi5hcmdzKSB7XG4gIHZhciBfYTtcbiAgY29uc3Qgc3VwcG9ydHNBYm9ydCA9IHR5cGVvZiBBYm9ydENvbnRyb2xsZXIgPT09IFwiZnVuY3Rpb25cIjtcbiAgbGV0IGZldGNoT3B0aW9ucyA9IHt9O1xuICBsZXQgb3B0aW9ucyA9IHtcbiAgICBpbW1lZGlhdGU6IHRydWUsXG4gICAgcmVmZXRjaDogZmFsc2UsXG4gICAgdGltZW91dDogMCxcbiAgICB1cGRhdGVEYXRhT25FcnJvcjogZmFsc2VcbiAgfTtcbiAgY29uc3QgY29uZmlnID0ge1xuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICB0eXBlOiBcInRleHRcIixcbiAgICBwYXlsb2FkOiB2b2lkIDBcbiAgfTtcbiAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgIGlmIChpc0ZldGNoT3B0aW9ucyhhcmdzWzBdKSlcbiAgICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIC4uLmFyZ3NbMF0gfTtcbiAgICBlbHNlXG4gICAgICBmZXRjaE9wdGlvbnMgPSBhcmdzWzBdO1xuICB9XG4gIGlmIChhcmdzLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoaXNGZXRjaE9wdGlvbnMoYXJnc1sxXSkpXG4gICAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCAuLi5hcmdzWzFdIH07XG4gIH1cbiAgY29uc3Qge1xuICAgIGZldGNoID0gKF9hID0gZGVmYXVsdFdpbmRvdykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmZldGNoLFxuICAgIGluaXRpYWxEYXRhLFxuICAgIHRpbWVvdXRcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHJlc3BvbnNlRXZlbnQgPSBjcmVhdGVFdmVudEhvb2soKTtcbiAgY29uc3QgZXJyb3JFdmVudCA9IGNyZWF0ZUV2ZW50SG9vaygpO1xuICBjb25zdCBmaW5hbGx5RXZlbnQgPSBjcmVhdGVFdmVudEhvb2soKTtcbiAgY29uc3QgaXNGaW5pc2hlZCA9IHJlZihmYWxzZSk7XG4gIGNvbnN0IGlzRmV0Y2hpbmcgPSByZWYoZmFsc2UpO1xuICBjb25zdCBhYm9ydGVkID0gcmVmKGZhbHNlKTtcbiAgY29uc3Qgc3RhdHVzQ29kZSA9IHJlZihudWxsKTtcbiAgY29uc3QgcmVzcG9uc2UgPSBzaGFsbG93UmVmKG51bGwpO1xuICBjb25zdCBlcnJvciA9IHNoYWxsb3dSZWYobnVsbCk7XG4gIGNvbnN0IGRhdGEgPSBzaGFsbG93UmVmKGluaXRpYWxEYXRhIHx8IG51bGwpO1xuICBjb25zdCBjYW5BYm9ydCA9IGNvbXB1dGVkKCgpID0+IHN1cHBvcnRzQWJvcnQgJiYgaXNGZXRjaGluZy52YWx1ZSk7XG4gIGxldCBjb250cm9sbGVyO1xuICBsZXQgdGltZXI7XG4gIGNvbnN0IGFib3J0ID0gKCkgPT4ge1xuICAgIGlmIChzdXBwb3J0c0Fib3J0KSB7XG4gICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29udHJvbGxlci5zaWduYWwub25hYm9ydCA9ICgpID0+IGFib3J0ZWQudmFsdWUgPSB0cnVlO1xuICAgICAgZmV0Y2hPcHRpb25zID0ge1xuICAgICAgICAuLi5mZXRjaE9wdGlvbnMsXG4gICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWxcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBjb25zdCBsb2FkaW5nID0gKGlzTG9hZGluZykgPT4ge1xuICAgIGlzRmV0Y2hpbmcudmFsdWUgPSBpc0xvYWRpbmc7XG4gICAgaXNGaW5pc2hlZC52YWx1ZSA9ICFpc0xvYWRpbmc7XG4gIH07XG4gIGlmICh0aW1lb3V0KVxuICAgIHRpbWVyID0gdXNlVGltZW91dEZuKGFib3J0LCB0aW1lb3V0LCB7IGltbWVkaWF0ZTogZmFsc2UgfSk7XG4gIGxldCBleGVjdXRlQ291bnRlciA9IDA7XG4gIGNvbnN0IGV4ZWN1dGUgPSBhc3luYyAodGhyb3dPbkZhaWxlZCA9IGZhbHNlKSA9PiB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgYWJvcnQoKTtcbiAgICBsb2FkaW5nKHRydWUpO1xuICAgIGVycm9yLnZhbHVlID0gbnVsbDtcbiAgICBzdGF0dXNDb2RlLnZhbHVlID0gbnVsbDtcbiAgICBhYm9ydGVkLnZhbHVlID0gZmFsc2U7XG4gICAgZXhlY3V0ZUNvdW50ZXIgKz0gMTtcbiAgICBjb25zdCBjdXJyZW50RXhlY3V0ZUNvdW50ZXIgPSBleGVjdXRlQ291bnRlcjtcbiAgICBjb25zdCBkZWZhdWx0RmV0Y2hPcHRpb25zID0ge1xuICAgICAgbWV0aG9kOiBjb25maWcubWV0aG9kLFxuICAgICAgaGVhZGVyczoge31cbiAgICB9O1xuICAgIGlmIChjb25maWcucGF5bG9hZCkge1xuICAgICAgY29uc3QgaGVhZGVycyA9IGhlYWRlcnNUb09iamVjdChkZWZhdWx0RmV0Y2hPcHRpb25zLmhlYWRlcnMpO1xuICAgICAgY29uc3QgcGF5bG9hZCA9IHRvVmFsdWUoY29uZmlnLnBheWxvYWQpO1xuICAgICAgaWYgKCFjb25maWcucGF5bG9hZFR5cGUgJiYgcGF5bG9hZCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YocGF5bG9hZCkgPT09IE9iamVjdC5wcm90b3R5cGUgJiYgIShwYXlsb2FkIGluc3RhbmNlb2YgRm9ybURhdGEpKVxuICAgICAgICBjb25maWcucGF5bG9hZFR5cGUgPSBcImpzb25cIjtcbiAgICAgIGlmIChjb25maWcucGF5bG9hZFR5cGUpXG4gICAgICAgIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSAoX2EyID0gcGF5bG9hZE1hcHBpbmdbY29uZmlnLnBheWxvYWRUeXBlXSkgIT0gbnVsbCA/IF9hMiA6IGNvbmZpZy5wYXlsb2FkVHlwZTtcbiAgICAgIGRlZmF1bHRGZXRjaE9wdGlvbnMuYm9keSA9IGNvbmZpZy5wYXlsb2FkVHlwZSA9PT0gXCJqc29uXCIgPyBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSA6IHBheWxvYWQ7XG4gICAgfVxuICAgIGxldCBpc0NhbmNlbGVkID0gZmFsc2U7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIHVybDogdG9WYWx1ZSh1cmwpLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICAuLi5kZWZhdWx0RmV0Y2hPcHRpb25zLFxuICAgICAgICAuLi5mZXRjaE9wdGlvbnNcbiAgICAgIH0sXG4gICAgICBjYW5jZWw6ICgpID0+IHtcbiAgICAgICAgaXNDYW5jZWxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAob3B0aW9ucy5iZWZvcmVGZXRjaClcbiAgICAgIE9iamVjdC5hc3NpZ24oY29udGV4dCwgYXdhaXQgb3B0aW9ucy5iZWZvcmVGZXRjaChjb250ZXh0KSk7XG4gICAgaWYgKGlzQ2FuY2VsZWQgfHwgIWZldGNoKSB7XG4gICAgICBsb2FkaW5nKGZhbHNlKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgfVxuICAgIGxldCByZXNwb25zZURhdGEgPSBudWxsO1xuICAgIGlmICh0aW1lcilcbiAgICAgIHRpbWVyLnN0YXJ0KCk7XG4gICAgcmV0dXJuIGZldGNoKFxuICAgICAgY29udGV4dC51cmwsXG4gICAgICB7XG4gICAgICAgIC4uLmRlZmF1bHRGZXRjaE9wdGlvbnMsXG4gICAgICAgIC4uLmNvbnRleHQub3B0aW9ucyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIC4uLmhlYWRlcnNUb09iamVjdChkZWZhdWx0RmV0Y2hPcHRpb25zLmhlYWRlcnMpLFxuICAgICAgICAgIC4uLmhlYWRlcnNUb09iamVjdCgoX2IgPSBjb250ZXh0Lm9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5oZWFkZXJzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKS50aGVuKGFzeW5jIChmZXRjaFJlc3BvbnNlKSA9PiB7XG4gICAgICByZXNwb25zZS52YWx1ZSA9IGZldGNoUmVzcG9uc2U7XG4gICAgICBzdGF0dXNDb2RlLnZhbHVlID0gZmV0Y2hSZXNwb25zZS5zdGF0dXM7XG4gICAgICByZXNwb25zZURhdGEgPSBhd2FpdCBmZXRjaFJlc3BvbnNlLmNsb25lKClbY29uZmlnLnR5cGVdKCk7XG4gICAgICBpZiAoIWZldGNoUmVzcG9uc2Uub2spIHtcbiAgICAgICAgZGF0YS52YWx1ZSA9IGluaXRpYWxEYXRhIHx8IG51bGw7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihmZXRjaFJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuYWZ0ZXJGZXRjaCkge1xuICAgICAgICAoeyBkYXRhOiByZXNwb25zZURhdGEgfSA9IGF3YWl0IG9wdGlvbnMuYWZ0ZXJGZXRjaCh7XG4gICAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICAgIHJlc3BvbnNlOiBmZXRjaFJlc3BvbnNlXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIGRhdGEudmFsdWUgPSByZXNwb25zZURhdGE7XG4gICAgICByZXNwb25zZUV2ZW50LnRyaWdnZXIoZmV0Y2hSZXNwb25zZSk7XG4gICAgICByZXR1cm4gZmV0Y2hSZXNwb25zZTtcbiAgICB9KS5jYXRjaChhc3luYyAoZmV0Y2hFcnJvcikgPT4ge1xuICAgICAgbGV0IGVycm9yRGF0YSA9IGZldGNoRXJyb3IubWVzc2FnZSB8fCBmZXRjaEVycm9yLm5hbWU7XG4gICAgICBpZiAob3B0aW9ucy5vbkZldGNoRXJyb3IpIHtcbiAgICAgICAgKHsgZXJyb3I6IGVycm9yRGF0YSwgZGF0YTogcmVzcG9uc2VEYXRhIH0gPSBhd2FpdCBvcHRpb25zLm9uRmV0Y2hFcnJvcih7XG4gICAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICAgIGVycm9yOiBmZXRjaEVycm9yLFxuICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZS52YWx1ZVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICBlcnJvci52YWx1ZSA9IGVycm9yRGF0YTtcbiAgICAgIGlmIChvcHRpb25zLnVwZGF0ZURhdGFPbkVycm9yKVxuICAgICAgICBkYXRhLnZhbHVlID0gcmVzcG9uc2VEYXRhO1xuICAgICAgZXJyb3JFdmVudC50cmlnZ2VyKGZldGNoRXJyb3IpO1xuICAgICAgaWYgKHRocm93T25GYWlsZWQpXG4gICAgICAgIHRocm93IGZldGNoRXJyb3I7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgIGlmIChjdXJyZW50RXhlY3V0ZUNvdW50ZXIgPT09IGV4ZWN1dGVDb3VudGVyKVxuICAgICAgICBsb2FkaW5nKGZhbHNlKTtcbiAgICAgIGlmICh0aW1lcilcbiAgICAgICAgdGltZXIuc3RvcCgpO1xuICAgICAgZmluYWxseUV2ZW50LnRyaWdnZXIobnVsbCk7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHJlZmV0Y2ggPSB0b1JlZihvcHRpb25zLnJlZmV0Y2gpO1xuICB3YXRjaChcbiAgICBbXG4gICAgICByZWZldGNoLFxuICAgICAgdG9SZWYodXJsKVxuICAgIF0sXG4gICAgKFtyZWZldGNoMl0pID0+IHJlZmV0Y2gyICYmIGV4ZWN1dGUoKSxcbiAgICB7IGRlZXA6IHRydWUgfVxuICApO1xuICBjb25zdCBzaGVsbCA9IHtcbiAgICBpc0ZpbmlzaGVkOiByZWFkb25seShpc0ZpbmlzaGVkKSxcbiAgICBpc0ZldGNoaW5nOiByZWFkb25seShpc0ZldGNoaW5nKSxcbiAgICBzdGF0dXNDb2RlLFxuICAgIHJlc3BvbnNlLFxuICAgIGVycm9yLFxuICAgIGRhdGEsXG4gICAgY2FuQWJvcnQsXG4gICAgYWJvcnRlZCxcbiAgICBhYm9ydCxcbiAgICBleGVjdXRlLFxuICAgIG9uRmV0Y2hSZXNwb25zZTogcmVzcG9uc2VFdmVudC5vbixcbiAgICBvbkZldGNoRXJyb3I6IGVycm9yRXZlbnQub24sXG4gICAgb25GZXRjaEZpbmFsbHk6IGZpbmFsbHlFdmVudC5vbixcbiAgICAvLyBtZXRob2RcbiAgICBnZXQ6IHNldE1ldGhvZChcIkdFVFwiKSxcbiAgICBwdXQ6IHNldE1ldGhvZChcIlBVVFwiKSxcbiAgICBwb3N0OiBzZXRNZXRob2QoXCJQT1NUXCIpLFxuICAgIGRlbGV0ZTogc2V0TWV0aG9kKFwiREVMRVRFXCIpLFxuICAgIHBhdGNoOiBzZXRNZXRob2QoXCJQQVRDSFwiKSxcbiAgICBoZWFkOiBzZXRNZXRob2QoXCJIRUFEXCIpLFxuICAgIG9wdGlvbnM6IHNldE1ldGhvZChcIk9QVElPTlNcIiksXG4gICAgLy8gdHlwZVxuICAgIGpzb246IHNldFR5cGUoXCJqc29uXCIpLFxuICAgIHRleHQ6IHNldFR5cGUoXCJ0ZXh0XCIpLFxuICAgIGJsb2I6IHNldFR5cGUoXCJibG9iXCIpLFxuICAgIGFycmF5QnVmZmVyOiBzZXRUeXBlKFwiYXJyYXlCdWZmZXJcIiksXG4gICAgZm9ybURhdGE6IHNldFR5cGUoXCJmb3JtRGF0YVwiKVxuICB9O1xuICBmdW5jdGlvbiBzZXRNZXRob2QobWV0aG9kKSB7XG4gICAgcmV0dXJuIChwYXlsb2FkLCBwYXlsb2FkVHlwZSkgPT4ge1xuICAgICAgaWYgKCFpc0ZldGNoaW5nLnZhbHVlKSB7XG4gICAgICAgIGNvbmZpZy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIGNvbmZpZy5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICAgICAgY29uZmlnLnBheWxvYWRUeXBlID0gcGF5bG9hZFR5cGU7XG4gICAgICAgIGlmIChpc1JlZihjb25maWcucGF5bG9hZCkpIHtcbiAgICAgICAgICB3YXRjaChcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgcmVmZXRjaCxcbiAgICAgICAgICAgICAgdG9SZWYoY29uZmlnLnBheWxvYWQpXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgKFtyZWZldGNoMl0pID0+IHJlZmV0Y2gyICYmIGV4ZWN1dGUoKSxcbiAgICAgICAgICAgIHsgZGVlcDogdHJ1ZSB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnNoZWxsLFxuICAgICAgICAgIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB3YWl0VW50aWxGaW5pc2hlZCgpLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiB3YWl0VW50aWxGaW5pc2hlZCgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdW50aWwoaXNGaW5pc2hlZCkudG9CZSh0cnVlKS50aGVuKCgpID0+IHJlc29sdmUoc2hlbGwpKS5jYXRjaCgoZXJyb3IyKSA9PiByZWplY3QoZXJyb3IyKSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0VHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICghaXNGZXRjaGluZy52YWx1ZSkge1xuICAgICAgICBjb25maWcudHlwZSA9IHR5cGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uc2hlbGwsXG4gICAgICAgICAgdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHdhaXRVbnRpbEZpbmlzaGVkKCkudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuICB9XG4gIGlmIChvcHRpb25zLmltbWVkaWF0ZSlcbiAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IGV4ZWN1dGUoKSk7XG4gIHJldHVybiB7XG4gICAgLi4uc2hlbGwsXG4gICAgdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgcmV0dXJuIHdhaXRVbnRpbEZpbmlzaGVkKCkudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gam9pblBhdGhzKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydC5lbmRzV2l0aChcIi9cIikgJiYgIWVuZC5zdGFydHNXaXRoKFwiL1wiKSlcbiAgICByZXR1cm4gYCR7c3RhcnR9LyR7ZW5kfWA7XG4gIHJldHVybiBgJHtzdGFydH0ke2VuZH1gO1xufVxuXG5jb25zdCBERUZBVUxUX09QVElPTlMgPSB7XG4gIG11bHRpcGxlOiB0cnVlLFxuICBhY2NlcHQ6IFwiKlwiLFxuICByZXNldDogZmFsc2UsXG4gIGRpcmVjdG9yeTogZmFsc2Vcbn07XG5mdW5jdGlvbiB1c2VGaWxlRGlhbG9nKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgZG9jdW1lbnQgPSBkZWZhdWx0RG9jdW1lbnRcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGZpbGVzID0gcmVmKG51bGwpO1xuICBjb25zdCB7IG9uOiBvbkNoYW5nZSwgdHJpZ2dlciB9ID0gY3JlYXRlRXZlbnRIb29rKCk7XG4gIGxldCBpbnB1dDtcbiAgaWYgKGRvY3VtZW50KSB7XG4gICAgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgaW5wdXQudHlwZSA9IFwiZmlsZVwiO1xuICAgIGlucHV0Lm9uY2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBldmVudC50YXJnZXQ7XG4gICAgICBmaWxlcy52YWx1ZSA9IHJlc3VsdC5maWxlcztcbiAgICAgIHRyaWdnZXIoZmlsZXMudmFsdWUpO1xuICAgIH07XG4gIH1cbiAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgZmlsZXMudmFsdWUgPSBudWxsO1xuICAgIGlmIChpbnB1dCAmJiBpbnB1dC52YWx1ZSkge1xuICAgICAgaW5wdXQudmFsdWUgPSBcIlwiO1xuICAgICAgdHJpZ2dlcihudWxsKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG9wZW4gPSAobG9jYWxPcHRpb25zKSA9PiB7XG4gICAgaWYgKCFpbnB1dClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBfb3B0aW9ucyA9IHtcbiAgICAgIC4uLkRFRkFVTFRfT1BUSU9OUyxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAuLi5sb2NhbE9wdGlvbnNcbiAgICB9O1xuICAgIGlucHV0Lm11bHRpcGxlID0gX29wdGlvbnMubXVsdGlwbGU7XG4gICAgaW5wdXQuYWNjZXB0ID0gX29wdGlvbnMuYWNjZXB0O1xuICAgIGlucHV0LndlYmtpdGRpcmVjdG9yeSA9IF9vcHRpb25zLmRpcmVjdG9yeTtcbiAgICBpZiAoaGFzT3duKF9vcHRpb25zLCBcImNhcHR1cmVcIikpXG4gICAgICBpbnB1dC5jYXB0dXJlID0gX29wdGlvbnMuY2FwdHVyZTtcbiAgICBpZiAoX29wdGlvbnMucmVzZXQpXG4gICAgICByZXNldCgpO1xuICAgIGlucHV0LmNsaWNrKCk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgZmlsZXM6IHJlYWRvbmx5KGZpbGVzKSxcbiAgICBvcGVuLFxuICAgIHJlc2V0LFxuICAgIG9uQ2hhbmdlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZUZpbGVTeXN0ZW1BY2Nlc3Mob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICB3aW5kb3c6IF93aW5kb3cgPSBkZWZhdWx0V2luZG93LFxuICAgIGRhdGFUeXBlID0gXCJUZXh0XCJcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHdpbmRvdyA9IF93aW5kb3c7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IHdpbmRvdyAmJiBcInNob3dTYXZlRmlsZVBpY2tlclwiIGluIHdpbmRvdyAmJiBcInNob3dPcGVuRmlsZVBpY2tlclwiIGluIHdpbmRvdyk7XG4gIGNvbnN0IGZpbGVIYW5kbGUgPSByZWYoKTtcbiAgY29uc3QgZGF0YSA9IHJlZigpO1xuICBjb25zdCBmaWxlID0gcmVmKCk7XG4gIGNvbnN0IGZpbGVOYW1lID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IGZpbGUudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5uYW1lKSAhPSBudWxsID8gX2IgOiBcIlwiO1xuICB9KTtcbiAgY29uc3QgZmlsZU1JTUUgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gZmlsZS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnR5cGUpICE9IG51bGwgPyBfYiA6IFwiXCI7XG4gIH0pO1xuICBjb25zdCBmaWxlU2l6ZSA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSBmaWxlLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2l6ZSkgIT0gbnVsbCA/IF9iIDogMDtcbiAgfSk7XG4gIGNvbnN0IGZpbGVMYXN0TW9kaWZpZWQgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gZmlsZS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmxhc3RNb2RpZmllZCkgIT0gbnVsbCA/IF9iIDogMDtcbiAgfSk7XG4gIGFzeW5jIGZ1bmN0aW9uIG9wZW4oX29wdGlvbnMgPSB7fSkge1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgW2hhbmRsZV0gPSBhd2FpdCB3aW5kb3cuc2hvd09wZW5GaWxlUGlja2VyKHsgLi4udG9WYWx1ZShvcHRpb25zKSwgLi4uX29wdGlvbnMgfSk7XG4gICAgZmlsZUhhbmRsZS52YWx1ZSA9IGhhbmRsZTtcbiAgICBhd2FpdCB1cGRhdGVEYXRhKCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlKF9vcHRpb25zID0ge30pIHtcbiAgICBpZiAoIWlzU3VwcG9ydGVkLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGZpbGVIYW5kbGUudmFsdWUgPSBhd2FpdCB3aW5kb3cuc2hvd1NhdmVGaWxlUGlja2VyKHsgLi4ub3B0aW9ucywgLi4uX29wdGlvbnMgfSk7XG4gICAgZGF0YS52YWx1ZSA9IHZvaWQgMDtcbiAgICBhd2FpdCB1cGRhdGVEYXRhKCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gc2F2ZShfb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFpc1N1cHBvcnRlZC52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoIWZpbGVIYW5kbGUudmFsdWUpXG4gICAgICByZXR1cm4gc2F2ZUFzKF9vcHRpb25zKTtcbiAgICBpZiAoZGF0YS52YWx1ZSkge1xuICAgICAgY29uc3Qgd3JpdGFibGVTdHJlYW0gPSBhd2FpdCBmaWxlSGFuZGxlLnZhbHVlLmNyZWF0ZVdyaXRhYmxlKCk7XG4gICAgICBhd2FpdCB3cml0YWJsZVN0cmVhbS53cml0ZShkYXRhLnZhbHVlKTtcbiAgICAgIGF3YWl0IHdyaXRhYmxlU3RyZWFtLmNsb3NlKCk7XG4gICAgfVxuICAgIGF3YWl0IHVwZGF0ZUZpbGUoKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBzYXZlQXMoX29wdGlvbnMgPSB7fSkge1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgZmlsZUhhbmRsZS52YWx1ZSA9IGF3YWl0IHdpbmRvdy5zaG93U2F2ZUZpbGVQaWNrZXIoeyAuLi5vcHRpb25zLCAuLi5fb3B0aW9ucyB9KTtcbiAgICBpZiAoZGF0YS52YWx1ZSkge1xuICAgICAgY29uc3Qgd3JpdGFibGVTdHJlYW0gPSBhd2FpdCBmaWxlSGFuZGxlLnZhbHVlLmNyZWF0ZVdyaXRhYmxlKCk7XG4gICAgICBhd2FpdCB3cml0YWJsZVN0cmVhbS53cml0ZShkYXRhLnZhbHVlKTtcbiAgICAgIGF3YWl0IHdyaXRhYmxlU3RyZWFtLmNsb3NlKCk7XG4gICAgfVxuICAgIGF3YWl0IHVwZGF0ZUZpbGUoKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiB1cGRhdGVGaWxlKCkge1xuICAgIHZhciBfYTtcbiAgICBmaWxlLnZhbHVlID0gYXdhaXQgKChfYSA9IGZpbGVIYW5kbGUudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5nZXRGaWxlKCkpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZURhdGEoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBhd2FpdCB1cGRhdGVGaWxlKCk7XG4gICAgY29uc3QgdHlwZSA9IHRvVmFsdWUoZGF0YVR5cGUpO1xuICAgIGlmICh0eXBlID09PSBcIlRleHRcIilcbiAgICAgIGRhdGEudmFsdWUgPSBhd2FpdCAoKF9hID0gZmlsZS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnRleHQoKSk7XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJBcnJheUJ1ZmZlclwiKVxuICAgICAgZGF0YS52YWx1ZSA9IGF3YWl0ICgoX2IgPSBmaWxlLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2IuYXJyYXlCdWZmZXIoKSk7XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJCbG9iXCIpXG4gICAgICBkYXRhLnZhbHVlID0gZmlsZS52YWx1ZTtcbiAgfVxuICB3YXRjaCgoKSA9PiB0b1ZhbHVlKGRhdGFUeXBlKSwgdXBkYXRlRGF0YSk7XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgZGF0YSxcbiAgICBmaWxlLFxuICAgIGZpbGVOYW1lLFxuICAgIGZpbGVNSU1FLFxuICAgIGZpbGVTaXplLFxuICAgIGZpbGVMYXN0TW9kaWZpZWQsXG4gICAgb3BlbixcbiAgICBjcmVhdGUsXG4gICAgc2F2ZSxcbiAgICBzYXZlQXMsXG4gICAgdXBkYXRlRGF0YVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VGb2N1cyh0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IGluaXRpYWxWYWx1ZSA9IGZhbHNlLCBmb2N1c1Zpc2libGUgPSBmYWxzZSwgcHJldmVudFNjcm9sbCA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICBjb25zdCBpbm5lckZvY3VzZWQgPSByZWYoZmFsc2UpO1xuICBjb25zdCB0YXJnZXRFbGVtZW50ID0gY29tcHV0ZWQoKCkgPT4gdW5yZWZFbGVtZW50KHRhcmdldCkpO1xuICB1c2VFdmVudExpc3RlbmVyKHRhcmdldEVsZW1lbnQsIFwiZm9jdXNcIiwgKGV2ZW50KSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoIWZvY3VzVmlzaWJsZSB8fCAoKF9iID0gKF9hID0gZXZlbnQudGFyZ2V0KS5tYXRjaGVzKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgXCI6Zm9jdXMtdmlzaWJsZVwiKSkpXG4gICAgICBpbm5lckZvY3VzZWQudmFsdWUgPSB0cnVlO1xuICB9KTtcbiAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXRFbGVtZW50LCBcImJsdXJcIiwgKCkgPT4gaW5uZXJGb2N1c2VkLnZhbHVlID0gZmFsc2UpO1xuICBjb25zdCBmb2N1c2VkID0gY29tcHV0ZWQoe1xuICAgIGdldDogKCkgPT4gaW5uZXJGb2N1c2VkLnZhbHVlLFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGlmICghdmFsdWUgJiYgaW5uZXJGb2N1c2VkLnZhbHVlKVxuICAgICAgICAoX2EgPSB0YXJnZXRFbGVtZW50LnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuYmx1cigpO1xuICAgICAgZWxzZSBpZiAodmFsdWUgJiYgIWlubmVyRm9jdXNlZC52YWx1ZSlcbiAgICAgICAgKF9iID0gdGFyZ2V0RWxlbWVudC52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmZvY3VzKHsgcHJldmVudFNjcm9sbCB9KTtcbiAgICB9XG4gIH0pO1xuICB3YXRjaChcbiAgICB0YXJnZXRFbGVtZW50LFxuICAgICgpID0+IHtcbiAgICAgIGZvY3VzZWQudmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgfSxcbiAgICB7IGltbWVkaWF0ZTogdHJ1ZSwgZmx1c2g6IFwicG9zdFwiIH1cbiAgKTtcbiAgcmV0dXJuIHsgZm9jdXNlZCB9O1xufVxuXG5mdW5jdGlvbiB1c2VGb2N1c1dpdGhpbih0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBhY3RpdmVFbGVtZW50ID0gdXNlQWN0aXZlRWxlbWVudChvcHRpb25zKTtcbiAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGNvbXB1dGVkKCgpID0+IHVucmVmRWxlbWVudCh0YXJnZXQpKTtcbiAgY29uc3QgZm9jdXNlZCA9IGNvbXB1dGVkKCgpID0+IHRhcmdldEVsZW1lbnQudmFsdWUgJiYgYWN0aXZlRWxlbWVudC52YWx1ZSA/IHRhcmdldEVsZW1lbnQudmFsdWUuY29udGFpbnMoYWN0aXZlRWxlbWVudC52YWx1ZSkgOiBmYWxzZSk7XG4gIHJldHVybiB7IGZvY3VzZWQgfTtcbn1cblxuZnVuY3Rpb24gdXNlRnBzKG9wdGlvbnMpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBmcHMgPSByZWYoMCk7XG4gIGlmICh0eXBlb2YgcGVyZm9ybWFuY2UgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgcmV0dXJuIGZwcztcbiAgY29uc3QgZXZlcnkgPSAoX2EgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmV2ZXJ5KSAhPSBudWxsID8gX2EgOiAxMDtcbiAgbGV0IGxhc3QgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgbGV0IHRpY2tzID0gMDtcbiAgdXNlUmFmRm4oKCkgPT4ge1xuICAgIHRpY2tzICs9IDE7XG4gICAgaWYgKHRpY2tzID49IGV2ZXJ5KSB7XG4gICAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IGRpZmYgPSBub3cgLSBsYXN0O1xuICAgICAgZnBzLnZhbHVlID0gTWF0aC5yb3VuZCgxZTMgLyAoZGlmZiAvIHRpY2tzKSk7XG4gICAgICBsYXN0ID0gbm93O1xuICAgICAgdGlja3MgPSAwO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBmcHM7XG59XG5cbmNvbnN0IGV2ZW50SGFuZGxlcnMgPSBbXG4gIFwiZnVsbHNjcmVlbmNoYW5nZVwiLFxuICBcIndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2VcIixcbiAgXCJ3ZWJraXRlbmRmdWxsc2NyZWVuXCIsXG4gIFwibW96ZnVsbHNjcmVlbmNoYW5nZVwiLFxuICBcIk1TRnVsbHNjcmVlbkNoYW5nZVwiXG5dO1xuZnVuY3Rpb24gdXNlRnVsbHNjcmVlbih0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgZG9jdW1lbnQgPSBkZWZhdWx0RG9jdW1lbnQsXG4gICAgYXV0b0V4aXQgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgdGFyZ2V0UmVmID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdW5yZWZFbGVtZW50KHRhcmdldCkpICE9IG51bGwgPyBfYSA6IGRvY3VtZW50ID09IG51bGwgPyB2b2lkIDAgOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiaHRtbFwiKTtcbiAgfSk7XG4gIGNvbnN0IGlzRnVsbHNjcmVlbiA9IHJlZihmYWxzZSk7XG4gIGNvbnN0IHJlcXVlc3RNZXRob2QgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgcmV0dXJuIFtcbiAgICAgIFwicmVxdWVzdEZ1bGxzY3JlZW5cIixcbiAgICAgIFwid2Via2l0UmVxdWVzdEZ1bGxzY3JlZW5cIixcbiAgICAgIFwid2Via2l0RW50ZXJGdWxsc2NyZWVuXCIsXG4gICAgICBcIndlYmtpdEVudGVyRnVsbFNjcmVlblwiLFxuICAgICAgXCJ3ZWJraXRSZXF1ZXN0RnVsbFNjcmVlblwiLFxuICAgICAgXCJtb3pSZXF1ZXN0RnVsbFNjcmVlblwiLFxuICAgICAgXCJtc1JlcXVlc3RGdWxsc2NyZWVuXCJcbiAgICBdLmZpbmQoKG0pID0+IGRvY3VtZW50ICYmIG0gaW4gZG9jdW1lbnQgfHwgdGFyZ2V0UmVmLnZhbHVlICYmIG0gaW4gdGFyZ2V0UmVmLnZhbHVlKTtcbiAgfSk7XG4gIGNvbnN0IGV4aXRNZXRob2QgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiZXhpdEZ1bGxzY3JlZW5cIixcbiAgICAgIFwid2Via2l0RXhpdEZ1bGxzY3JlZW5cIixcbiAgICAgIFwid2Via2l0RXhpdEZ1bGxTY3JlZW5cIixcbiAgICAgIFwid2Via2l0Q2FuY2VsRnVsbFNjcmVlblwiLFxuICAgICAgXCJtb3pDYW5jZWxGdWxsU2NyZWVuXCIsXG4gICAgICBcIm1zRXhpdEZ1bGxzY3JlZW5cIlxuICAgIF0uZmluZCgobSkgPT4gZG9jdW1lbnQgJiYgbSBpbiBkb2N1bWVudCB8fCB0YXJnZXRSZWYudmFsdWUgJiYgbSBpbiB0YXJnZXRSZWYudmFsdWUpO1xuICB9KTtcbiAgY29uc3QgZnVsbHNjcmVlbkVuYWJsZWQgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiZnVsbFNjcmVlblwiLFxuICAgICAgXCJ3ZWJraXRJc0Z1bGxTY3JlZW5cIixcbiAgICAgIFwid2Via2l0RGlzcGxheWluZ0Z1bGxzY3JlZW5cIixcbiAgICAgIFwibW96RnVsbFNjcmVlblwiLFxuICAgICAgXCJtc0Z1bGxzY3JlZW5FbGVtZW50XCJcbiAgICBdLmZpbmQoKG0pID0+IGRvY3VtZW50ICYmIG0gaW4gZG9jdW1lbnQgfHwgdGFyZ2V0UmVmLnZhbHVlICYmIG0gaW4gdGFyZ2V0UmVmLnZhbHVlKTtcbiAgfSk7XG4gIGNvbnN0IGZ1bGxzY3JlZW5FbGVtZW50TWV0aG9kID0gW1xuICAgIFwiZnVsbHNjcmVlbkVsZW1lbnRcIixcbiAgICBcIndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50XCIsXG4gICAgXCJtb3pGdWxsU2NyZWVuRWxlbWVudFwiLFxuICAgIFwibXNGdWxsc2NyZWVuRWxlbWVudFwiXG4gIF0uZmluZCgobSkgPT4gZG9jdW1lbnQgJiYgbSBpbiBkb2N1bWVudCk7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IHRhcmdldFJlZi52YWx1ZSAmJiBkb2N1bWVudCAmJiByZXF1ZXN0TWV0aG9kLnZhbHVlICE9PSB2b2lkIDAgJiYgZXhpdE1ldGhvZC52YWx1ZSAhPT0gdm9pZCAwICYmIGZ1bGxzY3JlZW5FbmFibGVkLnZhbHVlICE9PSB2b2lkIDApO1xuICBjb25zdCBpc0N1cnJlbnRFbGVtZW50RnVsbFNjcmVlbiA9ICgpID0+IHtcbiAgICBpZiAoZnVsbHNjcmVlbkVsZW1lbnRNZXRob2QpXG4gICAgICByZXR1cm4gKGRvY3VtZW50ID09IG51bGwgPyB2b2lkIDAgOiBkb2N1bWVudFtmdWxsc2NyZWVuRWxlbWVudE1ldGhvZF0pID09PSB0YXJnZXRSZWYudmFsdWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBjb25zdCBpc0VsZW1lbnRGdWxsU2NyZWVuID0gKCkgPT4ge1xuICAgIGlmIChmdWxsc2NyZWVuRW5hYmxlZC52YWx1ZSkge1xuICAgICAgaWYgKGRvY3VtZW50ICYmIGRvY3VtZW50W2Z1bGxzY3JlZW5FbmFibGVkLnZhbHVlXSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudFtmdWxsc2NyZWVuRW5hYmxlZC52YWx1ZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0YXJnZXQyID0gdGFyZ2V0UmVmLnZhbHVlO1xuICAgICAgICBpZiAoKHRhcmdldDIgPT0gbnVsbCA/IHZvaWQgMCA6IHRhcmdldDJbZnVsbHNjcmVlbkVuYWJsZWQudmFsdWVdKSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIEJvb2xlYW4odGFyZ2V0MltmdWxsc2NyZWVuRW5hYmxlZC52YWx1ZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgYXN5bmMgZnVuY3Rpb24gZXhpdCgpIHtcbiAgICBpZiAoIWlzU3VwcG9ydGVkLnZhbHVlIHx8ICFpc0Z1bGxzY3JlZW4udmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGV4aXRNZXRob2QudmFsdWUpIHtcbiAgICAgIGlmICgoZG9jdW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGRvY3VtZW50W2V4aXRNZXRob2QudmFsdWVdKSAhPSBudWxsKSB7XG4gICAgICAgIGF3YWl0IGRvY3VtZW50W2V4aXRNZXRob2QudmFsdWVdKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0YXJnZXQyID0gdGFyZ2V0UmVmLnZhbHVlO1xuICAgICAgICBpZiAoKHRhcmdldDIgPT0gbnVsbCA/IHZvaWQgMCA6IHRhcmdldDJbZXhpdE1ldGhvZC52YWx1ZV0pICE9IG51bGwpXG4gICAgICAgICAgYXdhaXQgdGFyZ2V0MltleGl0TWV0aG9kLnZhbHVlXSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpc0Z1bGxzY3JlZW4udmFsdWUgPSBmYWxzZTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBlbnRlcigpIHtcbiAgICBpZiAoIWlzU3VwcG9ydGVkLnZhbHVlIHx8IGlzRnVsbHNjcmVlbi52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoaXNFbGVtZW50RnVsbFNjcmVlbigpKVxuICAgICAgYXdhaXQgZXhpdCgpO1xuICAgIGNvbnN0IHRhcmdldDIgPSB0YXJnZXRSZWYudmFsdWU7XG4gICAgaWYgKHJlcXVlc3RNZXRob2QudmFsdWUgJiYgKHRhcmdldDIgPT0gbnVsbCA/IHZvaWQgMCA6IHRhcmdldDJbcmVxdWVzdE1ldGhvZC52YWx1ZV0pICE9IG51bGwpIHtcbiAgICAgIGF3YWl0IHRhcmdldDJbcmVxdWVzdE1ldGhvZC52YWx1ZV0oKTtcbiAgICAgIGlzRnVsbHNjcmVlbi52YWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICBhd2FpdCAoaXNGdWxsc2NyZWVuLnZhbHVlID8gZXhpdCgpIDogZW50ZXIoKSk7XG4gIH1cbiAgY29uc3QgaGFuZGxlckNhbGxiYWNrID0gKCkgPT4ge1xuICAgIGNvbnN0IGlzRWxlbWVudEZ1bGxTY3JlZW5WYWx1ZSA9IGlzRWxlbWVudEZ1bGxTY3JlZW4oKTtcbiAgICBpZiAoIWlzRWxlbWVudEZ1bGxTY3JlZW5WYWx1ZSB8fCBpc0VsZW1lbnRGdWxsU2NyZWVuVmFsdWUgJiYgaXNDdXJyZW50RWxlbWVudEZ1bGxTY3JlZW4oKSlcbiAgICAgIGlzRnVsbHNjcmVlbi52YWx1ZSA9IGlzRWxlbWVudEZ1bGxTY3JlZW5WYWx1ZTtcbiAgfTtcbiAgdXNlRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgZXZlbnRIYW5kbGVycywgaGFuZGxlckNhbGxiYWNrLCBmYWxzZSk7XG4gIHVzZUV2ZW50TGlzdGVuZXIoKCkgPT4gdW5yZWZFbGVtZW50KHRhcmdldFJlZiksIGV2ZW50SGFuZGxlcnMsIGhhbmRsZXJDYWxsYmFjaywgZmFsc2UpO1xuICBpZiAoYXV0b0V4aXQpXG4gICAgdHJ5T25TY29wZURpc3Bvc2UoZXhpdCk7XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgaXNGdWxsc2NyZWVuLFxuICAgIGVudGVyLFxuICAgIGV4aXQsXG4gICAgdG9nZ2xlXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1hcEdhbWVwYWRUb1hib3gzNjBDb250cm9sbGVyKGdhbWVwYWQpIHtcbiAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IHtcbiAgICBpZiAoZ2FtZXBhZC52YWx1ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnV0dG9uczoge1xuICAgICAgICAgIGE6IGdhbWVwYWQudmFsdWUuYnV0dG9uc1swXSxcbiAgICAgICAgICBiOiBnYW1lcGFkLnZhbHVlLmJ1dHRvbnNbMV0sXG4gICAgICAgICAgeDogZ2FtZXBhZC52YWx1ZS5idXR0b25zWzJdLFxuICAgICAgICAgIHk6IGdhbWVwYWQudmFsdWUuYnV0dG9uc1szXVxuICAgICAgICB9LFxuICAgICAgICBidW1wZXI6IHtcbiAgICAgICAgICBsZWZ0OiBnYW1lcGFkLnZhbHVlLmJ1dHRvbnNbNF0sXG4gICAgICAgICAgcmlnaHQ6IGdhbWVwYWQudmFsdWUuYnV0dG9uc1s1XVxuICAgICAgICB9LFxuICAgICAgICB0cmlnZ2Vyczoge1xuICAgICAgICAgIGxlZnQ6IGdhbWVwYWQudmFsdWUuYnV0dG9uc1s2XSxcbiAgICAgICAgICByaWdodDogZ2FtZXBhZC52YWx1ZS5idXR0b25zWzddXG4gICAgICAgIH0sXG4gICAgICAgIHN0aWNrOiB7XG4gICAgICAgICAgbGVmdDoge1xuICAgICAgICAgICAgaG9yaXpvbnRhbDogZ2FtZXBhZC52YWx1ZS5heGVzWzBdLFxuICAgICAgICAgICAgdmVydGljYWw6IGdhbWVwYWQudmFsdWUuYXhlc1sxXSxcbiAgICAgICAgICAgIGJ1dHRvbjogZ2FtZXBhZC52YWx1ZS5idXR0b25zWzEwXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmlnaHQ6IHtcbiAgICAgICAgICAgIGhvcml6b250YWw6IGdhbWVwYWQudmFsdWUuYXhlc1syXSxcbiAgICAgICAgICAgIHZlcnRpY2FsOiBnYW1lcGFkLnZhbHVlLmF4ZXNbM10sXG4gICAgICAgICAgICBidXR0b246IGdhbWVwYWQudmFsdWUuYnV0dG9uc1sxMV1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRwYWQ6IHtcbiAgICAgICAgICB1cDogZ2FtZXBhZC52YWx1ZS5idXR0b25zWzEyXSxcbiAgICAgICAgICBkb3duOiBnYW1lcGFkLnZhbHVlLmJ1dHRvbnNbMTNdLFxuICAgICAgICAgIGxlZnQ6IGdhbWVwYWQudmFsdWUuYnV0dG9uc1sxNF0sXG4gICAgICAgICAgcmlnaHQ6IGdhbWVwYWQudmFsdWUuYnV0dG9uc1sxNV1cbiAgICAgICAgfSxcbiAgICAgICAgYmFjazogZ2FtZXBhZC52YWx1ZS5idXR0b25zWzhdLFxuICAgICAgICBzdGFydDogZ2FtZXBhZC52YWx1ZS5idXR0b25zWzldXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSk7XG59XG5mdW5jdGlvbiB1c2VHYW1lcGFkKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgbmF2aWdhdG9yID0gZGVmYXVsdE5hdmlnYXRvclxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gbmF2aWdhdG9yICYmIFwiZ2V0R2FtZXBhZHNcIiBpbiBuYXZpZ2F0b3IpO1xuICBjb25zdCBnYW1lcGFkcyA9IHJlZihbXSk7XG4gIGNvbnN0IG9uQ29ubmVjdGVkSG9vayA9IGNyZWF0ZUV2ZW50SG9vaygpO1xuICBjb25zdCBvbkRpc2Nvbm5lY3RlZEhvb2sgPSBjcmVhdGVFdmVudEhvb2soKTtcbiAgY29uc3Qgc3RhdGVGcm9tR2FtZXBhZCA9IChnYW1lcGFkKSA9PiB7XG4gICAgY29uc3QgaGFwdGljQWN0dWF0b3JzID0gW107XG4gICAgY29uc3QgdmlicmF0aW9uQWN0dWF0b3IgPSBcInZpYnJhdGlvbkFjdHVhdG9yXCIgaW4gZ2FtZXBhZCA/IGdhbWVwYWQudmlicmF0aW9uQWN0dWF0b3IgOiBudWxsO1xuICAgIGlmICh2aWJyYXRpb25BY3R1YXRvcilcbiAgICAgIGhhcHRpY0FjdHVhdG9ycy5wdXNoKHZpYnJhdGlvbkFjdHVhdG9yKTtcbiAgICBpZiAoZ2FtZXBhZC5oYXB0aWNBY3R1YXRvcnMpXG4gICAgICBoYXB0aWNBY3R1YXRvcnMucHVzaCguLi5nYW1lcGFkLmhhcHRpY0FjdHVhdG9ycyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBnYW1lcGFkLmlkLFxuICAgICAgaW5kZXg6IGdhbWVwYWQuaW5kZXgsXG4gICAgICBjb25uZWN0ZWQ6IGdhbWVwYWQuY29ubmVjdGVkLFxuICAgICAgbWFwcGluZzogZ2FtZXBhZC5tYXBwaW5nLFxuICAgICAgdGltZXN0YW1wOiBnYW1lcGFkLnRpbWVzdGFtcCxcbiAgICAgIHZpYnJhdGlvbkFjdHVhdG9yOiBnYW1lcGFkLnZpYnJhdGlvbkFjdHVhdG9yLFxuICAgICAgaGFwdGljQWN0dWF0b3JzLFxuICAgICAgYXhlczogZ2FtZXBhZC5heGVzLm1hcCgoYXhlcykgPT4gYXhlcyksXG4gICAgICBidXR0b25zOiBnYW1lcGFkLmJ1dHRvbnMubWFwKChidXR0b24pID0+ICh7IHByZXNzZWQ6IGJ1dHRvbi5wcmVzc2VkLCB0b3VjaGVkOiBidXR0b24udG91Y2hlZCwgdmFsdWU6IGJ1dHRvbi52YWx1ZSB9KSlcbiAgICB9O1xuICB9O1xuICBjb25zdCB1cGRhdGVHYW1lcGFkU3RhdGUgPSAoKSA9PiB7XG4gICAgY29uc3QgX2dhbWVwYWRzID0gKG5hdmlnYXRvciA9PSBudWxsID8gdm9pZCAwIDogbmF2aWdhdG9yLmdldEdhbWVwYWRzKCkpIHx8IFtdO1xuICAgIGZvciAoY29uc3QgZ2FtZXBhZCBvZiBfZ2FtZXBhZHMpIHtcbiAgICAgIGlmIChnYW1lcGFkICYmIGdhbWVwYWRzLnZhbHVlW2dhbWVwYWQuaW5kZXhdKVxuICAgICAgICBnYW1lcGFkcy52YWx1ZVtnYW1lcGFkLmluZGV4XSA9IHN0YXRlRnJvbUdhbWVwYWQoZ2FtZXBhZCk7XG4gICAgfVxuICB9O1xuICBjb25zdCB7IGlzQWN0aXZlLCBwYXVzZSwgcmVzdW1lIH0gPSB1c2VSYWZGbih1cGRhdGVHYW1lcGFkU3RhdGUpO1xuICBjb25zdCBvbkdhbWVwYWRDb25uZWN0ZWQgPSAoZ2FtZXBhZCkgPT4ge1xuICAgIGlmICghZ2FtZXBhZHMudmFsdWUuc29tZSgoeyBpbmRleCB9KSA9PiBpbmRleCA9PT0gZ2FtZXBhZC5pbmRleCkpIHtcbiAgICAgIGdhbWVwYWRzLnZhbHVlLnB1c2goc3RhdGVGcm9tR2FtZXBhZChnYW1lcGFkKSk7XG4gICAgICBvbkNvbm5lY3RlZEhvb2sudHJpZ2dlcihnYW1lcGFkLmluZGV4KTtcbiAgICB9XG4gICAgcmVzdW1lKCk7XG4gIH07XG4gIGNvbnN0IG9uR2FtZXBhZERpc2Nvbm5lY3RlZCA9IChnYW1lcGFkKSA9PiB7XG4gICAgZ2FtZXBhZHMudmFsdWUgPSBnYW1lcGFkcy52YWx1ZS5maWx0ZXIoKHgpID0+IHguaW5kZXggIT09IGdhbWVwYWQuaW5kZXgpO1xuICAgIG9uRGlzY29ubmVjdGVkSG9vay50cmlnZ2VyKGdhbWVwYWQuaW5kZXgpO1xuICB9O1xuICB1c2VFdmVudExpc3RlbmVyKFwiZ2FtZXBhZGNvbm5lY3RlZFwiLCAoZSkgPT4gb25HYW1lcGFkQ29ubmVjdGVkKGUuZ2FtZXBhZCkpO1xuICB1c2VFdmVudExpc3RlbmVyKFwiZ2FtZXBhZGRpc2Nvbm5lY3RlZFwiLCAoZSkgPT4gb25HYW1lcGFkRGlzY29ubmVjdGVkKGUuZ2FtZXBhZCkpO1xuICB0cnlPbk1vdW50ZWQoKCkgPT4ge1xuICAgIGNvbnN0IF9nYW1lcGFkcyA9IChuYXZpZ2F0b3IgPT0gbnVsbCA/IHZvaWQgMCA6IG5hdmlnYXRvci5nZXRHYW1lcGFkcygpKSB8fCBbXTtcbiAgICBmb3IgKGNvbnN0IGdhbWVwYWQgb2YgX2dhbWVwYWRzKSB7XG4gICAgICBpZiAoZ2FtZXBhZCAmJiBnYW1lcGFkcy52YWx1ZVtnYW1lcGFkLmluZGV4XSlcbiAgICAgICAgb25HYW1lcGFkQ29ubmVjdGVkKGdhbWVwYWQpO1xuICAgIH1cbiAgfSk7XG4gIHBhdXNlKCk7XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgb25Db25uZWN0ZWQ6IG9uQ29ubmVjdGVkSG9vay5vbixcbiAgICBvbkRpc2Nvbm5lY3RlZDogb25EaXNjb25uZWN0ZWRIb29rLm9uLFxuICAgIGdhbWVwYWRzLFxuICAgIHBhdXNlLFxuICAgIHJlc3VtZSxcbiAgICBpc0FjdGl2ZVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VHZW9sb2NhdGlvbihvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGVuYWJsZUhpZ2hBY2N1cmFjeSA9IHRydWUsXG4gICAgbWF4aW11bUFnZSA9IDNlNCxcbiAgICB0aW1lb3V0ID0gMjdlMyxcbiAgICBuYXZpZ2F0b3IgPSBkZWZhdWx0TmF2aWdhdG9yLFxuICAgIGltbWVkaWF0ZSA9IHRydWVcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IG5hdmlnYXRvciAmJiBcImdlb2xvY2F0aW9uXCIgaW4gbmF2aWdhdG9yKTtcbiAgY29uc3QgbG9jYXRlZEF0ID0gcmVmKG51bGwpO1xuICBjb25zdCBlcnJvciA9IHNoYWxsb3dSZWYobnVsbCk7XG4gIGNvbnN0IGNvb3JkcyA9IHJlZih7XG4gICAgYWNjdXJhY3k6IDAsXG4gICAgbGF0aXR1ZGU6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICBsb25naXR1ZGU6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICBhbHRpdHVkZTogbnVsbCxcbiAgICBhbHRpdHVkZUFjY3VyYWN5OiBudWxsLFxuICAgIGhlYWRpbmc6IG51bGwsXG4gICAgc3BlZWQ6IG51bGxcbiAgfSk7XG4gIGZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgbG9jYXRlZEF0LnZhbHVlID0gcG9zaXRpb24udGltZXN0YW1wO1xuICAgIGNvb3Jkcy52YWx1ZSA9IHBvc2l0aW9uLmNvb3JkcztcbiAgICBlcnJvci52YWx1ZSA9IG51bGw7XG4gIH1cbiAgbGV0IHdhdGNoZXI7XG4gIGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUpIHtcbiAgICAgIHdhdGNoZXIgPSBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24ud2F0Y2hQb3NpdGlvbihcbiAgICAgICAgdXBkYXRlUG9zaXRpb24sXG4gICAgICAgIChlcnIpID0+IGVycm9yLnZhbHVlID0gZXJyLFxuICAgICAgICB7XG4gICAgICAgICAgZW5hYmxlSGlnaEFjY3VyYWN5LFxuICAgICAgICAgIG1heGltdW1BZ2UsXG4gICAgICAgICAgdGltZW91dFxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAoaW1tZWRpYXRlKVxuICAgIHJlc3VtZSgpO1xuICBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICBpZiAod2F0Y2hlciAmJiBuYXZpZ2F0b3IpXG4gICAgICBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCh3YXRjaGVyKTtcbiAgfVxuICB0cnlPblNjb3BlRGlzcG9zZSgoKSA9PiB7XG4gICAgcGF1c2UoKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgY29vcmRzLFxuICAgIGxvY2F0ZWRBdCxcbiAgICBlcnJvcixcbiAgICByZXN1bWUsXG4gICAgcGF1c2VcbiAgfTtcbn1cblxuY29uc3QgZGVmYXVsdEV2ZW50cyQxID0gW1wibW91c2Vtb3ZlXCIsIFwibW91c2Vkb3duXCIsIFwicmVzaXplXCIsIFwia2V5ZG93blwiLCBcInRvdWNoc3RhcnRcIiwgXCJ3aGVlbFwiXTtcbmNvbnN0IG9uZU1pbnV0ZSA9IDZlNDtcbmZ1bmN0aW9uIHVzZUlkbGUodGltZW91dCA9IG9uZU1pbnV0ZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBpbml0aWFsU3RhdGUgPSBmYWxzZSxcbiAgICBsaXN0ZW5Gb3JWaXNpYmlsaXR5Q2hhbmdlID0gdHJ1ZSxcbiAgICBldmVudHMgPSBkZWZhdWx0RXZlbnRzJDEsXG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvdyxcbiAgICBldmVudEZpbHRlciA9IHRocm90dGxlRmlsdGVyKDUwKVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgaWRsZSA9IHJlZihpbml0aWFsU3RhdGUpO1xuICBjb25zdCBsYXN0QWN0aXZlID0gcmVmKHRpbWVzdGFtcCgpKTtcbiAgbGV0IHRpbWVyO1xuICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICBpZGxlLnZhbHVlID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4gaWRsZS52YWx1ZSA9IHRydWUsIHRpbWVvdXQpO1xuICB9O1xuICBjb25zdCBvbkV2ZW50ID0gY3JlYXRlRmlsdGVyV3JhcHBlcihcbiAgICBldmVudEZpbHRlcixcbiAgICAoKSA9PiB7XG4gICAgICBsYXN0QWN0aXZlLnZhbHVlID0gdGltZXN0YW1wKCk7XG4gICAgICByZXNldCgpO1xuICAgIH1cbiAgKTtcbiAgaWYgKHdpbmRvdykge1xuICAgIGNvbnN0IGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKVxuICAgICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIGV2ZW50LCBvbkV2ZW50LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgaWYgKGxpc3RlbkZvclZpc2liaWxpdHlDaGFuZ2UpIHtcbiAgICAgIHVzZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsIFwidmlzaWJpbGl0eWNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICAgIGlmICghZG9jdW1lbnQuaGlkZGVuKVxuICAgICAgICAgIG9uRXZlbnQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXNldCgpO1xuICB9XG4gIHJldHVybiB7XG4gICAgaWRsZSxcbiAgICBsYXN0QWN0aXZlLFxuICAgIHJlc2V0XG4gIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGxvYWRJbWFnZShvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgY29uc3QgeyBzcmMsIHNyY3NldCwgc2l6ZXMsIGNsYXNzOiBjbGF6eiwgbG9hZGluZywgY3Jvc3NvcmlnaW4sIHJlZmVycmVyUG9saWN5IH0gPSBvcHRpb25zO1xuICAgIGltZy5zcmMgPSBzcmM7XG4gICAgaWYgKHNyY3NldClcbiAgICAgIGltZy5zcmNzZXQgPSBzcmNzZXQ7XG4gICAgaWYgKHNpemVzKVxuICAgICAgaW1nLnNpemVzID0gc2l6ZXM7XG4gICAgaWYgKGNsYXp6KVxuICAgICAgaW1nLmNsYXNzTmFtZSA9IGNsYXp6O1xuICAgIGlmIChsb2FkaW5nKVxuICAgICAgaW1nLmxvYWRpbmcgPSBsb2FkaW5nO1xuICAgIGlmIChjcm9zc29yaWdpbilcbiAgICAgIGltZy5jcm9zc09yaWdpbiA9IGNyb3Nzb3JpZ2luO1xuICAgIGlmIChyZWZlcnJlclBvbGljeSlcbiAgICAgIGltZy5yZWZlcnJlclBvbGljeSA9IHJlZmVycmVyUG9saWN5O1xuICAgIGltZy5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKGltZyk7XG4gICAgaW1nLm9uZXJyb3IgPSByZWplY3Q7XG4gIH0pO1xufVxuZnVuY3Rpb24gdXNlSW1hZ2Uob3B0aW9ucywgYXN5bmNTdGF0ZU9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBzdGF0ZSA9IHVzZUFzeW5jU3RhdGUoXG4gICAgKCkgPT4gbG9hZEltYWdlKHRvVmFsdWUob3B0aW9ucykpLFxuICAgIHZvaWQgMCxcbiAgICB7XG4gICAgICByZXNldE9uRXhlY3V0ZTogdHJ1ZSxcbiAgICAgIC4uLmFzeW5jU3RhdGVPcHRpb25zXG4gICAgfVxuICApO1xuICB3YXRjaChcbiAgICAoKSA9PiB0b1ZhbHVlKG9wdGlvbnMpLFxuICAgICgpID0+IHN0YXRlLmV4ZWN1dGUoYXN5bmNTdGF0ZU9wdGlvbnMuZGVsYXkpLFxuICAgIHsgZGVlcDogdHJ1ZSB9XG4gICk7XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuY29uc3QgQVJSSVZFRF9TVEFURV9USFJFU0hPTERfUElYRUxTID0gMTtcbmZ1bmN0aW9uIHVzZVNjcm9sbChlbGVtZW50LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHRocm90dGxlID0gMCxcbiAgICBpZGxlID0gMjAwLFxuICAgIG9uU3RvcCA9IG5vb3AsXG4gICAgb25TY3JvbGwgPSBub29wLFxuICAgIG9mZnNldCA9IHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIGJvdHRvbTogMFxuICAgIH0sXG4gICAgZXZlbnRMaXN0ZW5lck9wdGlvbnMgPSB7XG4gICAgICBjYXB0dXJlOiBmYWxzZSxcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9LFxuICAgIGJlaGF2aW9yID0gXCJhdXRvXCIsXG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvdyxcbiAgICBvbkVycm9yID0gKGUpID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgaW50ZXJuYWxYID0gcmVmKDApO1xuICBjb25zdCBpbnRlcm5hbFkgPSByZWYoMCk7XG4gIGNvbnN0IHggPSBjb21wdXRlZCh7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIGludGVybmFsWC52YWx1ZTtcbiAgICB9LFxuICAgIHNldCh4Mikge1xuICAgICAgc2Nyb2xsVG8oeDIsIHZvaWQgMCk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgeSA9IGNvbXB1dGVkKHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gaW50ZXJuYWxZLnZhbHVlO1xuICAgIH0sXG4gICAgc2V0KHkyKSB7XG4gICAgICBzY3JvbGxUbyh2b2lkIDAsIHkyKTtcbiAgICB9XG4gIH0pO1xuICBmdW5jdGlvbiBzY3JvbGxUbyhfeCwgX3kpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgaWYgKCF3aW5kb3cpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgX2VsZW1lbnQgPSB0b1ZhbHVlKGVsZW1lbnQpO1xuICAgIGlmICghX2VsZW1lbnQpXG4gICAgICByZXR1cm47XG4gICAgKF9jID0gX2VsZW1lbnQgaW5zdGFuY2VvZiBEb2N1bWVudCA/IHdpbmRvdy5kb2N1bWVudC5ib2R5IDogX2VsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYy5zY3JvbGxUbyh7XG4gICAgICB0b3A6IChfYSA9IHRvVmFsdWUoX3kpKSAhPSBudWxsID8gX2EgOiB5LnZhbHVlLFxuICAgICAgbGVmdDogKF9iID0gdG9WYWx1ZShfeCkpICE9IG51bGwgPyBfYiA6IHgudmFsdWUsXG4gICAgICBiZWhhdmlvcjogdG9WYWx1ZShiZWhhdmlvcilcbiAgICB9KTtcbiAgICBjb25zdCBzY3JvbGxDb250YWluZXIgPSAoKF9kID0gX2VsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50LmRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2QuZG9jdW1lbnRFbGVtZW50KSB8fCAoX2VsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50LmRvY3VtZW50RWxlbWVudCkgfHwgX2VsZW1lbnQ7XG4gICAgaWYgKHggIT0gbnVsbClcbiAgICAgIGludGVybmFsWC52YWx1ZSA9IHNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0O1xuICAgIGlmICh5ICE9IG51bGwpXG4gICAgICBpbnRlcm5hbFkudmFsdWUgPSBzY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wO1xuICB9XG4gIGNvbnN0IGlzU2Nyb2xsaW5nID0gcmVmKGZhbHNlKTtcbiAgY29uc3QgYXJyaXZlZFN0YXRlID0gcmVhY3RpdmUoe1xuICAgIGxlZnQ6IHRydWUsXG4gICAgcmlnaHQ6IGZhbHNlLFxuICAgIHRvcDogdHJ1ZSxcbiAgICBib3R0b206IGZhbHNlXG4gIH0pO1xuICBjb25zdCBkaXJlY3Rpb25zID0gcmVhY3RpdmUoe1xuICAgIGxlZnQ6IGZhbHNlLFxuICAgIHJpZ2h0OiBmYWxzZSxcbiAgICB0b3A6IGZhbHNlLFxuICAgIGJvdHRvbTogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IG9uU2Nyb2xsRW5kID0gKGUpID0+IHtcbiAgICBpZiAoIWlzU2Nyb2xsaW5nLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGlzU2Nyb2xsaW5nLnZhbHVlID0gZmFsc2U7XG4gICAgZGlyZWN0aW9ucy5sZWZ0ID0gZmFsc2U7XG4gICAgZGlyZWN0aW9ucy5yaWdodCA9IGZhbHNlO1xuICAgIGRpcmVjdGlvbnMudG9wID0gZmFsc2U7XG4gICAgZGlyZWN0aW9ucy5ib3R0b20gPSBmYWxzZTtcbiAgICBvblN0b3AoZSk7XG4gIH07XG4gIGNvbnN0IG9uU2Nyb2xsRW5kRGVib3VuY2VkID0gdXNlRGVib3VuY2VGbihvblNjcm9sbEVuZCwgdGhyb3R0bGUgKyBpZGxlKTtcbiAgY29uc3Qgc2V0QXJyaXZlZFN0YXRlID0gKHRhcmdldCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIXdpbmRvdylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlbCA9ICgoX2EgPSB0YXJnZXQgPT0gbnVsbCA/IHZvaWQgMCA6IHRhcmdldC5kb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRvY3VtZW50RWxlbWVudCkgfHwgKHRhcmdldCA9PSBudWxsID8gdm9pZCAwIDogdGFyZ2V0LmRvY3VtZW50RWxlbWVudCkgfHwgdW5yZWZFbGVtZW50KHRhcmdldCk7XG4gICAgY29uc3QgeyBkaXNwbGF5LCBmbGV4RGlyZWN0aW9uIH0gPSBnZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICBjb25zdCBzY3JvbGxMZWZ0ID0gZWwuc2Nyb2xsTGVmdDtcbiAgICBkaXJlY3Rpb25zLmxlZnQgPSBzY3JvbGxMZWZ0IDwgaW50ZXJuYWxYLnZhbHVlO1xuICAgIGRpcmVjdGlvbnMucmlnaHQgPSBzY3JvbGxMZWZ0ID4gaW50ZXJuYWxYLnZhbHVlO1xuICAgIGNvbnN0IGxlZnQgPSBNYXRoLmFicyhzY3JvbGxMZWZ0KSA8PSAob2Zmc2V0LmxlZnQgfHwgMCk7XG4gICAgY29uc3QgcmlnaHQgPSBNYXRoLmFicyhzY3JvbGxMZWZ0KSArIGVsLmNsaWVudFdpZHRoID49IGVsLnNjcm9sbFdpZHRoIC0gKG9mZnNldC5yaWdodCB8fCAwKSAtIEFSUklWRURfU1RBVEVfVEhSRVNIT0xEX1BJWEVMUztcbiAgICBpZiAoZGlzcGxheSA9PT0gXCJmbGV4XCIgJiYgZmxleERpcmVjdGlvbiA9PT0gXCJyb3ctcmV2ZXJzZVwiKSB7XG4gICAgICBhcnJpdmVkU3RhdGUubGVmdCA9IHJpZ2h0O1xuICAgICAgYXJyaXZlZFN0YXRlLnJpZ2h0ID0gbGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJyaXZlZFN0YXRlLmxlZnQgPSBsZWZ0O1xuICAgICAgYXJyaXZlZFN0YXRlLnJpZ2h0ID0gcmlnaHQ7XG4gICAgfVxuICAgIGludGVybmFsWC52YWx1ZSA9IHNjcm9sbExlZnQ7XG4gICAgbGV0IHNjcm9sbFRvcCA9IGVsLnNjcm9sbFRvcDtcbiAgICBpZiAodGFyZ2V0ID09PSB3aW5kb3cuZG9jdW1lbnQgJiYgIXNjcm9sbFRvcClcbiAgICAgIHNjcm9sbFRvcCA9IHdpbmRvdy5kb2N1bWVudC5ib2R5LnNjcm9sbFRvcDtcbiAgICBkaXJlY3Rpb25zLnRvcCA9IHNjcm9sbFRvcCA8IGludGVybmFsWS52YWx1ZTtcbiAgICBkaXJlY3Rpb25zLmJvdHRvbSA9IHNjcm9sbFRvcCA+IGludGVybmFsWS52YWx1ZTtcbiAgICBjb25zdCB0b3AgPSBNYXRoLmFicyhzY3JvbGxUb3ApIDw9IChvZmZzZXQudG9wIHx8IDApO1xuICAgIGNvbnN0IGJvdHRvbSA9IE1hdGguYWJzKHNjcm9sbFRvcCkgKyBlbC5jbGllbnRIZWlnaHQgPj0gZWwuc2Nyb2xsSGVpZ2h0IC0gKG9mZnNldC5ib3R0b20gfHwgMCkgLSBBUlJJVkVEX1NUQVRFX1RIUkVTSE9MRF9QSVhFTFM7XG4gICAgaWYgKGRpc3BsYXkgPT09IFwiZmxleFwiICYmIGZsZXhEaXJlY3Rpb24gPT09IFwiY29sdW1uLXJldmVyc2VcIikge1xuICAgICAgYXJyaXZlZFN0YXRlLnRvcCA9IGJvdHRvbTtcbiAgICAgIGFycml2ZWRTdGF0ZS5ib3R0b20gPSB0b3A7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFycml2ZWRTdGF0ZS50b3AgPSB0b3A7XG4gICAgICBhcnJpdmVkU3RhdGUuYm90dG9tID0gYm90dG9tO1xuICAgIH1cbiAgICBpbnRlcm5hbFkudmFsdWUgPSBzY3JvbGxUb3A7XG4gIH07XG4gIGNvbnN0IG9uU2Nyb2xsSGFuZGxlciA9IChlKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghd2luZG93KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGV2ZW50VGFyZ2V0ID0gKF9hID0gZS50YXJnZXQuZG9jdW1lbnRFbGVtZW50KSAhPSBudWxsID8gX2EgOiBlLnRhcmdldDtcbiAgICBzZXRBcnJpdmVkU3RhdGUoZXZlbnRUYXJnZXQpO1xuICAgIGlzU2Nyb2xsaW5nLnZhbHVlID0gdHJ1ZTtcbiAgICBvblNjcm9sbEVuZERlYm91bmNlZChlKTtcbiAgICBvblNjcm9sbChlKTtcbiAgfTtcbiAgdXNlRXZlbnRMaXN0ZW5lcihcbiAgICBlbGVtZW50LFxuICAgIFwic2Nyb2xsXCIsXG4gICAgdGhyb3R0bGUgPyB1c2VUaHJvdHRsZUZuKG9uU2Nyb2xsSGFuZGxlciwgdGhyb3R0bGUsIHRydWUsIGZhbHNlKSA6IG9uU2Nyb2xsSGFuZGxlcixcbiAgICBldmVudExpc3RlbmVyT3B0aW9uc1xuICApO1xuICB0cnlPbk1vdW50ZWQoKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBfZWxlbWVudCA9IHRvVmFsdWUoZWxlbWVudCk7XG4gICAgICBpZiAoIV9lbGVtZW50KVxuICAgICAgICByZXR1cm47XG4gICAgICBzZXRBcnJpdmVkU3RhdGUoX2VsZW1lbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG9uRXJyb3IoZSk7XG4gICAgfVxuICB9KTtcbiAgdXNlRXZlbnRMaXN0ZW5lcihcbiAgICBlbGVtZW50LFxuICAgIFwic2Nyb2xsZW5kXCIsXG4gICAgb25TY3JvbGxFbmQsXG4gICAgZXZlbnRMaXN0ZW5lck9wdGlvbnNcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHksXG4gICAgaXNTY3JvbGxpbmcsXG4gICAgYXJyaXZlZFN0YXRlLFxuICAgIGRpcmVjdGlvbnMsXG4gICAgbWVhc3VyZSgpIHtcbiAgICAgIGNvbnN0IF9lbGVtZW50ID0gdG9WYWx1ZShlbGVtZW50KTtcbiAgICAgIGlmICh3aW5kb3cgJiYgX2VsZW1lbnQpXG4gICAgICAgIHNldEFycml2ZWRTdGF0ZShfZWxlbWVudCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRWxlbWVudChlbCkge1xuICBpZiAodHlwZW9mIFdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlbCBpbnN0YW5jZW9mIFdpbmRvdylcbiAgICByZXR1cm4gZWwuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICBpZiAodHlwZW9mIERvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGVsIGluc3RhbmNlb2YgRG9jdW1lbnQpXG4gICAgcmV0dXJuIGVsLmRvY3VtZW50RWxlbWVudDtcbiAgcmV0dXJuIGVsO1xufVxuXG5mdW5jdGlvbiB1c2VJbmZpbml0ZVNjcm9sbChlbGVtZW50LCBvbkxvYWRNb3JlLCBvcHRpb25zID0ge30pIHtcbiAgdmFyIF9hO1xuICBjb25zdCB7XG4gICAgZGlyZWN0aW9uID0gXCJib3R0b21cIixcbiAgICBpbnRlcnZhbCA9IDEwMCxcbiAgICBjYW5Mb2FkTW9yZSA9ICgpID0+IHRydWVcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHN0YXRlID0gcmVhY3RpdmUodXNlU2Nyb2xsKFxuICAgIGVsZW1lbnQsXG4gICAge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIG9mZnNldDoge1xuICAgICAgICBbZGlyZWN0aW9uXTogKF9hID0gb3B0aW9ucy5kaXN0YW5jZSkgIT0gbnVsbCA/IF9hIDogMCxcbiAgICAgICAgLi4ub3B0aW9ucy5vZmZzZXRcbiAgICAgIH1cbiAgICB9XG4gICkpO1xuICBjb25zdCBwcm9taXNlID0gcmVmKCk7XG4gIGNvbnN0IGlzTG9hZGluZyA9IGNvbXB1dGVkKCgpID0+ICEhcHJvbWlzZS52YWx1ZSk7XG4gIGNvbnN0IG9ic2VydmVkRWxlbWVudCA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICByZXR1cm4gcmVzb2x2ZUVsZW1lbnQodG9WYWx1ZShlbGVtZW50KSk7XG4gIH0pO1xuICBjb25zdCBpc0VsZW1lbnRWaXNpYmxlID0gdXNlRWxlbWVudFZpc2liaWxpdHkob2JzZXJ2ZWRFbGVtZW50KTtcbiAgZnVuY3Rpb24gY2hlY2tBbmRMb2FkKCkge1xuICAgIHN0YXRlLm1lYXN1cmUoKTtcbiAgICBpZiAoIW9ic2VydmVkRWxlbWVudC52YWx1ZSB8fCAhaXNFbGVtZW50VmlzaWJsZS52YWx1ZSB8fCAhY2FuTG9hZE1vcmUob2JzZXJ2ZWRFbGVtZW50LnZhbHVlKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHNjcm9sbEhlaWdodCwgY2xpZW50SGVpZ2h0LCBzY3JvbGxXaWR0aCwgY2xpZW50V2lkdGggfSA9IG9ic2VydmVkRWxlbWVudC52YWx1ZTtcbiAgICBjb25zdCBpc05hcnJvd2VyID0gZGlyZWN0aW9uID09PSBcImJvdHRvbVwiIHx8IGRpcmVjdGlvbiA9PT0gXCJ0b3BcIiA/IHNjcm9sbEhlaWdodCA8PSBjbGllbnRIZWlnaHQgOiBzY3JvbGxXaWR0aCA8PSBjbGllbnRXaWR0aDtcbiAgICBpZiAoc3RhdGUuYXJyaXZlZFN0YXRlW2RpcmVjdGlvbl0gfHwgaXNOYXJyb3dlcikge1xuICAgICAgaWYgKCFwcm9taXNlLnZhbHVlKSB7XG4gICAgICAgIHByb21pc2UudmFsdWUgPSBQcm9taXNlLmFsbChbXG4gICAgICAgICAgb25Mb2FkTW9yZShzdGF0ZSksXG4gICAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgaW50ZXJ2YWwpKVxuICAgICAgICBdKS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICBwcm9taXNlLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICBuZXh0VGljaygoKSA9PiBjaGVja0FuZExvYWQoKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB3YXRjaChcbiAgICAoKSA9PiBbc3RhdGUuYXJyaXZlZFN0YXRlW2RpcmVjdGlvbl0sIGlzRWxlbWVudFZpc2libGUudmFsdWVdLFxuICAgIGNoZWNrQW5kTG9hZCxcbiAgICB7IGltbWVkaWF0ZTogdHJ1ZSB9XG4gICk7XG4gIHJldHVybiB7XG4gICAgaXNMb2FkaW5nXG4gIH07XG59XG5cbmNvbnN0IGRlZmF1bHRFdmVudHMgPSBbXCJtb3VzZWRvd25cIiwgXCJtb3VzZXVwXCIsIFwia2V5ZG93blwiLCBcImtleXVwXCJdO1xuZnVuY3Rpb24gdXNlS2V5TW9kaWZpZXIobW9kaWZpZXIsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgZXZlbnRzID0gZGVmYXVsdEV2ZW50cyxcbiAgICBkb2N1bWVudCA9IGRlZmF1bHREb2N1bWVudCxcbiAgICBpbml0aWFsID0gbnVsbFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgc3RhdGUgPSByZWYoaW5pdGlhbCk7XG4gIGlmIChkb2N1bWVudCkge1xuICAgIGV2ZW50cy5mb3JFYWNoKChsaXN0ZW5lckV2ZW50KSA9PiB7XG4gICAgICB1c2VFdmVudExpc3RlbmVyKGRvY3VtZW50LCBsaXN0ZW5lckV2ZW50LCAoZXZ0KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgZXZ0LmdldE1vZGlmaWVyU3RhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICBzdGF0ZS52YWx1ZSA9IGV2dC5nZXRNb2RpZmllclN0YXRlKG1vZGlmaWVyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuZnVuY3Rpb24gdXNlTG9jYWxTdG9yYWdlKGtleSwgaW5pdGlhbFZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB3aW5kb3cgPSBkZWZhdWx0V2luZG93IH0gPSBvcHRpb25zO1xuICByZXR1cm4gdXNlU3RvcmFnZShrZXksIGluaXRpYWxWYWx1ZSwgd2luZG93ID09IG51bGwgPyB2b2lkIDAgOiB3aW5kb3cubG9jYWxTdG9yYWdlLCBvcHRpb25zKTtcbn1cblxuY29uc3QgRGVmYXVsdE1hZ2ljS2V5c0FsaWFzTWFwID0ge1xuICBjdHJsOiBcImNvbnRyb2xcIixcbiAgY29tbWFuZDogXCJtZXRhXCIsXG4gIGNtZDogXCJtZXRhXCIsXG4gIG9wdGlvbjogXCJhbHRcIixcbiAgdXA6IFwiYXJyb3d1cFwiLFxuICBkb3duOiBcImFycm93ZG93blwiLFxuICBsZWZ0OiBcImFycm93bGVmdFwiLFxuICByaWdodDogXCJhcnJvd3JpZ2h0XCJcbn07XG5cbmZ1bmN0aW9uIHVzZU1hZ2ljS2V5cyhvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHJlYWN0aXZlOiB1c2VSZWFjdGl2ZSA9IGZhbHNlLFxuICAgIHRhcmdldCA9IGRlZmF1bHRXaW5kb3csXG4gICAgYWxpYXNNYXAgPSBEZWZhdWx0TWFnaWNLZXlzQWxpYXNNYXAsXG4gICAgcGFzc2l2ZSA9IHRydWUsXG4gICAgb25FdmVudEZpcmVkID0gbm9vcFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgY3VycmVudCA9IHJlYWN0aXZlKC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICBjb25zdCBvYmogPSB7XG4gICAgdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH0sXG4gICAgY3VycmVudFxuICB9O1xuICBjb25zdCByZWZzID0gdXNlUmVhY3RpdmUgPyByZWFjdGl2ZShvYmopIDogb2JqO1xuICBjb25zdCBtZXRhRGVwcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IHVzZWRLZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZnVuY3Rpb24gc2V0UmVmcyhrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiByZWZzKSB7XG4gICAgICBpZiAodXNlUmVhY3RpdmUpXG4gICAgICAgIHJlZnNba2V5XSA9IHZhbHVlO1xuICAgICAgZWxzZVxuICAgICAgICByZWZzW2tleV0udmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgY3VycmVudC5jbGVhcigpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHVzZWRLZXlzKVxuICAgICAgc2V0UmVmcyhrZXksIGZhbHNlKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVSZWZzKGUsIHZhbHVlKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBrZXkgPSAoX2EgPSBlLmtleSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgY29kZSA9IChfYiA9IGUuY29kZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgdmFsdWVzID0gW2NvZGUsIGtleV0uZmlsdGVyKEJvb2xlYW4pO1xuICAgIGlmIChrZXkpIHtcbiAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgY3VycmVudC5hZGQoa2V5KTtcbiAgICAgIGVsc2VcbiAgICAgICAgY3VycmVudC5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkyIG9mIHZhbHVlcykge1xuICAgICAgdXNlZEtleXMuYWRkKGtleTIpO1xuICAgICAgc2V0UmVmcyhrZXkyLCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChrZXkgPT09IFwibWV0YVwiICYmICF2YWx1ZSkge1xuICAgICAgbWV0YURlcHMuZm9yRWFjaCgoa2V5MikgPT4ge1xuICAgICAgICBjdXJyZW50LmRlbGV0ZShrZXkyKTtcbiAgICAgICAgc2V0UmVmcyhrZXkyLCBmYWxzZSk7XG4gICAgICB9KTtcbiAgICAgIG1ldGFEZXBzLmNsZWFyKCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZS5nZXRNb2RpZmllclN0YXRlID09PSBcImZ1bmN0aW9uXCIgJiYgZS5nZXRNb2RpZmllclN0YXRlKFwiTWV0YVwiKSAmJiB2YWx1ZSkge1xuICAgICAgWy4uLmN1cnJlbnQsIC4uLnZhbHVlc10uZm9yRWFjaCgoa2V5MikgPT4gbWV0YURlcHMuYWRkKGtleTIpKTtcbiAgICB9XG4gIH1cbiAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFwia2V5ZG93blwiLCAoZSkgPT4ge1xuICAgIHVwZGF0ZVJlZnMoZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIG9uRXZlbnRGaXJlZChlKTtcbiAgfSwgeyBwYXNzaXZlIH0pO1xuICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJrZXl1cFwiLCAoZSkgPT4ge1xuICAgIHVwZGF0ZVJlZnMoZSwgZmFsc2UpO1xuICAgIHJldHVybiBvbkV2ZW50RmlyZWQoZSk7XG4gIH0sIHsgcGFzc2l2ZSB9KTtcbiAgdXNlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgcmVzZXQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgdXNlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHJlc2V0LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KFxuICAgIHJlZnMsXG4gICAge1xuICAgICAgZ2V0KHRhcmdldDIsIHByb3AsIHJlYykge1xuICAgICAgICBpZiAodHlwZW9mIHByb3AgIT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldDIsIHByb3AsIHJlYyk7XG4gICAgICAgIHByb3AgPSBwcm9wLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChwcm9wIGluIGFsaWFzTWFwKVxuICAgICAgICAgIHByb3AgPSBhbGlhc01hcFtwcm9wXTtcbiAgICAgICAgaWYgKCEocHJvcCBpbiByZWZzKSkge1xuICAgICAgICAgIGlmICgvWytfLV0vLnRlc3QocHJvcCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBwcm9wLnNwbGl0KC9bK18tXS9nKS5tYXAoKGkpID0+IGkudHJpbSgpKTtcbiAgICAgICAgICAgIHJlZnNbcHJvcF0gPSBjb21wdXRlZCgoKSA9PiBrZXlzLmV2ZXJ5KChrZXkpID0+IHRvVmFsdWUocHJveHlba2V5XSkpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVmc1twcm9wXSA9IHJlZihmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHIgPSBSZWZsZWN0LmdldCh0YXJnZXQyLCBwcm9wLCByZWMpO1xuICAgICAgICByZXR1cm4gdXNlUmVhY3RpdmUgPyB0b1ZhbHVlKHIpIDogcjtcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIHJldHVybiBwcm94eTtcbn1cblxuZnVuY3Rpb24gdXNpbmdFbFJlZihzb3VyY2UsIGNiKSB7XG4gIGlmICh0b1ZhbHVlKHNvdXJjZSkpXG4gICAgY2IodG9WYWx1ZShzb3VyY2UpKTtcbn1cbmZ1bmN0aW9uIHRpbWVSYW5nZVRvQXJyYXkodGltZVJhbmdlcykge1xuICBsZXQgcmFuZ2VzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGltZVJhbmdlcy5sZW5ndGg7ICsraSlcbiAgICByYW5nZXMgPSBbLi4ucmFuZ2VzLCBbdGltZVJhbmdlcy5zdGFydChpKSwgdGltZVJhbmdlcy5lbmQoaSldXTtcbiAgcmV0dXJuIHJhbmdlcztcbn1cbmZ1bmN0aW9uIHRyYWNrc1RvQXJyYXkodHJhY2tzKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKHRyYWNrcykubWFwKCh7IGxhYmVsLCBraW5kLCBsYW5ndWFnZSwgbW9kZSwgYWN0aXZlQ3VlcywgY3VlcywgaW5CYW5kTWV0YWRhdGFUcmFja0Rpc3BhdGNoVHlwZSB9LCBpZCkgPT4gKHsgaWQsIGxhYmVsLCBraW5kLCBsYW5ndWFnZSwgbW9kZSwgYWN0aXZlQ3VlcywgY3VlcywgaW5CYW5kTWV0YWRhdGFUcmFja0Rpc3BhdGNoVHlwZSB9KSk7XG59XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgc3JjOiBcIlwiLFxuICB0cmFja3M6IFtdXG59O1xuZnVuY3Rpb24gdXNlTWVkaWFDb250cm9scyh0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICB0YXJnZXQgPSB0b1JlZih0YXJnZXQpO1xuICBvcHRpb25zID0ge1xuICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgY29uc3Qge1xuICAgIGRvY3VtZW50ID0gZGVmYXVsdERvY3VtZW50XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBjdXJyZW50VGltZSA9IHJlZigwKTtcbiAgY29uc3QgZHVyYXRpb24gPSByZWYoMCk7XG4gIGNvbnN0IHNlZWtpbmcgPSByZWYoZmFsc2UpO1xuICBjb25zdCB2b2x1bWUgPSByZWYoMSk7XG4gIGNvbnN0IHdhaXRpbmcgPSByZWYoZmFsc2UpO1xuICBjb25zdCBlbmRlZCA9IHJlZihmYWxzZSk7XG4gIGNvbnN0IHBsYXlpbmcgPSByZWYoZmFsc2UpO1xuICBjb25zdCByYXRlID0gcmVmKDEpO1xuICBjb25zdCBzdGFsbGVkID0gcmVmKGZhbHNlKTtcbiAgY29uc3QgYnVmZmVyZWQgPSByZWYoW10pO1xuICBjb25zdCB0cmFja3MgPSByZWYoW10pO1xuICBjb25zdCBzZWxlY3RlZFRyYWNrID0gcmVmKC0xKTtcbiAgY29uc3QgaXNQaWN0dXJlSW5QaWN0dXJlID0gcmVmKGZhbHNlKTtcbiAgY29uc3QgbXV0ZWQgPSByZWYoZmFsc2UpO1xuICBjb25zdCBzdXBwb3J0c1BpY3R1cmVJblBpY3R1cmUgPSBkb2N1bWVudCAmJiBcInBpY3R1cmVJblBpY3R1cmVFbmFibGVkXCIgaW4gZG9jdW1lbnQ7XG4gIGNvbnN0IHNvdXJjZUVycm9yRXZlbnQgPSBjcmVhdGVFdmVudEhvb2soKTtcbiAgY29uc3QgZGlzYWJsZVRyYWNrID0gKHRyYWNrKSA9PiB7XG4gICAgdXNpbmdFbFJlZih0YXJnZXQsIChlbCkgPT4ge1xuICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgIGNvbnN0IGlkID0gdHlwZW9mIHRyYWNrID09PSBcIm51bWJlclwiID8gdHJhY2sgOiB0cmFjay5pZDtcbiAgICAgICAgZWwudGV4dFRyYWNrc1tpZF0ubW9kZSA9IFwiZGlzYWJsZWRcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWwudGV4dFRyYWNrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBlbC50ZXh0VHJhY2tzW2ldLm1vZGUgPSBcImRpc2FibGVkXCI7XG4gICAgICB9XG4gICAgICBzZWxlY3RlZFRyYWNrLnZhbHVlID0gLTE7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IGVuYWJsZVRyYWNrID0gKHRyYWNrLCBkaXNhYmxlVHJhY2tzID0gdHJ1ZSkgPT4ge1xuICAgIHVzaW5nRWxSZWYodGFyZ2V0LCAoZWwpID0+IHtcbiAgICAgIGNvbnN0IGlkID0gdHlwZW9mIHRyYWNrID09PSBcIm51bWJlclwiID8gdHJhY2sgOiB0cmFjay5pZDtcbiAgICAgIGlmIChkaXNhYmxlVHJhY2tzKVxuICAgICAgICBkaXNhYmxlVHJhY2soKTtcbiAgICAgIGVsLnRleHRUcmFja3NbaWRdLm1vZGUgPSBcInNob3dpbmdcIjtcbiAgICAgIHNlbGVjdGVkVHJhY2sudmFsdWUgPSBpZDtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgdG9nZ2xlUGljdHVyZUluUGljdHVyZSA9ICgpID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdXNpbmdFbFJlZih0YXJnZXQsIGFzeW5jIChlbCkgPT4ge1xuICAgICAgICBpZiAoc3VwcG9ydHNQaWN0dXJlSW5QaWN0dXJlKSB7XG4gICAgICAgICAgaWYgKCFpc1BpY3R1cmVJblBpY3R1cmUudmFsdWUpIHtcbiAgICAgICAgICAgIGVsLnJlcXVlc3RQaWN0dXJlSW5QaWN0dXJlKCkudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb2N1bWVudC5leGl0UGljdHVyZUluUGljdHVyZSgpLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICB3YXRjaEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFkb2N1bWVudClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlbCA9IHRvVmFsdWUodGFyZ2V0KTtcbiAgICBpZiAoIWVsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHNyYyA9IHRvVmFsdWUob3B0aW9ucy5zcmMpO1xuICAgIGxldCBzb3VyY2VzID0gW107XG4gICAgaWYgKCFzcmMpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBzcmMgPT09IFwic3RyaW5nXCIpXG4gICAgICBzb3VyY2VzID0gW3sgc3JjIH1dO1xuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc3JjKSlcbiAgICAgIHNvdXJjZXMgPSBzcmM7XG4gICAgZWxzZSBpZiAoaXNPYmplY3Qoc3JjKSlcbiAgICAgIHNvdXJjZXMgPSBbc3JjXTtcbiAgICBlbC5xdWVyeVNlbGVjdG9yQWxsKFwic291cmNlXCIpLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHNvdXJjZUVycm9yRXZlbnQudHJpZ2dlcik7XG4gICAgICBlLnJlbW92ZSgpO1xuICAgIH0pO1xuICAgIHNvdXJjZXMuZm9yRWFjaCgoeyBzcmM6IHNyYzIsIHR5cGUgfSkgPT4ge1xuICAgICAgY29uc3Qgc291cmNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNvdXJjZVwiKTtcbiAgICAgIHNvdXJjZS5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgc3JjMik7XG4gICAgICBzb3VyY2Uuc2V0QXR0cmlidXRlKFwidHlwZVwiLCB0eXBlIHx8IFwiXCIpO1xuICAgICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBzb3VyY2VFcnJvckV2ZW50LnRyaWdnZXIpO1xuICAgICAgZWwuYXBwZW5kQ2hpbGQoc291cmNlKTtcbiAgICB9KTtcbiAgICBlbC5sb2FkKCk7XG4gIH0pO1xuICB0cnlPblNjb3BlRGlzcG9zZSgoKSA9PiB7XG4gICAgY29uc3QgZWwgPSB0b1ZhbHVlKHRhcmdldCk7XG4gICAgaWYgKCFlbClcbiAgICAgIHJldHVybjtcbiAgICBlbC5xdWVyeVNlbGVjdG9yQWxsKFwic291cmNlXCIpLmZvckVhY2goKGUpID0+IGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHNvdXJjZUVycm9yRXZlbnQudHJpZ2dlcikpO1xuICB9KTtcbiAgd2F0Y2goW3RhcmdldCwgdm9sdW1lXSwgKCkgPT4ge1xuICAgIGNvbnN0IGVsID0gdG9WYWx1ZSh0YXJnZXQpO1xuICAgIGlmICghZWwpXG4gICAgICByZXR1cm47XG4gICAgZWwudm9sdW1lID0gdm9sdW1lLnZhbHVlO1xuICB9KTtcbiAgd2F0Y2goW3RhcmdldCwgbXV0ZWRdLCAoKSA9PiB7XG4gICAgY29uc3QgZWwgPSB0b1ZhbHVlKHRhcmdldCk7XG4gICAgaWYgKCFlbClcbiAgICAgIHJldHVybjtcbiAgICBlbC5tdXRlZCA9IG11dGVkLnZhbHVlO1xuICB9KTtcbiAgd2F0Y2goW3RhcmdldCwgcmF0ZV0sICgpID0+IHtcbiAgICBjb25zdCBlbCA9IHRvVmFsdWUodGFyZ2V0KTtcbiAgICBpZiAoIWVsKVxuICAgICAgcmV0dXJuO1xuICAgIGVsLnBsYXliYWNrUmF0ZSA9IHJhdGUudmFsdWU7XG4gIH0pO1xuICB3YXRjaEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFkb2N1bWVudClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ZXh0VHJhY2tzID0gdG9WYWx1ZShvcHRpb25zLnRyYWNrcyk7XG4gICAgY29uc3QgZWwgPSB0b1ZhbHVlKHRhcmdldCk7XG4gICAgaWYgKCF0ZXh0VHJhY2tzIHx8ICF0ZXh0VHJhY2tzLmxlbmd0aCB8fCAhZWwpXG4gICAgICByZXR1cm47XG4gICAgZWwucXVlcnlTZWxlY3RvckFsbChcInRyYWNrXCIpLmZvckVhY2goKGUpID0+IGUucmVtb3ZlKCkpO1xuICAgIHRleHRUcmFja3MuZm9yRWFjaCgoeyBkZWZhdWx0OiBpc0RlZmF1bHQsIGtpbmQsIGxhYmVsLCBzcmMsIHNyY0xhbmcgfSwgaSkgPT4ge1xuICAgICAgY29uc3QgdHJhY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidHJhY2tcIik7XG4gICAgICB0cmFjay5kZWZhdWx0ID0gaXNEZWZhdWx0IHx8IGZhbHNlO1xuICAgICAgdHJhY2sua2luZCA9IGtpbmQ7XG4gICAgICB0cmFjay5sYWJlbCA9IGxhYmVsO1xuICAgICAgdHJhY2suc3JjID0gc3JjO1xuICAgICAgdHJhY2suc3JjbGFuZyA9IHNyY0xhbmc7XG4gICAgICBpZiAodHJhY2suZGVmYXVsdClcbiAgICAgICAgc2VsZWN0ZWRUcmFjay52YWx1ZSA9IGk7XG4gICAgICBlbC5hcHBlbmRDaGlsZCh0cmFjayk7XG4gICAgfSk7XG4gIH0pO1xuICBjb25zdCB7IGlnbm9yZVVwZGF0ZXM6IGlnbm9yZUN1cnJlbnRUaW1lVXBkYXRlcyB9ID0gd2F0Y2hJZ25vcmFibGUoY3VycmVudFRpbWUsICh0aW1lKSA9PiB7XG4gICAgY29uc3QgZWwgPSB0b1ZhbHVlKHRhcmdldCk7XG4gICAgaWYgKCFlbClcbiAgICAgIHJldHVybjtcbiAgICBlbC5jdXJyZW50VGltZSA9IHRpbWU7XG4gIH0pO1xuICBjb25zdCB7IGlnbm9yZVVwZGF0ZXM6IGlnbm9yZVBsYXlpbmdVcGRhdGVzIH0gPSB3YXRjaElnbm9yYWJsZShwbGF5aW5nLCAoaXNQbGF5aW5nKSA9PiB7XG4gICAgY29uc3QgZWwgPSB0b1ZhbHVlKHRhcmdldCk7XG4gICAgaWYgKCFlbClcbiAgICAgIHJldHVybjtcbiAgICBpc1BsYXlpbmcgPyBlbC5wbGF5KCkgOiBlbC5wYXVzZSgpO1xuICB9KTtcbiAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFwidGltZXVwZGF0ZVwiLCAoKSA9PiBpZ25vcmVDdXJyZW50VGltZVVwZGF0ZXMoKCkgPT4gY3VycmVudFRpbWUudmFsdWUgPSB0b1ZhbHVlKHRhcmdldCkuY3VycmVudFRpbWUpKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFwiZHVyYXRpb25jaGFuZ2VcIiwgKCkgPT4gZHVyYXRpb24udmFsdWUgPSB0b1ZhbHVlKHRhcmdldCkuZHVyYXRpb24pO1xuICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJwcm9ncmVzc1wiLCAoKSA9PiBidWZmZXJlZC52YWx1ZSA9IHRpbWVSYW5nZVRvQXJyYXkodG9WYWx1ZSh0YXJnZXQpLmJ1ZmZlcmVkKSk7XG4gIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcInNlZWtpbmdcIiwgKCkgPT4gc2Vla2luZy52YWx1ZSA9IHRydWUpO1xuICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJzZWVrZWRcIiwgKCkgPT4gc2Vla2luZy52YWx1ZSA9IGZhbHNlKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFtcIndhaXRpbmdcIiwgXCJsb2Fkc3RhcnRcIl0sICgpID0+IHtcbiAgICB3YWl0aW5nLnZhbHVlID0gdHJ1ZTtcbiAgICBpZ25vcmVQbGF5aW5nVXBkYXRlcygoKSA9PiBwbGF5aW5nLnZhbHVlID0gZmFsc2UpO1xuICB9KTtcbiAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFwibG9hZGVkZGF0YVwiLCAoKSA9PiB3YWl0aW5nLnZhbHVlID0gZmFsc2UpO1xuICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJwbGF5aW5nXCIsICgpID0+IHtcbiAgICB3YWl0aW5nLnZhbHVlID0gZmFsc2U7XG4gICAgZW5kZWQudmFsdWUgPSBmYWxzZTtcbiAgICBpZ25vcmVQbGF5aW5nVXBkYXRlcygoKSA9PiBwbGF5aW5nLnZhbHVlID0gdHJ1ZSk7XG4gIH0pO1xuICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJyYXRlY2hhbmdlXCIsICgpID0+IHJhdGUudmFsdWUgPSB0b1ZhbHVlKHRhcmdldCkucGxheWJhY2tSYXRlKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFwic3RhbGxlZFwiLCAoKSA9PiBzdGFsbGVkLnZhbHVlID0gdHJ1ZSk7XG4gIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcImVuZGVkXCIsICgpID0+IGVuZGVkLnZhbHVlID0gdHJ1ZSk7XG4gIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcInBhdXNlXCIsICgpID0+IGlnbm9yZVBsYXlpbmdVcGRhdGVzKCgpID0+IHBsYXlpbmcudmFsdWUgPSBmYWxzZSkpO1xuICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJwbGF5XCIsICgpID0+IGlnbm9yZVBsYXlpbmdVcGRhdGVzKCgpID0+IHBsYXlpbmcudmFsdWUgPSB0cnVlKSk7XG4gIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcImVudGVycGljdHVyZWlucGljdHVyZVwiLCAoKSA9PiBpc1BpY3R1cmVJblBpY3R1cmUudmFsdWUgPSB0cnVlKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFwibGVhdmVwaWN0dXJlaW5waWN0dXJlXCIsICgpID0+IGlzUGljdHVyZUluUGljdHVyZS52YWx1ZSA9IGZhbHNlKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFwidm9sdW1lY2hhbmdlXCIsICgpID0+IHtcbiAgICBjb25zdCBlbCA9IHRvVmFsdWUodGFyZ2V0KTtcbiAgICBpZiAoIWVsKVxuICAgICAgcmV0dXJuO1xuICAgIHZvbHVtZS52YWx1ZSA9IGVsLnZvbHVtZTtcbiAgICBtdXRlZC52YWx1ZSA9IGVsLm11dGVkO1xuICB9KTtcbiAgY29uc3QgbGlzdGVuZXJzID0gW107XG4gIGNvbnN0IHN0b3AgPSB3YXRjaChbdGFyZ2V0XSwgKCkgPT4ge1xuICAgIGNvbnN0IGVsID0gdG9WYWx1ZSh0YXJnZXQpO1xuICAgIGlmICghZWwpXG4gICAgICByZXR1cm47XG4gICAgc3RvcCgpO1xuICAgIGxpc3RlbmVyc1swXSA9IHVzZUV2ZW50TGlzdGVuZXIoZWwudGV4dFRyYWNrcywgXCJhZGR0cmFja1wiLCAoKSA9PiB0cmFja3MudmFsdWUgPSB0cmFja3NUb0FycmF5KGVsLnRleHRUcmFja3MpKTtcbiAgICBsaXN0ZW5lcnNbMV0gPSB1c2VFdmVudExpc3RlbmVyKGVsLnRleHRUcmFja3MsIFwicmVtb3ZldHJhY2tcIiwgKCkgPT4gdHJhY2tzLnZhbHVlID0gdHJhY2tzVG9BcnJheShlbC50ZXh0VHJhY2tzKSk7XG4gICAgbGlzdGVuZXJzWzJdID0gdXNlRXZlbnRMaXN0ZW5lcihlbC50ZXh0VHJhY2tzLCBcImNoYW5nZVwiLCAoKSA9PiB0cmFja3MudmFsdWUgPSB0cmFja3NUb0FycmF5KGVsLnRleHRUcmFja3MpKTtcbiAgfSk7XG4gIHRyeU9uU2NvcGVEaXNwb3NlKCgpID0+IGxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoKSkpO1xuICByZXR1cm4ge1xuICAgIGN1cnJlbnRUaW1lLFxuICAgIGR1cmF0aW9uLFxuICAgIHdhaXRpbmcsXG4gICAgc2Vla2luZyxcbiAgICBlbmRlZCxcbiAgICBzdGFsbGVkLFxuICAgIGJ1ZmZlcmVkLFxuICAgIHBsYXlpbmcsXG4gICAgcmF0ZSxcbiAgICAvLyBWb2x1bWVcbiAgICB2b2x1bWUsXG4gICAgbXV0ZWQsXG4gICAgLy8gVHJhY2tzXG4gICAgdHJhY2tzLFxuICAgIHNlbGVjdGVkVHJhY2ssXG4gICAgZW5hYmxlVHJhY2ssXG4gICAgZGlzYWJsZVRyYWNrLFxuICAgIC8vIFBpY3R1cmUgaW4gUGljdHVyZVxuICAgIHN1cHBvcnRzUGljdHVyZUluUGljdHVyZSxcbiAgICB0b2dnbGVQaWN0dXJlSW5QaWN0dXJlLFxuICAgIGlzUGljdHVyZUluUGljdHVyZSxcbiAgICAvLyBFdmVudHNcbiAgICBvblNvdXJjZUVycm9yOiBzb3VyY2VFcnJvckV2ZW50Lm9uXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldE1hcFZ1ZTJDb21wYXQoKSB7XG4gIGNvbnN0IGRhdGEgPSBzaGFsbG93UmVhY3RpdmUoe30pO1xuICByZXR1cm4ge1xuICAgIGdldDogKGtleSkgPT4gZGF0YVtrZXldLFxuICAgIHNldDogKGtleSwgdmFsdWUpID0+IHNldChkYXRhLCBrZXksIHZhbHVlKSxcbiAgICBoYXM6IChrZXkpID0+IGhhc093bihkYXRhLCBrZXkpLFxuICAgIGRlbGV0ZTogKGtleSkgPT4gZGVsKGRhdGEsIGtleSksXG4gICAgY2xlYXI6ICgpID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKGRhdGEpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBkZWwoZGF0YSwga2V5KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZU1lbW9pemUocmVzb2x2ZXIsIG9wdGlvbnMpIHtcbiAgY29uc3QgaW5pdENhY2hlID0gKCkgPT4ge1xuICAgIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmNhY2hlKVxuICAgICAgcmV0dXJuIHNoYWxsb3dSZWFjdGl2ZShvcHRpb25zLmNhY2hlKTtcbiAgICBpZiAoaXNWdWUyKVxuICAgICAgcmV0dXJuIGdldE1hcFZ1ZTJDb21wYXQoKTtcbiAgICByZXR1cm4gc2hhbGxvd1JlYWN0aXZlKC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICB9O1xuICBjb25zdCBjYWNoZSA9IGluaXRDYWNoZSgpO1xuICBjb25zdCBnZW5lcmF0ZUtleSA9ICguLi5hcmdzKSA9PiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5nZXRLZXkpID8gb3B0aW9ucy5nZXRLZXkoLi4uYXJncykgOiBKU09OLnN0cmluZ2lmeShhcmdzKTtcbiAgY29uc3QgX2xvYWREYXRhID0gKGtleSwgLi4uYXJncykgPT4ge1xuICAgIGNhY2hlLnNldChrZXksIHJlc29sdmVyKC4uLmFyZ3MpKTtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gIH07XG4gIGNvbnN0IGxvYWREYXRhID0gKC4uLmFyZ3MpID0+IF9sb2FkRGF0YShnZW5lcmF0ZUtleSguLi5hcmdzKSwgLi4uYXJncyk7XG4gIGNvbnN0IGRlbGV0ZURhdGEgPSAoLi4uYXJncykgPT4ge1xuICAgIGNhY2hlLmRlbGV0ZShnZW5lcmF0ZUtleSguLi5hcmdzKSk7XG4gIH07XG4gIGNvbnN0IGNsZWFyRGF0YSA9ICgpID0+IHtcbiAgICBjYWNoZS5jbGVhcigpO1xuICB9O1xuICBjb25zdCBtZW1vaXplZCA9ICguLi5hcmdzKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gZ2VuZXJhdGVLZXkoLi4uYXJncyk7XG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKVxuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIHJldHVybiBfbG9hZERhdGEoa2V5LCAuLi5hcmdzKTtcbiAgfTtcbiAgbWVtb2l6ZWQubG9hZCA9IGxvYWREYXRhO1xuICBtZW1vaXplZC5kZWxldGUgPSBkZWxldGVEYXRhO1xuICBtZW1vaXplZC5jbGVhciA9IGNsZWFyRGF0YTtcbiAgbWVtb2l6ZWQuZ2VuZXJhdGVLZXkgPSBnZW5lcmF0ZUtleTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG5mdW5jdGlvbiB1c2VNZW1vcnkob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IG1lbW9yeSA9IHJlZigpO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiB0eXBlb2YgcGVyZm9ybWFuY2UgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJtZW1vcnlcIiBpbiBwZXJmb3JtYW5jZSk7XG4gIGlmIChpc1N1cHBvcnRlZC52YWx1ZSkge1xuICAgIGNvbnN0IHsgaW50ZXJ2YWwgPSAxZTMgfSA9IG9wdGlvbnM7XG4gICAgdXNlSW50ZXJ2YWxGbigoKSA9PiB7XG4gICAgICBtZW1vcnkudmFsdWUgPSBwZXJmb3JtYW5jZS5tZW1vcnk7XG4gICAgfSwgaW50ZXJ2YWwsIHsgaW1tZWRpYXRlOiBvcHRpb25zLmltbWVkaWF0ZSwgaW1tZWRpYXRlQ2FsbGJhY2s6IG9wdGlvbnMuaW1tZWRpYXRlQ2FsbGJhY2sgfSk7XG4gIH1cbiAgcmV0dXJuIHsgaXNTdXBwb3J0ZWQsIG1lbW9yeSB9O1xufVxuXG5jb25zdCBVc2VNb3VzZUJ1aWx0aW5FeHRyYWN0b3JzID0ge1xuICBwYWdlOiAoZXZlbnQpID0+IFtldmVudC5wYWdlWCwgZXZlbnQucGFnZVldLFxuICBjbGllbnQ6IChldmVudCkgPT4gW2V2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFldLFxuICBzY3JlZW46IChldmVudCkgPT4gW2V2ZW50LnNjcmVlblgsIGV2ZW50LnNjcmVlblldLFxuICBtb3ZlbWVudDogKGV2ZW50KSA9PiBldmVudCBpbnN0YW5jZW9mIFRvdWNoID8gbnVsbCA6IFtldmVudC5tb3ZlbWVudFgsIGV2ZW50Lm1vdmVtZW50WV1cbn07XG5mdW5jdGlvbiB1c2VNb3VzZShvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHR5cGUgPSBcInBhZ2VcIixcbiAgICB0b3VjaCA9IHRydWUsXG4gICAgcmVzZXRPblRvdWNoRW5kcyA9IGZhbHNlLFxuICAgIGluaXRpYWxWYWx1ZSA9IHsgeDogMCwgeTogMCB9LFxuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3csXG4gICAgdGFyZ2V0ID0gd2luZG93LFxuICAgIHNjcm9sbCA9IHRydWUsXG4gICAgZXZlbnRGaWx0ZXJcbiAgfSA9IG9wdGlvbnM7XG4gIGxldCBfcHJldk1vdXNlRXZlbnQgPSBudWxsO1xuICBjb25zdCB4ID0gcmVmKGluaXRpYWxWYWx1ZS54KTtcbiAgY29uc3QgeSA9IHJlZihpbml0aWFsVmFsdWUueSk7XG4gIGNvbnN0IHNvdXJjZVR5cGUgPSByZWYobnVsbCk7XG4gIGNvbnN0IGV4dHJhY3RvciA9IHR5cGVvZiB0eXBlID09PSBcImZ1bmN0aW9uXCIgPyB0eXBlIDogVXNlTW91c2VCdWlsdGluRXh0cmFjdG9yc1t0eXBlXTtcbiAgY29uc3QgbW91c2VIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gZXh0cmFjdG9yKGV2ZW50KTtcbiAgICBfcHJldk1vdXNlRXZlbnQgPSBldmVudDtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBbeC52YWx1ZSwgeS52YWx1ZV0gPSByZXN1bHQ7XG4gICAgICBzb3VyY2VUeXBlLnZhbHVlID0gXCJtb3VzZVwiO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdG91Y2hIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZXh0cmFjdG9yKGV2ZW50LnRvdWNoZXNbMF0pO1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBbeC52YWx1ZSwgeS52YWx1ZV0gPSByZXN1bHQ7XG4gICAgICAgIHNvdXJjZVR5cGUudmFsdWUgPSBcInRvdWNoXCI7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBzY3JvbGxIYW5kbGVyID0gKCkgPT4ge1xuICAgIGlmICghX3ByZXZNb3VzZUV2ZW50IHx8ICF3aW5kb3cpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcG9zID0gZXh0cmFjdG9yKF9wcmV2TW91c2VFdmVudCk7XG4gICAgaWYgKF9wcmV2TW91c2VFdmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQgJiYgcG9zKSB7XG4gICAgICB4LnZhbHVlID0gcG9zWzBdICsgd2luZG93LnNjcm9sbFg7XG4gICAgICB5LnZhbHVlID0gcG9zWzFdICsgd2luZG93LnNjcm9sbFk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICB4LnZhbHVlID0gaW5pdGlhbFZhbHVlLng7XG4gICAgeS52YWx1ZSA9IGluaXRpYWxWYWx1ZS55O1xuICB9O1xuICBjb25zdCBtb3VzZUhhbmRsZXJXcmFwcGVyID0gZXZlbnRGaWx0ZXIgPyAoZXZlbnQpID0+IGV2ZW50RmlsdGVyKCgpID0+IG1vdXNlSGFuZGxlcihldmVudCksIHt9KSA6IChldmVudCkgPT4gbW91c2VIYW5kbGVyKGV2ZW50KTtcbiAgY29uc3QgdG91Y2hIYW5kbGVyV3JhcHBlciA9IGV2ZW50RmlsdGVyID8gKGV2ZW50KSA9PiBldmVudEZpbHRlcigoKSA9PiB0b3VjaEhhbmRsZXIoZXZlbnQpLCB7fSkgOiAoZXZlbnQpID0+IHRvdWNoSGFuZGxlcihldmVudCk7XG4gIGNvbnN0IHNjcm9sbEhhbmRsZXJXcmFwcGVyID0gZXZlbnRGaWx0ZXIgPyAoKSA9PiBldmVudEZpbHRlcigoKSA9PiBzY3JvbGxIYW5kbGVyKCksIHt9KSA6ICgpID0+IHNjcm9sbEhhbmRsZXIoKTtcbiAgaWYgKHRhcmdldCkge1xuICAgIGNvbnN0IGxpc3RlbmVyT3B0aW9ucyA9IHsgcGFzc2l2ZTogdHJ1ZSB9O1xuICAgIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBbXCJtb3VzZW1vdmVcIiwgXCJkcmFnb3ZlclwiXSwgbW91c2VIYW5kbGVyV3JhcHBlciwgbGlzdGVuZXJPcHRpb25zKTtcbiAgICBpZiAodG91Y2ggJiYgdHlwZSAhPT0gXCJtb3ZlbWVudFwiKSB7XG4gICAgICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgW1widG91Y2hzdGFydFwiLCBcInRvdWNobW92ZVwiXSwgdG91Y2hIYW5kbGVyV3JhcHBlciwgbGlzdGVuZXJPcHRpb25zKTtcbiAgICAgIGlmIChyZXNldE9uVG91Y2hFbmRzKVxuICAgICAgICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJ0b3VjaGVuZFwiLCByZXNldCwgbGlzdGVuZXJPcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKHNjcm9sbCAmJiB0eXBlID09PSBcInBhZ2VcIilcbiAgICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcInNjcm9sbFwiLCBzY3JvbGxIYW5kbGVyV3JhcHBlciwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5LFxuICAgIHNvdXJjZVR5cGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlTW91c2VJbkVsZW1lbnQodGFyZ2V0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGhhbmRsZU91dHNpZGUgPSB0cnVlLFxuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3dcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHR5cGUgPSBvcHRpb25zLnR5cGUgfHwgXCJwYWdlXCI7XG4gIGNvbnN0IHsgeCwgeSwgc291cmNlVHlwZSB9ID0gdXNlTW91c2Uob3B0aW9ucyk7XG4gIGNvbnN0IHRhcmdldFJlZiA9IHJlZih0YXJnZXQgIT0gbnVsbCA/IHRhcmdldCA6IHdpbmRvdyA9PSBudWxsID8gdm9pZCAwIDogd2luZG93LmRvY3VtZW50LmJvZHkpO1xuICBjb25zdCBlbGVtZW50WCA9IHJlZigwKTtcbiAgY29uc3QgZWxlbWVudFkgPSByZWYoMCk7XG4gIGNvbnN0IGVsZW1lbnRQb3NpdGlvblggPSByZWYoMCk7XG4gIGNvbnN0IGVsZW1lbnRQb3NpdGlvblkgPSByZWYoMCk7XG4gIGNvbnN0IGVsZW1lbnRIZWlnaHQgPSByZWYoMCk7XG4gIGNvbnN0IGVsZW1lbnRXaWR0aCA9IHJlZigwKTtcbiAgY29uc3QgaXNPdXRzaWRlID0gcmVmKHRydWUpO1xuICBsZXQgc3RvcCA9ICgpID0+IHtcbiAgfTtcbiAgaWYgKHdpbmRvdykge1xuICAgIHN0b3AgPSB3YXRjaChcbiAgICAgIFt0YXJnZXRSZWYsIHgsIHldLFxuICAgICAgKCkgPT4ge1xuICAgICAgICBjb25zdCBlbCA9IHVucmVmRWxlbWVudCh0YXJnZXRSZWYpO1xuICAgICAgICBpZiAoIWVsKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgdG9wLFxuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodFxuICAgICAgICB9ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGVsZW1lbnRQb3NpdGlvblgudmFsdWUgPSBsZWZ0ICsgKHR5cGUgPT09IFwicGFnZVwiID8gd2luZG93LnBhZ2VYT2Zmc2V0IDogMCk7XG4gICAgICAgIGVsZW1lbnRQb3NpdGlvblkudmFsdWUgPSB0b3AgKyAodHlwZSA9PT0gXCJwYWdlXCIgPyB3aW5kb3cucGFnZVlPZmZzZXQgOiAwKTtcbiAgICAgICAgZWxlbWVudEhlaWdodC52YWx1ZSA9IGhlaWdodDtcbiAgICAgICAgZWxlbWVudFdpZHRoLnZhbHVlID0gd2lkdGg7XG4gICAgICAgIGNvbnN0IGVsWCA9IHgudmFsdWUgLSBlbGVtZW50UG9zaXRpb25YLnZhbHVlO1xuICAgICAgICBjb25zdCBlbFkgPSB5LnZhbHVlIC0gZWxlbWVudFBvc2l0aW9uWS52YWx1ZTtcbiAgICAgICAgaXNPdXRzaWRlLnZhbHVlID0gd2lkdGggPT09IDAgfHwgaGVpZ2h0ID09PSAwIHx8IGVsWCA8IDAgfHwgZWxZIDwgMCB8fCBlbFggPiB3aWR0aCB8fCBlbFkgPiBoZWlnaHQ7XG4gICAgICAgIGlmIChoYW5kbGVPdXRzaWRlIHx8ICFpc091dHNpZGUudmFsdWUpIHtcbiAgICAgICAgICBlbGVtZW50WC52YWx1ZSA9IGVsWDtcbiAgICAgICAgICBlbGVtZW50WS52YWx1ZSA9IGVsWTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHsgaW1tZWRpYXRlOiB0cnVlIH1cbiAgICApO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsIFwibW91c2VsZWF2ZVwiLCAoKSA9PiB7XG4gICAgICBpc091dHNpZGUudmFsdWUgPSB0cnVlO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5LFxuICAgIHNvdXJjZVR5cGUsXG4gICAgZWxlbWVudFgsXG4gICAgZWxlbWVudFksXG4gICAgZWxlbWVudFBvc2l0aW9uWCxcbiAgICBlbGVtZW50UG9zaXRpb25ZLFxuICAgIGVsZW1lbnRIZWlnaHQsXG4gICAgZWxlbWVudFdpZHRoLFxuICAgIGlzT3V0c2lkZSxcbiAgICBzdG9wXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZU1vdXNlUHJlc3NlZChvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHRvdWNoID0gdHJ1ZSxcbiAgICBkcmFnID0gdHJ1ZSxcbiAgICBjYXB0dXJlID0gZmFsc2UsXG4gICAgaW5pdGlhbFZhbHVlID0gZmFsc2UsXG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvd1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcHJlc3NlZCA9IHJlZihpbml0aWFsVmFsdWUpO1xuICBjb25zdCBzb3VyY2VUeXBlID0gcmVmKG51bGwpO1xuICBpZiAoIXdpbmRvdykge1xuICAgIHJldHVybiB7XG4gICAgICBwcmVzc2VkLFxuICAgICAgc291cmNlVHlwZVxuICAgIH07XG4gIH1cbiAgY29uc3Qgb25QcmVzc2VkID0gKHNyY1R5cGUpID0+ICgpID0+IHtcbiAgICBwcmVzc2VkLnZhbHVlID0gdHJ1ZTtcbiAgICBzb3VyY2VUeXBlLnZhbHVlID0gc3JjVHlwZTtcbiAgfTtcbiAgY29uc3Qgb25SZWxlYXNlZCA9ICgpID0+IHtcbiAgICBwcmVzc2VkLnZhbHVlID0gZmFsc2U7XG4gICAgc291cmNlVHlwZS52YWx1ZSA9IG51bGw7XG4gIH07XG4gIGNvbnN0IHRhcmdldCA9IGNvbXB1dGVkKCgpID0+IHVucmVmRWxlbWVudChvcHRpb25zLnRhcmdldCkgfHwgd2luZG93KTtcbiAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFwibW91c2Vkb3duXCIsIG9uUHJlc3NlZChcIm1vdXNlXCIpLCB7IHBhc3NpdmU6IHRydWUsIGNhcHR1cmUgfSk7XG4gIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcIm1vdXNlbGVhdmVcIiwgb25SZWxlYXNlZCwgeyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlIH0pO1xuICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJtb3VzZXVwXCIsIG9uUmVsZWFzZWQsIHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZSB9KTtcbiAgaWYgKGRyYWcpIHtcbiAgICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJkcmFnc3RhcnRcIiwgb25QcmVzc2VkKFwibW91c2VcIiksIHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZSB9KTtcbiAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJkcm9wXCIsIG9uUmVsZWFzZWQsIHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZSB9KTtcbiAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJkcmFnZW5kXCIsIG9uUmVsZWFzZWQsIHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZSB9KTtcbiAgfVxuICBpZiAodG91Y2gpIHtcbiAgICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJ0b3VjaHN0YXJ0XCIsIG9uUHJlc3NlZChcInRvdWNoXCIpLCB7IHBhc3NpdmU6IHRydWUsIGNhcHR1cmUgfSk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwidG91Y2hlbmRcIiwgb25SZWxlYXNlZCwgeyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlIH0pO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcInRvdWNoY2FuY2VsXCIsIG9uUmVsZWFzZWQsIHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZSB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHByZXNzZWQsXG4gICAgc291cmNlVHlwZVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VOYXZpZ2F0b3JMYW5ndWFnZShvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB3aW5kb3cgPSBkZWZhdWx0V2luZG93IH0gPSBvcHRpb25zO1xuICBjb25zdCBuYXZpZ2F0b3IgPSB3aW5kb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHdpbmRvdy5uYXZpZ2F0b3I7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IG5hdmlnYXRvciAmJiBcImxhbmd1YWdlXCIgaW4gbmF2aWdhdG9yKTtcbiAgY29uc3QgbGFuZ3VhZ2UgPSByZWYobmF2aWdhdG9yID09IG51bGwgPyB2b2lkIDAgOiBuYXZpZ2F0b3IubGFuZ3VhZ2UpO1xuICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJsYW5ndWFnZWNoYW5nZVwiLCAoKSA9PiB7XG4gICAgaWYgKG5hdmlnYXRvcilcbiAgICAgIGxhbmd1YWdlLnZhbHVlID0gbmF2aWdhdG9yLmxhbmd1YWdlO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBsYW5ndWFnZVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VOZXR3b3JrKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IHdpbmRvdyA9IGRlZmF1bHRXaW5kb3cgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IG5hdmlnYXRvciA9IHdpbmRvdyA9PSBudWxsID8gdm9pZCAwIDogd2luZG93Lm5hdmlnYXRvcjtcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gbmF2aWdhdG9yICYmIFwiY29ubmVjdGlvblwiIGluIG5hdmlnYXRvcik7XG4gIGNvbnN0IGlzT25saW5lID0gcmVmKHRydWUpO1xuICBjb25zdCBzYXZlRGF0YSA9IHJlZihmYWxzZSk7XG4gIGNvbnN0IG9mZmxpbmVBdCA9IHJlZih2b2lkIDApO1xuICBjb25zdCBvbmxpbmVBdCA9IHJlZih2b2lkIDApO1xuICBjb25zdCBkb3dubGluayA9IHJlZih2b2lkIDApO1xuICBjb25zdCBkb3dubGlua01heCA9IHJlZih2b2lkIDApO1xuICBjb25zdCBydHQgPSByZWYodm9pZCAwKTtcbiAgY29uc3QgZWZmZWN0aXZlVHlwZSA9IHJlZih2b2lkIDApO1xuICBjb25zdCB0eXBlID0gcmVmKFwidW5rbm93blwiKTtcbiAgY29uc3QgY29ubmVjdGlvbiA9IGlzU3VwcG9ydGVkLnZhbHVlICYmIG5hdmlnYXRvci5jb25uZWN0aW9uO1xuICBmdW5jdGlvbiB1cGRhdGVOZXR3b3JrSW5mb3JtYXRpb24oKSB7XG4gICAgaWYgKCFuYXZpZ2F0b3IpXG4gICAgICByZXR1cm47XG4gICAgaXNPbmxpbmUudmFsdWUgPSBuYXZpZ2F0b3Iub25MaW5lO1xuICAgIG9mZmxpbmVBdC52YWx1ZSA9IGlzT25saW5lLnZhbHVlID8gdm9pZCAwIDogRGF0ZS5ub3coKTtcbiAgICBvbmxpbmVBdC52YWx1ZSA9IGlzT25saW5lLnZhbHVlID8gRGF0ZS5ub3coKSA6IHZvaWQgMDtcbiAgICBpZiAoY29ubmVjdGlvbikge1xuICAgICAgZG93bmxpbmsudmFsdWUgPSBjb25uZWN0aW9uLmRvd25saW5rO1xuICAgICAgZG93bmxpbmtNYXgudmFsdWUgPSBjb25uZWN0aW9uLmRvd25saW5rTWF4O1xuICAgICAgZWZmZWN0aXZlVHlwZS52YWx1ZSA9IGNvbm5lY3Rpb24uZWZmZWN0aXZlVHlwZTtcbiAgICAgIHJ0dC52YWx1ZSA9IGNvbm5lY3Rpb24ucnR0O1xuICAgICAgc2F2ZURhdGEudmFsdWUgPSBjb25uZWN0aW9uLnNhdmVEYXRhO1xuICAgICAgdHlwZS52YWx1ZSA9IGNvbm5lY3Rpb24udHlwZTtcbiAgICB9XG4gIH1cbiAgaWYgKHdpbmRvdykge1xuICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcIm9mZmxpbmVcIiwgKCkgPT4ge1xuICAgICAgaXNPbmxpbmUudmFsdWUgPSBmYWxzZTtcbiAgICAgIG9mZmxpbmVBdC52YWx1ZSA9IERhdGUubm93KCk7XG4gICAgfSk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwib25saW5lXCIsICgpID0+IHtcbiAgICAgIGlzT25saW5lLnZhbHVlID0gdHJ1ZTtcbiAgICAgIG9ubGluZUF0LnZhbHVlID0gRGF0ZS5ub3coKTtcbiAgICB9KTtcbiAgfVxuICBpZiAoY29ubmVjdGlvbilcbiAgICB1c2VFdmVudExpc3RlbmVyKGNvbm5lY3Rpb24sIFwiY2hhbmdlXCIsIHVwZGF0ZU5ldHdvcmtJbmZvcm1hdGlvbiwgZmFsc2UpO1xuICB1cGRhdGVOZXR3b3JrSW5mb3JtYXRpb24oKTtcbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBpc09ubGluZSxcbiAgICBzYXZlRGF0YSxcbiAgICBvZmZsaW5lQXQsXG4gICAgb25saW5lQXQsXG4gICAgZG93bmxpbmssXG4gICAgZG93bmxpbmtNYXgsXG4gICAgZWZmZWN0aXZlVHlwZSxcbiAgICBydHQsXG4gICAgdHlwZVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VOb3cob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBjb250cm9sczogZXhwb3NlQ29udHJvbHMgPSBmYWxzZSxcbiAgICBpbnRlcnZhbCA9IFwicmVxdWVzdEFuaW1hdGlvbkZyYW1lXCJcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IG5vdyA9IHJlZigvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSk7XG4gIGNvbnN0IHVwZGF0ZSA9ICgpID0+IG5vdy52YWx1ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICBjb25zdCBjb250cm9scyA9IGludGVydmFsID09PSBcInJlcXVlc3RBbmltYXRpb25GcmFtZVwiID8gdXNlUmFmRm4odXBkYXRlLCB7IGltbWVkaWF0ZTogdHJ1ZSB9KSA6IHVzZUludGVydmFsRm4odXBkYXRlLCBpbnRlcnZhbCwgeyBpbW1lZGlhdGU6IHRydWUgfSk7XG4gIGlmIChleHBvc2VDb250cm9scykge1xuICAgIHJldHVybiB7XG4gICAgICBub3csXG4gICAgICAuLi5jb250cm9sc1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5vdztcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VPYmplY3RVcmwob2JqZWN0KSB7XG4gIGNvbnN0IHVybCA9IHJlZigpO1xuICBjb25zdCByZWxlYXNlID0gKCkgPT4ge1xuICAgIGlmICh1cmwudmFsdWUpXG4gICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybC52YWx1ZSk7XG4gICAgdXJsLnZhbHVlID0gdm9pZCAwO1xuICB9O1xuICB3YXRjaChcbiAgICAoKSA9PiB0b1ZhbHVlKG9iamVjdCksXG4gICAgKG5ld09iamVjdCkgPT4ge1xuICAgICAgcmVsZWFzZSgpO1xuICAgICAgaWYgKG5ld09iamVjdClcbiAgICAgICAgdXJsLnZhbHVlID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXdPYmplY3QpO1xuICAgIH0sXG4gICAgeyBpbW1lZGlhdGU6IHRydWUgfVxuICApO1xuICB0cnlPblNjb3BlRGlzcG9zZShyZWxlYXNlKTtcbiAgcmV0dXJuIHJlYWRvbmx5KHVybCk7XG59XG5cbmZ1bmN0aW9uIHVzZUNsYW1wKHZhbHVlLCBtaW4sIG1heCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgfHwgaXNSZWFkb25seSh2YWx1ZSkpXG4gICAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IGNsYW1wKHRvVmFsdWUodmFsdWUpLCB0b1ZhbHVlKG1pbiksIHRvVmFsdWUobWF4KSkpO1xuICBjb25zdCBfdmFsdWUgPSByZWYodmFsdWUpO1xuICByZXR1cm4gY29tcHV0ZWQoe1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBfdmFsdWUudmFsdWUgPSBjbGFtcChfdmFsdWUudmFsdWUsIHRvVmFsdWUobWluKSwgdG9WYWx1ZShtYXgpKTtcbiAgICB9LFxuICAgIHNldCh2YWx1ZTIpIHtcbiAgICAgIF92YWx1ZS52YWx1ZSA9IGNsYW1wKHZhbHVlMiwgdG9WYWx1ZShtaW4pLCB0b1ZhbHVlKG1heCkpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVzZU9mZnNldFBhZ2luYXRpb24ob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgdG90YWwgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgcGFnZVNpemUgPSAxMCxcbiAgICBwYWdlID0gMSxcbiAgICBvblBhZ2VDaGFuZ2UgPSBub29wLFxuICAgIG9uUGFnZVNpemVDaGFuZ2UgPSBub29wLFxuICAgIG9uUGFnZUNvdW50Q2hhbmdlID0gbm9vcFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgY3VycmVudFBhZ2VTaXplID0gdXNlQ2xhbXAocGFnZVNpemUsIDEsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gIGNvbnN0IHBhZ2VDb3VudCA9IGNvbXB1dGVkKCgpID0+IE1hdGgubWF4KFxuICAgIDEsXG4gICAgTWF0aC5jZWlsKHRvVmFsdWUodG90YWwpIC8gdG9WYWx1ZShjdXJyZW50UGFnZVNpemUpKVxuICApKTtcbiAgY29uc3QgY3VycmVudFBhZ2UgPSB1c2VDbGFtcChwYWdlLCAxLCBwYWdlQ291bnQpO1xuICBjb25zdCBpc0ZpcnN0UGFnZSA9IGNvbXB1dGVkKCgpID0+IGN1cnJlbnRQYWdlLnZhbHVlID09PSAxKTtcbiAgY29uc3QgaXNMYXN0UGFnZSA9IGNvbXB1dGVkKCgpID0+IGN1cnJlbnRQYWdlLnZhbHVlID09PSBwYWdlQ291bnQudmFsdWUpO1xuICBpZiAoaXNSZWYocGFnZSkpIHtcbiAgICBzeW5jUmVmKHBhZ2UsIGN1cnJlbnRQYWdlLCB7XG4gICAgICBkaXJlY3Rpb246IGlzUmVhZG9ubHkocGFnZSkgPyBcImx0clwiIDogXCJib3RoXCJcbiAgICB9KTtcbiAgfVxuICBpZiAoaXNSZWYocGFnZVNpemUpKSB7XG4gICAgc3luY1JlZihwYWdlU2l6ZSwgY3VycmVudFBhZ2VTaXplLCB7XG4gICAgICBkaXJlY3Rpb246IGlzUmVhZG9ubHkocGFnZVNpemUpID8gXCJsdHJcIiA6IFwiYm90aFwiXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcHJldigpIHtcbiAgICBjdXJyZW50UGFnZS52YWx1ZS0tO1xuICB9XG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgY3VycmVudFBhZ2UudmFsdWUrKztcbiAgfVxuICBjb25zdCByZXR1cm5WYWx1ZSA9IHtcbiAgICBjdXJyZW50UGFnZSxcbiAgICBjdXJyZW50UGFnZVNpemUsXG4gICAgcGFnZUNvdW50LFxuICAgIGlzRmlyc3RQYWdlLFxuICAgIGlzTGFzdFBhZ2UsXG4gICAgcHJldixcbiAgICBuZXh0XG4gIH07XG4gIHdhdGNoKGN1cnJlbnRQYWdlLCAoKSA9PiB7XG4gICAgb25QYWdlQ2hhbmdlKHJlYWN0aXZlKHJldHVyblZhbHVlKSk7XG4gIH0pO1xuICB3YXRjaChjdXJyZW50UGFnZVNpemUsICgpID0+IHtcbiAgICBvblBhZ2VTaXplQ2hhbmdlKHJlYWN0aXZlKHJldHVyblZhbHVlKSk7XG4gIH0pO1xuICB3YXRjaChwYWdlQ291bnQsICgpID0+IHtcbiAgICBvblBhZ2VDb3VudENoYW5nZShyZWFjdGl2ZShyZXR1cm5WYWx1ZSkpO1xuICB9KTtcbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG5mdW5jdGlvbiB1c2VPbmxpbmUob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgaXNPbmxpbmUgfSA9IHVzZU5ldHdvcmsob3B0aW9ucyk7XG4gIHJldHVybiBpc09ubGluZTtcbn1cblxuZnVuY3Rpb24gdXNlUGFnZUxlYXZlKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IHdpbmRvdyA9IGRlZmF1bHRXaW5kb3cgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlzTGVmdCA9IHJlZihmYWxzZSk7XG4gIGNvbnN0IGhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICBpZiAoIXdpbmRvdylcbiAgICAgIHJldHVybjtcbiAgICBldmVudCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDtcbiAgICBjb25zdCBmcm9tID0gZXZlbnQucmVsYXRlZFRhcmdldCB8fCBldmVudC50b0VsZW1lbnQ7XG4gICAgaXNMZWZ0LnZhbHVlID0gIWZyb207XG4gIH07XG4gIGlmICh3aW5kb3cpIHtcbiAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJtb3VzZW91dFwiLCBoYW5kbGVyLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3cuZG9jdW1lbnQsIFwibW91c2VsZWF2ZVwiLCBoYW5kbGVyLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3cuZG9jdW1lbnQsIFwibW91c2VlbnRlclwiLCBoYW5kbGVyLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gIH1cbiAgcmV0dXJuIGlzTGVmdDtcbn1cblxuZnVuY3Rpb24gdXNlU2NyZWVuT3JpZW50YXRpb24ob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiB3aW5kb3cgJiYgXCJzY3JlZW5cIiBpbiB3aW5kb3cgJiYgXCJvcmllbnRhdGlvblwiIGluIHdpbmRvdy5zY3JlZW4pO1xuICBjb25zdCBzY3JlZW5PcmllbnRhdGlvbiA9IGlzU3VwcG9ydGVkLnZhbHVlID8gd2luZG93LnNjcmVlbi5vcmllbnRhdGlvbiA6IHt9O1xuICBjb25zdCBvcmllbnRhdGlvbiA9IHJlZihzY3JlZW5PcmllbnRhdGlvbi50eXBlKTtcbiAgY29uc3QgYW5nbGUgPSByZWYoc2NyZWVuT3JpZW50YXRpb24uYW5nbGUgfHwgMCk7XG4gIGlmIChpc1N1cHBvcnRlZC52YWx1ZSkge1xuICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcIm9yaWVudGF0aW9uY2hhbmdlXCIsICgpID0+IHtcbiAgICAgIG9yaWVudGF0aW9uLnZhbHVlID0gc2NyZWVuT3JpZW50YXRpb24udHlwZTtcbiAgICAgIGFuZ2xlLnZhbHVlID0gc2NyZWVuT3JpZW50YXRpb24uYW5nbGU7XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbG9ja09yaWVudGF0aW9uID0gKHR5cGUpID0+IHtcbiAgICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUgJiYgdHlwZW9mIHNjcmVlbk9yaWVudGF0aW9uLmxvY2sgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHJldHVybiBzY3JlZW5PcmllbnRhdGlvbi5sb2NrKHR5cGUpO1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJOb3Qgc3VwcG9ydGVkXCIpKTtcbiAgfTtcbiAgY29uc3QgdW5sb2NrT3JpZW50YXRpb24gPSAoKSA9PiB7XG4gICAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlICYmIHR5cGVvZiBzY3JlZW5PcmllbnRhdGlvbi51bmxvY2sgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHNjcmVlbk9yaWVudGF0aW9uLnVubG9jaygpO1xuICB9O1xuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIG9yaWVudGF0aW9uLFxuICAgIGFuZ2xlLFxuICAgIGxvY2tPcmllbnRhdGlvbixcbiAgICB1bmxvY2tPcmllbnRhdGlvblxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VQYXJhbGxheCh0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgZGV2aWNlT3JpZW50YXRpb25UaWx0QWRqdXN0ID0gKGkpID0+IGksXG4gICAgZGV2aWNlT3JpZW50YXRpb25Sb2xsQWRqdXN0ID0gKGkpID0+IGksXG4gICAgbW91c2VUaWx0QWRqdXN0ID0gKGkpID0+IGksXG4gICAgbW91c2VSb2xsQWRqdXN0ID0gKGkpID0+IGksXG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvd1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgb3JpZW50YXRpb24gPSByZWFjdGl2ZSh1c2VEZXZpY2VPcmllbnRhdGlvbih7IHdpbmRvdyB9KSk7XG4gIGNvbnN0IHNjcmVlbk9yaWVudGF0aW9uID0gcmVhY3RpdmUodXNlU2NyZWVuT3JpZW50YXRpb24oeyB3aW5kb3cgfSkpO1xuICBjb25zdCB7XG4gICAgZWxlbWVudFg6IHgsXG4gICAgZWxlbWVudFk6IHksXG4gICAgZWxlbWVudFdpZHRoOiB3aWR0aCxcbiAgICBlbGVtZW50SGVpZ2h0OiBoZWlnaHRcbiAgfSA9IHVzZU1vdXNlSW5FbGVtZW50KHRhcmdldCwgeyBoYW5kbGVPdXRzaWRlOiBmYWxzZSwgd2luZG93IH0pO1xuICBjb25zdCBzb3VyY2UgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgaWYgKG9yaWVudGF0aW9uLmlzU3VwcG9ydGVkICYmIChvcmllbnRhdGlvbi5hbHBoYSAhPSBudWxsICYmIG9yaWVudGF0aW9uLmFscGhhICE9PSAwIHx8IG9yaWVudGF0aW9uLmdhbW1hICE9IG51bGwgJiYgb3JpZW50YXRpb24uZ2FtbWEgIT09IDApKSB7XG4gICAgICByZXR1cm4gXCJkZXZpY2VPcmllbnRhdGlvblwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJtb3VzZVwiO1xuICB9KTtcbiAgY29uc3Qgcm9sbCA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICBpZiAoc291cmNlLnZhbHVlID09PSBcImRldmljZU9yaWVudGF0aW9uXCIpIHtcbiAgICAgIGxldCB2YWx1ZTtcbiAgICAgIHN3aXRjaCAoc2NyZWVuT3JpZW50YXRpb24ub3JpZW50YXRpb24pIHtcbiAgICAgICAgY2FzZSBcImxhbmRzY2FwZS1wcmltYXJ5XCI6XG4gICAgICAgICAgdmFsdWUgPSBvcmllbnRhdGlvbi5nYW1tYSAvIDkwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGFuZHNjYXBlLXNlY29uZGFyeVwiOlxuICAgICAgICAgIHZhbHVlID0gLW9yaWVudGF0aW9uLmdhbW1hIC8gOTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwb3J0cmFpdC1wcmltYXJ5XCI6XG4gICAgICAgICAgdmFsdWUgPSAtb3JpZW50YXRpb24uYmV0YSAvIDkwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicG9ydHJhaXQtc2Vjb25kYXJ5XCI6XG4gICAgICAgICAgdmFsdWUgPSBvcmllbnRhdGlvbi5iZXRhIC8gOTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdmFsdWUgPSAtb3JpZW50YXRpb24uYmV0YSAvIDkwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRldmljZU9yaWVudGF0aW9uUm9sbEFkanVzdCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gLSh5LnZhbHVlIC0gaGVpZ2h0LnZhbHVlIC8gMikgLyBoZWlnaHQudmFsdWU7XG4gICAgICByZXR1cm4gbW91c2VSb2xsQWRqdXN0KHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCB0aWx0ID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIGlmIChzb3VyY2UudmFsdWUgPT09IFwiZGV2aWNlT3JpZW50YXRpb25cIikge1xuICAgICAgbGV0IHZhbHVlO1xuICAgICAgc3dpdGNoIChzY3JlZW5PcmllbnRhdGlvbi5vcmllbnRhdGlvbikge1xuICAgICAgICBjYXNlIFwibGFuZHNjYXBlLXByaW1hcnlcIjpcbiAgICAgICAgICB2YWx1ZSA9IG9yaWVudGF0aW9uLmJldGEgLyA5MDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImxhbmRzY2FwZS1zZWNvbmRhcnlcIjpcbiAgICAgICAgICB2YWx1ZSA9IC1vcmllbnRhdGlvbi5iZXRhIC8gOTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwb3J0cmFpdC1wcmltYXJ5XCI6XG4gICAgICAgICAgdmFsdWUgPSBvcmllbnRhdGlvbi5nYW1tYSAvIDkwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicG9ydHJhaXQtc2Vjb25kYXJ5XCI6XG4gICAgICAgICAgdmFsdWUgPSAtb3JpZW50YXRpb24uZ2FtbWEgLyA5MDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB2YWx1ZSA9IG9yaWVudGF0aW9uLmdhbW1hIC8gOTA7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGV2aWNlT3JpZW50YXRpb25UaWx0QWRqdXN0KHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdmFsdWUgPSAoeC52YWx1ZSAtIHdpZHRoLnZhbHVlIC8gMikgLyB3aWR0aC52YWx1ZTtcbiAgICAgIHJldHVybiBtb3VzZVRpbHRBZGp1c3QodmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7IHJvbGwsIHRpbHQsIHNvdXJjZSB9O1xufVxuXG5mdW5jdGlvbiB1c2VQYXJlbnRFbGVtZW50KGVsZW1lbnQgPSB1c2VDdXJyZW50RWxlbWVudCgpKSB7XG4gIGNvbnN0IHBhcmVudEVsZW1lbnQgPSBzaGFsbG93UmVmKCk7XG4gIGNvbnN0IHVwZGF0ZSA9ICgpID0+IHtcbiAgICBjb25zdCBlbCA9IHVucmVmRWxlbWVudChlbGVtZW50KTtcbiAgICBpZiAoZWwpXG4gICAgICBwYXJlbnRFbGVtZW50LnZhbHVlID0gZWwucGFyZW50RWxlbWVudDtcbiAgfTtcbiAgdHJ5T25Nb3VudGVkKHVwZGF0ZSk7XG4gIHdhdGNoKCgpID0+IHRvVmFsdWUoZWxlbWVudCksIHVwZGF0ZSk7XG4gIHJldHVybiBwYXJlbnRFbGVtZW50O1xufVxuXG5mdW5jdGlvbiB1c2VQZXJmb3JtYW5jZU9ic2VydmVyKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHtcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93LFxuICAgIGltbWVkaWF0ZSA9IHRydWUsXG4gICAgLi4ucGVyZm9ybWFuY2VPcHRpb25zXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiB3aW5kb3cgJiYgXCJQZXJmb3JtYW5jZU9ic2VydmVyXCIgaW4gd2luZG93KTtcbiAgbGV0IG9ic2VydmVyO1xuICBjb25zdCBzdG9wID0gKCkgPT4ge1xuICAgIG9ic2VydmVyID09IG51bGwgPyB2b2lkIDAgOiBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH07XG4gIGNvbnN0IHN0YXJ0ID0gKCkgPT4ge1xuICAgIGlmIChpc1N1cHBvcnRlZC52YWx1ZSkge1xuICAgICAgc3RvcCgpO1xuICAgICAgb2JzZXJ2ZXIgPSBuZXcgUGVyZm9ybWFuY2VPYnNlcnZlcihjYWxsYmFjayk7XG4gICAgICBvYnNlcnZlci5vYnNlcnZlKHBlcmZvcm1hbmNlT3B0aW9ucyk7XG4gICAgfVxuICB9O1xuICB0cnlPblNjb3BlRGlzcG9zZShzdG9wKTtcbiAgaWYgKGltbWVkaWF0ZSlcbiAgICBzdGFydCgpO1xuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIHN0YXJ0LFxuICAgIHN0b3BcbiAgfTtcbn1cblxuY29uc3QgZGVmYXVsdFN0YXRlID0ge1xuICB4OiAwLFxuICB5OiAwLFxuICBwb2ludGVySWQ6IDAsXG4gIHByZXNzdXJlOiAwLFxuICB0aWx0WDogMCxcbiAgdGlsdFk6IDAsXG4gIHdpZHRoOiAwLFxuICBoZWlnaHQ6IDAsXG4gIHR3aXN0OiAwLFxuICBwb2ludGVyVHlwZTogbnVsbFxufTtcbmNvbnN0IGtleXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmtleXMoZGVmYXVsdFN0YXRlKTtcbmZ1bmN0aW9uIHVzZVBvaW50ZXIob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICB0YXJnZXQgPSBkZWZhdWx0V2luZG93XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpc0luc2lkZSA9IHJlZihmYWxzZSk7XG4gIGNvbnN0IHN0YXRlID0gcmVmKG9wdGlvbnMuaW5pdGlhbFZhbHVlIHx8IHt9KTtcbiAgT2JqZWN0LmFzc2lnbihzdGF0ZS52YWx1ZSwgZGVmYXVsdFN0YXRlLCBzdGF0ZS52YWx1ZSk7XG4gIGNvbnN0IGhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICBpc0luc2lkZS52YWx1ZSA9IHRydWU7XG4gICAgaWYgKG9wdGlvbnMucG9pbnRlclR5cGVzICYmICFvcHRpb25zLnBvaW50ZXJUeXBlcy5pbmNsdWRlcyhldmVudC5wb2ludGVyVHlwZSkpXG4gICAgICByZXR1cm47XG4gICAgc3RhdGUudmFsdWUgPSBvYmplY3RQaWNrKGV2ZW50LCBrZXlzLCBmYWxzZSk7XG4gIH07XG4gIGlmICh0YXJnZXQpIHtcbiAgICBjb25zdCBsaXN0ZW5lck9wdGlvbnMgPSB7IHBhc3NpdmU6IHRydWUgfTtcbiAgICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgW1wicG9pbnRlcmRvd25cIiwgXCJwb2ludGVybW92ZVwiLCBcInBvaW50ZXJ1cFwiXSwgaGFuZGxlciwgbGlzdGVuZXJPcHRpb25zKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJwb2ludGVybGVhdmVcIiwgKCkgPT4gaXNJbnNpZGUudmFsdWUgPSBmYWxzZSwgbGlzdGVuZXJPcHRpb25zKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnRvUmVmcyhzdGF0ZSksXG4gICAgaXNJbnNpZGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlUG9pbnRlckxvY2sodGFyZ2V0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyBkb2N1bWVudCA9IGRlZmF1bHREb2N1bWVudCB9ID0gb3B0aW9ucztcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gZG9jdW1lbnQgJiYgXCJwb2ludGVyTG9ja0VsZW1lbnRcIiBpbiBkb2N1bWVudCk7XG4gIGNvbnN0IGVsZW1lbnQgPSByZWYoKTtcbiAgY29uc3QgdHJpZ2dlckVsZW1lbnQgPSByZWYoKTtcbiAgbGV0IHRhcmdldEVsZW1lbnQ7XG4gIGlmIChpc1N1cHBvcnRlZC52YWx1ZSkge1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsIFwicG9pbnRlcmxvY2tjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgY3VycmVudEVsZW1lbnQgPSAoX2EgPSBkb2N1bWVudC5wb2ludGVyTG9ja0VsZW1lbnQpICE9IG51bGwgPyBfYSA6IGVsZW1lbnQudmFsdWU7XG4gICAgICBpZiAodGFyZ2V0RWxlbWVudCAmJiBjdXJyZW50RWxlbWVudCA9PT0gdGFyZ2V0RWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LnZhbHVlID0gZG9jdW1lbnQucG9pbnRlckxvY2tFbGVtZW50O1xuICAgICAgICBpZiAoIWVsZW1lbnQudmFsdWUpXG4gICAgICAgICAgdGFyZ2V0RWxlbWVudCA9IHRyaWdnZXJFbGVtZW50LnZhbHVlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB1c2VFdmVudExpc3RlbmVyKGRvY3VtZW50LCBcInBvaW50ZXJsb2NrZXJyb3JcIiwgKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgY3VycmVudEVsZW1lbnQgPSAoX2EgPSBkb2N1bWVudC5wb2ludGVyTG9ja0VsZW1lbnQpICE9IG51bGwgPyBfYSA6IGVsZW1lbnQudmFsdWU7XG4gICAgICBpZiAodGFyZ2V0RWxlbWVudCAmJiBjdXJyZW50RWxlbWVudCA9PT0gdGFyZ2V0RWxlbWVudCkge1xuICAgICAgICBjb25zdCBhY3Rpb24gPSBkb2N1bWVudC5wb2ludGVyTG9ja0VsZW1lbnQgPyBcInJlbGVhc2VcIiA6IFwiYWNxdWlyZVwiO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byAke2FjdGlvbn0gcG9pbnRlciBsb2NrLmApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGxvY2soZSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIWlzU3VwcG9ydGVkLnZhbHVlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9pbnRlciBMb2NrIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHlvdXIgYnJvd3Nlci5cIik7XG4gICAgdHJpZ2dlckVsZW1lbnQudmFsdWUgPSBlIGluc3RhbmNlb2YgRXZlbnQgPyBlLmN1cnJlbnRUYXJnZXQgOiBudWxsO1xuICAgIHRhcmdldEVsZW1lbnQgPSBlIGluc3RhbmNlb2YgRXZlbnQgPyAoX2EgPSB1bnJlZkVsZW1lbnQodGFyZ2V0KSkgIT0gbnVsbCA/IF9hIDogdHJpZ2dlckVsZW1lbnQudmFsdWUgOiB1bnJlZkVsZW1lbnQoZSk7XG4gICAgaWYgKCF0YXJnZXRFbGVtZW50KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGFyZ2V0IGVsZW1lbnQgdW5kZWZpbmVkLlwiKTtcbiAgICB0YXJnZXRFbGVtZW50LnJlcXVlc3RQb2ludGVyTG9jaygpO1xuICAgIHJldHVybiBhd2FpdCB1bnRpbChlbGVtZW50KS50b0JlKHRhcmdldEVsZW1lbnQpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHVubG9jaygpIHtcbiAgICBpZiAoIWVsZW1lbnQudmFsdWUpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZG9jdW1lbnQuZXhpdFBvaW50ZXJMb2NrKCk7XG4gICAgYXdhaXQgdW50aWwoZWxlbWVudCkudG9CZU51bGwoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIGVsZW1lbnQsXG4gICAgdHJpZ2dlckVsZW1lbnQsXG4gICAgbG9jayxcbiAgICB1bmxvY2tcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlUG9pbnRlclN3aXBlKHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHRhcmdldFJlZiA9IHRvUmVmKHRhcmdldCk7XG4gIGNvbnN0IHtcbiAgICB0aHJlc2hvbGQgPSA1MCxcbiAgICBvblN3aXBlLFxuICAgIG9uU3dpcGVFbmQsXG4gICAgb25Td2lwZVN0YXJ0LFxuICAgIGRpc2FibGVUZXh0U2VsZWN0ID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHBvc1N0YXJ0ID0gcmVhY3RpdmUoeyB4OiAwLCB5OiAwIH0pO1xuICBjb25zdCB1cGRhdGVQb3NTdGFydCA9ICh4LCB5KSA9PiB7XG4gICAgcG9zU3RhcnQueCA9IHg7XG4gICAgcG9zU3RhcnQueSA9IHk7XG4gIH07XG4gIGNvbnN0IHBvc0VuZCA9IHJlYWN0aXZlKHsgeDogMCwgeTogMCB9KTtcbiAgY29uc3QgdXBkYXRlUG9zRW5kID0gKHgsIHkpID0+IHtcbiAgICBwb3NFbmQueCA9IHg7XG4gICAgcG9zRW5kLnkgPSB5O1xuICB9O1xuICBjb25zdCBkaXN0YW5jZVggPSBjb21wdXRlZCgoKSA9PiBwb3NTdGFydC54IC0gcG9zRW5kLngpO1xuICBjb25zdCBkaXN0YW5jZVkgPSBjb21wdXRlZCgoKSA9PiBwb3NTdGFydC55IC0gcG9zRW5kLnkpO1xuICBjb25zdCB7IG1heCwgYWJzIH0gPSBNYXRoO1xuICBjb25zdCBpc1RocmVzaG9sZEV4Y2VlZGVkID0gY29tcHV0ZWQoKCkgPT4gbWF4KGFicyhkaXN0YW5jZVgudmFsdWUpLCBhYnMoZGlzdGFuY2VZLnZhbHVlKSkgPj0gdGhyZXNob2xkKTtcbiAgY29uc3QgaXNTd2lwaW5nID0gcmVmKGZhbHNlKTtcbiAgY29uc3QgaXNQb2ludGVyRG93biA9IHJlZihmYWxzZSk7XG4gIGNvbnN0IGRpcmVjdGlvbiA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICBpZiAoIWlzVGhyZXNob2xkRXhjZWVkZWQudmFsdWUpXG4gICAgICByZXR1cm4gXCJub25lXCI7XG4gICAgaWYgKGFicyhkaXN0YW5jZVgudmFsdWUpID4gYWJzKGRpc3RhbmNlWS52YWx1ZSkpIHtcbiAgICAgIHJldHVybiBkaXN0YW5jZVgudmFsdWUgPiAwID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkaXN0YW5jZVkudmFsdWUgPiAwID8gXCJ1cFwiIDogXCJkb3duXCI7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgZXZlbnRJc0FsbG93ZWQgPSAoZSkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IGlzUmVsZWFzaW5nQnV0dG9uID0gZS5idXR0b25zID09PSAwO1xuICAgIGNvbnN0IGlzUHJpbWFyeUJ1dHRvbiA9IGUuYnV0dG9ucyA9PT0gMTtcbiAgICByZXR1cm4gKF9jID0gKF9iID0gKF9hID0gb3B0aW9ucy5wb2ludGVyVHlwZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcyhlLnBvaW50ZXJUeXBlKSkgIT0gbnVsbCA/IF9iIDogaXNSZWxlYXNpbmdCdXR0b24gfHwgaXNQcmltYXJ5QnV0dG9uKSAhPSBudWxsID8gX2MgOiB0cnVlO1xuICB9O1xuICBjb25zdCBzdG9wcyA9IFtcbiAgICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJwb2ludGVyZG93blwiLCAoZSkgPT4ge1xuICAgICAgaWYgKCFldmVudElzQWxsb3dlZChlKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaXNQb2ludGVyRG93bi52YWx1ZSA9IHRydWU7XG4gICAgICBjb25zdCBldmVudFRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgZXZlbnRUYXJnZXQgPT0gbnVsbCA/IHZvaWQgMCA6IGV2ZW50VGFyZ2V0LnNldFBvaW50ZXJDYXB0dXJlKGUucG9pbnRlcklkKTtcbiAgICAgIGNvbnN0IHsgY2xpZW50WDogeCwgY2xpZW50WTogeSB9ID0gZTtcbiAgICAgIHVwZGF0ZVBvc1N0YXJ0KHgsIHkpO1xuICAgICAgdXBkYXRlUG9zRW5kKHgsIHkpO1xuICAgICAgb25Td2lwZVN0YXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvblN3aXBlU3RhcnQoZSk7XG4gICAgfSksXG4gICAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFwicG9pbnRlcm1vdmVcIiwgKGUpID0+IHtcbiAgICAgIGlmICghZXZlbnRJc0FsbG93ZWQoZSkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICghaXNQb2ludGVyRG93bi52YWx1ZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgeyBjbGllbnRYOiB4LCBjbGllbnRZOiB5IH0gPSBlO1xuICAgICAgdXBkYXRlUG9zRW5kKHgsIHkpO1xuICAgICAgaWYgKCFpc1N3aXBpbmcudmFsdWUgJiYgaXNUaHJlc2hvbGRFeGNlZWRlZC52YWx1ZSlcbiAgICAgICAgaXNTd2lwaW5nLnZhbHVlID0gdHJ1ZTtcbiAgICAgIGlmIChpc1N3aXBpbmcudmFsdWUpXG4gICAgICAgIG9uU3dpcGUgPT0gbnVsbCA/IHZvaWQgMCA6IG9uU3dpcGUoZSk7XG4gICAgfSksXG4gICAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFwicG9pbnRlcnVwXCIsIChlKSA9PiB7XG4gICAgICBpZiAoIWV2ZW50SXNBbGxvd2VkKGUpKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoaXNTd2lwaW5nLnZhbHVlKVxuICAgICAgICBvblN3aXBlRW5kID09IG51bGwgPyB2b2lkIDAgOiBvblN3aXBlRW5kKGUsIGRpcmVjdGlvbi52YWx1ZSk7XG4gICAgICBpc1BvaW50ZXJEb3duLnZhbHVlID0gZmFsc2U7XG4gICAgICBpc1N3aXBpbmcudmFsdWUgPSBmYWxzZTtcbiAgICB9KVxuICBdO1xuICB0cnlPbk1vdW50ZWQoKCkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgKF9iID0gKF9hID0gdGFyZ2V0UmVmLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc3R5bGUpID09IG51bGwgPyB2b2lkIDAgOiBfYi5zZXRQcm9wZXJ0eShcInRvdWNoLWFjdGlvblwiLCBcIm5vbmVcIik7XG4gICAgaWYgKGRpc2FibGVUZXh0U2VsZWN0KSB7XG4gICAgICAoX2QgPSAoX2MgPSB0YXJnZXRSZWYudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYy5zdHlsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLnNldFByb3BlcnR5KFwiLXdlYmtpdC11c2VyLXNlbGVjdFwiLCBcIm5vbmVcIik7XG4gICAgICAoX2YgPSAoX2UgPSB0YXJnZXRSZWYudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfZS5zdHlsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLnNldFByb3BlcnR5KFwiLW1zLXVzZXItc2VsZWN0XCIsIFwibm9uZVwiKTtcbiAgICAgIChfaCA9IChfZyA9IHRhcmdldFJlZi52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLnN0eWxlKSA9PSBudWxsID8gdm9pZCAwIDogX2guc2V0UHJvcGVydHkoXCJ1c2VyLXNlbGVjdFwiLCBcIm5vbmVcIik7XG4gICAgfVxuICB9KTtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IHN0b3BzLmZvckVhY2goKHMpID0+IHMoKSk7XG4gIHJldHVybiB7XG4gICAgaXNTd2lwaW5nOiByZWFkb25seShpc1N3aXBpbmcpLFxuICAgIGRpcmVjdGlvbjogcmVhZG9ubHkoZGlyZWN0aW9uKSxcbiAgICBwb3NTdGFydDogcmVhZG9ubHkocG9zU3RhcnQpLFxuICAgIHBvc0VuZDogcmVhZG9ubHkocG9zRW5kKSxcbiAgICBkaXN0YW5jZVgsXG4gICAgZGlzdGFuY2VZLFxuICAgIHN0b3BcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlUHJlZmVycmVkQ29sb3JTY2hlbWUob3B0aW9ucykge1xuICBjb25zdCBpc0xpZ2h0ID0gdXNlTWVkaWFRdWVyeShcIihwcmVmZXJzLWNvbG9yLXNjaGVtZTogbGlnaHQpXCIsIG9wdGlvbnMpO1xuICBjb25zdCBpc0RhcmsgPSB1c2VNZWRpYVF1ZXJ5KFwiKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKVwiLCBvcHRpb25zKTtcbiAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IHtcbiAgICBpZiAoaXNEYXJrLnZhbHVlKVxuICAgICAgcmV0dXJuIFwiZGFya1wiO1xuICAgIGlmIChpc0xpZ2h0LnZhbHVlKVxuICAgICAgcmV0dXJuIFwibGlnaHRcIjtcbiAgICByZXR1cm4gXCJuby1wcmVmZXJlbmNlXCI7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VQcmVmZXJyZWRDb250cmFzdChvcHRpb25zKSB7XG4gIGNvbnN0IGlzTW9yZSA9IHVzZU1lZGlhUXVlcnkoXCIocHJlZmVycy1jb250cmFzdDogbW9yZSlcIiwgb3B0aW9ucyk7XG4gIGNvbnN0IGlzTGVzcyA9IHVzZU1lZGlhUXVlcnkoXCIocHJlZmVycy1jb250cmFzdDogbGVzcylcIiwgb3B0aW9ucyk7XG4gIGNvbnN0IGlzQ3VzdG9tID0gdXNlTWVkaWFRdWVyeShcIihwcmVmZXJzLWNvbnRyYXN0OiBjdXN0b20pXCIsIG9wdGlvbnMpO1xuICByZXR1cm4gY29tcHV0ZWQoKCkgPT4ge1xuICAgIGlmIChpc01vcmUudmFsdWUpXG4gICAgICByZXR1cm4gXCJtb3JlXCI7XG4gICAgaWYgKGlzTGVzcy52YWx1ZSlcbiAgICAgIHJldHVybiBcImxlc3NcIjtcbiAgICBpZiAoaXNDdXN0b20udmFsdWUpXG4gICAgICByZXR1cm4gXCJjdXN0b21cIjtcbiAgICByZXR1cm4gXCJuby1wcmVmZXJlbmNlXCI7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VQcmVmZXJyZWRMYW5ndWFnZXMob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgd2luZG93ID0gZGVmYXVsdFdpbmRvdyB9ID0gb3B0aW9ucztcbiAgaWYgKCF3aW5kb3cpXG4gICAgcmV0dXJuIHJlZihbXCJlblwiXSk7XG4gIGNvbnN0IG5hdmlnYXRvciA9IHdpbmRvdy5uYXZpZ2F0b3I7XG4gIGNvbnN0IHZhbHVlID0gcmVmKG5hdmlnYXRvci5sYW5ndWFnZXMpO1xuICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJsYW5ndWFnZWNoYW5nZVwiLCAoKSA9PiB7XG4gICAgdmFsdWUudmFsdWUgPSBuYXZpZ2F0b3IubGFuZ3VhZ2VzO1xuICB9KTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB1c2VQcmVmZXJyZWRSZWR1Y2VkTW90aW9uKG9wdGlvbnMpIHtcbiAgY29uc3QgaXNSZWR1Y2VkID0gdXNlTWVkaWFRdWVyeShcIihwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpXCIsIG9wdGlvbnMpO1xuICByZXR1cm4gY29tcHV0ZWQoKCkgPT4ge1xuICAgIGlmIChpc1JlZHVjZWQudmFsdWUpXG4gICAgICByZXR1cm4gXCJyZWR1Y2VcIjtcbiAgICByZXR1cm4gXCJuby1wcmVmZXJlbmNlXCI7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VQcmV2aW91cyh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gIGNvbnN0IHByZXZpb3VzID0gc2hhbGxvd1JlZihpbml0aWFsVmFsdWUpO1xuICB3YXRjaChcbiAgICB0b1JlZih2YWx1ZSksXG4gICAgKF8sIG9sZFZhbHVlKSA9PiB7XG4gICAgICBwcmV2aW91cy52YWx1ZSA9IG9sZFZhbHVlO1xuICAgIH0sXG4gICAgeyBmbHVzaDogXCJzeW5jXCIgfVxuICApO1xuICByZXR1cm4gcmVhZG9ubHkocHJldmlvdXMpO1xufVxuXG5jb25zdCB0b3BWYXJOYW1lID0gXCItLXZ1ZXVzZS1zYWZlLWFyZWEtdG9wXCI7XG5jb25zdCByaWdodFZhck5hbWUgPSBcIi0tdnVldXNlLXNhZmUtYXJlYS1yaWdodFwiO1xuY29uc3QgYm90dG9tVmFyTmFtZSA9IFwiLS12dWV1c2Utc2FmZS1hcmVhLWJvdHRvbVwiO1xuY29uc3QgbGVmdFZhck5hbWUgPSBcIi0tdnVldXNlLXNhZmUtYXJlYS1sZWZ0XCI7XG5mdW5jdGlvbiB1c2VTY3JlZW5TYWZlQXJlYSgpIHtcbiAgY29uc3QgdG9wID0gcmVmKFwiXCIpO1xuICBjb25zdCByaWdodCA9IHJlZihcIlwiKTtcbiAgY29uc3QgYm90dG9tID0gcmVmKFwiXCIpO1xuICBjb25zdCBsZWZ0ID0gcmVmKFwiXCIpO1xuICBpZiAoaXNDbGllbnQpIHtcbiAgICBjb25zdCB0b3BDc3NWYXIgPSB1c2VDc3NWYXIodG9wVmFyTmFtZSk7XG4gICAgY29uc3QgcmlnaHRDc3NWYXIgPSB1c2VDc3NWYXIocmlnaHRWYXJOYW1lKTtcbiAgICBjb25zdCBib3R0b21Dc3NWYXIgPSB1c2VDc3NWYXIoYm90dG9tVmFyTmFtZSk7XG4gICAgY29uc3QgbGVmdENzc1ZhciA9IHVzZUNzc1ZhcihsZWZ0VmFyTmFtZSk7XG4gICAgdG9wQ3NzVmFyLnZhbHVlID0gXCJlbnYoc2FmZS1hcmVhLWluc2V0LXRvcCwgMHB4KVwiO1xuICAgIHJpZ2h0Q3NzVmFyLnZhbHVlID0gXCJlbnYoc2FmZS1hcmVhLWluc2V0LXJpZ2h0LCAwcHgpXCI7XG4gICAgYm90dG9tQ3NzVmFyLnZhbHVlID0gXCJlbnYoc2FmZS1hcmVhLWluc2V0LWJvdHRvbSwgMHB4KVwiO1xuICAgIGxlZnRDc3NWYXIudmFsdWUgPSBcImVudihzYWZlLWFyZWEtaW5zZXQtbGVmdCwgMHB4KVwiO1xuICAgIHVwZGF0ZSgpO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdXNlRGVib3VuY2VGbih1cGRhdGUpKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdG9wLnZhbHVlID0gZ2V0VmFsdWUodG9wVmFyTmFtZSk7XG4gICAgcmlnaHQudmFsdWUgPSBnZXRWYWx1ZShyaWdodFZhck5hbWUpO1xuICAgIGJvdHRvbS52YWx1ZSA9IGdldFZhbHVlKGJvdHRvbVZhck5hbWUpO1xuICAgIGxlZnQudmFsdWUgPSBnZXRWYWx1ZShsZWZ0VmFyTmFtZSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b3AsXG4gICAgcmlnaHQsXG4gICAgYm90dG9tLFxuICAgIGxlZnQsXG4gICAgdXBkYXRlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRWYWx1ZShwb3NpdGlvbikge1xuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUocG9zaXRpb24pO1xufVxuXG5mdW5jdGlvbiB1c2VTY3JpcHRUYWcoc3JjLCBvbkxvYWRlZCA9IG5vb3AsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgaW1tZWRpYXRlID0gdHJ1ZSxcbiAgICBtYW51YWwgPSBmYWxzZSxcbiAgICB0eXBlID0gXCJ0ZXh0L2phdmFzY3JpcHRcIixcbiAgICBhc3luYyA9IHRydWUsXG4gICAgY3Jvc3NPcmlnaW4sXG4gICAgcmVmZXJyZXJQb2xpY3ksXG4gICAgbm9Nb2R1bGUsXG4gICAgZGVmZXIsXG4gICAgZG9jdW1lbnQgPSBkZWZhdWx0RG9jdW1lbnQsXG4gICAgYXR0cnMgPSB7fVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgc2NyaXB0VGFnID0gcmVmKG51bGwpO1xuICBsZXQgX3Byb21pc2UgPSBudWxsO1xuICBjb25zdCBsb2FkU2NyaXB0ID0gKHdhaXRGb3JTY3JpcHRMb2FkKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVzb2x2ZVdpdGhFbGVtZW50ID0gKGVsMikgPT4ge1xuICAgICAgc2NyaXB0VGFnLnZhbHVlID0gZWwyO1xuICAgICAgcmVzb2x2ZShlbDIpO1xuICAgICAgcmV0dXJuIGVsMjtcbiAgICB9O1xuICAgIGlmICghZG9jdW1lbnQpIHtcbiAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgc2hvdWxkQXBwZW5kID0gZmFsc2U7XG4gICAgbGV0IGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihgc2NyaXB0W3NyYz1cIiR7dG9WYWx1ZShzcmMpfVwiXWApO1xuICAgIGlmICghZWwpIHtcbiAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgIGVsLnR5cGUgPSB0eXBlO1xuICAgICAgZWwuYXN5bmMgPSBhc3luYztcbiAgICAgIGVsLnNyYyA9IHRvVmFsdWUoc3JjKTtcbiAgICAgIGlmIChkZWZlcilcbiAgICAgICAgZWwuZGVmZXIgPSBkZWZlcjtcbiAgICAgIGlmIChjcm9zc09yaWdpbilcbiAgICAgICAgZWwuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcbiAgICAgIGlmIChub01vZHVsZSlcbiAgICAgICAgZWwubm9Nb2R1bGUgPSBub01vZHVsZTtcbiAgICAgIGlmIChyZWZlcnJlclBvbGljeSlcbiAgICAgICAgZWwucmVmZXJyZXJQb2xpY3kgPSByZWZlcnJlclBvbGljeTtcbiAgICAgIE9iamVjdC5lbnRyaWVzKGF0dHJzKS5mb3JFYWNoKChbbmFtZSwgdmFsdWVdKSA9PiBlbCA9PSBudWxsID8gdm9pZCAwIDogZWwuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSk7XG4gICAgICBzaG91bGRBcHBlbmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZWwuaGFzQXR0cmlidXRlKFwiZGF0YS1sb2FkZWRcIikpIHtcbiAgICAgIHJlc29sdmVXaXRoRWxlbWVudChlbCk7XG4gICAgfVxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoZXZlbnQpID0+IHJlamVjdChldmVudCkpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoZXZlbnQpID0+IHJlamVjdChldmVudCkpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShcImRhdGEtbG9hZGVkXCIsIFwidHJ1ZVwiKTtcbiAgICAgIG9uTG9hZGVkKGVsKTtcbiAgICAgIHJlc29sdmVXaXRoRWxlbWVudChlbCk7XG4gICAgfSk7XG4gICAgaWYgKHNob3VsZEFwcGVuZClcbiAgICAgIGVsID0gZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChlbCk7XG4gICAgaWYgKCF3YWl0Rm9yU2NyaXB0TG9hZClcbiAgICAgIHJlc29sdmVXaXRoRWxlbWVudChlbCk7XG4gIH0pO1xuICBjb25zdCBsb2FkID0gKHdhaXRGb3JTY3JpcHRMb2FkID0gdHJ1ZSkgPT4ge1xuICAgIGlmICghX3Byb21pc2UpXG4gICAgICBfcHJvbWlzZSA9IGxvYWRTY3JpcHQod2FpdEZvclNjcmlwdExvYWQpO1xuICAgIHJldHVybiBfcHJvbWlzZTtcbiAgfTtcbiAgY29uc3QgdW5sb2FkID0gKCkgPT4ge1xuICAgIGlmICghZG9jdW1lbnQpXG4gICAgICByZXR1cm47XG4gICAgX3Byb21pc2UgPSBudWxsO1xuICAgIGlmIChzY3JpcHRUYWcudmFsdWUpXG4gICAgICBzY3JpcHRUYWcudmFsdWUgPSBudWxsO1xuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihgc2NyaXB0W3NyYz1cIiR7dG9WYWx1ZShzcmMpfVwiXWApO1xuICAgIGlmIChlbClcbiAgICAgIGRvY3VtZW50LmhlYWQucmVtb3ZlQ2hpbGQoZWwpO1xuICB9O1xuICBpZiAoaW1tZWRpYXRlICYmICFtYW51YWwpXG4gICAgdHJ5T25Nb3VudGVkKGxvYWQpO1xuICBpZiAoIW1hbnVhbClcbiAgICB0cnlPblVubW91bnRlZCh1bmxvYWQpO1xuICByZXR1cm4geyBzY3JpcHRUYWcsIGxvYWQsIHVubG9hZCB9O1xufVxuXG5mdW5jdGlvbiBjaGVja092ZXJmbG93U2Nyb2xsKGVsZSkge1xuICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZSk7XG4gIGlmIChzdHlsZS5vdmVyZmxvd1ggPT09IFwic2Nyb2xsXCIgfHwgc3R5bGUub3ZlcmZsb3dZID09PSBcInNjcm9sbFwiIHx8IHN0eWxlLm92ZXJmbG93WCA9PT0gXCJhdXRvXCIgJiYgZWxlLmNsaWVudFdpZHRoIDwgZWxlLnNjcm9sbFdpZHRoIHx8IHN0eWxlLm92ZXJmbG93WSA9PT0gXCJhdXRvXCIgJiYgZWxlLmNsaWVudEhlaWdodCA8IGVsZS5zY3JvbGxIZWlnaHQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBwYXJlbnQgPSBlbGUucGFyZW50Tm9kZTtcbiAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQudGFnTmFtZSA9PT0gXCJCT0RZXCIpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGNoZWNrT3ZlcmZsb3dTY3JvbGwocGFyZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQocmF3RXZlbnQpIHtcbiAgY29uc3QgZSA9IHJhd0V2ZW50IHx8IHdpbmRvdy5ldmVudDtcbiAgY29uc3QgX3RhcmdldCA9IGUudGFyZ2V0O1xuICBpZiAoY2hlY2tPdmVyZmxvd1Njcm9sbChfdGFyZ2V0KSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChlLnRvdWNoZXMubGVuZ3RoID4gMSlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKGUucHJldmVudERlZmF1bHQpXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICByZXR1cm4gZmFsc2U7XG59XG5jb25zdCBlbEluaXRpYWxPdmVyZmxvdyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gdXNlU2Nyb2xsTG9jayhlbGVtZW50LCBpbml0aWFsU3RhdGUgPSBmYWxzZSkge1xuICBjb25zdCBpc0xvY2tlZCA9IHJlZihpbml0aWFsU3RhdGUpO1xuICBsZXQgc3RvcFRvdWNoTW92ZUxpc3RlbmVyID0gbnVsbDtcbiAgbGV0IGluaXRpYWxPdmVyZmxvdyA9IFwiXCI7XG4gIHdhdGNoKHRvUmVmKGVsZW1lbnQpLCAoZWwpID0+IHtcbiAgICBjb25zdCB0YXJnZXQgPSByZXNvbHZlRWxlbWVudCh0b1ZhbHVlKGVsKSk7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgY29uc3QgZWxlID0gdGFyZ2V0O1xuICAgICAgaWYgKCFlbEluaXRpYWxPdmVyZmxvdy5nZXQoZWxlKSlcbiAgICAgICAgZWxJbml0aWFsT3ZlcmZsb3cuc2V0KGVsZSwgZWxlLnN0eWxlLm92ZXJmbG93KTtcbiAgICAgIGlmIChlbGUuc3R5bGUub3ZlcmZsb3cgIT09IFwiaGlkZGVuXCIpXG4gICAgICAgIGluaXRpYWxPdmVyZmxvdyA9IGVsZS5zdHlsZS5vdmVyZmxvdztcbiAgICAgIGlmIChlbGUuc3R5bGUub3ZlcmZsb3cgPT09IFwiaGlkZGVuXCIpXG4gICAgICAgIHJldHVybiBpc0xvY2tlZC52YWx1ZSA9IHRydWU7XG4gICAgICBpZiAoaXNMb2NrZWQudmFsdWUpXG4gICAgICAgIHJldHVybiBlbGUuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICAgIH1cbiAgfSwge1xuICAgIGltbWVkaWF0ZTogdHJ1ZVxuICB9KTtcbiAgY29uc3QgbG9jayA9ICgpID0+IHtcbiAgICBjb25zdCBlbCA9IHJlc29sdmVFbGVtZW50KHRvVmFsdWUoZWxlbWVudCkpO1xuICAgIGlmICghZWwgfHwgaXNMb2NrZWQudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGlzSU9TKSB7XG4gICAgICBzdG9wVG91Y2hNb3ZlTGlzdGVuZXIgPSB1c2VFdmVudExpc3RlbmVyKFxuICAgICAgICBlbCxcbiAgICAgICAgXCJ0b3VjaG1vdmVcIixcbiAgICAgICAgKGUpID0+IHtcbiAgICAgICAgICBwcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgfSxcbiAgICAgICAgeyBwYXNzaXZlOiBmYWxzZSB9XG4gICAgICApO1xuICAgIH1cbiAgICBlbC5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgaXNMb2NrZWQudmFsdWUgPSB0cnVlO1xuICB9O1xuICBjb25zdCB1bmxvY2sgPSAoKSA9PiB7XG4gICAgY29uc3QgZWwgPSByZXNvbHZlRWxlbWVudCh0b1ZhbHVlKGVsZW1lbnQpKTtcbiAgICBpZiAoIWVsIHx8ICFpc0xvY2tlZC52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBpc0lPUyAmJiAoc3RvcFRvdWNoTW92ZUxpc3RlbmVyID09IG51bGwgPyB2b2lkIDAgOiBzdG9wVG91Y2hNb3ZlTGlzdGVuZXIoKSk7XG4gICAgZWwuc3R5bGUub3ZlcmZsb3cgPSBpbml0aWFsT3ZlcmZsb3c7XG4gICAgZWxJbml0aWFsT3ZlcmZsb3cuZGVsZXRlKGVsKTtcbiAgICBpc0xvY2tlZC52YWx1ZSA9IGZhbHNlO1xuICB9O1xuICB0cnlPblNjb3BlRGlzcG9zZSh1bmxvY2spO1xuICByZXR1cm4gY29tcHV0ZWQoe1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBpc0xvY2tlZC52YWx1ZTtcbiAgICB9LFxuICAgIHNldCh2KSB7XG4gICAgICBpZiAodilcbiAgICAgICAgbG9jaygpO1xuICAgICAgZWxzZSB1bmxvY2soKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VTZXNzaW9uU3RvcmFnZShrZXksIGluaXRpYWxWYWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgd2luZG93ID0gZGVmYXVsdFdpbmRvdyB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIHVzZVN0b3JhZ2Uoa2V5LCBpbml0aWFsVmFsdWUsIHdpbmRvdyA9PSBudWxsID8gdm9pZCAwIDogd2luZG93LnNlc3Npb25TdG9yYWdlLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gdXNlU2hhcmUoc2hhcmVPcHRpb25zID0ge30sIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IG5hdmlnYXRvciA9IGRlZmF1bHROYXZpZ2F0b3IgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IF9uYXZpZ2F0b3IgPSBuYXZpZ2F0b3I7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IF9uYXZpZ2F0b3IgJiYgXCJjYW5TaGFyZVwiIGluIF9uYXZpZ2F0b3IpO1xuICBjb25zdCBzaGFyZSA9IGFzeW5jIChvdmVycmlkZU9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGlmIChpc1N1cHBvcnRlZC52YWx1ZSkge1xuICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgLi4udG9WYWx1ZShzaGFyZU9wdGlvbnMpLFxuICAgICAgICAuLi50b1ZhbHVlKG92ZXJyaWRlT3B0aW9ucylcbiAgICAgIH07XG4gICAgICBsZXQgZ3JhbnRlZCA9IHRydWU7XG4gICAgICBpZiAoZGF0YS5maWxlcyAmJiBfbmF2aWdhdG9yLmNhblNoYXJlKVxuICAgICAgICBncmFudGVkID0gX25hdmlnYXRvci5jYW5TaGFyZSh7IGZpbGVzOiBkYXRhLmZpbGVzIH0pO1xuICAgICAgaWYgKGdyYW50ZWQpXG4gICAgICAgIHJldHVybiBfbmF2aWdhdG9yLnNoYXJlKGRhdGEpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBzaGFyZVxuICB9O1xufVxuXG5jb25zdCBkZWZhdWx0U29ydEZuID0gKHNvdXJjZSwgY29tcGFyZUZuKSA9PiBzb3VyY2Uuc29ydChjb21wYXJlRm4pO1xuY29uc3QgZGVmYXVsdENvbXBhcmUgPSAoYSwgYikgPT4gYSAtIGI7XG5mdW5jdGlvbiB1c2VTb3J0ZWQoLi4uYXJncykge1xuICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gIGNvbnN0IFtzb3VyY2VdID0gYXJncztcbiAgbGV0IGNvbXBhcmVGbiA9IGRlZmF1bHRDb21wYXJlO1xuICBsZXQgb3B0aW9ucyA9IHt9O1xuICBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3NbMV0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIG9wdGlvbnMgPSBhcmdzWzFdO1xuICAgICAgY29tcGFyZUZuID0gKF9hID0gb3B0aW9ucy5jb21wYXJlRm4pICE9IG51bGwgPyBfYSA6IGRlZmF1bHRDb21wYXJlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21wYXJlRm4gPSAoX2IgPSBhcmdzWzFdKSAhPSBudWxsID8gX2IgOiBkZWZhdWx0Q29tcGFyZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPiAyKSB7XG4gICAgY29tcGFyZUZuID0gKF9jID0gYXJnc1sxXSkgIT0gbnVsbCA/IF9jIDogZGVmYXVsdENvbXBhcmU7XG4gICAgb3B0aW9ucyA9IChfZCA9IGFyZ3NbMl0pICE9IG51bGwgPyBfZCA6IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBkaXJ0eSA9IGZhbHNlLFxuICAgIHNvcnRGbiA9IGRlZmF1bHRTb3J0Rm5cbiAgfSA9IG9wdGlvbnM7XG4gIGlmICghZGlydHkpXG4gICAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IHNvcnRGbihbLi4udG9WYWx1ZShzb3VyY2UpXSwgY29tcGFyZUZuKSk7XG4gIHdhdGNoRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBzb3J0Rm4odG9WYWx1ZShzb3VyY2UpLCBjb21wYXJlRm4pO1xuICAgIGlmIChpc1JlZihzb3VyY2UpKVxuICAgICAgc291cmNlLnZhbHVlID0gcmVzdWx0O1xuICAgIGVsc2VcbiAgICAgIHNvdXJjZS5zcGxpY2UoMCwgc291cmNlLmxlbmd0aCwgLi4ucmVzdWx0KTtcbiAgfSk7XG4gIHJldHVybiBzb3VyY2U7XG59XG5cbmZ1bmN0aW9uIHVzZVNwZWVjaFJlY29nbml0aW9uKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgaW50ZXJpbVJlc3VsdHMgPSB0cnVlLFxuICAgIGNvbnRpbnVvdXMgPSB0cnVlLFxuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3dcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGxhbmcgPSB0b1JlZihvcHRpb25zLmxhbmcgfHwgXCJlbi1VU1wiKTtcbiAgY29uc3QgaXNMaXN0ZW5pbmcgPSByZWYoZmFsc2UpO1xuICBjb25zdCBpc0ZpbmFsID0gcmVmKGZhbHNlKTtcbiAgY29uc3QgcmVzdWx0ID0gcmVmKFwiXCIpO1xuICBjb25zdCBlcnJvciA9IHNoYWxsb3dSZWYodm9pZCAwKTtcbiAgY29uc3QgdG9nZ2xlID0gKHZhbHVlID0gIWlzTGlzdGVuaW5nLnZhbHVlKSA9PiB7XG4gICAgaXNMaXN0ZW5pbmcudmFsdWUgPSB2YWx1ZTtcbiAgfTtcbiAgY29uc3Qgc3RhcnQgPSAoKSA9PiB7XG4gICAgaXNMaXN0ZW5pbmcudmFsdWUgPSB0cnVlO1xuICB9O1xuICBjb25zdCBzdG9wID0gKCkgPT4ge1xuICAgIGlzTGlzdGVuaW5nLnZhbHVlID0gZmFsc2U7XG4gIH07XG4gIGNvbnN0IFNwZWVjaFJlY29nbml0aW9uID0gd2luZG93ICYmICh3aW5kb3cuU3BlZWNoUmVjb2duaXRpb24gfHwgd2luZG93LndlYmtpdFNwZWVjaFJlY29nbml0aW9uKTtcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gU3BlZWNoUmVjb2duaXRpb24pO1xuICBsZXQgcmVjb2duaXRpb247XG4gIGlmIChpc1N1cHBvcnRlZC52YWx1ZSkge1xuICAgIHJlY29nbml0aW9uID0gbmV3IFNwZWVjaFJlY29nbml0aW9uKCk7XG4gICAgcmVjb2duaXRpb24uY29udGludW91cyA9IGNvbnRpbnVvdXM7XG4gICAgcmVjb2duaXRpb24uaW50ZXJpbVJlc3VsdHMgPSBpbnRlcmltUmVzdWx0cztcbiAgICByZWNvZ25pdGlvbi5sYW5nID0gdG9WYWx1ZShsYW5nKTtcbiAgICByZWNvZ25pdGlvbi5vbnN0YXJ0ID0gKCkgPT4ge1xuICAgICAgaXNGaW5hbC52YWx1ZSA9IGZhbHNlO1xuICAgIH07XG4gICAgd2F0Y2gobGFuZywgKGxhbmcyKSA9PiB7XG4gICAgICBpZiAocmVjb2duaXRpb24gJiYgIWlzTGlzdGVuaW5nLnZhbHVlKVxuICAgICAgICByZWNvZ25pdGlvbi5sYW5nID0gbGFuZzI7XG4gICAgfSk7XG4gICAgcmVjb2duaXRpb24ub25yZXN1bHQgPSAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRSZXN1bHQgPSBldmVudC5yZXN1bHRzW2V2ZW50LnJlc3VsdEluZGV4XTtcbiAgICAgIGNvbnN0IHsgdHJhbnNjcmlwdCB9ID0gY3VycmVudFJlc3VsdFswXTtcbiAgICAgIGlzRmluYWwudmFsdWUgPSBjdXJyZW50UmVzdWx0LmlzRmluYWw7XG4gICAgICByZXN1bHQudmFsdWUgPSB0cmFuc2NyaXB0O1xuICAgICAgZXJyb3IudmFsdWUgPSB2b2lkIDA7XG4gICAgfTtcbiAgICByZWNvZ25pdGlvbi5vbmVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICBlcnJvci52YWx1ZSA9IGV2ZW50O1xuICAgIH07XG4gICAgcmVjb2duaXRpb24ub25lbmQgPSAoKSA9PiB7XG4gICAgICBpc0xpc3RlbmluZy52YWx1ZSA9IGZhbHNlO1xuICAgICAgcmVjb2duaXRpb24ubGFuZyA9IHRvVmFsdWUobGFuZyk7XG4gICAgfTtcbiAgICB3YXRjaChpc0xpc3RlbmluZywgKCkgPT4ge1xuICAgICAgaWYgKGlzTGlzdGVuaW5nLnZhbHVlKVxuICAgICAgICByZWNvZ25pdGlvbi5zdGFydCgpO1xuICAgICAgZWxzZVxuICAgICAgICByZWNvZ25pdGlvbi5zdG9wKCk7XG4gICAgfSk7XG4gIH1cbiAgdHJ5T25TY29wZURpc3Bvc2UoKCkgPT4ge1xuICAgIGlzTGlzdGVuaW5nLnZhbHVlID0gZmFsc2U7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIGlzTGlzdGVuaW5nLFxuICAgIGlzRmluYWwsXG4gICAgcmVjb2duaXRpb24sXG4gICAgcmVzdWx0LFxuICAgIGVycm9yLFxuICAgIHRvZ2dsZSxcbiAgICBzdGFydCxcbiAgICBzdG9wXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVNwZWVjaFN5bnRoZXNpcyh0ZXh0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHBpdGNoID0gMSxcbiAgICByYXRlID0gMSxcbiAgICB2b2x1bWUgPSAxLFxuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3dcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHN5bnRoID0gd2luZG93ICYmIHdpbmRvdy5zcGVlY2hTeW50aGVzaXM7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IHN5bnRoKTtcbiAgY29uc3QgaXNQbGF5aW5nID0gcmVmKGZhbHNlKTtcbiAgY29uc3Qgc3RhdHVzID0gcmVmKFwiaW5pdFwiKTtcbiAgY29uc3Qgc3Bva2VuVGV4dCA9IHRvUmVmKHRleHQgfHwgXCJcIik7XG4gIGNvbnN0IGxhbmcgPSB0b1JlZihvcHRpb25zLmxhbmcgfHwgXCJlbi1VU1wiKTtcbiAgY29uc3QgZXJyb3IgPSBzaGFsbG93UmVmKHZvaWQgMCk7XG4gIGNvbnN0IHRvZ2dsZSA9ICh2YWx1ZSA9ICFpc1BsYXlpbmcudmFsdWUpID0+IHtcbiAgICBpc1BsYXlpbmcudmFsdWUgPSB2YWx1ZTtcbiAgfTtcbiAgY29uc3QgYmluZEV2ZW50c0ZvclV0dGVyYW5jZSA9ICh1dHRlcmFuY2UyKSA9PiB7XG4gICAgdXR0ZXJhbmNlMi5sYW5nID0gdG9WYWx1ZShsYW5nKTtcbiAgICB1dHRlcmFuY2UyLnZvaWNlID0gdG9WYWx1ZShvcHRpb25zLnZvaWNlKSB8fCBudWxsO1xuICAgIHV0dGVyYW5jZTIucGl0Y2ggPSB0b1ZhbHVlKHBpdGNoKTtcbiAgICB1dHRlcmFuY2UyLnJhdGUgPSB0b1ZhbHVlKHJhdGUpO1xuICAgIHV0dGVyYW5jZTIudm9sdW1lID0gdm9sdW1lO1xuICAgIHV0dGVyYW5jZTIub25zdGFydCA9ICgpID0+IHtcbiAgICAgIGlzUGxheWluZy52YWx1ZSA9IHRydWU7XG4gICAgICBzdGF0dXMudmFsdWUgPSBcInBsYXlcIjtcbiAgICB9O1xuICAgIHV0dGVyYW5jZTIub25wYXVzZSA9ICgpID0+IHtcbiAgICAgIGlzUGxheWluZy52YWx1ZSA9IGZhbHNlO1xuICAgICAgc3RhdHVzLnZhbHVlID0gXCJwYXVzZVwiO1xuICAgIH07XG4gICAgdXR0ZXJhbmNlMi5vbnJlc3VtZSA9ICgpID0+IHtcbiAgICAgIGlzUGxheWluZy52YWx1ZSA9IHRydWU7XG4gICAgICBzdGF0dXMudmFsdWUgPSBcInBsYXlcIjtcbiAgICB9O1xuICAgIHV0dGVyYW5jZTIub25lbmQgPSAoKSA9PiB7XG4gICAgICBpc1BsYXlpbmcudmFsdWUgPSBmYWxzZTtcbiAgICAgIHN0YXR1cy52YWx1ZSA9IFwiZW5kXCI7XG4gICAgfTtcbiAgICB1dHRlcmFuY2UyLm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgIGVycm9yLnZhbHVlID0gZXZlbnQ7XG4gICAgfTtcbiAgfTtcbiAgY29uc3QgdXR0ZXJhbmNlID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIGlzUGxheWluZy52YWx1ZSA9IGZhbHNlO1xuICAgIHN0YXR1cy52YWx1ZSA9IFwiaW5pdFwiO1xuICAgIGNvbnN0IG5ld1V0dGVyYW5jZSA9IG5ldyBTcGVlY2hTeW50aGVzaXNVdHRlcmFuY2Uoc3Bva2VuVGV4dC52YWx1ZSk7XG4gICAgYmluZEV2ZW50c0ZvclV0dGVyYW5jZShuZXdVdHRlcmFuY2UpO1xuICAgIHJldHVybiBuZXdVdHRlcmFuY2U7XG4gIH0pO1xuICBjb25zdCBzcGVhayA9ICgpID0+IHtcbiAgICBzeW50aC5jYW5jZWwoKTtcbiAgICB1dHRlcmFuY2UgJiYgc3ludGguc3BlYWsodXR0ZXJhbmNlLnZhbHVlKTtcbiAgfTtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IHtcbiAgICBzeW50aC5jYW5jZWwoKTtcbiAgICBpc1BsYXlpbmcudmFsdWUgPSBmYWxzZTtcbiAgfTtcbiAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlKSB7XG4gICAgYmluZEV2ZW50c0ZvclV0dGVyYW5jZSh1dHRlcmFuY2UudmFsdWUpO1xuICAgIHdhdGNoKGxhbmcsIChsYW5nMikgPT4ge1xuICAgICAgaWYgKHV0dGVyYW5jZS52YWx1ZSAmJiAhaXNQbGF5aW5nLnZhbHVlKVxuICAgICAgICB1dHRlcmFuY2UudmFsdWUubGFuZyA9IGxhbmcyO1xuICAgIH0pO1xuICAgIGlmIChvcHRpb25zLnZvaWNlKSB7XG4gICAgICB3YXRjaChvcHRpb25zLnZvaWNlLCAoKSA9PiB7XG4gICAgICAgIHN5bnRoLmNhbmNlbCgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHdhdGNoKGlzUGxheWluZywgKCkgPT4ge1xuICAgICAgaWYgKGlzUGxheWluZy52YWx1ZSlcbiAgICAgICAgc3ludGgucmVzdW1lKCk7XG4gICAgICBlbHNlXG4gICAgICAgIHN5bnRoLnBhdXNlKCk7XG4gICAgfSk7XG4gIH1cbiAgdHJ5T25TY29wZURpc3Bvc2UoKCkgPT4ge1xuICAgIGlzUGxheWluZy52YWx1ZSA9IGZhbHNlO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBpc1BsYXlpbmcsXG4gICAgc3RhdHVzLFxuICAgIHV0dGVyYW5jZSxcbiAgICBlcnJvcixcbiAgICBzdG9wLFxuICAgIHRvZ2dsZSxcbiAgICBzcGVha1xuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VTdGVwcGVyKHN0ZXBzLCBpbml0aWFsU3RlcCkge1xuICBjb25zdCBzdGVwc1JlZiA9IHJlZihzdGVwcyk7XG4gIGNvbnN0IHN0ZXBOYW1lcyA9IGNvbXB1dGVkKCgpID0+IEFycmF5LmlzQXJyYXkoc3RlcHNSZWYudmFsdWUpID8gc3RlcHNSZWYudmFsdWUgOiBPYmplY3Qua2V5cyhzdGVwc1JlZi52YWx1ZSkpO1xuICBjb25zdCBpbmRleCA9IHJlZihzdGVwTmFtZXMudmFsdWUuaW5kZXhPZihpbml0aWFsU3RlcCAhPSBudWxsID8gaW5pdGlhbFN0ZXAgOiBzdGVwTmFtZXMudmFsdWVbMF0pKTtcbiAgY29uc3QgY3VycmVudCA9IGNvbXB1dGVkKCgpID0+IGF0KGluZGV4LnZhbHVlKSk7XG4gIGNvbnN0IGlzRmlyc3QgPSBjb21wdXRlZCgoKSA9PiBpbmRleC52YWx1ZSA9PT0gMCk7XG4gIGNvbnN0IGlzTGFzdCA9IGNvbXB1dGVkKCgpID0+IGluZGV4LnZhbHVlID09PSBzdGVwTmFtZXMudmFsdWUubGVuZ3RoIC0gMSk7XG4gIGNvbnN0IG5leHQgPSBjb21wdXRlZCgoKSA9PiBzdGVwTmFtZXMudmFsdWVbaW5kZXgudmFsdWUgKyAxXSk7XG4gIGNvbnN0IHByZXZpb3VzID0gY29tcHV0ZWQoKCkgPT4gc3RlcE5hbWVzLnZhbHVlW2luZGV4LnZhbHVlIC0gMV0pO1xuICBmdW5jdGlvbiBhdChpbmRleDIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdGVwc1JlZi52YWx1ZSkpXG4gICAgICByZXR1cm4gc3RlcHNSZWYudmFsdWVbaW5kZXgyXTtcbiAgICByZXR1cm4gc3RlcHNSZWYudmFsdWVbc3RlcE5hbWVzLnZhbHVlW2luZGV4Ml1dO1xuICB9XG4gIGZ1bmN0aW9uIGdldChzdGVwKSB7XG4gICAgaWYgKCFzdGVwTmFtZXMudmFsdWUuaW5jbHVkZXMoc3RlcCkpXG4gICAgICByZXR1cm47XG4gICAgcmV0dXJuIGF0KHN0ZXBOYW1lcy52YWx1ZS5pbmRleE9mKHN0ZXApKTtcbiAgfVxuICBmdW5jdGlvbiBnb1RvKHN0ZXApIHtcbiAgICBpZiAoc3RlcE5hbWVzLnZhbHVlLmluY2x1ZGVzKHN0ZXApKVxuICAgICAgaW5kZXgudmFsdWUgPSBzdGVwTmFtZXMudmFsdWUuaW5kZXhPZihzdGVwKTtcbiAgfVxuICBmdW5jdGlvbiBnb1RvTmV4dCgpIHtcbiAgICBpZiAoaXNMYXN0LnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGluZGV4LnZhbHVlKys7XG4gIH1cbiAgZnVuY3Rpb24gZ29Ub1ByZXZpb3VzKCkge1xuICAgIGlmIChpc0ZpcnN0LnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGluZGV4LnZhbHVlLS07XG4gIH1cbiAgZnVuY3Rpb24gZ29CYWNrVG8oc3RlcCkge1xuICAgIGlmIChpc0FmdGVyKHN0ZXApKVxuICAgICAgZ29UbyhzdGVwKTtcbiAgfVxuICBmdW5jdGlvbiBpc05leHQoc3RlcCkge1xuICAgIHJldHVybiBzdGVwTmFtZXMudmFsdWUuaW5kZXhPZihzdGVwKSA9PT0gaW5kZXgudmFsdWUgKyAxO1xuICB9XG4gIGZ1bmN0aW9uIGlzUHJldmlvdXMoc3RlcCkge1xuICAgIHJldHVybiBzdGVwTmFtZXMudmFsdWUuaW5kZXhPZihzdGVwKSA9PT0gaW5kZXgudmFsdWUgLSAxO1xuICB9XG4gIGZ1bmN0aW9uIGlzQ3VycmVudChzdGVwKSB7XG4gICAgcmV0dXJuIHN0ZXBOYW1lcy52YWx1ZS5pbmRleE9mKHN0ZXApID09PSBpbmRleC52YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBpc0JlZm9yZShzdGVwKSB7XG4gICAgcmV0dXJuIGluZGV4LnZhbHVlIDwgc3RlcE5hbWVzLnZhbHVlLmluZGV4T2Yoc3RlcCk7XG4gIH1cbiAgZnVuY3Rpb24gaXNBZnRlcihzdGVwKSB7XG4gICAgcmV0dXJuIGluZGV4LnZhbHVlID4gc3RlcE5hbWVzLnZhbHVlLmluZGV4T2Yoc3RlcCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdGVwczogc3RlcHNSZWYsXG4gICAgc3RlcE5hbWVzLFxuICAgIGluZGV4LFxuICAgIGN1cnJlbnQsXG4gICAgbmV4dCxcbiAgICBwcmV2aW91cyxcbiAgICBpc0ZpcnN0LFxuICAgIGlzTGFzdCxcbiAgICBhdCxcbiAgICBnZXQsXG4gICAgZ29UbyxcbiAgICBnb1RvTmV4dCxcbiAgICBnb1RvUHJldmlvdXMsXG4gICAgZ29CYWNrVG8sXG4gICAgaXNOZXh0LFxuICAgIGlzUHJldmlvdXMsXG4gICAgaXNDdXJyZW50LFxuICAgIGlzQmVmb3JlLFxuICAgIGlzQWZ0ZXJcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlU3RvcmFnZUFzeW5jKGtleSwgaW5pdGlhbFZhbHVlLCBzdG9yYWdlLCBvcHRpb25zID0ge30pIHtcbiAgdmFyIF9hO1xuICBjb25zdCB7XG4gICAgZmx1c2ggPSBcInByZVwiLFxuICAgIGRlZXAgPSB0cnVlLFxuICAgIGxpc3RlblRvU3RvcmFnZUNoYW5nZXMgPSB0cnVlLFxuICAgIHdyaXRlRGVmYXVsdHMgPSB0cnVlLFxuICAgIG1lcmdlRGVmYXVsdHMgPSBmYWxzZSxcbiAgICBzaGFsbG93LFxuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3csXG4gICAgZXZlbnRGaWx0ZXIsXG4gICAgb25FcnJvciA9IChlKSA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH1cbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHJhd0luaXQgPSB0b1ZhbHVlKGluaXRpYWxWYWx1ZSk7XG4gIGNvbnN0IHR5cGUgPSBndWVzc1NlcmlhbGl6ZXJUeXBlKHJhd0luaXQpO1xuICBjb25zdCBkYXRhID0gKHNoYWxsb3cgPyBzaGFsbG93UmVmIDogcmVmKShpbml0aWFsVmFsdWUpO1xuICBjb25zdCBzZXJpYWxpemVyID0gKF9hID0gb3B0aW9ucy5zZXJpYWxpemVyKSAhPSBudWxsID8gX2EgOiBTdG9yYWdlU2VyaWFsaXplcnNbdHlwZV07XG4gIGlmICghc3RvcmFnZSkge1xuICAgIHRyeSB7XG4gICAgICBzdG9yYWdlID0gZ2V0U1NSSGFuZGxlcihcImdldERlZmF1bHRTdG9yYWdlQXN5bmNcIiwgKCkgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICByZXR1cm4gKF9hMiA9IGRlZmF1bHRXaW5kb3cpID09IG51bGwgPyB2b2lkIDAgOiBfYTIubG9jYWxTdG9yYWdlO1xuICAgICAgfSkoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBvbkVycm9yKGUpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiByZWFkKGV2ZW50KSB7XG4gICAgaWYgKCFzdG9yYWdlIHx8IGV2ZW50ICYmIGV2ZW50LmtleSAhPT0ga2V5KVxuICAgICAgcmV0dXJuO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByYXdWYWx1ZSA9IGV2ZW50ID8gZXZlbnQubmV3VmFsdWUgOiBhd2FpdCBzdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgIGlmIChyYXdWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGRhdGEudmFsdWUgPSByYXdJbml0O1xuICAgICAgICBpZiAod3JpdGVEZWZhdWx0cyAmJiByYXdJbml0ICE9PSBudWxsKVxuICAgICAgICAgIGF3YWl0IHN0b3JhZ2Uuc2V0SXRlbShrZXksIGF3YWl0IHNlcmlhbGl6ZXIud3JpdGUocmF3SW5pdCkpO1xuICAgICAgfSBlbHNlIGlmIChtZXJnZURlZmF1bHRzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgc2VyaWFsaXplci5yZWFkKHJhd1ZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXJnZURlZmF1bHRzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgZGF0YS52YWx1ZSA9IG1lcmdlRGVmYXVsdHModmFsdWUsIHJhd0luaXQpO1xuICAgICAgICBlbHNlIGlmICh0eXBlID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgICBkYXRhLnZhbHVlID0geyAuLi5yYXdJbml0LCAuLi52YWx1ZSB9O1xuICAgICAgICBlbHNlIGRhdGEudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEudmFsdWUgPSBhd2FpdCBzZXJpYWxpemVyLnJlYWQocmF3VmFsdWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG9uRXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIHJlYWQoKTtcbiAgaWYgKHdpbmRvdyAmJiBsaXN0ZW5Ub1N0b3JhZ2VDaGFuZ2VzKVxuICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcInN0b3JhZ2VcIiwgKGUpID0+IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gcmVhZChlKSkpO1xuICBpZiAoc3RvcmFnZSkge1xuICAgIHdhdGNoV2l0aEZpbHRlcihcbiAgICAgIGRhdGEsXG4gICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGRhdGEudmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgIGF3YWl0IHN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGF3YWl0IHN0b3JhZ2Uuc2V0SXRlbShrZXksIGF3YWl0IHNlcmlhbGl6ZXIud3JpdGUoZGF0YS52YWx1ZSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgb25FcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgZmx1c2gsXG4gICAgICAgIGRlZXAsXG4gICAgICAgIGV2ZW50RmlsdGVyXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxubGV0IF9pZCA9IDA7XG5mdW5jdGlvbiB1c2VTdHlsZVRhZyhjc3MsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBpc0xvYWRlZCA9IHJlZihmYWxzZSk7XG4gIGNvbnN0IHtcbiAgICBkb2N1bWVudCA9IGRlZmF1bHREb2N1bWVudCxcbiAgICBpbW1lZGlhdGUgPSB0cnVlLFxuICAgIG1hbnVhbCA9IGZhbHNlLFxuICAgIGlkID0gYHZ1ZXVzZV9zdHlsZXRhZ18keysrX2lkfWBcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGNzc1JlZiA9IHJlZihjc3MpO1xuICBsZXQgc3RvcCA9ICgpID0+IHtcbiAgfTtcbiAgY29uc3QgbG9hZCA9ICgpID0+IHtcbiAgICBpZiAoIWRvY3VtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICBpZiAoIWVsLmlzQ29ubmVjdGVkKSB7XG4gICAgICBlbC5pZCA9IGlkO1xuICAgICAgaWYgKG9wdGlvbnMubWVkaWEpXG4gICAgICAgIGVsLm1lZGlhID0gb3B0aW9ucy5tZWRpYTtcbiAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIH1cbiAgICBpZiAoaXNMb2FkZWQudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgc3RvcCA9IHdhdGNoKFxuICAgICAgY3NzUmVmLFxuICAgICAgKHZhbHVlKSA9PiB7XG4gICAgICAgIGVsLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICB9LFxuICAgICAgeyBpbW1lZGlhdGU6IHRydWUgfVxuICAgICk7XG4gICAgaXNMb2FkZWQudmFsdWUgPSB0cnVlO1xuICB9O1xuICBjb25zdCB1bmxvYWQgPSAoKSA9PiB7XG4gICAgaWYgKCFkb2N1bWVudCB8fCAhaXNMb2FkZWQudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgc3RvcCgpO1xuICAgIGRvY3VtZW50LmhlYWQucmVtb3ZlQ2hpbGQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpKTtcbiAgICBpc0xvYWRlZC52YWx1ZSA9IGZhbHNlO1xuICB9O1xuICBpZiAoaW1tZWRpYXRlICYmICFtYW51YWwpXG4gICAgdHJ5T25Nb3VudGVkKGxvYWQpO1xuICBpZiAoIW1hbnVhbClcbiAgICB0cnlPblNjb3BlRGlzcG9zZSh1bmxvYWQpO1xuICByZXR1cm4ge1xuICAgIGlkLFxuICAgIGNzczogY3NzUmVmLFxuICAgIHVubG9hZCxcbiAgICBsb2FkLFxuICAgIGlzTG9hZGVkOiByZWFkb25seShpc0xvYWRlZClcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlU3dpcGUodGFyZ2V0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHRocmVzaG9sZCA9IDUwLFxuICAgIG9uU3dpcGUsXG4gICAgb25Td2lwZUVuZCxcbiAgICBvblN3aXBlU3RhcnQsXG4gICAgcGFzc2l2ZSA9IHRydWUsXG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvd1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgY29vcmRzU3RhcnQgPSByZWFjdGl2ZSh7IHg6IDAsIHk6IDAgfSk7XG4gIGNvbnN0IGNvb3Jkc0VuZCA9IHJlYWN0aXZlKHsgeDogMCwgeTogMCB9KTtcbiAgY29uc3QgZGlmZlggPSBjb21wdXRlZCgoKSA9PiBjb29yZHNTdGFydC54IC0gY29vcmRzRW5kLngpO1xuICBjb25zdCBkaWZmWSA9IGNvbXB1dGVkKCgpID0+IGNvb3Jkc1N0YXJ0LnkgLSBjb29yZHNFbmQueSk7XG4gIGNvbnN0IHsgbWF4LCBhYnMgfSA9IE1hdGg7XG4gIGNvbnN0IGlzVGhyZXNob2xkRXhjZWVkZWQgPSBjb21wdXRlZCgoKSA9PiBtYXgoYWJzKGRpZmZYLnZhbHVlKSwgYWJzKGRpZmZZLnZhbHVlKSkgPj0gdGhyZXNob2xkKTtcbiAgY29uc3QgaXNTd2lwaW5nID0gcmVmKGZhbHNlKTtcbiAgY29uc3QgZGlyZWN0aW9uID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIGlmICghaXNUaHJlc2hvbGRFeGNlZWRlZC52YWx1ZSlcbiAgICAgIHJldHVybiBcIm5vbmVcIjtcbiAgICBpZiAoYWJzKGRpZmZYLnZhbHVlKSA+IGFicyhkaWZmWS52YWx1ZSkpIHtcbiAgICAgIHJldHVybiBkaWZmWC52YWx1ZSA+IDAgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRpZmZZLnZhbHVlID4gMCA/IFwidXBcIiA6IFwiZG93blwiO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGdldFRvdWNoRXZlbnRDb29yZHMgPSAoZSkgPT4gW2UudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WV07XG4gIGNvbnN0IHVwZGF0ZUNvb3Jkc1N0YXJ0ID0gKHgsIHkpID0+IHtcbiAgICBjb29yZHNTdGFydC54ID0geDtcbiAgICBjb29yZHNTdGFydC55ID0geTtcbiAgfTtcbiAgY29uc3QgdXBkYXRlQ29vcmRzRW5kID0gKHgsIHkpID0+IHtcbiAgICBjb29yZHNFbmQueCA9IHg7XG4gICAgY29vcmRzRW5kLnkgPSB5O1xuICB9O1xuICBsZXQgbGlzdGVuZXJPcHRpb25zO1xuICBjb25zdCBpc1Bhc3NpdmVFdmVudFN1cHBvcnRlZCA9IGNoZWNrUGFzc2l2ZUV2ZW50U3VwcG9ydCh3aW5kb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHdpbmRvdy5kb2N1bWVudCk7XG4gIGlmICghcGFzc2l2ZSlcbiAgICBsaXN0ZW5lck9wdGlvbnMgPSBpc1Bhc3NpdmVFdmVudFN1cHBvcnRlZCA/IHsgcGFzc2l2ZTogZmFsc2UsIGNhcHR1cmU6IHRydWUgfSA6IHsgY2FwdHVyZTogdHJ1ZSB9O1xuICBlbHNlXG4gICAgbGlzdGVuZXJPcHRpb25zID0gaXNQYXNzaXZlRXZlbnRTdXBwb3J0ZWQgPyB7IHBhc3NpdmU6IHRydWUgfSA6IHsgY2FwdHVyZTogZmFsc2UgfTtcbiAgY29uc3Qgb25Ub3VjaEVuZCA9IChlKSA9PiB7XG4gICAgaWYgKGlzU3dpcGluZy52YWx1ZSlcbiAgICAgIG9uU3dpcGVFbmQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uU3dpcGVFbmQoZSwgZGlyZWN0aW9uLnZhbHVlKTtcbiAgICBpc1N3aXBpbmcudmFsdWUgPSBmYWxzZTtcbiAgfTtcbiAgY29uc3Qgc3RvcHMgPSBbXG4gICAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFwidG91Y2hzdGFydFwiLCAoZSkgPT4ge1xuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggIT09IDEpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmIChsaXN0ZW5lck9wdGlvbnMuY2FwdHVyZSAmJiAhbGlzdGVuZXJPcHRpb25zLnBhc3NpdmUpXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IFt4LCB5XSA9IGdldFRvdWNoRXZlbnRDb29yZHMoZSk7XG4gICAgICB1cGRhdGVDb29yZHNTdGFydCh4LCB5KTtcbiAgICAgIHVwZGF0ZUNvb3Jkc0VuZCh4LCB5KTtcbiAgICAgIG9uU3dpcGVTdGFydCA9PSBudWxsID8gdm9pZCAwIDogb25Td2lwZVN0YXJ0KGUpO1xuICAgIH0sIGxpc3RlbmVyT3B0aW9ucyksXG4gICAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFwidG91Y2htb3ZlXCIsIChlKSA9PiB7XG4gICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgW3gsIHldID0gZ2V0VG91Y2hFdmVudENvb3JkcyhlKTtcbiAgICAgIHVwZGF0ZUNvb3Jkc0VuZCh4LCB5KTtcbiAgICAgIGlmICghaXNTd2lwaW5nLnZhbHVlICYmIGlzVGhyZXNob2xkRXhjZWVkZWQudmFsdWUpXG4gICAgICAgIGlzU3dpcGluZy52YWx1ZSA9IHRydWU7XG4gICAgICBpZiAoaXNTd2lwaW5nLnZhbHVlKVxuICAgICAgICBvblN3aXBlID09IG51bGwgPyB2b2lkIDAgOiBvblN3aXBlKGUpO1xuICAgIH0sIGxpc3RlbmVyT3B0aW9ucyksXG4gICAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFtcInRvdWNoZW5kXCIsIFwidG91Y2hjYW5jZWxcIl0sIG9uVG91Y2hFbmQsIGxpc3RlbmVyT3B0aW9ucylcbiAgXTtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IHN0b3BzLmZvckVhY2goKHMpID0+IHMoKSk7XG4gIHJldHVybiB7XG4gICAgaXNQYXNzaXZlRXZlbnRTdXBwb3J0ZWQsXG4gICAgaXNTd2lwaW5nLFxuICAgIGRpcmVjdGlvbixcbiAgICBjb29yZHNTdGFydCxcbiAgICBjb29yZHNFbmQsXG4gICAgbGVuZ3RoWDogZGlmZlgsXG4gICAgbGVuZ3RoWTogZGlmZlksXG4gICAgc3RvcFxuICB9O1xufVxuZnVuY3Rpb24gY2hlY2tQYXNzaXZlRXZlbnRTdXBwb3J0KGRvY3VtZW50KSB7XG4gIGlmICghZG9jdW1lbnQpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBsZXQgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG4gIGNvbnN0IG9wdGlvbnNCbG9jayA9IHtcbiAgICBnZXQgcGFzc2l2ZSgpIHtcbiAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwieFwiLCBub29wLCBvcHRpb25zQmxvY2spO1xuICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwieFwiLCBub29wKTtcbiAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZTtcbn1cblxuZnVuY3Rpb24gdXNlVGVtcGxhdGVSZWZzTGlzdCgpIHtcbiAgY29uc3QgcmVmcyA9IHJlZihbXSk7XG4gIHJlZnMudmFsdWUuc2V0ID0gKGVsKSA9PiB7XG4gICAgaWYgKGVsKVxuICAgICAgcmVmcy52YWx1ZS5wdXNoKGVsKTtcbiAgfTtcbiAgb25CZWZvcmVVcGRhdGUoKCkgPT4ge1xuICAgIHJlZnMudmFsdWUubGVuZ3RoID0gMDtcbiAgfSk7XG4gIHJldHVybiByZWZzO1xufVxuXG5mdW5jdGlvbiB1c2VUZXh0RGlyZWN0aW9uKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgZG9jdW1lbnQgPSBkZWZhdWx0RG9jdW1lbnQsXG4gICAgc2VsZWN0b3IgPSBcImh0bWxcIixcbiAgICBvYnNlcnZlID0gZmFsc2UsXG4gICAgaW5pdGlhbFZhbHVlID0gXCJsdHJcIlxuICB9ID0gb3B0aW9ucztcbiAgZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gZG9jdW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZ2V0QXR0cmlidXRlKFwiZGlyXCIpKSAhPSBudWxsID8gX2IgOiBpbml0aWFsVmFsdWU7XG4gIH1cbiAgY29uc3QgZGlyID0gcmVmKGdldFZhbHVlKCkpO1xuICB0cnlPbk1vdW50ZWQoKCkgPT4gZGlyLnZhbHVlID0gZ2V0VmFsdWUoKSk7XG4gIGlmIChvYnNlcnZlICYmIGRvY3VtZW50KSB7XG4gICAgdXNlTXV0YXRpb25PYnNlcnZlcihcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpLFxuICAgICAgKCkgPT4gZGlyLnZhbHVlID0gZ2V0VmFsdWUoKSxcbiAgICAgIHsgYXR0cmlidXRlczogdHJ1ZSB9XG4gICAgKTtcbiAgfVxuICByZXR1cm4gY29tcHV0ZWQoe1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBkaXIudmFsdWU7XG4gICAgfSxcbiAgICBzZXQodikge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGRpci52YWx1ZSA9IHY7XG4gICAgICBpZiAoIWRvY3VtZW50KVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoZGlyLnZhbHVlKVxuICAgICAgICAoX2EgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNldEF0dHJpYnV0ZShcImRpclwiLCBkaXIudmFsdWUpO1xuICAgICAgZWxzZVxuICAgICAgICAoX2IgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnJlbW92ZUF0dHJpYnV0ZShcImRpclwiKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRSYW5nZXNGcm9tU2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICB2YXIgX2E7XG4gIGNvbnN0IHJhbmdlQ291bnQgPSAoX2EgPSBzZWxlY3Rpb24ucmFuZ2VDb3VudCkgIT0gbnVsbCA/IF9hIDogMDtcbiAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IHJhbmdlQ291bnQgfSwgKF8sIGkpID0+IHNlbGVjdGlvbi5nZXRSYW5nZUF0KGkpKTtcbn1cbmZ1bmN0aW9uIHVzZVRleHRTZWxlY3Rpb24ob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBzZWxlY3Rpb24gPSByZWYobnVsbCk7XG4gIGNvbnN0IHRleHQgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gc2VsZWN0aW9uLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EudG9TdHJpbmcoKSkgIT0gbnVsbCA/IF9iIDogXCJcIjtcbiAgfSk7XG4gIGNvbnN0IHJhbmdlcyA9IGNvbXB1dGVkKCgpID0+IHNlbGVjdGlvbi52YWx1ZSA/IGdldFJhbmdlc0Zyb21TZWxlY3Rpb24oc2VsZWN0aW9uLnZhbHVlKSA6IFtdKTtcbiAgY29uc3QgcmVjdHMgPSBjb21wdXRlZCgoKSA9PiByYW5nZXMudmFsdWUubWFwKChyYW5nZSkgPT4gcmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpKTtcbiAgZnVuY3Rpb24gb25TZWxlY3Rpb25DaGFuZ2UoKSB7XG4gICAgc2VsZWN0aW9uLnZhbHVlID0gbnVsbDtcbiAgICBpZiAod2luZG93KVxuICAgICAgc2VsZWN0aW9uLnZhbHVlID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICB9XG4gIGlmICh3aW5kb3cpXG4gICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3cuZG9jdW1lbnQsIFwic2VsZWN0aW9uY2hhbmdlXCIsIG9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgcmV0dXJuIHtcbiAgICB0ZXh0LFxuICAgIHJlY3RzLFxuICAgIHJhbmdlcyxcbiAgICBzZWxlY3Rpb25cbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlVGV4dGFyZWFBdXRvc2l6ZShvcHRpb25zKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgdGV4dGFyZWEgPSByZWYob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5lbGVtZW50KTtcbiAgY29uc3QgaW5wdXQgPSByZWYob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5pbnB1dCk7XG4gIGNvbnN0IHN0eWxlUHJvcCA9IChfYSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc3R5bGVQcm9wKSAhPSBudWxsID8gX2EgOiBcImhlaWdodFwiO1xuICBjb25zdCB0ZXh0YXJlYVNjcm9sbEhlaWdodCA9IHJlZigxKTtcbiAgZnVuY3Rpb24gdHJpZ2dlclJlc2l6ZSgpIHtcbiAgICB2YXIgX2EyO1xuICAgIGlmICghdGV4dGFyZWEudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgbGV0IGhlaWdodCA9IFwiXCI7XG4gICAgdGV4dGFyZWEudmFsdWUuc3R5bGVbc3R5bGVQcm9wXSA9IFwiMXB4XCI7XG4gICAgdGV4dGFyZWFTY3JvbGxIZWlnaHQudmFsdWUgPSAoX2EyID0gdGV4dGFyZWEudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuc2Nyb2xsSGVpZ2h0O1xuICAgIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnN0eWxlVGFyZ2V0KVxuICAgICAgdG9WYWx1ZShvcHRpb25zLnN0eWxlVGFyZ2V0KS5zdHlsZVtzdHlsZVByb3BdID0gYCR7dGV4dGFyZWFTY3JvbGxIZWlnaHQudmFsdWV9cHhgO1xuICAgIGVsc2VcbiAgICAgIGhlaWdodCA9IGAke3RleHRhcmVhU2Nyb2xsSGVpZ2h0LnZhbHVlfXB4YDtcbiAgICB0ZXh0YXJlYS52YWx1ZS5zdHlsZVtzdHlsZVByb3BdID0gaGVpZ2h0O1xuICB9XG4gIHdhdGNoKFtpbnB1dCwgdGV4dGFyZWFdLCAoKSA9PiBuZXh0VGljayh0cmlnZ2VyUmVzaXplKSwgeyBpbW1lZGlhdGU6IHRydWUgfSk7XG4gIHdhdGNoKHRleHRhcmVhU2Nyb2xsSGVpZ2h0LCAoKSA9PiB7XG4gICAgdmFyIF9hMjtcbiAgICByZXR1cm4gKF9hMiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMub25SZXNpemUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2FsbChvcHRpb25zKTtcbiAgfSk7XG4gIHVzZVJlc2l6ZU9ic2VydmVyKHRleHRhcmVhLCAoKSA9PiB0cmlnZ2VyUmVzaXplKCkpO1xuICBpZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy53YXRjaClcbiAgICB3YXRjaChvcHRpb25zLndhdGNoLCB0cmlnZ2VyUmVzaXplLCB7IGltbWVkaWF0ZTogdHJ1ZSwgZGVlcDogdHJ1ZSB9KTtcbiAgcmV0dXJuIHtcbiAgICB0ZXh0YXJlYSxcbiAgICBpbnB1dCxcbiAgICB0cmlnZ2VyUmVzaXplXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVRocm90dGxlZFJlZkhpc3Rvcnkoc291cmNlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB0aHJvdHRsZSA9IDIwMCwgdHJhaWxpbmcgPSB0cnVlIH0gPSBvcHRpb25zO1xuICBjb25zdCBmaWx0ZXIgPSB0aHJvdHRsZUZpbHRlcih0aHJvdHRsZSwgdHJhaWxpbmcpO1xuICBjb25zdCBoaXN0b3J5ID0gdXNlUmVmSGlzdG9yeShzb3VyY2UsIHsgLi4ub3B0aW9ucywgZXZlbnRGaWx0ZXI6IGZpbHRlciB9KTtcbiAgcmV0dXJuIHtcbiAgICAuLi5oaXN0b3J5XG4gIH07XG59XG5cbmNvbnN0IERFRkFVTFRfVU5JVFMgPSBbXG4gIHsgbWF4OiA2ZTQsIHZhbHVlOiAxZTMsIG5hbWU6IFwic2Vjb25kXCIgfSxcbiAgeyBtYXg6IDI3NmU0LCB2YWx1ZTogNmU0LCBuYW1lOiBcIm1pbnV0ZVwiIH0sXG4gIHsgbWF4OiA3MmU2LCB2YWx1ZTogMzZlNSwgbmFtZTogXCJob3VyXCIgfSxcbiAgeyBtYXg6IDUxODRlNSwgdmFsdWU6IDg2NGU1LCBuYW1lOiBcImRheVwiIH0sXG4gIHsgbWF4OiAyNDE5MmU1LCB2YWx1ZTogNjA0OGU1LCBuYW1lOiBcIndlZWtcIiB9LFxuICB7IG1heDogMjg1MTJlNiwgdmFsdWU6IDI1OTJlNiwgbmFtZTogXCJtb250aFwiIH0sXG4gIHsgbWF4OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIHZhbHVlOiAzMTUzNmU2LCBuYW1lOiBcInllYXJcIiB9XG5dO1xuY29uc3QgREVGQVVMVF9NRVNTQUdFUyA9IHtcbiAganVzdE5vdzogXCJqdXN0IG5vd1wiLFxuICBwYXN0OiAobikgPT4gbi5tYXRjaCgvXFxkLykgPyBgJHtufSBhZ29gIDogbixcbiAgZnV0dXJlOiAobikgPT4gbi5tYXRjaCgvXFxkLykgPyBgaW4gJHtufWAgOiBuLFxuICBtb250aDogKG4sIHBhc3QpID0+IG4gPT09IDEgPyBwYXN0ID8gXCJsYXN0IG1vbnRoXCIgOiBcIm5leHQgbW9udGhcIiA6IGAke259IG1vbnRoJHtuID4gMSA/IFwic1wiIDogXCJcIn1gLFxuICB5ZWFyOiAobiwgcGFzdCkgPT4gbiA9PT0gMSA/IHBhc3QgPyBcImxhc3QgeWVhclwiIDogXCJuZXh0IHllYXJcIiA6IGAke259IHllYXIke24gPiAxID8gXCJzXCIgOiBcIlwifWAsXG4gIGRheTogKG4sIHBhc3QpID0+IG4gPT09IDEgPyBwYXN0ID8gXCJ5ZXN0ZXJkYXlcIiA6IFwidG9tb3Jyb3dcIiA6IGAke259IGRheSR7biA+IDEgPyBcInNcIiA6IFwiXCJ9YCxcbiAgd2VlazogKG4sIHBhc3QpID0+IG4gPT09IDEgPyBwYXN0ID8gXCJsYXN0IHdlZWtcIiA6IFwibmV4dCB3ZWVrXCIgOiBgJHtufSB3ZWVrJHtuID4gMSA/IFwic1wiIDogXCJcIn1gLFxuICBob3VyOiAobikgPT4gYCR7bn0gaG91ciR7biA+IDEgPyBcInNcIiA6IFwiXCJ9YCxcbiAgbWludXRlOiAobikgPT4gYCR7bn0gbWludXRlJHtuID4gMSA/IFwic1wiIDogXCJcIn1gLFxuICBzZWNvbmQ6IChuKSA9PiBgJHtufSBzZWNvbmQke24gPiAxID8gXCJzXCIgOiBcIlwifWAsXG4gIGludmFsaWQ6IFwiXCJcbn07XG5mdW5jdGlvbiBERUZBVUxUX0ZPUk1BVFRFUihkYXRlKSB7XG4gIHJldHVybiBkYXRlLnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwgMTApO1xufVxuZnVuY3Rpb24gdXNlVGltZUFnbyh0aW1lLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGNvbnRyb2xzOiBleHBvc2VDb250cm9scyA9IGZhbHNlLFxuICAgIHVwZGF0ZUludGVydmFsID0gM2U0XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCB7IG5vdywgLi4uY29udHJvbHMgfSA9IHVzZU5vdyh7IGludGVydmFsOiB1cGRhdGVJbnRlcnZhbCwgY29udHJvbHM6IHRydWUgfSk7XG4gIGNvbnN0IHRpbWVBZ28gPSBjb21wdXRlZCgoKSA9PiBmb3JtYXRUaW1lQWdvKG5ldyBEYXRlKHRvVmFsdWUodGltZSkpLCBvcHRpb25zLCB0b1ZhbHVlKG5vdykpKTtcbiAgaWYgKGV4cG9zZUNvbnRyb2xzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRpbWVBZ28sXG4gICAgICAuLi5jb250cm9sc1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRpbWVBZ287XG4gIH1cbn1cbmZ1bmN0aW9uIGZvcm1hdFRpbWVBZ28oZnJvbSwgb3B0aW9ucyA9IHt9LCBub3cgPSBEYXRlLm5vdygpKSB7XG4gIHZhciBfYTtcbiAgY29uc3Qge1xuICAgIG1heCxcbiAgICBtZXNzYWdlcyA9IERFRkFVTFRfTUVTU0FHRVMsXG4gICAgZnVsbERhdGVGb3JtYXR0ZXIgPSBERUZBVUxUX0ZPUk1BVFRFUixcbiAgICB1bml0cyA9IERFRkFVTFRfVU5JVFMsXG4gICAgc2hvd1NlY29uZCA9IGZhbHNlLFxuICAgIHJvdW5kaW5nID0gXCJyb3VuZFwiXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCByb3VuZEZuID0gdHlwZW9mIHJvdW5kaW5nID09PSBcIm51bWJlclwiID8gKG4pID0+ICtuLnRvRml4ZWQocm91bmRpbmcpIDogTWF0aFtyb3VuZGluZ107XG4gIGNvbnN0IGRpZmYgPSArbm93IC0gK2Zyb207XG4gIGNvbnN0IGFic0RpZmYgPSBNYXRoLmFicyhkaWZmKTtcbiAgZnVuY3Rpb24gZ2V0VmFsdWUoZGlmZjIsIHVuaXQpIHtcbiAgICByZXR1cm4gcm91bmRGbihNYXRoLmFicyhkaWZmMikgLyB1bml0LnZhbHVlKTtcbiAgfVxuICBmdW5jdGlvbiBmb3JtYXQoZGlmZjIsIHVuaXQpIHtcbiAgICBjb25zdCB2YWwgPSBnZXRWYWx1ZShkaWZmMiwgdW5pdCk7XG4gICAgY29uc3QgcGFzdCA9IGRpZmYyID4gMDtcbiAgICBjb25zdCBzdHIgPSBhcHBseUZvcm1hdCh1bml0Lm5hbWUsIHZhbCwgcGFzdCk7XG4gICAgcmV0dXJuIGFwcGx5Rm9ybWF0KHBhc3QgPyBcInBhc3RcIiA6IFwiZnV0dXJlXCIsIHN0ciwgcGFzdCk7XG4gIH1cbiAgZnVuY3Rpb24gYXBwbHlGb3JtYXQobmFtZSwgdmFsLCBpc1Bhc3QpIHtcbiAgICBjb25zdCBmb3JtYXR0ZXIgPSBtZXNzYWdlc1tuYW1lXTtcbiAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgcmV0dXJuIGZvcm1hdHRlcih2YWwsIGlzUGFzdCk7XG4gICAgcmV0dXJuIGZvcm1hdHRlci5yZXBsYWNlKFwiezB9XCIsIHZhbC50b1N0cmluZygpKTtcbiAgfVxuICBpZiAoYWJzRGlmZiA8IDZlNCAmJiAhc2hvd1NlY29uZClcbiAgICByZXR1cm4gbWVzc2FnZXMuanVzdE5vdztcbiAgaWYgKHR5cGVvZiBtYXggPT09IFwibnVtYmVyXCIgJiYgYWJzRGlmZiA+IG1heClcbiAgICByZXR1cm4gZnVsbERhdGVGb3JtYXR0ZXIobmV3IERhdGUoZnJvbSkpO1xuICBpZiAodHlwZW9mIG1heCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IHVuaXRNYXggPSAoX2EgPSB1bml0cy5maW5kKChpKSA9PiBpLm5hbWUgPT09IG1heCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5tYXg7XG4gICAgaWYgKHVuaXRNYXggJiYgYWJzRGlmZiA+IHVuaXRNYXgpXG4gICAgICByZXR1cm4gZnVsbERhdGVGb3JtYXR0ZXIobmV3IERhdGUoZnJvbSkpO1xuICB9XG4gIGZvciAoY29uc3QgW2lkeCwgdW5pdF0gb2YgdW5pdHMuZW50cmllcygpKSB7XG4gICAgY29uc3QgdmFsID0gZ2V0VmFsdWUoZGlmZiwgdW5pdCk7XG4gICAgaWYgKHZhbCA8PSAwICYmIHVuaXRzW2lkeCAtIDFdKVxuICAgICAgcmV0dXJuIGZvcm1hdChkaWZmLCB1bml0c1tpZHggLSAxXSk7XG4gICAgaWYgKGFic0RpZmYgPCB1bml0Lm1heClcbiAgICAgIHJldHVybiBmb3JtYXQoZGlmZiwgdW5pdCk7XG4gIH1cbiAgcmV0dXJuIG1lc3NhZ2VzLmludmFsaWQ7XG59XG5cbmZ1bmN0aW9uIHVzZVRpbWVvdXRQb2xsKGZuLCBpbnRlcnZhbCwgdGltZW91dFBvbGxPcHRpb25zKSB7XG4gIGNvbnN0IHsgc3RhcnQgfSA9IHVzZVRpbWVvdXRGbihsb29wLCBpbnRlcnZhbCwgeyBpbW1lZGlhdGU6IGZhbHNlIH0pO1xuICBjb25zdCBpc0FjdGl2ZSA9IHJlZihmYWxzZSk7XG4gIGFzeW5jIGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgaWYgKCFpc0FjdGl2ZS52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBhd2FpdCBmbigpO1xuICAgIHN0YXJ0KCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVzdW1lKCkge1xuICAgIGlmICghaXNBY3RpdmUudmFsdWUpIHtcbiAgICAgIGlzQWN0aXZlLnZhbHVlID0gdHJ1ZTtcbiAgICAgIGxvb3AoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgaXNBY3RpdmUudmFsdWUgPSBmYWxzZTtcbiAgfVxuICBpZiAodGltZW91dFBvbGxPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiB0aW1lb3V0UG9sbE9wdGlvbnMuaW1tZWRpYXRlKVxuICAgIHJlc3VtZSgpO1xuICB0cnlPblNjb3BlRGlzcG9zZShwYXVzZSk7XG4gIHJldHVybiB7XG4gICAgaXNBY3RpdmUsXG4gICAgcGF1c2UsXG4gICAgcmVzdW1lXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVRpbWVzdGFtcChvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGNvbnRyb2xzOiBleHBvc2VDb250cm9scyA9IGZhbHNlLFxuICAgIG9mZnNldCA9IDAsXG4gICAgaW1tZWRpYXRlID0gdHJ1ZSxcbiAgICBpbnRlcnZhbCA9IFwicmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIsXG4gICAgY2FsbGJhY2tcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHRzID0gcmVmKHRpbWVzdGFtcCgpICsgb2Zmc2V0KTtcbiAgY29uc3QgdXBkYXRlID0gKCkgPT4gdHMudmFsdWUgPSB0aW1lc3RhbXAoKSArIG9mZnNldDtcbiAgY29uc3QgY2IgPSBjYWxsYmFjayA/ICgpID0+IHtcbiAgICB1cGRhdGUoKTtcbiAgICBjYWxsYmFjayh0cy52YWx1ZSk7XG4gIH0gOiB1cGRhdGU7XG4gIGNvbnN0IGNvbnRyb2xzID0gaW50ZXJ2YWwgPT09IFwicmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIgPyB1c2VSYWZGbihjYiwgeyBpbW1lZGlhdGUgfSkgOiB1c2VJbnRlcnZhbEZuKGNiLCBpbnRlcnZhbCwgeyBpbW1lZGlhdGUgfSk7XG4gIGlmIChleHBvc2VDb250cm9scykge1xuICAgIHJldHVybiB7XG4gICAgICB0aW1lc3RhbXA6IHRzLFxuICAgICAgLi4uY29udHJvbHNcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cztcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VUaXRsZShuZXdUaXRsZSA9IG51bGwsIG9wdGlvbnMgPSB7fSkge1xuICB2YXIgX2EsIF9iLCBfYztcbiAgY29uc3Qge1xuICAgIGRvY3VtZW50ID0gZGVmYXVsdERvY3VtZW50LFxuICAgIHJlc3RvcmVPblVubW91bnQgPSAodCkgPT4gdFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgb3JpZ2luYWxUaXRsZSA9IChfYSA9IGRvY3VtZW50ID09IG51bGwgPyB2b2lkIDAgOiBkb2N1bWVudC50aXRsZSkgIT0gbnVsbCA/IF9hIDogXCJcIjtcbiAgY29uc3QgdGl0bGUgPSB0b1JlZigoX2IgPSBuZXdUaXRsZSAhPSBudWxsID8gbmV3VGl0bGUgOiBkb2N1bWVudCA9PSBudWxsID8gdm9pZCAwIDogZG9jdW1lbnQudGl0bGUpICE9IG51bGwgPyBfYiA6IG51bGwpO1xuICBjb25zdCBpc1JlYWRvbmx5ID0gbmV3VGl0bGUgJiYgdHlwZW9mIG5ld1RpdGxlID09PSBcImZ1bmN0aW9uXCI7XG4gIGZ1bmN0aW9uIGZvcm1hdCh0KSB7XG4gICAgaWYgKCEoXCJ0aXRsZVRlbXBsYXRlXCIgaW4gb3B0aW9ucykpXG4gICAgICByZXR1cm4gdDtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IG9wdGlvbnMudGl0bGVUZW1wbGF0ZSB8fCBcIiVzXCI7XG4gICAgcmV0dXJuIHR5cGVvZiB0ZW1wbGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gdGVtcGxhdGUodCkgOiB0b1ZhbHVlKHRlbXBsYXRlKS5yZXBsYWNlKC8lcy9nLCB0KTtcbiAgfVxuICB3YXRjaChcbiAgICB0aXRsZSxcbiAgICAodCwgbykgPT4ge1xuICAgICAgaWYgKHQgIT09IG8gJiYgZG9jdW1lbnQpXG4gICAgICAgIGRvY3VtZW50LnRpdGxlID0gZm9ybWF0KHR5cGVvZiB0ID09PSBcInN0cmluZ1wiID8gdCA6IFwiXCIpO1xuICAgIH0sXG4gICAgeyBpbW1lZGlhdGU6IHRydWUgfVxuICApO1xuICBpZiAob3B0aW9ucy5vYnNlcnZlICYmICFvcHRpb25zLnRpdGxlVGVtcGxhdGUgJiYgZG9jdW1lbnQgJiYgIWlzUmVhZG9ubHkpIHtcbiAgICB1c2VNdXRhdGlvbk9ic2VydmVyKFxuICAgICAgKF9jID0gZG9jdW1lbnQuaGVhZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnF1ZXJ5U2VsZWN0b3IoXCJ0aXRsZVwiKSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgaWYgKGRvY3VtZW50ICYmIGRvY3VtZW50LnRpdGxlICE9PSB0aXRsZS52YWx1ZSlcbiAgICAgICAgICB0aXRsZS52YWx1ZSA9IGZvcm1hdChkb2N1bWVudC50aXRsZSk7XG4gICAgICB9LFxuICAgICAgeyBjaGlsZExpc3Q6IHRydWUgfVxuICAgICk7XG4gIH1cbiAgdHJ5T25CZWZvcmVVbm1vdW50KCgpID0+IHtcbiAgICBpZiAocmVzdG9yZU9uVW5tb3VudCkge1xuICAgICAgY29uc3QgcmVzdG9yZWRUaXRsZSA9IHJlc3RvcmVPblVubW91bnQob3JpZ2luYWxUaXRsZSwgdGl0bGUudmFsdWUgfHwgXCJcIik7XG4gICAgICBpZiAocmVzdG9yZWRUaXRsZSAhPSBudWxsICYmIGRvY3VtZW50KVxuICAgICAgICBkb2N1bWVudC50aXRsZSA9IHJlc3RvcmVkVGl0bGU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRpdGxlO1xufVxuXG5jb25zdCBfVHJhbnNpdGlvblByZXNldHMgPSB7XG4gIGVhc2VJblNpbmU6IFswLjEyLCAwLCAwLjM5LCAwXSxcbiAgZWFzZU91dFNpbmU6IFswLjYxLCAxLCAwLjg4LCAxXSxcbiAgZWFzZUluT3V0U2luZTogWzAuMzcsIDAsIDAuNjMsIDFdLFxuICBlYXNlSW5RdWFkOiBbMC4xMSwgMCwgMC41LCAwXSxcbiAgZWFzZU91dFF1YWQ6IFswLjUsIDEsIDAuODksIDFdLFxuICBlYXNlSW5PdXRRdWFkOiBbMC40NSwgMCwgMC41NSwgMV0sXG4gIGVhc2VJbkN1YmljOiBbMC4zMiwgMCwgMC42NywgMF0sXG4gIGVhc2VPdXRDdWJpYzogWzAuMzMsIDEsIDAuNjgsIDFdLFxuICBlYXNlSW5PdXRDdWJpYzogWzAuNjUsIDAsIDAuMzUsIDFdLFxuICBlYXNlSW5RdWFydDogWzAuNSwgMCwgMC43NSwgMF0sXG4gIGVhc2VPdXRRdWFydDogWzAuMjUsIDEsIDAuNSwgMV0sXG4gIGVhc2VJbk91dFF1YXJ0OiBbMC43NiwgMCwgMC4yNCwgMV0sXG4gIGVhc2VJblF1aW50OiBbMC42NCwgMCwgMC43OCwgMF0sXG4gIGVhc2VPdXRRdWludDogWzAuMjIsIDEsIDAuMzYsIDFdLFxuICBlYXNlSW5PdXRRdWludDogWzAuODMsIDAsIDAuMTcsIDFdLFxuICBlYXNlSW5FeHBvOiBbMC43LCAwLCAwLjg0LCAwXSxcbiAgZWFzZU91dEV4cG86IFswLjE2LCAxLCAwLjMsIDFdLFxuICBlYXNlSW5PdXRFeHBvOiBbMC44NywgMCwgMC4xMywgMV0sXG4gIGVhc2VJbkNpcmM6IFswLjU1LCAwLCAxLCAwLjQ1XSxcbiAgZWFzZU91dENpcmM6IFswLCAwLjU1LCAwLjQ1LCAxXSxcbiAgZWFzZUluT3V0Q2lyYzogWzAuODUsIDAsIDAuMTUsIDFdLFxuICBlYXNlSW5CYWNrOiBbMC4zNiwgMCwgMC42NiwgLTAuNTZdLFxuICBlYXNlT3V0QmFjazogWzAuMzQsIDEuNTYsIDAuNjQsIDFdLFxuICBlYXNlSW5PdXRCYWNrOiBbMC42OCwgLTAuNiwgMC4zMiwgMS42XVxufTtcbmNvbnN0IFRyYW5zaXRpb25QcmVzZXRzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5hc3NpZ24oe30sIHsgbGluZWFyOiBpZGVudGl0eSB9LCBfVHJhbnNpdGlvblByZXNldHMpO1xuZnVuY3Rpb24gY3JlYXRlRWFzaW5nRnVuY3Rpb24oW3AwLCBwMSwgcDIsIHAzXSkge1xuICBjb25zdCBhID0gKGExLCBhMikgPT4gMSAtIDMgKiBhMiArIDMgKiBhMTtcbiAgY29uc3QgYiA9IChhMSwgYTIpID0+IDMgKiBhMiAtIDYgKiBhMTtcbiAgY29uc3QgYyA9IChhMSkgPT4gMyAqIGExO1xuICBjb25zdCBjYWxjQmV6aWVyID0gKHQsIGExLCBhMikgPT4gKChhKGExLCBhMikgKiB0ICsgYihhMSwgYTIpKSAqIHQgKyBjKGExKSkgKiB0O1xuICBjb25zdCBnZXRTbG9wZSA9ICh0LCBhMSwgYTIpID0+IDMgKiBhKGExLCBhMikgKiB0ICogdCArIDIgKiBiKGExLCBhMikgKiB0ICsgYyhhMSk7XG4gIGNvbnN0IGdldFRmb3JYID0gKHgpID0+IHtcbiAgICBsZXQgYUd1ZXNzVCA9IHg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRTbG9wZSA9IGdldFNsb3BlKGFHdWVzc1QsIHAwLCBwMik7XG4gICAgICBpZiAoY3VycmVudFNsb3BlID09PSAwKVxuICAgICAgICByZXR1cm4gYUd1ZXNzVDtcbiAgICAgIGNvbnN0IGN1cnJlbnRYID0gY2FsY0JlemllcihhR3Vlc3NULCBwMCwgcDIpIC0geDtcbiAgICAgIGFHdWVzc1QgLT0gY3VycmVudFggLyBjdXJyZW50U2xvcGU7XG4gICAgfVxuICAgIHJldHVybiBhR3Vlc3NUO1xuICB9O1xuICByZXR1cm4gKHgpID0+IHAwID09PSBwMSAmJiBwMiA9PT0gcDMgPyB4IDogY2FsY0JlemllcihnZXRUZm9yWCh4KSwgcDEsIHAzKTtcbn1cbmZ1bmN0aW9uIGxlcnAoYSwgYiwgYWxwaGEpIHtcbiAgcmV0dXJuIGEgKyBhbHBoYSAqIChiIC0gYSk7XG59XG5mdW5jdGlvbiB0b1ZlYyh0KSB7XG4gIHJldHVybiAodHlwZW9mIHQgPT09IFwibnVtYmVyXCIgPyBbdF0gOiB0KSB8fCBbXTtcbn1cbmZ1bmN0aW9uIGV4ZWN1dGVUcmFuc2l0aW9uKHNvdXJjZSwgZnJvbSwgdG8sIG9wdGlvbnMgPSB7fSkge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCBmcm9tVmFsID0gdG9WYWx1ZShmcm9tKTtcbiAgY29uc3QgdG9WYWwgPSB0b1ZhbHVlKHRvKTtcbiAgY29uc3QgdjEgPSB0b1ZlYyhmcm9tVmFsKTtcbiAgY29uc3QgdjIgPSB0b1ZlYyh0b1ZhbCk7XG4gIGNvbnN0IGR1cmF0aW9uID0gKF9hID0gdG9WYWx1ZShvcHRpb25zLmR1cmF0aW9uKSkgIT0gbnVsbCA/IF9hIDogMWUzO1xuICBjb25zdCBzdGFydGVkQXQgPSBEYXRlLm5vdygpO1xuICBjb25zdCBlbmRBdCA9IERhdGUubm93KCkgKyBkdXJhdGlvbjtcbiAgY29uc3QgdHJhbnMgPSB0eXBlb2Ygb3B0aW9ucy50cmFuc2l0aW9uID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zLnRyYW5zaXRpb24gOiAoX2IgPSB0b1ZhbHVlKG9wdGlvbnMudHJhbnNpdGlvbikpICE9IG51bGwgPyBfYiA6IGlkZW50aXR5O1xuICBjb25zdCBlYXNlID0gdHlwZW9mIHRyYW5zID09PSBcImZ1bmN0aW9uXCIgPyB0cmFucyA6IGNyZWF0ZUVhc2luZ0Z1bmN0aW9uKHRyYW5zKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgc291cmNlLnZhbHVlID0gZnJvbVZhbDtcbiAgICBjb25zdCB0aWNrID0gKCkgPT4ge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIGlmICgoX2EyID0gb3B0aW9ucy5hYm9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jYWxsKG9wdGlvbnMpKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IGFscGhhID0gZWFzZSgobm93IC0gc3RhcnRlZEF0KSAvIGR1cmF0aW9uKTtcbiAgICAgIGNvbnN0IGFyciA9IHRvVmVjKHNvdXJjZS52YWx1ZSkubWFwKChuLCBpKSA9PiBsZXJwKHYxW2ldLCB2MltpXSwgYWxwaGEpKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZS52YWx1ZSkpXG4gICAgICAgIHNvdXJjZS52YWx1ZSA9IGFyci5tYXAoKG4sIGkpID0+IHtcbiAgICAgICAgICB2YXIgX2EzLCBfYjI7XG4gICAgICAgICAgcmV0dXJuIGxlcnAoKF9hMyA9IHYxW2ldKSAhPSBudWxsID8gX2EzIDogMCwgKF9iMiA9IHYyW2ldKSAhPSBudWxsID8gX2IyIDogMCwgYWxwaGEpO1xuICAgICAgICB9KTtcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2UudmFsdWUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgIHNvdXJjZS52YWx1ZSA9IGFyclswXTtcbiAgICAgIGlmIChub3cgPCBlbmRBdCkge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGljayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VyY2UudmFsdWUgPSB0b1ZhbDtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGljaygpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb24oc291cmNlLCBvcHRpb25zID0ge30pIHtcbiAgbGV0IGN1cnJlbnRJZCA9IDA7XG4gIGNvbnN0IHNvdXJjZVZhbCA9ICgpID0+IHtcbiAgICBjb25zdCB2ID0gdG9WYWx1ZShzb3VyY2UpO1xuICAgIHJldHVybiB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIiA/IHYgOiB2Lm1hcCh0b1ZhbHVlKTtcbiAgfTtcbiAgY29uc3Qgb3V0cHV0UmVmID0gcmVmKHNvdXJjZVZhbCgpKTtcbiAgd2F0Y2goc291cmNlVmFsLCBhc3luYyAodG8pID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICh0b1ZhbHVlKG9wdGlvbnMuZGlzYWJsZWQpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGlkID0gKytjdXJyZW50SWQ7XG4gICAgaWYgKG9wdGlvbnMuZGVsYXkpXG4gICAgICBhd2FpdCBwcm9taXNlVGltZW91dCh0b1ZhbHVlKG9wdGlvbnMuZGVsYXkpKTtcbiAgICBpZiAoaWQgIT09IGN1cnJlbnRJZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0b1ZhbCA9IEFycmF5LmlzQXJyYXkodG8pID8gdG8ubWFwKHRvVmFsdWUpIDogdG9WYWx1ZSh0byk7XG4gICAgKF9hID0gb3B0aW9ucy5vblN0YXJ0ZWQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdGlvbnMpO1xuICAgIGF3YWl0IGV4ZWN1dGVUcmFuc2l0aW9uKG91dHB1dFJlZiwgb3V0cHV0UmVmLnZhbHVlLCB0b1ZhbCwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGFib3J0OiAoKSA9PiB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHJldHVybiBpZCAhPT0gY3VycmVudElkIHx8ICgoX2EyID0gb3B0aW9ucy5hYm9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jYWxsKG9wdGlvbnMpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAoX2IgPSBvcHRpb25zLm9uRmluaXNoZWQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKG9wdGlvbnMpO1xuICB9LCB7IGRlZXA6IHRydWUgfSk7XG4gIHdhdGNoKCgpID0+IHRvVmFsdWUob3B0aW9ucy5kaXNhYmxlZCksIChkaXNhYmxlZCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgY3VycmVudElkKys7XG4gICAgICBvdXRwdXRSZWYudmFsdWUgPSBzb3VyY2VWYWwoKTtcbiAgICB9XG4gIH0pO1xuICB0cnlPblNjb3BlRGlzcG9zZSgoKSA9PiB7XG4gICAgY3VycmVudElkKys7XG4gIH0pO1xuICByZXR1cm4gY29tcHV0ZWQoKCkgPT4gdG9WYWx1ZShvcHRpb25zLmRpc2FibGVkKSA/IHNvdXJjZVZhbCgpIDogb3V0cHV0UmVmLnZhbHVlKTtcbn1cblxuZnVuY3Rpb24gdXNlVXJsU2VhcmNoUGFyYW1zKG1vZGUgPSBcImhpc3RvcnlcIiwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBpbml0aWFsVmFsdWUgPSB7fSxcbiAgICByZW1vdmVOdWxsaXNoVmFsdWVzID0gdHJ1ZSxcbiAgICByZW1vdmVGYWxzeVZhbHVlcyA9IGZhbHNlLFxuICAgIHdyaXRlOiBlbmFibGVXcml0ZSA9IHRydWUsXG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvd1xuICB9ID0gb3B0aW9ucztcbiAgaWYgKCF3aW5kb3cpXG4gICAgcmV0dXJuIHJlYWN0aXZlKGluaXRpYWxWYWx1ZSk7XG4gIGNvbnN0IHN0YXRlID0gcmVhY3RpdmUoe30pO1xuICBmdW5jdGlvbiBnZXRSYXdQYXJhbXMoKSB7XG4gICAgaWYgKG1vZGUgPT09IFwiaGlzdG9yeVwiKSB7XG4gICAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLnNlYXJjaCB8fCBcIlwiO1xuICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gXCJoYXNoXCIpIHtcbiAgICAgIGNvbnN0IGhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaCB8fCBcIlwiO1xuICAgICAgY29uc3QgaW5kZXggPSBoYXNoLmluZGV4T2YoXCI/XCIpO1xuICAgICAgcmV0dXJuIGluZGV4ID4gMCA/IGhhc2guc2xpY2UoaW5kZXgpIDogXCJcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICh3aW5kb3cubG9jYXRpb24uaGFzaCB8fCBcIlwiKS5yZXBsYWNlKC9eIy8sIFwiXCIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjb25zdHJ1Y3RRdWVyeShwYXJhbXMpIHtcbiAgICBjb25zdCBzdHJpbmdpZmllZCA9IHBhcmFtcy50b1N0cmluZygpO1xuICAgIGlmIChtb2RlID09PSBcImhpc3RvcnlcIilcbiAgICAgIHJldHVybiBgJHtzdHJpbmdpZmllZCA/IGA/JHtzdHJpbmdpZmllZH1gIDogXCJcIn0ke3dpbmRvdy5sb2NhdGlvbi5oYXNoIHx8IFwiXCJ9YDtcbiAgICBpZiAobW9kZSA9PT0gXCJoYXNoLXBhcmFtc1wiKVxuICAgICAgcmV0dXJuIGAke3dpbmRvdy5sb2NhdGlvbi5zZWFyY2ggfHwgXCJcIn0ke3N0cmluZ2lmaWVkID8gYCMke3N0cmluZ2lmaWVkfWAgOiBcIlwifWA7XG4gICAgY29uc3QgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoIHx8IFwiI1wiO1xuICAgIGNvbnN0IGluZGV4ID0gaGFzaC5pbmRleE9mKFwiP1wiKTtcbiAgICBpZiAoaW5kZXggPiAwKVxuICAgICAgcmV0dXJuIGAke2hhc2guc2xpY2UoMCwgaW5kZXgpfSR7c3RyaW5naWZpZWQgPyBgPyR7c3RyaW5naWZpZWR9YCA6IFwiXCJ9YDtcbiAgICByZXR1cm4gYCR7aGFzaH0ke3N0cmluZ2lmaWVkID8gYD8ke3N0cmluZ2lmaWVkfWAgOiBcIlwifWA7XG4gIH1cbiAgZnVuY3Rpb24gcmVhZCgpIHtcbiAgICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtcyhnZXRSYXdQYXJhbXMoKSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlU3RhdGUocGFyYW1zKSB7XG4gICAgY29uc3QgdW51c2VkS2V5cyA9IG5ldyBTZXQoT2JqZWN0LmtleXMoc3RhdGUpKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBwYXJhbXMua2V5cygpKSB7XG4gICAgICBjb25zdCBwYXJhbXNGb3JLZXkgPSBwYXJhbXMuZ2V0QWxsKGtleSk7XG4gICAgICBzdGF0ZVtrZXldID0gcGFyYW1zRm9yS2V5Lmxlbmd0aCA+IDEgPyBwYXJhbXNGb3JLZXkgOiBwYXJhbXMuZ2V0KGtleSkgfHwgXCJcIjtcbiAgICAgIHVudXNlZEtleXMuZGVsZXRlKGtleSk7XG4gICAgfVxuICAgIEFycmF5LmZyb20odW51c2VkS2V5cykuZm9yRWFjaCgoa2V5KSA9PiBkZWxldGUgc3RhdGVba2V5XSk7XG4gIH1cbiAgY29uc3QgeyBwYXVzZSwgcmVzdW1lIH0gPSBwYXVzYWJsZVdhdGNoKFxuICAgIHN0YXRlLFxuICAgICgpID0+IHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoXCJcIik7XG4gICAgICBPYmplY3Qua2V5cyhzdGF0ZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IG1hcEVudHJ5ID0gc3RhdGVba2V5XTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWFwRW50cnkpKVxuICAgICAgICAgIG1hcEVudHJ5LmZvckVhY2goKHZhbHVlKSA9PiBwYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpKTtcbiAgICAgICAgZWxzZSBpZiAocmVtb3ZlTnVsbGlzaFZhbHVlcyAmJiBtYXBFbnRyeSA9PSBudWxsKVxuICAgICAgICAgIHBhcmFtcy5kZWxldGUoa2V5KTtcbiAgICAgICAgZWxzZSBpZiAocmVtb3ZlRmFsc3lWYWx1ZXMgJiYgIW1hcEVudHJ5KVxuICAgICAgICAgIHBhcmFtcy5kZWxldGUoa2V5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHBhcmFtcy5zZXQoa2V5LCBtYXBFbnRyeSk7XG4gICAgICB9KTtcbiAgICAgIHdyaXRlKHBhcmFtcyk7XG4gICAgfSxcbiAgICB7IGRlZXA6IHRydWUgfVxuICApO1xuICBmdW5jdGlvbiB3cml0ZShwYXJhbXMsIHNob3VsZFVwZGF0ZSkge1xuICAgIHBhdXNlKCk7XG4gICAgaWYgKHNob3VsZFVwZGF0ZSlcbiAgICAgIHVwZGF0ZVN0YXRlKHBhcmFtcyk7XG4gICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKFxuICAgICAgd2luZG93Lmhpc3Rvcnkuc3RhdGUsXG4gICAgICB3aW5kb3cuZG9jdW1lbnQudGl0bGUsXG4gICAgICB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyBjb25zdHJ1Y3RRdWVyeShwYXJhbXMpXG4gICAgKTtcbiAgICByZXN1bWUoKTtcbiAgfVxuICBmdW5jdGlvbiBvbkNoYW5nZWQoKSB7XG4gICAgaWYgKCFlbmFibGVXcml0ZSlcbiAgICAgIHJldHVybjtcbiAgICB3cml0ZShyZWFkKCksIHRydWUpO1xuICB9XG4gIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcInBvcHN0YXRlXCIsIG9uQ2hhbmdlZCwgZmFsc2UpO1xuICBpZiAobW9kZSAhPT0gXCJoaXN0b3J5XCIpXG4gICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwiaGFzaGNoYW5nZVwiLCBvbkNoYW5nZWQsIGZhbHNlKTtcbiAgY29uc3QgaW5pdGlhbCA9IHJlYWQoKTtcbiAgaWYgKGluaXRpYWwua2V5cygpLm5leHQoKS52YWx1ZSlcbiAgICB1cGRhdGVTdGF0ZShpbml0aWFsKTtcbiAgZWxzZVxuICAgIE9iamVjdC5hc3NpZ24oc3RhdGUsIGluaXRpYWxWYWx1ZSk7XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuZnVuY3Rpb24gdXNlVXNlck1lZGlhKG9wdGlvbnMgPSB7fSkge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCBlbmFibGVkID0gcmVmKChfYSA9IG9wdGlvbnMuZW5hYmxlZCkgIT0gbnVsbCA/IF9hIDogZmFsc2UpO1xuICBjb25zdCBhdXRvU3dpdGNoID0gcmVmKChfYiA9IG9wdGlvbnMuYXV0b1N3aXRjaCkgIT0gbnVsbCA/IF9iIDogdHJ1ZSk7XG4gIGNvbnN0IGNvbnN0cmFpbnRzID0gcmVmKG9wdGlvbnMuY29uc3RyYWludHMpO1xuICBjb25zdCB7IG5hdmlnYXRvciA9IGRlZmF1bHROYXZpZ2F0b3IgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIHJldHVybiAoX2EyID0gbmF2aWdhdG9yID09IG51bGwgPyB2b2lkIDAgOiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldFVzZXJNZWRpYTtcbiAgfSk7XG4gIGNvbnN0IHN0cmVhbSA9IHNoYWxsb3dSZWYoKTtcbiAgZnVuY3Rpb24gZ2V0RGV2aWNlT3B0aW9ucyh0eXBlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwidmlkZW9cIjoge1xuICAgICAgICBpZiAoY29uc3RyYWludHMudmFsdWUpXG4gICAgICAgICAgcmV0dXJuIGNvbnN0cmFpbnRzLnZhbHVlLnZpZGVvIHx8IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJhdWRpb1wiOiB7XG4gICAgICAgIGlmIChjb25zdHJhaW50cy52YWx1ZSlcbiAgICAgICAgICByZXR1cm4gY29uc3RyYWludHMudmFsdWUuYXVkaW8gfHwgZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBfc3RhcnQoKSB7XG4gICAgaWYgKCFpc1N1cHBvcnRlZC52YWx1ZSB8fCBzdHJlYW0udmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgc3RyZWFtLnZhbHVlID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe1xuICAgICAgdmlkZW86IGdldERldmljZU9wdGlvbnMoXCJ2aWRlb1wiKSxcbiAgICAgIGF1ZGlvOiBnZXREZXZpY2VPcHRpb25zKFwiYXVkaW9cIilcbiAgICB9KTtcbiAgICByZXR1cm4gc3RyZWFtLnZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIF9zdG9wKCkge1xuICAgIHZhciBfYTI7XG4gICAgKF9hMiA9IHN0cmVhbS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5nZXRUcmFja3MoKS5mb3JFYWNoKCh0KSA9PiB0LnN0b3AoKSk7XG4gICAgc3RyZWFtLnZhbHVlID0gdm9pZCAwO1xuICB9XG4gIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgX3N0b3AoKTtcbiAgICBlbmFibGVkLnZhbHVlID0gZmFsc2U7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgYXdhaXQgX3N0YXJ0KCk7XG4gICAgaWYgKHN0cmVhbS52YWx1ZSlcbiAgICAgIGVuYWJsZWQudmFsdWUgPSB0cnVlO1xuICAgIHJldHVybiBzdHJlYW0udmFsdWU7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcmVzdGFydCgpIHtcbiAgICBfc3RvcCgpO1xuICAgIHJldHVybiBhd2FpdCBzdGFydCgpO1xuICB9XG4gIHdhdGNoKFxuICAgIGVuYWJsZWQsXG4gICAgKHYpID0+IHtcbiAgICAgIGlmICh2KVxuICAgICAgICBfc3RhcnQoKTtcbiAgICAgIGVsc2UgX3N0b3AoKTtcbiAgICB9LFxuICAgIHsgaW1tZWRpYXRlOiB0cnVlIH1cbiAgKTtcbiAgd2F0Y2goXG4gICAgY29uc3RyYWludHMsXG4gICAgKCkgPT4ge1xuICAgICAgaWYgKGF1dG9Td2l0Y2gudmFsdWUgJiYgc3RyZWFtLnZhbHVlKVxuICAgICAgICByZXN0YXJ0KCk7XG4gICAgfSxcbiAgICB7IGltbWVkaWF0ZTogdHJ1ZSB9XG4gICk7XG4gIHRyeU9uU2NvcGVEaXNwb3NlKCgpID0+IHtcbiAgICBzdG9wKCk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIHN0cmVhbSxcbiAgICBzdGFydCxcbiAgICBzdG9wLFxuICAgIHJlc3RhcnQsXG4gICAgY29uc3RyYWludHMsXG4gICAgZW5hYmxlZCxcbiAgICBhdXRvU3dpdGNoXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVZNb2RlbChwcm9wcywga2V5LCBlbWl0LCBvcHRpb25zID0ge30pIHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgY29uc3Qge1xuICAgIGNsb25lID0gZmFsc2UsXG4gICAgcGFzc2l2ZSA9IGZhbHNlLFxuICAgIGV2ZW50TmFtZSxcbiAgICBkZWVwID0gZmFsc2UsXG4gICAgZGVmYXVsdFZhbHVlLFxuICAgIHNob3VsZEVtaXRcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHZtID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGNvbnN0IF9lbWl0ID0gZW1pdCB8fCAodm0gPT0gbnVsbCA/IHZvaWQgMCA6IHZtLmVtaXQpIHx8ICgoX2EgPSB2bSA9PSBudWxsID8gdm9pZCAwIDogdm0uJGVtaXQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5iaW5kKHZtKSkgfHwgKChfYyA9IChfYiA9IHZtID09IG51bGwgPyB2b2lkIDAgOiB2bS5wcm94eSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLiRlbWl0KSA9PSBudWxsID8gdm9pZCAwIDogX2MuYmluZCh2bSA9PSBudWxsID8gdm9pZCAwIDogdm0ucHJveHkpKTtcbiAgbGV0IGV2ZW50ID0gZXZlbnROYW1lO1xuICBpZiAoIWtleSkge1xuICAgIGlmIChpc1Z1ZTIpIHtcbiAgICAgIGNvbnN0IG1vZGVsT3B0aW9ucyA9IChfZSA9IChfZCA9IHZtID09IG51bGwgPyB2b2lkIDAgOiB2bS5wcm94eSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLiRvcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2UubW9kZWw7XG4gICAgICBrZXkgPSAobW9kZWxPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBtb2RlbE9wdGlvbnMudmFsdWUpIHx8IFwidmFsdWVcIjtcbiAgICAgIGlmICghZXZlbnROYW1lKVxuICAgICAgICBldmVudCA9IChtb2RlbE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG1vZGVsT3B0aW9ucy5ldmVudCkgfHwgXCJpbnB1dFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBcIm1vZGVsVmFsdWVcIjtcbiAgICB9XG4gIH1cbiAgZXZlbnQgPSBldmVudCB8fCBgdXBkYXRlOiR7a2V5LnRvU3RyaW5nKCl9YDtcbiAgY29uc3QgY2xvbmVGbiA9ICh2YWwpID0+ICFjbG9uZSA/IHZhbCA6IHR5cGVvZiBjbG9uZSA9PT0gXCJmdW5jdGlvblwiID8gY2xvbmUodmFsKSA6IGNsb25lRm5KU09OKHZhbCk7XG4gIGNvbnN0IGdldFZhbHVlID0gKCkgPT4gaXNEZWYocHJvcHNba2V5XSkgPyBjbG9uZUZuKHByb3BzW2tleV0pIDogZGVmYXVsdFZhbHVlO1xuICBjb25zdCB0cmlnZ2VyRW1pdCA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmIChzaG91bGRFbWl0KSB7XG4gICAgICBpZiAoc2hvdWxkRW1pdCh2YWx1ZSkpXG4gICAgICAgIF9lbWl0KGV2ZW50LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9lbWl0KGV2ZW50LCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuICBpZiAocGFzc2l2ZSkge1xuICAgIGNvbnN0IGluaXRpYWxWYWx1ZSA9IGdldFZhbHVlKCk7XG4gICAgY29uc3QgcHJveHkgPSByZWYoaW5pdGlhbFZhbHVlKTtcbiAgICBsZXQgaXNVcGRhdGluZyA9IGZhbHNlO1xuICAgIHdhdGNoKFxuICAgICAgKCkgPT4gcHJvcHNba2V5XSxcbiAgICAgICh2KSA9PiB7XG4gICAgICAgIGlmICghaXNVcGRhdGluZykge1xuICAgICAgICAgIGlzVXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIHByb3h5LnZhbHVlID0gY2xvbmVGbih2KTtcbiAgICAgICAgICBuZXh0VGljaygoKSA9PiBpc1VwZGF0aW5nID0gZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICB3YXRjaChcbiAgICAgIHByb3h5LFxuICAgICAgKHYpID0+IHtcbiAgICAgICAgaWYgKCFpc1VwZGF0aW5nICYmICh2ICE9PSBwcm9wc1trZXldIHx8IGRlZXApKVxuICAgICAgICAgIHRyaWdnZXJFbWl0KHYpO1xuICAgICAgfSxcbiAgICAgIHsgZGVlcCB9XG4gICAgKTtcbiAgICByZXR1cm4gcHJveHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbXB1dGVkKHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGdldFZhbHVlKCk7XG4gICAgICB9LFxuICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgIHRyaWdnZXJFbWl0KHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VWTW9kZWxzKHByb3BzLCBlbWl0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgcmV0W2tleV0gPSB1c2VWTW9kZWwoXG4gICAgICBwcm9wcyxcbiAgICAgIGtleSxcbiAgICAgIGVtaXQsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiB1c2VWaWJyYXRlKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHBhdHRlcm4gPSBbXSxcbiAgICBpbnRlcnZhbCA9IDAsXG4gICAgbmF2aWdhdG9yID0gZGVmYXVsdE5hdmlnYXRvclxuICB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcInZpYnJhdGVcIiBpbiBuYXZpZ2F0b3IpO1xuICBjb25zdCBwYXR0ZXJuUmVmID0gdG9SZWYocGF0dGVybik7XG4gIGxldCBpbnRlcnZhbENvbnRyb2xzO1xuICBjb25zdCB2aWJyYXRlID0gKHBhdHRlcm4yID0gcGF0dGVyblJlZi52YWx1ZSkgPT4ge1xuICAgIGlmIChpc1N1cHBvcnRlZC52YWx1ZSlcbiAgICAgIG5hdmlnYXRvci52aWJyYXRlKHBhdHRlcm4yKTtcbiAgfTtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IHtcbiAgICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUpXG4gICAgICBuYXZpZ2F0b3IudmlicmF0ZSgwKTtcbiAgICBpbnRlcnZhbENvbnRyb2xzID09IG51bGwgPyB2b2lkIDAgOiBpbnRlcnZhbENvbnRyb2xzLnBhdXNlKCk7XG4gIH07XG4gIGlmIChpbnRlcnZhbCA+IDApIHtcbiAgICBpbnRlcnZhbENvbnRyb2xzID0gdXNlSW50ZXJ2YWxGbihcbiAgICAgIHZpYnJhdGUsXG4gICAgICBpbnRlcnZhbCxcbiAgICAgIHtcbiAgICAgICAgaW1tZWRpYXRlOiBmYWxzZSxcbiAgICAgICAgaW1tZWRpYXRlQ2FsbGJhY2s6IGZhbHNlXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIHBhdHRlcm4sXG4gICAgaW50ZXJ2YWxDb250cm9scyxcbiAgICB2aWJyYXRlLFxuICAgIHN0b3BcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlVmlydHVhbExpc3QobGlzdCwgb3B0aW9ucykge1xuICBjb25zdCB7IGNvbnRhaW5lclN0eWxlLCB3cmFwcGVyUHJvcHMsIHNjcm9sbFRvLCBjYWxjdWxhdGVSYW5nZSwgY3VycmVudExpc3QsIGNvbnRhaW5lclJlZiB9ID0gXCJpdGVtSGVpZ2h0XCIgaW4gb3B0aW9ucyA/IHVzZVZlcnRpY2FsVmlydHVhbExpc3Qob3B0aW9ucywgbGlzdCkgOiB1c2VIb3Jpem9udGFsVmlydHVhbExpc3Qob3B0aW9ucywgbGlzdCk7XG4gIHJldHVybiB7XG4gICAgbGlzdDogY3VycmVudExpc3QsXG4gICAgc2Nyb2xsVG8sXG4gICAgY29udGFpbmVyUHJvcHM6IHtcbiAgICAgIHJlZjogY29udGFpbmVyUmVmLFxuICAgICAgb25TY3JvbGw6ICgpID0+IHtcbiAgICAgICAgY2FsY3VsYXRlUmFuZ2UoKTtcbiAgICAgIH0sXG4gICAgICBzdHlsZTogY29udGFpbmVyU3R5bGVcbiAgICB9LFxuICAgIHdyYXBwZXJQcm9wc1xuICB9O1xufVxuZnVuY3Rpb24gdXNlVmlydHVhbExpc3RSZXNvdXJjZXMobGlzdCkge1xuICBjb25zdCBjb250YWluZXJSZWYgPSByZWYobnVsbCk7XG4gIGNvbnN0IHNpemUgPSB1c2VFbGVtZW50U2l6ZShjb250YWluZXJSZWYpO1xuICBjb25zdCBjdXJyZW50TGlzdCA9IHJlZihbXSk7XG4gIGNvbnN0IHNvdXJjZSA9IHNoYWxsb3dSZWYobGlzdCk7XG4gIGNvbnN0IHN0YXRlID0gcmVmKHsgc3RhcnQ6IDAsIGVuZDogMTAgfSk7XG4gIHJldHVybiB7IHN0YXRlLCBzb3VyY2UsIGN1cnJlbnRMaXN0LCBzaXplLCBjb250YWluZXJSZWYgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUdldFZpZXdDYXBhY2l0eShzdGF0ZSwgc291cmNlLCBpdGVtU2l6ZSkge1xuICByZXR1cm4gKGNvbnRhaW5lclNpemUpID0+IHtcbiAgICBpZiAodHlwZW9mIGl0ZW1TaXplID09PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIE1hdGguY2VpbChjb250YWluZXJTaXplIC8gaXRlbVNpemUpO1xuICAgIGNvbnN0IHsgc3RhcnQgPSAwIH0gPSBzdGF0ZS52YWx1ZTtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBsZXQgY2FwYWNpdHkgPSAwO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHNvdXJjZS52YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc2l6ZSA9IGl0ZW1TaXplKGkpO1xuICAgICAgc3VtICs9IHNpemU7XG4gICAgICBjYXBhY2l0eSA9IGk7XG4gICAgICBpZiAoc3VtID4gY29udGFpbmVyU2l6ZSlcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBjYXBhY2l0eSAtIHN0YXJ0O1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlR2V0T2Zmc2V0KHNvdXJjZSwgaXRlbVNpemUpIHtcbiAgcmV0dXJuIChzY3JvbGxEaXJlY3Rpb24pID0+IHtcbiAgICBpZiAodHlwZW9mIGl0ZW1TaXplID09PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIE1hdGguZmxvb3Ioc2Nyb2xsRGlyZWN0aW9uIC8gaXRlbVNpemUpICsgMTtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZS52YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc2l6ZSA9IGl0ZW1TaXplKGkpO1xuICAgICAgc3VtICs9IHNpemU7XG4gICAgICBpZiAoc3VtID49IHNjcm9sbERpcmVjdGlvbikge1xuICAgICAgICBvZmZzZXQgPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldCArIDE7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVDYWxjdWxhdGVSYW5nZSh0eXBlLCBvdmVyc2NhbiwgZ2V0T2Zmc2V0LCBnZXRWaWV3Q2FwYWNpdHksIHsgY29udGFpbmVyUmVmLCBzdGF0ZSwgY3VycmVudExpc3QsIHNvdXJjZSB9KSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgY29uc3QgZWxlbWVudCA9IGNvbnRhaW5lclJlZi52YWx1ZTtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gZ2V0T2Zmc2V0KHR5cGUgPT09IFwidmVydGljYWxcIiA/IGVsZW1lbnQuc2Nyb2xsVG9wIDogZWxlbWVudC5zY3JvbGxMZWZ0KTtcbiAgICAgIGNvbnN0IHZpZXdDYXBhY2l0eSA9IGdldFZpZXdDYXBhY2l0eSh0eXBlID09PSBcInZlcnRpY2FsXCIgPyBlbGVtZW50LmNsaWVudEhlaWdodCA6IGVsZW1lbnQuY2xpZW50V2lkdGgpO1xuICAgICAgY29uc3QgZnJvbSA9IG9mZnNldCAtIG92ZXJzY2FuO1xuICAgICAgY29uc3QgdG8gPSBvZmZzZXQgKyB2aWV3Q2FwYWNpdHkgKyBvdmVyc2NhbjtcbiAgICAgIHN0YXRlLnZhbHVlID0ge1xuICAgICAgICBzdGFydDogZnJvbSA8IDAgPyAwIDogZnJvbSxcbiAgICAgICAgZW5kOiB0byA+IHNvdXJjZS52YWx1ZS5sZW5ndGggPyBzb3VyY2UudmFsdWUubGVuZ3RoIDogdG9cbiAgICAgIH07XG4gICAgICBjdXJyZW50TGlzdC52YWx1ZSA9IHNvdXJjZS52YWx1ZS5zbGljZShzdGF0ZS52YWx1ZS5zdGFydCwgc3RhdGUudmFsdWUuZW5kKS5tYXAoKGVsZSwgaW5kZXgpID0+ICh7XG4gICAgICAgIGRhdGE6IGVsZSxcbiAgICAgICAgaW5kZXg6IGluZGV4ICsgc3RhdGUudmFsdWUuc3RhcnRcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVHZXREaXN0YW5jZShpdGVtU2l6ZSwgc291cmNlKSB7XG4gIHJldHVybiAoaW5kZXgpID0+IHtcbiAgICBpZiAodHlwZW9mIGl0ZW1TaXplID09PSBcIm51bWJlclwiKSB7XG4gICAgICBjb25zdCBzaXplMiA9IGluZGV4ICogaXRlbVNpemU7XG4gICAgICByZXR1cm4gc2l6ZTI7XG4gICAgfVxuICAgIGNvbnN0IHNpemUgPSBzb3VyY2UudmFsdWUuc2xpY2UoMCwgaW5kZXgpLnJlZHVjZSgoc3VtLCBfLCBpKSA9PiBzdW0gKyBpdGVtU2l6ZShpKSwgMCk7XG4gICAgcmV0dXJuIHNpemU7XG4gIH07XG59XG5mdW5jdGlvbiB1c2VXYXRjaEZvclNpemVzKHNpemUsIGxpc3QsIGNvbnRhaW5lclJlZiwgY2FsY3VsYXRlUmFuZ2UpIHtcbiAgd2F0Y2goW3NpemUud2lkdGgsIHNpemUuaGVpZ2h0LCBsaXN0LCBjb250YWluZXJSZWZdLCAoKSA9PiB7XG4gICAgY2FsY3VsYXRlUmFuZ2UoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVDb21wdXRlZFRvdGFsU2l6ZShpdGVtU2l6ZSwgc291cmNlKSB7XG4gIHJldHVybiBjb21wdXRlZCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBpdGVtU2l6ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiBzb3VyY2UudmFsdWUubGVuZ3RoICogaXRlbVNpemU7XG4gICAgcmV0dXJuIHNvdXJjZS52YWx1ZS5yZWR1Y2UoKHN1bSwgXywgaW5kZXgpID0+IHN1bSArIGl0ZW1TaXplKGluZGV4KSwgMCk7XG4gIH0pO1xufVxuY29uc3Qgc2Nyb2xsVG9EaWN0aW9uYXJ5Rm9yRWxlbWVudFNjcm9sbEtleSA9IHtcbiAgaG9yaXpvbnRhbDogXCJzY3JvbGxMZWZ0XCIsXG4gIHZlcnRpY2FsOiBcInNjcm9sbFRvcFwiXG59O1xuZnVuY3Rpb24gY3JlYXRlU2Nyb2xsVG8odHlwZSwgY2FsY3VsYXRlUmFuZ2UsIGdldERpc3RhbmNlLCBjb250YWluZXJSZWYpIHtcbiAgcmV0dXJuIChpbmRleCkgPT4ge1xuICAgIGlmIChjb250YWluZXJSZWYudmFsdWUpIHtcbiAgICAgIGNvbnRhaW5lclJlZi52YWx1ZVtzY3JvbGxUb0RpY3Rpb25hcnlGb3JFbGVtZW50U2Nyb2xsS2V5W3R5cGVdXSA9IGdldERpc3RhbmNlKGluZGV4KTtcbiAgICAgIGNhbGN1bGF0ZVJhbmdlKCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gdXNlSG9yaXpvbnRhbFZpcnR1YWxMaXN0KG9wdGlvbnMsIGxpc3QpIHtcbiAgY29uc3QgcmVzb3VyY2VzID0gdXNlVmlydHVhbExpc3RSZXNvdXJjZXMobGlzdCk7XG4gIGNvbnN0IHsgc3RhdGUsIHNvdXJjZSwgY3VycmVudExpc3QsIHNpemUsIGNvbnRhaW5lclJlZiB9ID0gcmVzb3VyY2VzO1xuICBjb25zdCBjb250YWluZXJTdHlsZSA9IHsgb3ZlcmZsb3dYOiBcImF1dG9cIiB9O1xuICBjb25zdCB7IGl0ZW1XaWR0aCwgb3ZlcnNjYW4gPSA1IH0gPSBvcHRpb25zO1xuICBjb25zdCBnZXRWaWV3Q2FwYWNpdHkgPSBjcmVhdGVHZXRWaWV3Q2FwYWNpdHkoc3RhdGUsIHNvdXJjZSwgaXRlbVdpZHRoKTtcbiAgY29uc3QgZ2V0T2Zmc2V0ID0gY3JlYXRlR2V0T2Zmc2V0KHNvdXJjZSwgaXRlbVdpZHRoKTtcbiAgY29uc3QgY2FsY3VsYXRlUmFuZ2UgPSBjcmVhdGVDYWxjdWxhdGVSYW5nZShcImhvcml6b250YWxcIiwgb3ZlcnNjYW4sIGdldE9mZnNldCwgZ2V0Vmlld0NhcGFjaXR5LCByZXNvdXJjZXMpO1xuICBjb25zdCBnZXREaXN0YW5jZUxlZnQgPSBjcmVhdGVHZXREaXN0YW5jZShpdGVtV2lkdGgsIHNvdXJjZSk7XG4gIGNvbnN0IG9mZnNldExlZnQgPSBjb21wdXRlZCgoKSA9PiBnZXREaXN0YW5jZUxlZnQoc3RhdGUudmFsdWUuc3RhcnQpKTtcbiAgY29uc3QgdG90YWxXaWR0aCA9IGNyZWF0ZUNvbXB1dGVkVG90YWxTaXplKGl0ZW1XaWR0aCwgc291cmNlKTtcbiAgdXNlV2F0Y2hGb3JTaXplcyhzaXplLCBsaXN0LCBjb250YWluZXJSZWYsIGNhbGN1bGF0ZVJhbmdlKTtcbiAgY29uc3Qgc2Nyb2xsVG8gPSBjcmVhdGVTY3JvbGxUbyhcImhvcml6b250YWxcIiwgY2FsY3VsYXRlUmFuZ2UsIGdldERpc3RhbmNlTGVmdCwgY29udGFpbmVyUmVmKTtcbiAgY29uc3Qgd3JhcHBlclByb3BzID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICB3aWR0aDogYCR7dG90YWxXaWR0aC52YWx1ZSAtIG9mZnNldExlZnQudmFsdWV9cHhgLFxuICAgICAgICBtYXJnaW5MZWZ0OiBgJHtvZmZzZXRMZWZ0LnZhbHVlfXB4YCxcbiAgICAgICAgZGlzcGxheTogXCJmbGV4XCJcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxUbyxcbiAgICBjYWxjdWxhdGVSYW5nZSxcbiAgICB3cmFwcGVyUHJvcHMsXG4gICAgY29udGFpbmVyU3R5bGUsXG4gICAgY3VycmVudExpc3QsXG4gICAgY29udGFpbmVyUmVmXG4gIH07XG59XG5mdW5jdGlvbiB1c2VWZXJ0aWNhbFZpcnR1YWxMaXN0KG9wdGlvbnMsIGxpc3QpIHtcbiAgY29uc3QgcmVzb3VyY2VzID0gdXNlVmlydHVhbExpc3RSZXNvdXJjZXMobGlzdCk7XG4gIGNvbnN0IHsgc3RhdGUsIHNvdXJjZSwgY3VycmVudExpc3QsIHNpemUsIGNvbnRhaW5lclJlZiB9ID0gcmVzb3VyY2VzO1xuICBjb25zdCBjb250YWluZXJTdHlsZSA9IHsgb3ZlcmZsb3dZOiBcImF1dG9cIiB9O1xuICBjb25zdCB7IGl0ZW1IZWlnaHQsIG92ZXJzY2FuID0gNSB9ID0gb3B0aW9ucztcbiAgY29uc3QgZ2V0Vmlld0NhcGFjaXR5ID0gY3JlYXRlR2V0Vmlld0NhcGFjaXR5KHN0YXRlLCBzb3VyY2UsIGl0ZW1IZWlnaHQpO1xuICBjb25zdCBnZXRPZmZzZXQgPSBjcmVhdGVHZXRPZmZzZXQoc291cmNlLCBpdGVtSGVpZ2h0KTtcbiAgY29uc3QgY2FsY3VsYXRlUmFuZ2UgPSBjcmVhdGVDYWxjdWxhdGVSYW5nZShcInZlcnRpY2FsXCIsIG92ZXJzY2FuLCBnZXRPZmZzZXQsIGdldFZpZXdDYXBhY2l0eSwgcmVzb3VyY2VzKTtcbiAgY29uc3QgZ2V0RGlzdGFuY2VUb3AgPSBjcmVhdGVHZXREaXN0YW5jZShpdGVtSGVpZ2h0LCBzb3VyY2UpO1xuICBjb25zdCBvZmZzZXRUb3AgPSBjb21wdXRlZCgoKSA9PiBnZXREaXN0YW5jZVRvcChzdGF0ZS52YWx1ZS5zdGFydCkpO1xuICBjb25zdCB0b3RhbEhlaWdodCA9IGNyZWF0ZUNvbXB1dGVkVG90YWxTaXplKGl0ZW1IZWlnaHQsIHNvdXJjZSk7XG4gIHVzZVdhdGNoRm9yU2l6ZXMoc2l6ZSwgbGlzdCwgY29udGFpbmVyUmVmLCBjYWxjdWxhdGVSYW5nZSk7XG4gIGNvbnN0IHNjcm9sbFRvID0gY3JlYXRlU2Nyb2xsVG8oXCJ2ZXJ0aWNhbFwiLCBjYWxjdWxhdGVSYW5nZSwgZ2V0RGlzdGFuY2VUb3AsIGNvbnRhaW5lclJlZik7XG4gIGNvbnN0IHdyYXBwZXJQcm9wcyA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgICAgICBoZWlnaHQ6IGAke3RvdGFsSGVpZ2h0LnZhbHVlIC0gb2Zmc2V0VG9wLnZhbHVlfXB4YCxcbiAgICAgICAgbWFyZ2luVG9wOiBgJHtvZmZzZXRUb3AudmFsdWV9cHhgXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY2FsY3VsYXRlUmFuZ2UsXG4gICAgc2Nyb2xsVG8sXG4gICAgY29udGFpbmVyU3R5bGUsXG4gICAgd3JhcHBlclByb3BzLFxuICAgIGN1cnJlbnRMaXN0LFxuICAgIGNvbnRhaW5lclJlZlxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VXYWtlTG9jayhvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIG5hdmlnYXRvciA9IGRlZmF1bHROYXZpZ2F0b3IsXG4gICAgZG9jdW1lbnQgPSBkZWZhdWx0RG9jdW1lbnRcbiAgfSA9IG9wdGlvbnM7XG4gIGxldCB3YWtlTG9jaztcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gbmF2aWdhdG9yICYmIFwid2FrZUxvY2tcIiBpbiBuYXZpZ2F0b3IpO1xuICBjb25zdCBpc0FjdGl2ZSA9IHJlZihmYWxzZSk7XG4gIGFzeW5jIGZ1bmN0aW9uIG9uVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICBpZiAoIWlzU3VwcG9ydGVkLnZhbHVlIHx8ICF3YWtlTG9jaylcbiAgICAgIHJldHVybjtcbiAgICBpZiAoZG9jdW1lbnQgJiYgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSBcInZpc2libGVcIilcbiAgICAgIHdha2VMb2NrID0gYXdhaXQgbmF2aWdhdG9yLndha2VMb2NrLnJlcXVlc3QoXCJzY3JlZW5cIik7XG4gICAgaXNBY3RpdmUudmFsdWUgPSAhd2FrZUxvY2sucmVsZWFzZWQ7XG4gIH1cbiAgaWYgKGRvY3VtZW50KVxuICAgIHVzZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsIFwidmlzaWJpbGl0eWNoYW5nZVwiLCBvblZpc2liaWxpdHlDaGFuZ2UsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgYXN5bmMgZnVuY3Rpb24gcmVxdWVzdCh0eXBlKSB7XG4gICAgaWYgKCFpc1N1cHBvcnRlZC52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICB3YWtlTG9jayA9IGF3YWl0IG5hdmlnYXRvci53YWtlTG9jay5yZXF1ZXN0KHR5cGUpO1xuICAgIGlzQWN0aXZlLnZhbHVlID0gIXdha2VMb2NrLnJlbGVhc2VkO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHJlbGVhc2UoKSB7XG4gICAgaWYgKCFpc1N1cHBvcnRlZC52YWx1ZSB8fCAhd2FrZUxvY2spXG4gICAgICByZXR1cm47XG4gICAgYXdhaXQgd2FrZUxvY2sucmVsZWFzZSgpO1xuICAgIGlzQWN0aXZlLnZhbHVlID0gIXdha2VMb2NrLnJlbGVhc2VkO1xuICAgIHdha2VMb2NrID0gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIGlzQWN0aXZlLFxuICAgIHJlcXVlc3QsXG4gICAgcmVsZWFzZVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VXZWJOb3RpZmljYXRpb24ob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93LFxuICAgIHJlcXVlc3RQZXJtaXNzaW9uczogX3JlcXVlc3RGb3JQZXJtaXNzaW9ucyA9IHRydWVcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGRlZmF1bHRXZWJOb3RpZmljYXRpb25PcHRpb25zID0gb3B0aW9ucztcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4ge1xuICAgIGlmICghd2luZG93IHx8ICEoXCJOb3RpZmljYXRpb25cIiBpbiB3aW5kb3cpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBuZXcgTm90aWZpY2F0aW9uKFwiXCIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuICBjb25zdCBwZXJtaXNzaW9uR3JhbnRlZCA9IHJlZihpc1N1cHBvcnRlZC52YWx1ZSAmJiBcInBlcm1pc3Npb25cIiBpbiBOb3RpZmljYXRpb24gJiYgTm90aWZpY2F0aW9uLnBlcm1pc3Npb24gPT09IFwiZ3JhbnRlZFwiKTtcbiAgY29uc3Qgbm90aWZpY2F0aW9uID0gcmVmKG51bGwpO1xuICBjb25zdCBlbnN1cmVQZXJtaXNzaW9ucyA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWlzU3VwcG9ydGVkLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghcGVybWlzc2lvbkdyYW50ZWQudmFsdWUgJiYgTm90aWZpY2F0aW9uLnBlcm1pc3Npb24gIT09IFwiZGVuaWVkXCIpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IE5vdGlmaWNhdGlvbi5yZXF1ZXN0UGVybWlzc2lvbigpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gXCJncmFudGVkXCIpXG4gICAgICAgIHBlcm1pc3Npb25HcmFudGVkLnZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHBlcm1pc3Npb25HcmFudGVkLnZhbHVlO1xuICB9O1xuICBjb25zdCB7IG9uOiBvbkNsaWNrLCB0cmlnZ2VyOiBjbGlja1RyaWdnZXIgfSA9IGNyZWF0ZUV2ZW50SG9vaygpO1xuICBjb25zdCB7IG9uOiBvblNob3csIHRyaWdnZXI6IHNob3dUcmlnZ2VyIH0gPSBjcmVhdGVFdmVudEhvb2soKTtcbiAgY29uc3QgeyBvbjogb25FcnJvciwgdHJpZ2dlcjogZXJyb3JUcmlnZ2VyIH0gPSBjcmVhdGVFdmVudEhvb2soKTtcbiAgY29uc3QgeyBvbjogb25DbG9zZSwgdHJpZ2dlcjogY2xvc2VUcmlnZ2VyIH0gPSBjcmVhdGVFdmVudEhvb2soKTtcbiAgY29uc3Qgc2hvdyA9IGFzeW5jIChvdmVycmlkZXMpID0+IHtcbiAgICBpZiAoIWlzU3VwcG9ydGVkLnZhbHVlIHx8ICFwZXJtaXNzaW9uR3JhbnRlZC52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBvcHRpb25zMiA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRXZWJOb3RpZmljYXRpb25PcHRpb25zLCBvdmVycmlkZXMpO1xuICAgIG5vdGlmaWNhdGlvbi52YWx1ZSA9IG5ldyBOb3RpZmljYXRpb24ob3B0aW9uczIudGl0bGUgfHwgXCJcIiwgb3B0aW9uczIpO1xuICAgIG5vdGlmaWNhdGlvbi52YWx1ZS5vbmNsaWNrID0gY2xpY2tUcmlnZ2VyO1xuICAgIG5vdGlmaWNhdGlvbi52YWx1ZS5vbnNob3cgPSBzaG93VHJpZ2dlcjtcbiAgICBub3RpZmljYXRpb24udmFsdWUub25lcnJvciA9IGVycm9yVHJpZ2dlcjtcbiAgICBub3RpZmljYXRpb24udmFsdWUub25jbG9zZSA9IGNsb3NlVHJpZ2dlcjtcbiAgICByZXR1cm4gbm90aWZpY2F0aW9uLnZhbHVlO1xuICB9O1xuICBjb25zdCBjbG9zZSA9ICgpID0+IHtcbiAgICBpZiAobm90aWZpY2F0aW9uLnZhbHVlKVxuICAgICAgbm90aWZpY2F0aW9uLnZhbHVlLmNsb3NlKCk7XG4gICAgbm90aWZpY2F0aW9uLnZhbHVlID0gbnVsbDtcbiAgfTtcbiAgaWYgKF9yZXF1ZXN0Rm9yUGVybWlzc2lvbnMpXG4gICAgdHJ5T25Nb3VudGVkKGVuc3VyZVBlcm1pc3Npb25zKTtcbiAgdHJ5T25TY29wZURpc3Bvc2UoY2xvc2UpO1xuICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUgJiYgd2luZG93KSB7XG4gICAgY29uc3QgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIChlKSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSBcInZpc2libGVcIikge1xuICAgICAgICBjbG9zZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgbm90aWZpY2F0aW9uLFxuICAgIGVuc3VyZVBlcm1pc3Npb25zLFxuICAgIHBlcm1pc3Npb25HcmFudGVkLFxuICAgIHNob3csXG4gICAgY2xvc2UsXG4gICAgb25DbGljayxcbiAgICBvblNob3csXG4gICAgb25FcnJvcixcbiAgICBvbkNsb3NlXG4gIH07XG59XG5cbmNvbnN0IERFRkFVTFRfUElOR19NRVNTQUdFID0gXCJwaW5nXCI7XG5mdW5jdGlvbiByZXNvbHZlTmVzdGVkT3B0aW9ucyhvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB0cnVlKVxuICAgIHJldHVybiB7fTtcbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiB1c2VXZWJTb2NrZXQodXJsLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIG9uQ29ubmVjdGVkLFxuICAgIG9uRGlzY29ubmVjdGVkLFxuICAgIG9uRXJyb3IsXG4gICAgb25NZXNzYWdlLFxuICAgIGltbWVkaWF0ZSA9IHRydWUsXG4gICAgYXV0b0Nsb3NlID0gdHJ1ZSxcbiAgICBwcm90b2NvbHMgPSBbXVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgZGF0YSA9IHJlZihudWxsKTtcbiAgY29uc3Qgc3RhdHVzID0gcmVmKFwiQ0xPU0VEXCIpO1xuICBjb25zdCB3c1JlZiA9IHJlZigpO1xuICBjb25zdCB1cmxSZWYgPSB0b1JlZih1cmwpO1xuICBsZXQgaGVhcnRiZWF0UGF1c2U7XG4gIGxldCBoZWFydGJlYXRSZXN1bWU7XG4gIGxldCBleHBsaWNpdGx5Q2xvc2VkID0gZmFsc2U7XG4gIGxldCByZXRyaWVkID0gMDtcbiAgbGV0IGJ1ZmZlcmVkRGF0YSA9IFtdO1xuICBsZXQgcG9uZ1RpbWVvdXRXYWl0O1xuICBjb25zdCBfc2VuZEJ1ZmZlciA9ICgpID0+IHtcbiAgICBpZiAoYnVmZmVyZWREYXRhLmxlbmd0aCAmJiB3c1JlZi52YWx1ZSAmJiBzdGF0dXMudmFsdWUgPT09IFwiT1BFTlwiKSB7XG4gICAgICBmb3IgKGNvbnN0IGJ1ZmZlciBvZiBidWZmZXJlZERhdGEpXG4gICAgICAgIHdzUmVmLnZhbHVlLnNlbmQoYnVmZmVyKTtcbiAgICAgIGJ1ZmZlcmVkRGF0YSA9IFtdO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVzZXRIZWFydGJlYXQgPSAoKSA9PiB7XG4gICAgY2xlYXJUaW1lb3V0KHBvbmdUaW1lb3V0V2FpdCk7XG4gICAgcG9uZ1RpbWVvdXRXYWl0ID0gdm9pZCAwO1xuICB9O1xuICBjb25zdCBjbG9zZSA9IChjb2RlID0gMWUzLCByZWFzb24pID0+IHtcbiAgICBpZiAoIWlzQ2xpZW50IHx8ICF3c1JlZi52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBleHBsaWNpdGx5Q2xvc2VkID0gdHJ1ZTtcbiAgICByZXNldEhlYXJ0YmVhdCgpO1xuICAgIGhlYXJ0YmVhdFBhdXNlID09IG51bGwgPyB2b2lkIDAgOiBoZWFydGJlYXRQYXVzZSgpO1xuICAgIHdzUmVmLnZhbHVlLmNsb3NlKGNvZGUsIHJlYXNvbik7XG4gICAgd3NSZWYudmFsdWUgPSB2b2lkIDA7XG4gIH07XG4gIGNvbnN0IHNlbmQgPSAoZGF0YTIsIHVzZUJ1ZmZlciA9IHRydWUpID0+IHtcbiAgICBpZiAoIXdzUmVmLnZhbHVlIHx8IHN0YXR1cy52YWx1ZSAhPT0gXCJPUEVOXCIpIHtcbiAgICAgIGlmICh1c2VCdWZmZXIpXG4gICAgICAgIGJ1ZmZlcmVkRGF0YS5wdXNoKGRhdGEyKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX3NlbmRCdWZmZXIoKTtcbiAgICB3c1JlZi52YWx1ZS5zZW5kKGRhdGEyKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgY29uc3QgX2luaXQgPSAoKSA9PiB7XG4gICAgaWYgKGV4cGxpY2l0bHlDbG9zZWQgfHwgdHlwZW9mIHVybFJlZi52YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB3cyA9IG5ldyBXZWJTb2NrZXQodXJsUmVmLnZhbHVlLCBwcm90b2NvbHMpO1xuICAgIHdzUmVmLnZhbHVlID0gd3M7XG4gICAgc3RhdHVzLnZhbHVlID0gXCJDT05ORUNUSU5HXCI7XG4gICAgd3Mub25vcGVuID0gKCkgPT4ge1xuICAgICAgc3RhdHVzLnZhbHVlID0gXCJPUEVOXCI7XG4gICAgICBvbkNvbm5lY3RlZCA9PSBudWxsID8gdm9pZCAwIDogb25Db25uZWN0ZWQod3MpO1xuICAgICAgaGVhcnRiZWF0UmVzdW1lID09IG51bGwgPyB2b2lkIDAgOiBoZWFydGJlYXRSZXN1bWUoKTtcbiAgICAgIF9zZW5kQnVmZmVyKCk7XG4gICAgfTtcbiAgICB3cy5vbmNsb3NlID0gKGV2KSA9PiB7XG4gICAgICBzdGF0dXMudmFsdWUgPSBcIkNMT1NFRFwiO1xuICAgICAgb25EaXNjb25uZWN0ZWQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRGlzY29ubmVjdGVkKHdzLCBldik7XG4gICAgICBpZiAoIWV4cGxpY2l0bHlDbG9zZWQgJiYgb3B0aW9ucy5hdXRvUmVjb25uZWN0KSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICByZXRyaWVzID0gLTEsXG4gICAgICAgICAgZGVsYXkgPSAxZTMsXG4gICAgICAgICAgb25GYWlsZWRcbiAgICAgICAgfSA9IHJlc29sdmVOZXN0ZWRPcHRpb25zKG9wdGlvbnMuYXV0b1JlY29ubmVjdCk7XG4gICAgICAgIHJldHJpZWQgKz0gMTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXRyaWVzID09PSBcIm51bWJlclwiICYmIChyZXRyaWVzIDwgMCB8fCByZXRyaWVkIDwgcmV0cmllcykpXG4gICAgICAgICAgc2V0VGltZW91dChfaW5pdCwgZGVsYXkpO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcmV0cmllcyA9PT0gXCJmdW5jdGlvblwiICYmIHJldHJpZXMoKSlcbiAgICAgICAgICBzZXRUaW1lb3V0KF9pbml0LCBkZWxheSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBvbkZhaWxlZCA9PSBudWxsID8gdm9pZCAwIDogb25GYWlsZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdzLm9uZXJyb3IgPSAoZSkgPT4ge1xuICAgICAgb25FcnJvciA9PSBudWxsID8gdm9pZCAwIDogb25FcnJvcih3cywgZSk7XG4gICAgfTtcbiAgICB3cy5vbm1lc3NhZ2UgPSAoZSkgPT4ge1xuICAgICAgaWYgKG9wdGlvbnMuaGVhcnRiZWF0KSB7XG4gICAgICAgIHJlc2V0SGVhcnRiZWF0KCk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBtZXNzYWdlID0gREVGQVVMVF9QSU5HX01FU1NBR0VcbiAgICAgICAgfSA9IHJlc29sdmVOZXN0ZWRPcHRpb25zKG9wdGlvbnMuaGVhcnRiZWF0KTtcbiAgICAgICAgaWYgKGUuZGF0YSA9PT0gbWVzc2FnZSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkYXRhLnZhbHVlID0gZS5kYXRhO1xuICAgICAgb25NZXNzYWdlID09IG51bGwgPyB2b2lkIDAgOiBvbk1lc3NhZ2Uod3MsIGUpO1xuICAgIH07XG4gIH07XG4gIGlmIChvcHRpb25zLmhlYXJ0YmVhdCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lc3NhZ2UgPSBERUZBVUxUX1BJTkdfTUVTU0FHRSxcbiAgICAgIGludGVydmFsID0gMWUzLFxuICAgICAgcG9uZ1RpbWVvdXQgPSAxZTNcbiAgICB9ID0gcmVzb2x2ZU5lc3RlZE9wdGlvbnMob3B0aW9ucy5oZWFydGJlYXQpO1xuICAgIGNvbnN0IHsgcGF1c2UsIHJlc3VtZSB9ID0gdXNlSW50ZXJ2YWxGbihcbiAgICAgICgpID0+IHtcbiAgICAgICAgc2VuZChtZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIGlmIChwb25nVGltZW91dFdhaXQgIT0gbnVsbClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHBvbmdUaW1lb3V0V2FpdCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgZXhwbGljaXRseUNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB9LCBwb25nVGltZW91dCk7XG4gICAgICB9LFxuICAgICAgaW50ZXJ2YWwsXG4gICAgICB7IGltbWVkaWF0ZTogZmFsc2UgfVxuICAgICk7XG4gICAgaGVhcnRiZWF0UGF1c2UgPSBwYXVzZTtcbiAgICBoZWFydGJlYXRSZXN1bWUgPSByZXN1bWU7XG4gIH1cbiAgaWYgKGF1dG9DbG9zZSkge1xuICAgIGlmIChpc0NsaWVudClcbiAgICAgIHVzZUV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgKCkgPT4gY2xvc2UoKSk7XG4gICAgdHJ5T25TY29wZURpc3Bvc2UoY2xvc2UpO1xuICB9XG4gIGNvbnN0IG9wZW4gPSAoKSA9PiB7XG4gICAgaWYgKCFpc0NsaWVudCAmJiAhaXNXb3JrZXIpXG4gICAgICByZXR1cm47XG4gICAgY2xvc2UoKTtcbiAgICBleHBsaWNpdGx5Q2xvc2VkID0gZmFsc2U7XG4gICAgcmV0cmllZCA9IDA7XG4gICAgX2luaXQoKTtcbiAgfTtcbiAgaWYgKGltbWVkaWF0ZSlcbiAgICBvcGVuKCk7XG4gIHdhdGNoKHVybFJlZiwgb3Blbik7XG4gIHJldHVybiB7XG4gICAgZGF0YSxcbiAgICBzdGF0dXMsXG4gICAgY2xvc2UsXG4gICAgc2VuZCxcbiAgICBvcGVuLFxuICAgIHdzOiB3c1JlZlxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VXZWJXb3JrZXIoYXJnMCwgd29ya2VyT3B0aW9ucywgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvd1xuICB9ID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucyA6IHt9O1xuICBjb25zdCBkYXRhID0gcmVmKG51bGwpO1xuICBjb25zdCB3b3JrZXIgPSBzaGFsbG93UmVmKCk7XG4gIGNvbnN0IHBvc3QgPSAoLi4uYXJncykgPT4ge1xuICAgIGlmICghd29ya2VyLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIHdvcmtlci52YWx1ZS5wb3N0TWVzc2FnZSguLi5hcmdzKTtcbiAgfTtcbiAgY29uc3QgdGVybWluYXRlID0gZnVuY3Rpb24gdGVybWluYXRlMigpIHtcbiAgICBpZiAoIXdvcmtlci52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICB3b3JrZXIudmFsdWUudGVybWluYXRlKCk7XG4gIH07XG4gIGlmICh3aW5kb3cpIHtcbiAgICBpZiAodHlwZW9mIGFyZzAgPT09IFwic3RyaW5nXCIpXG4gICAgICB3b3JrZXIudmFsdWUgPSBuZXcgV29ya2VyKGFyZzAsIHdvcmtlck9wdGlvbnMpO1xuICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcwID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICB3b3JrZXIudmFsdWUgPSBhcmcwKCk7XG4gICAgZWxzZVxuICAgICAgd29ya2VyLnZhbHVlID0gYXJnMDtcbiAgICB3b3JrZXIudmFsdWUub25tZXNzYWdlID0gKGUpID0+IHtcbiAgICAgIGRhdGEudmFsdWUgPSBlLmRhdGE7XG4gICAgfTtcbiAgICB0cnlPblNjb3BlRGlzcG9zZSgoKSA9PiB7XG4gICAgICBpZiAod29ya2VyLnZhbHVlKVxuICAgICAgICB3b3JrZXIudmFsdWUudGVybWluYXRlKCk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkYXRhLFxuICAgIHBvc3QsXG4gICAgdGVybWluYXRlLFxuICAgIHdvcmtlclxuICB9O1xufVxuXG5mdW5jdGlvbiBqb2JSdW5uZXIodXNlckZ1bmMpIHtcbiAgcmV0dXJuIChlKSA9PiB7XG4gICAgY29uc3QgdXNlckZ1bmNBcmdzID0gZS5kYXRhWzBdO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodXNlckZ1bmMuYXBwbHkodm9pZCAwLCB1c2VyRnVuY0FyZ3MpKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgIHBvc3RNZXNzYWdlKFtcIlNVQ0NFU1NcIiwgcmVzdWx0XSk7XG4gICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICBwb3N0TWVzc2FnZShbXCJFUlJPUlwiLCBlcnJvcl0pO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkZXBzUGFyc2VyKGRlcHMsIGxvY2FsRGVwcykge1xuICBpZiAoZGVwcy5sZW5ndGggPT09IDAgJiYgbG9jYWxEZXBzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gXCJcIjtcbiAgY29uc3QgZGVwc1N0cmluZyA9IGRlcHMubWFwKChkZXApID0+IGAnJHtkZXB9J2ApLnRvU3RyaW5nKCk7XG4gIGNvbnN0IGRlcHNGdW5jdGlvblN0cmluZyA9IGxvY2FsRGVwcy5maWx0ZXIoKGRlcCkgPT4gdHlwZW9mIGRlcCA9PT0gXCJmdW5jdGlvblwiKS5tYXAoKGZuKSA9PiB7XG4gICAgY29uc3Qgc3RyID0gZm4udG9TdHJpbmcoKTtcbiAgICBpZiAoc3RyLnRyaW0oKS5zdGFydHNXaXRoKFwiZnVuY3Rpb25cIikpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBmbi5uYW1lO1xuICAgICAgcmV0dXJuIGBjb25zdCAke25hbWV9ID0gJHtzdHJ9YDtcbiAgICB9XG4gIH0pLmpvaW4oXCI7XCIpO1xuICBjb25zdCBpbXBvcnRTdHJpbmcgPSBgaW1wb3J0U2NyaXB0cygke2RlcHNTdHJpbmd9KTtgO1xuICByZXR1cm4gYCR7ZGVwc1N0cmluZy50cmltKCkgPT09IFwiXCIgPyBcIlwiIDogaW1wb3J0U3RyaW5nfSAke2RlcHNGdW5jdGlvblN0cmluZ31gO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVXb3JrZXJCbG9iVXJsKGZuLCBkZXBzLCBsb2NhbERlcHMpIHtcbiAgY29uc3QgYmxvYkNvZGUgPSBgJHtkZXBzUGFyc2VyKGRlcHMsIGxvY2FsRGVwcyl9OyBvbm1lc3NhZ2U9KCR7am9iUnVubmVyfSkoJHtmbn0pYDtcbiAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtibG9iQ29kZV0sIHsgdHlwZTogXCJ0ZXh0L2phdmFzY3JpcHRcIiB9KTtcbiAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgcmV0dXJuIHVybDtcbn1cblxuZnVuY3Rpb24gdXNlV2ViV29ya2VyRm4oZm4sIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgZGVwZW5kZW5jaWVzID0gW10sXG4gICAgbG9jYWxEZXBlbmRlbmNpZXMgPSBbXSxcbiAgICB0aW1lb3V0LFxuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3dcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHdvcmtlciA9IHJlZigpO1xuICBjb25zdCB3b3JrZXJTdGF0dXMgPSByZWYoXCJQRU5ESU5HXCIpO1xuICBjb25zdCBwcm9taXNlID0gcmVmKHt9KTtcbiAgY29uc3QgdGltZW91dElkID0gcmVmKCk7XG4gIGNvbnN0IHdvcmtlclRlcm1pbmF0ZSA9IChzdGF0dXMgPSBcIlBFTkRJTkdcIikgPT4ge1xuICAgIGlmICh3b3JrZXIudmFsdWUgJiYgd29ya2VyLnZhbHVlLl91cmwgJiYgd2luZG93KSB7XG4gICAgICB3b3JrZXIudmFsdWUudGVybWluYXRlKCk7XG4gICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHdvcmtlci52YWx1ZS5fdXJsKTtcbiAgICAgIHByb21pc2UudmFsdWUgPSB7fTtcbiAgICAgIHdvcmtlci52YWx1ZSA9IHZvaWQgMDtcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dElkLnZhbHVlKTtcbiAgICAgIHdvcmtlclN0YXR1cy52YWx1ZSA9IHN0YXR1cztcbiAgICB9XG4gIH07XG4gIHdvcmtlclRlcm1pbmF0ZSgpO1xuICB0cnlPblNjb3BlRGlzcG9zZSh3b3JrZXJUZXJtaW5hdGUpO1xuICBjb25zdCBnZW5lcmF0ZVdvcmtlciA9ICgpID0+IHtcbiAgICBjb25zdCBibG9iVXJsID0gY3JlYXRlV29ya2VyQmxvYlVybChmbiwgZGVwZW5kZW5jaWVzLCBsb2NhbERlcGVuZGVuY2llcyk7XG4gICAgY29uc3QgbmV3V29ya2VyID0gbmV3IFdvcmtlcihibG9iVXJsKTtcbiAgICBuZXdXb3JrZXIuX3VybCA9IGJsb2JVcmw7XG4gICAgbmV3V29ya2VyLm9ubWVzc2FnZSA9IChlKSA9PiB7XG4gICAgICBjb25zdCB7IHJlc29sdmUgPSAoKSA9PiB7XG4gICAgICB9LCByZWplY3QgPSAoKSA9PiB7XG4gICAgICB9IH0gPSBwcm9taXNlLnZhbHVlO1xuICAgICAgY29uc3QgW3N0YXR1cywgcmVzdWx0XSA9IGUuZGF0YTtcbiAgICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgXCJTVUNDRVNTXCI6XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIHdvcmtlclRlcm1pbmF0ZShzdGF0dXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlamVjdChyZXN1bHQpO1xuICAgICAgICAgIHdvcmtlclRlcm1pbmF0ZShcIkVSUk9SXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH07XG4gICAgbmV3V29ya2VyLm9uZXJyb3IgPSAoZSkgPT4ge1xuICAgICAgY29uc3QgeyByZWplY3QgPSAoKSA9PiB7XG4gICAgICB9IH0gPSBwcm9taXNlLnZhbHVlO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmVqZWN0KGUpO1xuICAgICAgd29ya2VyVGVybWluYXRlKFwiRVJST1JcIik7XG4gICAgfTtcbiAgICBpZiAodGltZW91dCkge1xuICAgICAgdGltZW91dElkLnZhbHVlID0gc2V0VGltZW91dChcbiAgICAgICAgKCkgPT4gd29ya2VyVGVybWluYXRlKFwiVElNRU9VVF9FWFBJUkVEXCIpLFxuICAgICAgICB0aW1lb3V0XG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3V29ya2VyO1xuICB9O1xuICBjb25zdCBjYWxsV29ya2VyID0gKC4uLmZuQXJncykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHByb21pc2UudmFsdWUgPSB7XG4gICAgICByZXNvbHZlLFxuICAgICAgcmVqZWN0XG4gICAgfTtcbiAgICB3b3JrZXIudmFsdWUgJiYgd29ya2VyLnZhbHVlLnBvc3RNZXNzYWdlKFtbLi4uZm5BcmdzXV0pO1xuICAgIHdvcmtlclN0YXR1cy52YWx1ZSA9IFwiUlVOTklOR1wiO1xuICB9KTtcbiAgY29uc3Qgd29ya2VyRm4gPSAoLi4uZm5BcmdzKSA9PiB7XG4gICAgaWYgKHdvcmtlclN0YXR1cy52YWx1ZSA9PT0gXCJSVU5OSU5HXCIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiW3VzZVdlYldvcmtlckZuXSBZb3UgY2FuIG9ubHkgcnVuIG9uZSBpbnN0YW5jZSBvZiB0aGUgd29ya2VyIGF0IGEgdGltZS5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICAgIH1cbiAgICB3b3JrZXIudmFsdWUgPSBnZW5lcmF0ZVdvcmtlcigpO1xuICAgIHJldHVybiBjYWxsV29ya2VyKC4uLmZuQXJncyk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgd29ya2VyRm4sXG4gICAgd29ya2VyU3RhdHVzLFxuICAgIHdvcmtlclRlcm1pbmF0ZVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VXaW5kb3dGb2N1cyhvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB3aW5kb3cgPSBkZWZhdWx0V2luZG93IH0gPSBvcHRpb25zO1xuICBpZiAoIXdpbmRvdylcbiAgICByZXR1cm4gcmVmKGZhbHNlKTtcbiAgY29uc3QgZm9jdXNlZCA9IHJlZih3aW5kb3cuZG9jdW1lbnQuaGFzRm9jdXMoKSk7XG4gIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcImJsdXJcIiwgKCkgPT4ge1xuICAgIGZvY3VzZWQudmFsdWUgPSBmYWxzZTtcbiAgfSk7XG4gIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcImZvY3VzXCIsICgpID0+IHtcbiAgICBmb2N1c2VkLnZhbHVlID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiBmb2N1c2VkO1xufVxuXG5mdW5jdGlvbiB1c2VXaW5kb3dTY3JvbGwob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgd2luZG93ID0gZGVmYXVsdFdpbmRvdywgYmVoYXZpb3IgPSBcImF1dG9cIiB9ID0gb3B0aW9ucztcbiAgaWYgKCF3aW5kb3cpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcmVmKDApLFxuICAgICAgeTogcmVmKDApXG4gICAgfTtcbiAgfVxuICBjb25zdCBpbnRlcm5hbFggPSByZWYod2luZG93LnNjcm9sbFgpO1xuICBjb25zdCBpbnRlcm5hbFkgPSByZWYod2luZG93LnNjcm9sbFkpO1xuICBjb25zdCB4ID0gY29tcHV0ZWQoe1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBpbnRlcm5hbFgudmFsdWU7XG4gICAgfSxcbiAgICBzZXQoeDIpIHtcbiAgICAgIHNjcm9sbFRvKHsgbGVmdDogeDIsIGJlaGF2aW9yIH0pO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHkgPSBjb21wdXRlZCh7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIGludGVybmFsWS52YWx1ZTtcbiAgICB9LFxuICAgIHNldCh5Mikge1xuICAgICAgc2Nyb2xsVG8oeyB0b3A6IHkyLCBiZWhhdmlvciB9KTtcbiAgICB9XG4gIH0pO1xuICB1c2VFdmVudExpc3RlbmVyKFxuICAgIHdpbmRvdyxcbiAgICBcInNjcm9sbFwiLFxuICAgICgpID0+IHtcbiAgICAgIGludGVybmFsWC52YWx1ZSA9IHdpbmRvdy5zY3JvbGxYO1xuICAgICAgaW50ZXJuYWxZLnZhbHVlID0gd2luZG93LnNjcm9sbFk7XG4gICAgfSxcbiAgICB7XG4gICAgICBjYXB0dXJlOiBmYWxzZSxcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9XG4gICk7XG4gIHJldHVybiB7IHgsIHkgfTtcbn1cblxuZnVuY3Rpb24gdXNlV2luZG93U2l6ZShvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3csXG4gICAgaW5pdGlhbFdpZHRoID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgIGluaXRpYWxIZWlnaHQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgbGlzdGVuT3JpZW50YXRpb24gPSB0cnVlLFxuICAgIGluY2x1ZGVTY3JvbGxiYXIgPSB0cnVlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCB3aWR0aCA9IHJlZihpbml0aWFsV2lkdGgpO1xuICBjb25zdCBoZWlnaHQgPSByZWYoaW5pdGlhbEhlaWdodCk7XG4gIGNvbnN0IHVwZGF0ZSA9ICgpID0+IHtcbiAgICBpZiAod2luZG93KSB7XG4gICAgICBpZiAoaW5jbHVkZVNjcm9sbGJhcikge1xuICAgICAgICB3aWR0aC52YWx1ZSA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICBoZWlnaHQudmFsdWUgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aWR0aC52YWx1ZSA9IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICAgIGhlaWdodC52YWx1ZSA9IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdXBkYXRlKCk7XG4gIHRyeU9uTW91bnRlZCh1cGRhdGUpO1xuICB1c2VFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHVwZGF0ZSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICBpZiAobGlzdGVuT3JpZW50YXRpb24pIHtcbiAgICBjb25zdCBtYXRjaGVzID0gdXNlTWVkaWFRdWVyeShcIihvcmllbnRhdGlvbjogcG9ydHJhaXQpXCIpO1xuICAgIHdhdGNoKG1hdGNoZXMsICgpID0+IHVwZGF0ZSgpKTtcbiAgfVxuICByZXR1cm4geyB3aWR0aCwgaGVpZ2h0IH07XG59XG5cbmV4cG9ydCB7IERlZmF1bHRNYWdpY0tleXNBbGlhc01hcCwgU3RvcmFnZVNlcmlhbGl6ZXJzLCBUcmFuc2l0aW9uUHJlc2V0cywgY29tcHV0ZWRBc3luYyBhcyBhc3luY0NvbXB1dGVkLCBicmVha3BvaW50c0FudERlc2lnbiwgYnJlYWtwb2ludHNCb290c3RyYXBWNSwgYnJlYWtwb2ludHNNYXN0ZXJDc3MsIGJyZWFrcG9pbnRzUHJpbWVGbGV4LCBicmVha3BvaW50c1F1YXNhciwgYnJlYWtwb2ludHNTZW1hdGljLCBicmVha3BvaW50c1RhaWx3aW5kLCBicmVha3BvaW50c1Z1ZXRpZnksIGJyZWFrcG9pbnRzVnVldGlmeVYyLCBicmVha3BvaW50c1Z1ZXRpZnlWMywgY2xvbmVGbkpTT04sIGNvbXB1dGVkQXN5bmMsIGNvbXB1dGVkSW5qZWN0LCBjcmVhdGVGZXRjaCwgY3JlYXRlUmV1c2FibGVUZW1wbGF0ZSwgY3JlYXRlVGVtcGxhdGVQcm9taXNlLCBjcmVhdGVVbnJlZkZuLCBjdXN0b21TdG9yYWdlRXZlbnROYW1lLCBkZWZhdWx0RG9jdW1lbnQsIGRlZmF1bHRMb2NhdGlvbiwgZGVmYXVsdE5hdmlnYXRvciwgZGVmYXVsdFdpbmRvdywgZXhlY3V0ZVRyYW5zaXRpb24sIGZvcm1hdFRpbWVBZ28sIGdldFNTUkhhbmRsZXIsIG1hcEdhbWVwYWRUb1hib3gzNjBDb250cm9sbGVyLCBvbkNsaWNrT3V0c2lkZSwgb25LZXlEb3duLCBvbktleVByZXNzZWQsIG9uS2V5U3Ryb2tlLCBvbktleVVwLCBvbkxvbmdQcmVzcywgb25TdGFydFR5cGluZywgc2V0U1NSSGFuZGxlciwgdGVtcGxhdGVSZWYsIHVucmVmRWxlbWVudCwgdXNlQWN0aXZlRWxlbWVudCwgdXNlQW5pbWF0ZSwgdXNlQXN5bmNRdWV1ZSwgdXNlQXN5bmNTdGF0ZSwgdXNlQmFzZTY0LCB1c2VCYXR0ZXJ5LCB1c2VCbHVldG9vdGgsIHVzZUJyZWFrcG9pbnRzLCB1c2VCcm9hZGNhc3RDaGFubmVsLCB1c2VCcm93c2VyTG9jYXRpb24sIHVzZUNhY2hlZCwgdXNlQ2xpcGJvYXJkLCB1c2VDbGlwYm9hcmRJdGVtcywgdXNlQ2xvbmVkLCB1c2VDb2xvck1vZGUsIHVzZUNvbmZpcm1EaWFsb2csIHVzZUNzc1ZhciwgdXNlQ3VycmVudEVsZW1lbnQsIHVzZUN5Y2xlTGlzdCwgdXNlRGFyaywgdXNlRGVib3VuY2VkUmVmSGlzdG9yeSwgdXNlRGV2aWNlTW90aW9uLCB1c2VEZXZpY2VPcmllbnRhdGlvbiwgdXNlRGV2aWNlUGl4ZWxSYXRpbywgdXNlRGV2aWNlc0xpc3QsIHVzZURpc3BsYXlNZWRpYSwgdXNlRG9jdW1lbnRWaXNpYmlsaXR5LCB1c2VEcmFnZ2FibGUsIHVzZURyb3Bab25lLCB1c2VFbGVtZW50Qm91bmRpbmcsIHVzZUVsZW1lbnRCeVBvaW50LCB1c2VFbGVtZW50SG92ZXIsIHVzZUVsZW1lbnRTaXplLCB1c2VFbGVtZW50VmlzaWJpbGl0eSwgdXNlRXZlbnRCdXMsIHVzZUV2ZW50TGlzdGVuZXIsIHVzZUV2ZW50U291cmNlLCB1c2VFeWVEcm9wcGVyLCB1c2VGYXZpY29uLCB1c2VGZXRjaCwgdXNlRmlsZURpYWxvZywgdXNlRmlsZVN5c3RlbUFjY2VzcywgdXNlRm9jdXMsIHVzZUZvY3VzV2l0aGluLCB1c2VGcHMsIHVzZUZ1bGxzY3JlZW4sIHVzZUdhbWVwYWQsIHVzZUdlb2xvY2F0aW9uLCB1c2VJZGxlLCB1c2VJbWFnZSwgdXNlSW5maW5pdGVTY3JvbGwsIHVzZUludGVyc2VjdGlvbk9ic2VydmVyLCB1c2VLZXlNb2RpZmllciwgdXNlTG9jYWxTdG9yYWdlLCB1c2VNYWdpY0tleXMsIHVzZU1hbnVhbFJlZkhpc3RvcnksIHVzZU1lZGlhQ29udHJvbHMsIHVzZU1lZGlhUXVlcnksIHVzZU1lbW9pemUsIHVzZU1lbW9yeSwgdXNlTW91bnRlZCwgdXNlTW91c2UsIHVzZU1vdXNlSW5FbGVtZW50LCB1c2VNb3VzZVByZXNzZWQsIHVzZU11dGF0aW9uT2JzZXJ2ZXIsIHVzZU5hdmlnYXRvckxhbmd1YWdlLCB1c2VOZXR3b3JrLCB1c2VOb3csIHVzZU9iamVjdFVybCwgdXNlT2Zmc2V0UGFnaW5hdGlvbiwgdXNlT25saW5lLCB1c2VQYWdlTGVhdmUsIHVzZVBhcmFsbGF4LCB1c2VQYXJlbnRFbGVtZW50LCB1c2VQZXJmb3JtYW5jZU9ic2VydmVyLCB1c2VQZXJtaXNzaW9uLCB1c2VQb2ludGVyLCB1c2VQb2ludGVyTG9jaywgdXNlUG9pbnRlclN3aXBlLCB1c2VQcmVmZXJyZWRDb2xvclNjaGVtZSwgdXNlUHJlZmVycmVkQ29udHJhc3QsIHVzZVByZWZlcnJlZERhcmssIHVzZVByZWZlcnJlZExhbmd1YWdlcywgdXNlUHJlZmVycmVkUmVkdWNlZE1vdGlvbiwgdXNlUHJldmlvdXMsIHVzZVJhZkZuLCB1c2VSZWZIaXN0b3J5LCB1c2VSZXNpemVPYnNlcnZlciwgdXNlU2NyZWVuT3JpZW50YXRpb24sIHVzZVNjcmVlblNhZmVBcmVhLCB1c2VTY3JpcHRUYWcsIHVzZVNjcm9sbCwgdXNlU2Nyb2xsTG9jaywgdXNlU2Vzc2lvblN0b3JhZ2UsIHVzZVNoYXJlLCB1c2VTb3J0ZWQsIHVzZVNwZWVjaFJlY29nbml0aW9uLCB1c2VTcGVlY2hTeW50aGVzaXMsIHVzZVN0ZXBwZXIsIHVzZVN0b3JhZ2UsIHVzZVN0b3JhZ2VBc3luYywgdXNlU3R5bGVUYWcsIHVzZVN1cHBvcnRlZCwgdXNlU3dpcGUsIHVzZVRlbXBsYXRlUmVmc0xpc3QsIHVzZVRleHREaXJlY3Rpb24sIHVzZVRleHRTZWxlY3Rpb24sIHVzZVRleHRhcmVhQXV0b3NpemUsIHVzZVRocm90dGxlZFJlZkhpc3RvcnksIHVzZVRpbWVBZ28sIHVzZVRpbWVvdXRQb2xsLCB1c2VUaW1lc3RhbXAsIHVzZVRpdGxlLCB1c2VUcmFuc2l0aW9uLCB1c2VVcmxTZWFyY2hQYXJhbXMsIHVzZVVzZXJNZWRpYSwgdXNlVk1vZGVsLCB1c2VWTW9kZWxzLCB1c2VWaWJyYXRlLCB1c2VWaXJ0dWFsTGlzdCwgdXNlV2FrZUxvY2ssIHVzZVdlYk5vdGlmaWNhdGlvbiwgdXNlV2ViU29ja2V0LCB1c2VXZWJXb3JrZXIsIHVzZVdlYldvcmtlckZuLCB1c2VXaW5kb3dGb2N1cywgdXNlV2luZG93U2Nyb2xsLCB1c2VXaW5kb3dTaXplIH07XG4iLCJpbXBvcnQgeyBzaGFsbG93UmVmLCB3YXRjaEVmZmVjdCwgcmVhZG9ubHksIHJlZiwgd2F0Y2gsIGN1c3RvbVJlZiwgZ2V0Q3VycmVudFNjb3BlLCBvblNjb3BlRGlzcG9zZSwgZWZmZWN0U2NvcGUsIGdldEN1cnJlbnRJbnN0YW5jZSwgcHJvdmlkZSwgaW5qZWN0LCBpc1Z1ZTMsIHZlcnNpb24sIGlzUmVmLCB1bnJlZiwgY29tcHV0ZWQsIHJlYWN0aXZlLCB0b1JlZnMgYXMgdG9SZWZzJDEsIHRvUmVmIGFzIHRvUmVmJDEsIGlzVnVlMiwgc2V0IGFzIHNldCQxLCBvbkJlZm9yZU1vdW50LCBuZXh0VGljaywgb25CZWZvcmVVbm1vdW50LCBvbk1vdW50ZWQsIG9uVW5tb3VudGVkLCBpc1JlYWN0aXZlIH0gZnJvbSAndnVlLWRlbWknO1xuXG5mdW5jdGlvbiBjb21wdXRlZEVhZ2VyKGZuLCBvcHRpb25zKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgcmVzdWx0ID0gc2hhbGxvd1JlZigpO1xuICB3YXRjaEVmZmVjdCgoKSA9PiB7XG4gICAgcmVzdWx0LnZhbHVlID0gZm4oKTtcbiAgfSwge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgZmx1c2g6IChfYSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZmx1c2gpICE9IG51bGwgPyBfYSA6IFwic3luY1wiXG4gIH0pO1xuICByZXR1cm4gcmVhZG9ubHkocmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZWRXaXRoQ29udHJvbChzb3VyY2UsIGZuKSB7XG4gIGxldCB2ID0gdm9pZCAwO1xuICBsZXQgdHJhY2s7XG4gIGxldCB0cmlnZ2VyO1xuICBjb25zdCBkaXJ0eSA9IHJlZih0cnVlKTtcbiAgY29uc3QgdXBkYXRlID0gKCkgPT4ge1xuICAgIGRpcnR5LnZhbHVlID0gdHJ1ZTtcbiAgICB0cmlnZ2VyKCk7XG4gIH07XG4gIHdhdGNoKHNvdXJjZSwgdXBkYXRlLCB7IGZsdXNoOiBcInN5bmNcIiB9KTtcbiAgY29uc3QgZ2V0ID0gdHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIgPyBmbiA6IGZuLmdldDtcbiAgY29uc3Qgc2V0ID0gdHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIgPyB2b2lkIDAgOiBmbi5zZXQ7XG4gIGNvbnN0IHJlc3VsdCA9IGN1c3RvbVJlZigoX3RyYWNrLCBfdHJpZ2dlcikgPT4ge1xuICAgIHRyYWNrID0gX3RyYWNrO1xuICAgIHRyaWdnZXIgPSBfdHJpZ2dlcjtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0KCkge1xuICAgICAgICBpZiAoZGlydHkudmFsdWUpIHtcbiAgICAgICAgICB2ID0gZ2V0KCk7XG4gICAgICAgICAgZGlydHkudmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cmFjaygpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH0sXG4gICAgICBzZXQodjIpIHtcbiAgICAgICAgc2V0ID09IG51bGwgPyB2b2lkIDAgOiBzZXQodjIpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICBpZiAoT2JqZWN0LmlzRXh0ZW5zaWJsZShyZXN1bHQpKVxuICAgIHJlc3VsdC50cmlnZ2VyID0gdXBkYXRlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB0cnlPblNjb3BlRGlzcG9zZShmbikge1xuICBpZiAoZ2V0Q3VycmVudFNjb3BlKCkpIHtcbiAgICBvblNjb3BlRGlzcG9zZShmbik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFdmVudEhvb2soKSB7XG4gIGNvbnN0IGZucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IG9mZiA9IChmbikgPT4ge1xuICAgIGZucy5kZWxldGUoZm4pO1xuICB9O1xuICBjb25zdCBvbiA9IChmbikgPT4ge1xuICAgIGZucy5hZGQoZm4pO1xuICAgIGNvbnN0IG9mZkZuID0gKCkgPT4gb2ZmKGZuKTtcbiAgICB0cnlPblNjb3BlRGlzcG9zZShvZmZGbik7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9mZjogb2ZmRm5cbiAgICB9O1xuICB9O1xuICBjb25zdCB0cmlnZ2VyID0gKC4uLmFyZ3MpID0+IHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoQXJyYXkuZnJvbShmbnMpLm1hcCgoZm4pID0+IGZuKC4uLmFyZ3MpKSk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgb24sXG4gICAgb2ZmLFxuICAgIHRyaWdnZXJcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlR2xvYmFsU3RhdGUoc3RhdGVGYWN0b3J5KSB7XG4gIGxldCBpbml0aWFsaXplZCA9IGZhbHNlO1xuICBsZXQgc3RhdGU7XG4gIGNvbnN0IHNjb3BlID0gZWZmZWN0U2NvcGUodHJ1ZSk7XG4gIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgIGlmICghaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHN0YXRlID0gc2NvcGUucnVuKCgpID0+IHN0YXRlRmFjdG9yeSguLi5hcmdzKSk7XG4gICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbiAgfTtcbn1cblxuY29uc3QgbG9jYWxQcm92aWRlZFN0YXRlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5cbmNvbnN0IHByb3ZpZGVMb2NhbCA9IChrZXksIHZhbHVlKSA9PiB7XG4gIHZhciBfYTtcbiAgY29uc3QgaW5zdGFuY2UgPSAoX2EgPSBnZXRDdXJyZW50SW5zdGFuY2UoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnByb3h5O1xuICBpZiAoaW5zdGFuY2UgPT0gbnVsbClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm92aWRlTG9jYWwgbXVzdCBiZSBjYWxsZWQgaW4gc2V0dXBcIik7XG4gIGlmICghbG9jYWxQcm92aWRlZFN0YXRlTWFwLmhhcyhpbnN0YW5jZSkpXG4gICAgbG9jYWxQcm92aWRlZFN0YXRlTWFwLnNldChpbnN0YW5jZSwgLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICBjb25zdCBsb2NhbFByb3ZpZGVkU3RhdGUgPSBsb2NhbFByb3ZpZGVkU3RhdGVNYXAuZ2V0KGluc3RhbmNlKTtcbiAgbG9jYWxQcm92aWRlZFN0YXRlW2tleV0gPSB2YWx1ZTtcbiAgcHJvdmlkZShrZXksIHZhbHVlKTtcbn07XG5cbmNvbnN0IGluamVjdExvY2FsID0gKC4uLmFyZ3MpID0+IHtcbiAgdmFyIF9hO1xuICBjb25zdCBrZXkgPSBhcmdzWzBdO1xuICBjb25zdCBpbnN0YW5jZSA9IChfYSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpKSA9PSBudWxsID8gdm9pZCAwIDogX2EucHJveHk7XG4gIGlmIChpbnN0YW5jZSA9PSBudWxsKVxuICAgIHRocm93IG5ldyBFcnJvcihcImluamVjdExvY2FsIG11c3QgYmUgY2FsbGVkIGluIHNldHVwXCIpO1xuICBpZiAobG9jYWxQcm92aWRlZFN0YXRlTWFwLmhhcyhpbnN0YW5jZSkgJiYga2V5IGluIGxvY2FsUHJvdmlkZWRTdGF0ZU1hcC5nZXQoaW5zdGFuY2UpKVxuICAgIHJldHVybiBsb2NhbFByb3ZpZGVkU3RhdGVNYXAuZ2V0KGluc3RhbmNlKVtrZXldO1xuICByZXR1cm4gaW5qZWN0KC4uLmFyZ3MpO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlSW5qZWN0aW9uU3RhdGUoY29tcG9zYWJsZSwgb3B0aW9ucykge1xuICBjb25zdCBrZXkgPSAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5pbmplY3Rpb25LZXkpIHx8IFN5bWJvbChjb21wb3NhYmxlLm5hbWUgfHwgXCJJbmplY3Rpb25TdGF0ZVwiKTtcbiAgY29uc3QgZGVmYXVsdFZhbHVlID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kZWZhdWx0VmFsdWU7XG4gIGNvbnN0IHVzZVByb3ZpZGluZ1N0YXRlID0gKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IGNvbXBvc2FibGUoLi4uYXJncyk7XG4gICAgcHJvdmlkZUxvY2FsKGtleSwgc3RhdGUpO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfTtcbiAgY29uc3QgdXNlSW5qZWN0ZWRTdGF0ZSA9ICgpID0+IGluamVjdExvY2FsKGtleSwgZGVmYXVsdFZhbHVlKTtcbiAgcmV0dXJuIFt1c2VQcm92aWRpbmdTdGF0ZSwgdXNlSW5qZWN0ZWRTdGF0ZV07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNoYXJlZENvbXBvc2FibGUoY29tcG9zYWJsZSkge1xuICBsZXQgc3Vic2NyaWJlcnMgPSAwO1xuICBsZXQgc3RhdGU7XG4gIGxldCBzY29wZTtcbiAgY29uc3QgZGlzcG9zZSA9ICgpID0+IHtcbiAgICBzdWJzY3JpYmVycyAtPSAxO1xuICAgIGlmIChzY29wZSAmJiBzdWJzY3JpYmVycyA8PSAwKSB7XG4gICAgICBzY29wZS5zdG9wKCk7XG4gICAgICBzdGF0ZSA9IHZvaWQgMDtcbiAgICAgIHNjb3BlID0gdm9pZCAwO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgc3Vic2NyaWJlcnMgKz0gMTtcbiAgICBpZiAoIXN0YXRlKSB7XG4gICAgICBzY29wZSA9IGVmZmVjdFNjb3BlKHRydWUpO1xuICAgICAgc3RhdGUgPSBzY29wZS5ydW4oKCkgPT4gY29tcG9zYWJsZSguLi5hcmdzKSk7XG4gICAgfVxuICAgIHRyeU9uU2NvcGVEaXNwb3NlKGRpc3Bvc2UpO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kUmVmKHJlZiwgZXh0ZW5kLCB7IGVudW1lcmFibGUgPSBmYWxzZSwgdW53cmFwID0gdHJ1ZSB9ID0ge30pIHtcbiAgaWYgKCFpc1Z1ZTMgJiYgIXZlcnNpb24uc3RhcnRzV2l0aChcIjIuNy5cIikpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW1Z1ZVVzZV0gZXh0ZW5kUmVmIG9ubHkgd29ya3MgaW4gVnVlIDIuNyBvciBhYm92ZS5cIik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGV4dGVuZCkpIHtcbiAgICBpZiAoa2V5ID09PSBcInZhbHVlXCIpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAoaXNSZWYodmFsdWUpICYmIHVud3JhcCkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlZiwga2V5LCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgdmFsdWUudmFsdWUgPSB2O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlZiwga2V5LCB7IHZhbHVlLCBlbnVtZXJhYmxlIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVmO1xufVxuXG5mdW5jdGlvbiBnZXQob2JqLCBrZXkpIHtcbiAgaWYgKGtleSA9PSBudWxsKVxuICAgIHJldHVybiB1bnJlZihvYmopO1xuICByZXR1cm4gdW5yZWYob2JqKVtrZXldO1xufVxuXG5mdW5jdGlvbiBpc0RlZmluZWQodikge1xuICByZXR1cm4gdW5yZWYodikgIT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gbWFrZURlc3RydWN0dXJhYmxlKG9iaiwgYXJyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY29uc3QgY2xvbmUgPSB7IC4uLm9iaiB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbG9uZSwgU3ltYm9sLml0ZXJhdG9yLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlKCkge1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5leHQ6ICgpID0+ICh7XG4gICAgICAgICAgICB2YWx1ZTogYXJyW2luZGV4KytdLFxuICAgICAgICAgICAgZG9uZTogaW5kZXggPiBhcnIubGVuZ3RoXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oWy4uLmFycl0sIG9iaik7XG4gIH1cbn1cblxuZnVuY3Rpb24gdG9WYWx1ZShyKSB7XG4gIHJldHVybiB0eXBlb2YgciA9PT0gXCJmdW5jdGlvblwiID8gcigpIDogdW5yZWYocik7XG59XG5jb25zdCByZXNvbHZlVW5yZWYgPSB0b1ZhbHVlO1xuXG5mdW5jdGlvbiByZWFjdGlmeShmbiwgb3B0aW9ucykge1xuICBjb25zdCB1bnJlZkZuID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuY29tcHV0ZWRHZXR0ZXIpID09PSBmYWxzZSA/IHVucmVmIDogdG9WYWx1ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gY29tcHV0ZWQoKCkgPT4gZm4uYXBwbHkodGhpcywgYXJncy5tYXAoKGkpID0+IHVucmVmRm4oaSkpKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlYWN0aWZ5T2JqZWN0KG9iaiwgb3B0aW9uc09yS2V5cyA9IHt9KSB7XG4gIGxldCBrZXlzID0gW107XG4gIGxldCBvcHRpb25zO1xuICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zT3JLZXlzKSkge1xuICAgIGtleXMgPSBvcHRpb25zT3JLZXlzO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zT3JLZXlzO1xuICAgIGNvbnN0IHsgaW5jbHVkZU93blByb3BlcnRpZXMgPSB0cnVlIH0gPSBvcHRpb25zT3JLZXlzO1xuICAgIGtleXMucHVzaCguLi5PYmplY3Qua2V5cyhvYmopKTtcbiAgICBpZiAoaW5jbHVkZU93blByb3BlcnRpZXMpXG4gICAgICBrZXlzLnB1c2goLi4uT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKSk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBrZXlzLm1hcCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAga2V5LFxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IHJlYWN0aWZ5KHZhbHVlLmJpbmQob2JqKSwgb3B0aW9ucykgOiB2YWx1ZVxuICAgICAgXTtcbiAgICB9KVxuICApO1xufVxuXG5mdW5jdGlvbiB0b1JlYWN0aXZlKG9iamVjdFJlZikge1xuICBpZiAoIWlzUmVmKG9iamVjdFJlZikpXG4gICAgcmV0dXJuIHJlYWN0aXZlKG9iamVjdFJlZik7XG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KHt9LCB7XG4gICAgZ2V0KF8sIHAsIHJlY2VpdmVyKSB7XG4gICAgICByZXR1cm4gdW5yZWYoUmVmbGVjdC5nZXQob2JqZWN0UmVmLnZhbHVlLCBwLCByZWNlaXZlcikpO1xuICAgIH0sXG4gICAgc2V0KF8sIHAsIHZhbHVlKSB7XG4gICAgICBpZiAoaXNSZWYob2JqZWN0UmVmLnZhbHVlW3BdKSAmJiAhaXNSZWYodmFsdWUpKVxuICAgICAgICBvYmplY3RSZWYudmFsdWVbcF0udmFsdWUgPSB2YWx1ZTtcbiAgICAgIGVsc2VcbiAgICAgICAgb2JqZWN0UmVmLnZhbHVlW3BdID0gdmFsdWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGRlbGV0ZVByb3BlcnR5KF8sIHApIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KG9iamVjdFJlZi52YWx1ZSwgcCk7XG4gICAgfSxcbiAgICBoYXMoXywgcCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKG9iamVjdFJlZi52YWx1ZSwgcCk7XG4gICAgfSxcbiAgICBvd25LZXlzKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdFJlZi52YWx1ZSk7XG4gICAgfSxcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlYWN0aXZlKHByb3h5KTtcbn1cblxuZnVuY3Rpb24gcmVhY3RpdmVDb21wdXRlZChmbikge1xuICByZXR1cm4gdG9SZWFjdGl2ZShjb21wdXRlZChmbikpO1xufVxuXG5mdW5jdGlvbiByZWFjdGl2ZU9taXQob2JqLCAuLi5rZXlzKSB7XG4gIGNvbnN0IGZsYXRLZXlzID0ga2V5cy5mbGF0KCk7XG4gIGNvbnN0IHByZWRpY2F0ZSA9IGZsYXRLZXlzWzBdO1xuICByZXR1cm4gcmVhY3RpdmVDb21wdXRlZCgoKSA9PiB0eXBlb2YgcHJlZGljYXRlID09PSBcImZ1bmN0aW9uXCIgPyBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXModG9SZWZzJDEob2JqKSkuZmlsdGVyKChbaywgdl0pID0+ICFwcmVkaWNhdGUodG9WYWx1ZSh2KSwgaykpKSA6IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyh0b1JlZnMkMShvYmopKS5maWx0ZXIoKGUpID0+ICFmbGF0S2V5cy5pbmNsdWRlcyhlWzBdKSkpKTtcbn1cblxuY29uc3QgaXNDbGllbnQgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIjtcbmNvbnN0IGlzV29ya2VyID0gdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbFRoaXMgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZTtcbmNvbnN0IGlzRGVmID0gKHZhbCkgPT4gdHlwZW9mIHZhbCAhPT0gXCJ1bmRlZmluZWRcIjtcbmNvbnN0IG5vdE51bGxpc2ggPSAodmFsKSA9PiB2YWwgIT0gbnVsbDtcbmNvbnN0IGFzc2VydCA9IChjb25kaXRpb24sIC4uLmluZm9zKSA9PiB7XG4gIGlmICghY29uZGl0aW9uKVxuICAgIGNvbnNvbGUud2FybiguLi5pbmZvcyk7XG59O1xuY29uc3QgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB0b1N0cmluZy5jYWxsKHZhbCkgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG5jb25zdCBub3cgPSAoKSA9PiBEYXRlLm5vdygpO1xuY29uc3QgdGltZXN0YW1wID0gKCkgPT4gK0RhdGUubm93KCk7XG5jb25zdCBjbGFtcCA9IChuLCBtaW4sIG1heCkgPT4gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIG4pKTtcbmNvbnN0IG5vb3AgPSAoKSA9PiB7XG59O1xuY29uc3QgcmFuZCA9IChtaW4sIG1heCkgPT4ge1xuICBtaW4gPSBNYXRoLmNlaWwobWluKTtcbiAgbWF4ID0gTWF0aC5mbG9vcihtYXgpO1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pbjtcbn07XG5jb25zdCBoYXNPd24gPSAodmFsLCBrZXkpID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWwsIGtleSk7XG5jb25zdCBpc0lPUyA9IC8qIEBfX1BVUkVfXyAqLyBnZXRJc0lPUygpO1xuZnVuY3Rpb24gZ2V0SXNJT1MoKSB7XG4gIHZhciBfYSwgX2I7XG4gIHJldHVybiBpc0NsaWVudCAmJiAoKF9hID0gd2luZG93ID09IG51bGwgPyB2b2lkIDAgOiB3aW5kb3cubmF2aWdhdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX2EudXNlckFnZW50KSAmJiAoL2lQKD86YWR8aG9uZXxvZCkvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpIHx8ICgoX2IgPSB3aW5kb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHdpbmRvdy5uYXZpZ2F0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfYi5tYXhUb3VjaFBvaW50cykgPiAyICYmIC9pUGFkfE1hY2ludG9zaC8udGVzdCh3aW5kb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpbHRlcldyYXBwZXIoZmlsdGVyLCBmbikge1xuICBmdW5jdGlvbiB3cmFwcGVyKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKGZpbHRlcigoKSA9PiBmbi5hcHBseSh0aGlzLCBhcmdzKSwgeyBmbiwgdGhpc0FyZzogdGhpcywgYXJncyB9KSkudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB3cmFwcGVyO1xufVxuY29uc3QgYnlwYXNzRmlsdGVyID0gKGludm9rZSkgPT4ge1xuICByZXR1cm4gaW52b2tlKCk7XG59O1xuZnVuY3Rpb24gZGVib3VuY2VGaWx0ZXIobXMsIG9wdGlvbnMgPSB7fSkge1xuICBsZXQgdGltZXI7XG4gIGxldCBtYXhUaW1lcjtcbiAgbGV0IGxhc3RSZWplY3RvciA9IG5vb3A7XG4gIGNvbnN0IF9jbGVhclRpbWVvdXQgPSAodGltZXIyKSA9PiB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyMik7XG4gICAgbGFzdFJlamVjdG9yKCk7XG4gICAgbGFzdFJlamVjdG9yID0gbm9vcDtcbiAgfTtcbiAgY29uc3QgZmlsdGVyID0gKGludm9rZSkgPT4ge1xuICAgIGNvbnN0IGR1cmF0aW9uID0gdG9WYWx1ZShtcyk7XG4gICAgY29uc3QgbWF4RHVyYXRpb24gPSB0b1ZhbHVlKG9wdGlvbnMubWF4V2FpdCk7XG4gICAgaWYgKHRpbWVyKVxuICAgICAgX2NsZWFyVGltZW91dCh0aW1lcik7XG4gICAgaWYgKGR1cmF0aW9uIDw9IDAgfHwgbWF4RHVyYXRpb24gIT09IHZvaWQgMCAmJiBtYXhEdXJhdGlvbiA8PSAwKSB7XG4gICAgICBpZiAobWF4VGltZXIpIHtcbiAgICAgICAgX2NsZWFyVGltZW91dChtYXhUaW1lcik7XG4gICAgICAgIG1heFRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaW52b2tlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGFzdFJlamVjdG9yID0gb3B0aW9ucy5yZWplY3RPbkNhbmNlbCA/IHJlamVjdCA6IHJlc29sdmU7XG4gICAgICBpZiAobWF4RHVyYXRpb24gJiYgIW1heFRpbWVyKSB7XG4gICAgICAgIG1heFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHRpbWVyKVxuICAgICAgICAgICAgX2NsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgbWF4VGltZXIgPSBudWxsO1xuICAgICAgICAgIHJlc29sdmUoaW52b2tlKCkpO1xuICAgICAgICB9LCBtYXhEdXJhdGlvbik7XG4gICAgICB9XG4gICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAobWF4VGltZXIpXG4gICAgICAgICAgX2NsZWFyVGltZW91dChtYXhUaW1lcik7XG4gICAgICAgIG1heFRpbWVyID0gbnVsbDtcbiAgICAgICAgcmVzb2x2ZShpbnZva2UoKSk7XG4gICAgICB9LCBkdXJhdGlvbik7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBmaWx0ZXI7XG59XG5mdW5jdGlvbiB0aHJvdHRsZUZpbHRlciguLi5hcmdzKSB7XG4gIGxldCBsYXN0RXhlYyA9IDA7XG4gIGxldCB0aW1lcjtcbiAgbGV0IGlzTGVhZGluZyA9IHRydWU7XG4gIGxldCBsYXN0UmVqZWN0b3IgPSBub29wO1xuICBsZXQgbGFzdFZhbHVlO1xuICBsZXQgbXM7XG4gIGxldCB0cmFpbGluZztcbiAgbGV0IGxlYWRpbmc7XG4gIGxldCByZWplY3RPbkNhbmNlbDtcbiAgaWYgKCFpc1JlZihhcmdzWzBdKSAmJiB0eXBlb2YgYXJnc1swXSA9PT0gXCJvYmplY3RcIilcbiAgICAoeyBkZWxheTogbXMsIHRyYWlsaW5nID0gdHJ1ZSwgbGVhZGluZyA9IHRydWUsIHJlamVjdE9uQ2FuY2VsID0gZmFsc2UgfSA9IGFyZ3NbMF0pO1xuICBlbHNlXG4gICAgW21zLCB0cmFpbGluZyA9IHRydWUsIGxlYWRpbmcgPSB0cnVlLCByZWplY3RPbkNhbmNlbCA9IGZhbHNlXSA9IGFyZ3M7XG4gIGNvbnN0IGNsZWFyID0gKCkgPT4ge1xuICAgIGlmICh0aW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIHRpbWVyID0gdm9pZCAwO1xuICAgICAgbGFzdFJlamVjdG9yKCk7XG4gICAgICBsYXN0UmVqZWN0b3IgPSBub29wO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgZmlsdGVyID0gKF9pbnZva2UpID0+IHtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHRvVmFsdWUobXMpO1xuICAgIGNvbnN0IGVsYXBzZWQgPSBEYXRlLm5vdygpIC0gbGFzdEV4ZWM7XG4gICAgY29uc3QgaW52b2tlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGxhc3RWYWx1ZSA9IF9pbnZva2UoKTtcbiAgICB9O1xuICAgIGNsZWFyKCk7XG4gICAgaWYgKGR1cmF0aW9uIDw9IDApIHtcbiAgICAgIGxhc3RFeGVjID0gRGF0ZS5ub3coKTtcbiAgICAgIHJldHVybiBpbnZva2UoKTtcbiAgICB9XG4gICAgaWYgKGVsYXBzZWQgPiBkdXJhdGlvbiAmJiAobGVhZGluZyB8fCAhaXNMZWFkaW5nKSkge1xuICAgICAgbGFzdEV4ZWMgPSBEYXRlLm5vdygpO1xuICAgICAgaW52b2tlKCk7XG4gICAgfSBlbHNlIGlmICh0cmFpbGluZykge1xuICAgICAgbGFzdFZhbHVlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBsYXN0UmVqZWN0b3IgPSByZWplY3RPbkNhbmNlbCA/IHJlamVjdCA6IHJlc29sdmU7XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgbGFzdEV4ZWMgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIGlzTGVhZGluZyA9IHRydWU7XG4gICAgICAgICAgcmVzb2x2ZShpbnZva2UoKSk7XG4gICAgICAgICAgY2xlYXIoKTtcbiAgICAgICAgfSwgTWF0aC5tYXgoMCwgZHVyYXRpb24gLSBlbGFwc2VkKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFsZWFkaW5nICYmICF0aW1lcilcbiAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiBpc0xlYWRpbmcgPSB0cnVlLCBkdXJhdGlvbik7XG4gICAgaXNMZWFkaW5nID0gZmFsc2U7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZTtcbiAgfTtcbiAgcmV0dXJuIGZpbHRlcjtcbn1cbmZ1bmN0aW9uIHBhdXNhYmxlRmlsdGVyKGV4dGVuZEZpbHRlciA9IGJ5cGFzc0ZpbHRlcikge1xuICBjb25zdCBpc0FjdGl2ZSA9IHJlZih0cnVlKTtcbiAgZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgaXNBY3RpdmUudmFsdWUgPSBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiByZXN1bWUoKSB7XG4gICAgaXNBY3RpdmUudmFsdWUgPSB0cnVlO1xuICB9XG4gIGNvbnN0IGV2ZW50RmlsdGVyID0gKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoaXNBY3RpdmUudmFsdWUpXG4gICAgICBleHRlbmRGaWx0ZXIoLi4uYXJncyk7XG4gIH07XG4gIHJldHVybiB7IGlzQWN0aXZlOiByZWFkb25seShpc0FjdGl2ZSksIHBhdXNlLCByZXN1bWUsIGV2ZW50RmlsdGVyIH07XG59XG5cbmNvbnN0IGRpcmVjdGl2ZUhvb2tzID0ge1xuICBtb3VudGVkOiBpc1Z1ZTMgPyBcIm1vdW50ZWRcIiA6IFwiaW5zZXJ0ZWRcIixcbiAgdXBkYXRlZDogaXNWdWUzID8gXCJ1cGRhdGVkXCIgOiBcImNvbXBvbmVudFVwZGF0ZWRcIixcbiAgdW5tb3VudGVkOiBpc1Z1ZTMgPyBcInVubW91bnRlZFwiIDogXCJ1bmJpbmRcIlxufTtcblxuZnVuY3Rpb24gY2FjaGVTdHJpbmdGdW5jdGlvbihmbikge1xuICBjb25zdCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKHN0cikgPT4ge1xuICAgIGNvbnN0IGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpO1xuICB9O1xufVxuY29uc3QgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xuY29uc3QgaHlwaGVuYXRlID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgXCItJDFcIikudG9Mb3dlckNhc2UoKSk7XG5jb25zdCBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xuY29uc3QgY2FtZWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiBjID8gYy50b1VwcGVyQ2FzZSgpIDogXCJcIik7XG59KTtcblxuZnVuY3Rpb24gcHJvbWlzZVRpbWVvdXQobXMsIHRocm93T25UaW1lb3V0ID0gZmFsc2UsIHJlYXNvbiA9IFwiVGltZW91dFwiKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKHRocm93T25UaW1lb3V0KVxuICAgICAgc2V0VGltZW91dCgoKSA9PiByZWplY3QocmVhc29uKSwgbXMpO1xuICAgIGVsc2VcbiAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlkZW50aXR5KGFyZykge1xuICByZXR1cm4gYXJnO1xufVxuZnVuY3Rpb24gY3JlYXRlU2luZ2xldG9uUHJvbWlzZShmbikge1xuICBsZXQgX3Byb21pc2U7XG4gIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgaWYgKCFfcHJvbWlzZSlcbiAgICAgIF9wcm9taXNlID0gZm4oKTtcbiAgICByZXR1cm4gX3Byb21pc2U7XG4gIH1cbiAgd3JhcHBlci5yZXNldCA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBfcHJldiA9IF9wcm9taXNlO1xuICAgIF9wcm9taXNlID0gdm9pZCAwO1xuICAgIGlmIChfcHJldilcbiAgICAgIGF3YWl0IF9wcmV2O1xuICB9O1xuICByZXR1cm4gd3JhcHBlcjtcbn1cbmZ1bmN0aW9uIGludm9rZShmbikge1xuICByZXR1cm4gZm4oKTtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zUHJvcChvYmosIC4uLnByb3BzKSB7XG4gIHJldHVybiBwcm9wcy5zb21lKChrKSA9PiBrIGluIG9iaik7XG59XG5mdW5jdGlvbiBpbmNyZWFzZVdpdGhVbml0KHRhcmdldCwgZGVsdGEpIHtcbiAgdmFyIF9hO1xuICBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4gdGFyZ2V0ICsgZGVsdGE7XG4gIGNvbnN0IHZhbHVlID0gKChfYSA9IHRhcmdldC5tYXRjaCgvXi0/XFxkK1xcLj9cXGQqLykpID09IG51bGwgPyB2b2lkIDAgOiBfYVswXSkgfHwgXCJcIjtcbiAgY29uc3QgdW5pdCA9IHRhcmdldC5zbGljZSh2YWx1ZS5sZW5ndGgpO1xuICBjb25zdCByZXN1bHQgPSBOdW1iZXIucGFyc2VGbG9hdCh2YWx1ZSkgKyBkZWx0YTtcbiAgaWYgKE51bWJlci5pc05hTihyZXN1bHQpKVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIHJldHVybiByZXN1bHQgKyB1bml0O1xufVxuZnVuY3Rpb24gb2JqZWN0UGljayhvYmosIGtleXMsIG9taXRVbmRlZmluZWQgPSBmYWxzZSkge1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoKG4sIGspID0+IHtcbiAgICBpZiAoayBpbiBvYmopIHtcbiAgICAgIGlmICghb21pdFVuZGVmaW5lZCB8fCBvYmpba10gIT09IHZvaWQgMClcbiAgICAgICAgbltrXSA9IG9ialtrXTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIG9iamVjdE9taXQob2JqLCBrZXlzLCBvbWl0VW5kZWZpbmVkID0gZmFsc2UpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhvYmopLmZpbHRlcigoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgcmV0dXJuICghb21pdFVuZGVmaW5lZCB8fCB2YWx1ZSAhPT0gdm9pZCAwKSAmJiAha2V5cy5pbmNsdWRlcyhrZXkpO1xuICB9KSk7XG59XG5mdW5jdGlvbiBvYmplY3RFbnRyaWVzKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2JqKTtcbn1cbmZ1bmN0aW9uIGdldExpZmVDeWNsZVRhcmdldCh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldCB8fCBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbn1cblxuZnVuY3Rpb24gdG9SZWYoLi4uYXJncykge1xuICBpZiAoYXJncy5sZW5ndGggIT09IDEpXG4gICAgcmV0dXJuIHRvUmVmJDEoLi4uYXJncyk7XG4gIGNvbnN0IHIgPSBhcmdzWzBdO1xuICByZXR1cm4gdHlwZW9mIHIgPT09IFwiZnVuY3Rpb25cIiA/IHJlYWRvbmx5KGN1c3RvbVJlZigoKSA9PiAoeyBnZXQ6IHIsIHNldDogbm9vcCB9KSkpIDogcmVmKHIpO1xufVxuY29uc3QgcmVzb2x2ZVJlZiA9IHRvUmVmO1xuXG5mdW5jdGlvbiByZWFjdGl2ZVBpY2sob2JqLCAuLi5rZXlzKSB7XG4gIGNvbnN0IGZsYXRLZXlzID0ga2V5cy5mbGF0KCk7XG4gIGNvbnN0IHByZWRpY2F0ZSA9IGZsYXRLZXlzWzBdO1xuICByZXR1cm4gcmVhY3RpdmVDb21wdXRlZCgoKSA9PiB0eXBlb2YgcHJlZGljYXRlID09PSBcImZ1bmN0aW9uXCIgPyBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXModG9SZWZzJDEob2JqKSkuZmlsdGVyKChbaywgdl0pID0+IHByZWRpY2F0ZSh0b1ZhbHVlKHYpLCBrKSkpIDogT2JqZWN0LmZyb21FbnRyaWVzKGZsYXRLZXlzLm1hcCgoaykgPT4gW2ssIHRvUmVmKG9iaiwgayldKSkpO1xufVxuXG5mdW5jdGlvbiByZWZBdXRvUmVzZXQoZGVmYXVsdFZhbHVlLCBhZnRlck1zID0gMWU0KSB7XG4gIHJldHVybiBjdXN0b21SZWYoKHRyYWNrLCB0cmlnZ2VyKSA9PiB7XG4gICAgbGV0IHZhbHVlID0gdG9WYWx1ZShkZWZhdWx0VmFsdWUpO1xuICAgIGxldCB0aW1lcjtcbiAgICBjb25zdCByZXNldEFmdGVyID0gKCkgPT4gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB2YWx1ZSA9IHRvVmFsdWUoZGVmYXVsdFZhbHVlKTtcbiAgICAgIHRyaWdnZXIoKTtcbiAgICB9LCB0b1ZhbHVlKGFmdGVyTXMpKTtcbiAgICB0cnlPblNjb3BlRGlzcG9zZSgoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHRyYWNrKCk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBzZXQobmV3VmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgdHJpZ2dlcigpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICB0aW1lciA9IHJlc2V0QWZ0ZXIoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlRGVib3VuY2VGbihmbiwgbXMgPSAyMDAsIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gY3JlYXRlRmlsdGVyV3JhcHBlcihcbiAgICBkZWJvdW5jZUZpbHRlcihtcywgb3B0aW9ucyksXG4gICAgZm5cbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVmRGVib3VuY2VkKHZhbHVlLCBtcyA9IDIwMCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGRlYm91bmNlZCA9IHJlZih2YWx1ZS52YWx1ZSk7XG4gIGNvbnN0IHVwZGF0ZXIgPSB1c2VEZWJvdW5jZUZuKCgpID0+IHtcbiAgICBkZWJvdW5jZWQudmFsdWUgPSB2YWx1ZS52YWx1ZTtcbiAgfSwgbXMsIG9wdGlvbnMpO1xuICB3YXRjaCh2YWx1ZSwgKCkgPT4gdXBkYXRlcigpKTtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxuZnVuY3Rpb24gcmVmRGVmYXVsdChzb3VyY2UsIGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4gY29tcHV0ZWQoe1xuICAgIGdldCgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiAoX2EgPSBzb3VyY2UudmFsdWUpICE9IG51bGwgPyBfYSA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgc291cmNlLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlVGhyb3R0bGVGbihmbiwgbXMgPSAyMDAsIHRyYWlsaW5nID0gZmFsc2UsIGxlYWRpbmcgPSB0cnVlLCByZWplY3RPbkNhbmNlbCA9IGZhbHNlKSB7XG4gIHJldHVybiBjcmVhdGVGaWx0ZXJXcmFwcGVyKFxuICAgIHRocm90dGxlRmlsdGVyKG1zLCB0cmFpbGluZywgbGVhZGluZywgcmVqZWN0T25DYW5jZWwpLFxuICAgIGZuXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlZlRocm90dGxlZCh2YWx1ZSwgZGVsYXkgPSAyMDAsIHRyYWlsaW5nID0gdHJ1ZSwgbGVhZGluZyA9IHRydWUpIHtcbiAgaWYgKGRlbGF5IDw9IDApXG4gICAgcmV0dXJuIHZhbHVlO1xuICBjb25zdCB0aHJvdHRsZWQgPSByZWYodmFsdWUudmFsdWUpO1xuICBjb25zdCB1cGRhdGVyID0gdXNlVGhyb3R0bGVGbigoKSA9PiB7XG4gICAgdGhyb3R0bGVkLnZhbHVlID0gdmFsdWUudmFsdWU7XG4gIH0sIGRlbGF5LCB0cmFpbGluZywgbGVhZGluZyk7XG4gIHdhdGNoKHZhbHVlLCAoKSA9PiB1cGRhdGVyKCkpO1xuICByZXR1cm4gdGhyb3R0bGVkO1xufVxuXG5mdW5jdGlvbiByZWZXaXRoQ29udHJvbChpbml0aWFsLCBvcHRpb25zID0ge30pIHtcbiAgbGV0IHNvdXJjZSA9IGluaXRpYWw7XG4gIGxldCB0cmFjaztcbiAgbGV0IHRyaWdnZXI7XG4gIGNvbnN0IHJlZiA9IGN1c3RvbVJlZigoX3RyYWNrLCBfdHJpZ2dlcikgPT4ge1xuICAgIHRyYWNrID0gX3RyYWNrO1xuICAgIHRyaWdnZXIgPSBfdHJpZ2dlcjtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gZ2V0KCk7XG4gICAgICB9LFxuICAgICAgc2V0KHYpIHtcbiAgICAgICAgc2V0KHYpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICBmdW5jdGlvbiBnZXQodHJhY2tpbmcgPSB0cnVlKSB7XG4gICAgaWYgKHRyYWNraW5nKVxuICAgICAgdHJhY2soKTtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG4gIGZ1bmN0aW9uIHNldCh2YWx1ZSwgdHJpZ2dlcmluZyA9IHRydWUpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICh2YWx1ZSA9PT0gc291cmNlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG9sZCA9IHNvdXJjZTtcbiAgICBpZiAoKChfYSA9IG9wdGlvbnMub25CZWZvcmVDaGFuZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdGlvbnMsIHZhbHVlLCBvbGQpKSA9PT0gZmFsc2UpXG4gICAgICByZXR1cm47XG4gICAgc291cmNlID0gdmFsdWU7XG4gICAgKF9iID0gb3B0aW9ucy5vbkNoYW5nZWQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKG9wdGlvbnMsIHZhbHVlLCBvbGQpO1xuICAgIGlmICh0cmlnZ2VyaW5nKVxuICAgICAgdHJpZ2dlcigpO1xuICB9XG4gIGNvbnN0IHVudHJhY2tlZEdldCA9ICgpID0+IGdldChmYWxzZSk7XG4gIGNvbnN0IHNpbGVudFNldCA9ICh2KSA9PiBzZXQodiwgZmFsc2UpO1xuICBjb25zdCBwZWVrID0gKCkgPT4gZ2V0KGZhbHNlKTtcbiAgY29uc3QgbGF5ID0gKHYpID0+IHNldCh2LCBmYWxzZSk7XG4gIHJldHVybiBleHRlbmRSZWYoXG4gICAgcmVmLFxuICAgIHtcbiAgICAgIGdldCxcbiAgICAgIHNldCxcbiAgICAgIHVudHJhY2tlZEdldCxcbiAgICAgIHNpbGVudFNldCxcbiAgICAgIHBlZWssXG4gICAgICBsYXlcbiAgICB9LFxuICAgIHsgZW51bWVyYWJsZTogdHJ1ZSB9XG4gICk7XG59XG5jb25zdCBjb250cm9sbGVkUmVmID0gcmVmV2l0aENvbnRyb2w7XG5cbmZ1bmN0aW9uIHNldCguLi5hcmdzKSB7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgIGNvbnN0IFtyZWYsIHZhbHVlXSA9IGFyZ3M7XG4gICAgcmVmLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgaWYgKGlzVnVlMikge1xuICAgICAgc2V0JDEoLi4uYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFt0YXJnZXQsIGtleSwgdmFsdWVdID0gYXJncztcbiAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdhdGNoV2l0aEZpbHRlcihzb3VyY2UsIGNiLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGV2ZW50RmlsdGVyID0gYnlwYXNzRmlsdGVyLFxuICAgIC4uLndhdGNoT3B0aW9uc1xuICB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIHdhdGNoKFxuICAgIHNvdXJjZSxcbiAgICBjcmVhdGVGaWx0ZXJXcmFwcGVyKFxuICAgICAgZXZlbnRGaWx0ZXIsXG4gICAgICBjYlxuICAgICksXG4gICAgd2F0Y2hPcHRpb25zXG4gICk7XG59XG5cbmZ1bmN0aW9uIHdhdGNoUGF1c2FibGUoc291cmNlLCBjYiwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBldmVudEZpbHRlcjogZmlsdGVyLFxuICAgIC4uLndhdGNoT3B0aW9uc1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgeyBldmVudEZpbHRlciwgcGF1c2UsIHJlc3VtZSwgaXNBY3RpdmUgfSA9IHBhdXNhYmxlRmlsdGVyKGZpbHRlcik7XG4gIGNvbnN0IHN0b3AgPSB3YXRjaFdpdGhGaWx0ZXIoXG4gICAgc291cmNlLFxuICAgIGNiLFxuICAgIHtcbiAgICAgIC4uLndhdGNoT3B0aW9ucyxcbiAgICAgIGV2ZW50RmlsdGVyXG4gICAgfVxuICApO1xuICByZXR1cm4geyBzdG9wLCBwYXVzZSwgcmVzdW1lLCBpc0FjdGl2ZSB9O1xufVxuXG5mdW5jdGlvbiBzeW5jUmVmKGxlZnQsIHJpZ2h0LCAuLi5bb3B0aW9uc10pIHtcbiAgY29uc3Qge1xuICAgIGZsdXNoID0gXCJzeW5jXCIsXG4gICAgZGVlcCA9IGZhbHNlLFxuICAgIGltbWVkaWF0ZSA9IHRydWUsXG4gICAgZGlyZWN0aW9uID0gXCJib3RoXCIsXG4gICAgdHJhbnNmb3JtID0ge31cbiAgfSA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHdhdGNoZXJzID0gW107XG4gIGNvbnN0IHRyYW5zZm9ybUxUUiA9IFwibHRyXCIgaW4gdHJhbnNmb3JtICYmIHRyYW5zZm9ybS5sdHIgfHwgKCh2KSA9PiB2KTtcbiAgY29uc3QgdHJhbnNmb3JtUlRMID0gXCJydGxcIiBpbiB0cmFuc2Zvcm0gJiYgdHJhbnNmb3JtLnJ0bCB8fCAoKHYpID0+IHYpO1xuICBpZiAoZGlyZWN0aW9uID09PSBcImJvdGhcIiB8fCBkaXJlY3Rpb24gPT09IFwibHRyXCIpIHtcbiAgICB3YXRjaGVycy5wdXNoKHdhdGNoUGF1c2FibGUoXG4gICAgICBsZWZ0LFxuICAgICAgKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgIHdhdGNoZXJzLmZvckVhY2goKHcpID0+IHcucGF1c2UoKSk7XG4gICAgICAgIHJpZ2h0LnZhbHVlID0gdHJhbnNmb3JtTFRSKG5ld1ZhbHVlKTtcbiAgICAgICAgd2F0Y2hlcnMuZm9yRWFjaCgodykgPT4gdy5yZXN1bWUoKSk7XG4gICAgICB9LFxuICAgICAgeyBmbHVzaCwgZGVlcCwgaW1tZWRpYXRlIH1cbiAgICApKTtcbiAgfVxuICBpZiAoZGlyZWN0aW9uID09PSBcImJvdGhcIiB8fCBkaXJlY3Rpb24gPT09IFwicnRsXCIpIHtcbiAgICB3YXRjaGVycy5wdXNoKHdhdGNoUGF1c2FibGUoXG4gICAgICByaWdodCxcbiAgICAgIChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICB3YXRjaGVycy5mb3JFYWNoKCh3KSA9PiB3LnBhdXNlKCkpO1xuICAgICAgICBsZWZ0LnZhbHVlID0gdHJhbnNmb3JtUlRMKG5ld1ZhbHVlKTtcbiAgICAgICAgd2F0Y2hlcnMuZm9yRWFjaCgodykgPT4gdy5yZXN1bWUoKSk7XG4gICAgICB9LFxuICAgICAgeyBmbHVzaCwgZGVlcCwgaW1tZWRpYXRlIH1cbiAgICApKTtcbiAgfVxuICBjb25zdCBzdG9wID0gKCkgPT4ge1xuICAgIHdhdGNoZXJzLmZvckVhY2goKHcpID0+IHcuc3RvcCgpKTtcbiAgfTtcbiAgcmV0dXJuIHN0b3A7XG59XG5cbmZ1bmN0aW9uIHN5bmNSZWZzKHNvdXJjZSwgdGFyZ2V0cywgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBmbHVzaCA9IFwic3luY1wiLFxuICAgIGRlZXAgPSBmYWxzZSxcbiAgICBpbW1lZGlhdGUgPSB0cnVlXG4gIH0gPSBvcHRpb25zO1xuICBpZiAoIUFycmF5LmlzQXJyYXkodGFyZ2V0cykpXG4gICAgdGFyZ2V0cyA9IFt0YXJnZXRzXTtcbiAgcmV0dXJuIHdhdGNoKFxuICAgIHNvdXJjZSxcbiAgICAobmV3VmFsdWUpID0+IHRhcmdldHMuZm9yRWFjaCgodGFyZ2V0KSA9PiB0YXJnZXQudmFsdWUgPSBuZXdWYWx1ZSksXG4gICAgeyBmbHVzaCwgZGVlcCwgaW1tZWRpYXRlIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gdG9SZWZzKG9iamVjdFJlZiwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICghaXNSZWYob2JqZWN0UmVmKSlcbiAgICByZXR1cm4gdG9SZWZzJDEob2JqZWN0UmVmKTtcbiAgY29uc3QgcmVzdWx0ID0gQXJyYXkuaXNBcnJheShvYmplY3RSZWYudmFsdWUpID8gQXJyYXkuZnJvbSh7IGxlbmd0aDogb2JqZWN0UmVmLnZhbHVlLmxlbmd0aCB9KSA6IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3RSZWYudmFsdWUpIHtcbiAgICByZXN1bHRba2V5XSA9IGN1c3RvbVJlZigoKSA9PiAoe1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0UmVmLnZhbHVlW2tleV07XG4gICAgICB9LFxuICAgICAgc2V0KHYpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCByZXBsYWNlUmVmID0gKF9hID0gdG9WYWx1ZShvcHRpb25zLnJlcGxhY2VSZWYpKSAhPSBudWxsID8gX2EgOiB0cnVlO1xuICAgICAgICBpZiAocmVwbGFjZVJlZikge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdFJlZi52YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvcHkgPSBbLi4ub2JqZWN0UmVmLnZhbHVlXTtcbiAgICAgICAgICAgIGNvcHlba2V5XSA9IHY7XG4gICAgICAgICAgICBvYmplY3RSZWYudmFsdWUgPSBjb3B5O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBuZXdPYmplY3QgPSB7IC4uLm9iamVjdFJlZi52YWx1ZSwgW2tleV06IHYgfTtcbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdPYmplY3QsIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3RSZWYudmFsdWUpKTtcbiAgICAgICAgICAgIG9iamVjdFJlZi52YWx1ZSA9IG5ld09iamVjdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqZWN0UmVmLnZhbHVlW2tleV0gPSB2O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHRyeU9uQmVmb3JlTW91bnQoZm4sIHN5bmMgPSB0cnVlLCB0YXJnZXQpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBnZXRMaWZlQ3ljbGVUYXJnZXQodGFyZ2V0KTtcbiAgaWYgKGluc3RhbmNlKVxuICAgIG9uQmVmb3JlTW91bnQoZm4sIHRhcmdldCk7XG4gIGVsc2UgaWYgKHN5bmMpXG4gICAgZm4oKTtcbiAgZWxzZVxuICAgIG5leHRUaWNrKGZuKTtcbn1cblxuZnVuY3Rpb24gdHJ5T25CZWZvcmVVbm1vdW50KGZuLCB0YXJnZXQpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBnZXRMaWZlQ3ljbGVUYXJnZXQodGFyZ2V0KTtcbiAgaWYgKGluc3RhbmNlKVxuICAgIG9uQmVmb3JlVW5tb3VudChmbiwgdGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gdHJ5T25Nb3VudGVkKGZuLCBzeW5jID0gdHJ1ZSwgdGFyZ2V0KSB7XG4gIGNvbnN0IGluc3RhbmNlID0gZ2V0TGlmZUN5Y2xlVGFyZ2V0KCk7XG4gIGlmIChpbnN0YW5jZSlcbiAgICBvbk1vdW50ZWQoZm4sIHRhcmdldCk7XG4gIGVsc2UgaWYgKHN5bmMpXG4gICAgZm4oKTtcbiAgZWxzZVxuICAgIG5leHRUaWNrKGZuKTtcbn1cblxuZnVuY3Rpb24gdHJ5T25Vbm1vdW50ZWQoZm4sIHRhcmdldCkge1xuICBjb25zdCBpbnN0YW5jZSA9IGdldExpZmVDeWNsZVRhcmdldCh0YXJnZXQpO1xuICBpZiAoaW5zdGFuY2UpXG4gICAgb25Vbm1vdW50ZWQoZm4sIHRhcmdldCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVVudGlsKHIsIGlzTm90ID0gZmFsc2UpIHtcbiAgZnVuY3Rpb24gdG9NYXRjaChjb25kaXRpb24sIHsgZmx1c2ggPSBcInN5bmNcIiwgZGVlcCA9IGZhbHNlLCB0aW1lb3V0LCB0aHJvd09uVGltZW91dCB9ID0ge30pIHtcbiAgICBsZXQgc3RvcCA9IG51bGw7XG4gICAgY29uc3Qgd2F0Y2hlciA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBzdG9wID0gd2F0Y2goXG4gICAgICAgIHIsXG4gICAgICAgICh2KSA9PiB7XG4gICAgICAgICAgaWYgKGNvbmRpdGlvbih2KSAhPT0gaXNOb3QpIHtcbiAgICAgICAgICAgIHN0b3AgPT0gbnVsbCA/IHZvaWQgMCA6IHN0b3AoKTtcbiAgICAgICAgICAgIHJlc29sdmUodik7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgZmx1c2gsXG4gICAgICAgICAgZGVlcCxcbiAgICAgICAgICBpbW1lZGlhdGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBjb25zdCBwcm9taXNlcyA9IFt3YXRjaGVyXTtcbiAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XG4gICAgICBwcm9taXNlcy5wdXNoKFxuICAgICAgICBwcm9taXNlVGltZW91dCh0aW1lb3V0LCB0aHJvd09uVGltZW91dCkudGhlbigoKSA9PiB0b1ZhbHVlKHIpKS5maW5hbGx5KCgpID0+IHN0b3AgPT0gbnVsbCA/IHZvaWQgMCA6IHN0b3AoKSlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJhY2UocHJvbWlzZXMpO1xuICB9XG4gIGZ1bmN0aW9uIHRvQmUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIWlzUmVmKHZhbHVlKSlcbiAgICAgIHJldHVybiB0b01hdGNoKCh2KSA9PiB2ID09PSB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgY29uc3QgeyBmbHVzaCA9IFwic3luY1wiLCBkZWVwID0gZmFsc2UsIHRpbWVvdXQsIHRocm93T25UaW1lb3V0IH0gPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zIDoge307XG4gICAgbGV0IHN0b3AgPSBudWxsO1xuICAgIGNvbnN0IHdhdGNoZXIgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgc3RvcCA9IHdhdGNoKFxuICAgICAgICBbciwgdmFsdWVdLFxuICAgICAgICAoW3YxLCB2Ml0pID0+IHtcbiAgICAgICAgICBpZiAoaXNOb3QgIT09ICh2MSA9PT0gdjIpKSB7XG4gICAgICAgICAgICBzdG9wID09IG51bGwgPyB2b2lkIDAgOiBzdG9wKCk7XG4gICAgICAgICAgICByZXNvbHZlKHYxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBmbHVzaCxcbiAgICAgICAgICBkZWVwLFxuICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuICAgIGNvbnN0IHByb21pc2VzID0gW3dhdGNoZXJdO1xuICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgIHByb21pc2VUaW1lb3V0KHRpbWVvdXQsIHRocm93T25UaW1lb3V0KS50aGVuKCgpID0+IHRvVmFsdWUocikpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgIHN0b3AgPT0gbnVsbCA/IHZvaWQgMCA6IHN0b3AoKTtcbiAgICAgICAgICByZXR1cm4gdG9WYWx1ZShyKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJhY2UocHJvbWlzZXMpO1xuICB9XG4gIGZ1bmN0aW9uIHRvQmVUcnV0aHkob3B0aW9ucykge1xuICAgIHJldHVybiB0b01hdGNoKCh2KSA9PiBCb29sZWFuKHYpLCBvcHRpb25zKTtcbiAgfVxuICBmdW5jdGlvbiB0b0JlTnVsbChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRvQmUobnVsbCwgb3B0aW9ucyk7XG4gIH1cbiAgZnVuY3Rpb24gdG9CZVVuZGVmaW5lZChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRvQmUodm9pZCAwLCBvcHRpb25zKTtcbiAgfVxuICBmdW5jdGlvbiB0b0JlTmFOKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdG9NYXRjaChOdW1iZXIuaXNOYU4sIG9wdGlvbnMpO1xuICB9XG4gIGZ1bmN0aW9uIHRvQ29udGFpbnModmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdG9NYXRjaCgodikgPT4ge1xuICAgICAgY29uc3QgYXJyYXkgPSBBcnJheS5mcm9tKHYpO1xuICAgICAgcmV0dXJuIGFycmF5LmluY2x1ZGVzKHZhbHVlKSB8fCBhcnJheS5pbmNsdWRlcyh0b1ZhbHVlKHZhbHVlKSk7XG4gICAgfSwgb3B0aW9ucyk7XG4gIH1cbiAgZnVuY3Rpb24gY2hhbmdlZChvcHRpb25zKSB7XG4gICAgcmV0dXJuIGNoYW5nZWRUaW1lcygxLCBvcHRpb25zKTtcbiAgfVxuICBmdW5jdGlvbiBjaGFuZ2VkVGltZXMobiA9IDEsIG9wdGlvbnMpIHtcbiAgICBsZXQgY291bnQgPSAtMTtcbiAgICByZXR1cm4gdG9NYXRjaCgoKSA9PiB7XG4gICAgICBjb3VudCArPSAxO1xuICAgICAgcmV0dXJuIGNvdW50ID49IG47XG4gICAgfSwgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodG9WYWx1ZShyKSkpIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHtcbiAgICAgIHRvTWF0Y2gsXG4gICAgICB0b0NvbnRhaW5zLFxuICAgICAgY2hhbmdlZCxcbiAgICAgIGNoYW5nZWRUaW1lcyxcbiAgICAgIGdldCBub3QoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVVbnRpbChyLCAhaXNOb3QpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGluc3RhbmNlID0ge1xuICAgICAgdG9NYXRjaCxcbiAgICAgIHRvQmUsXG4gICAgICB0b0JlVHJ1dGh5LFxuICAgICAgdG9CZU51bGwsXG4gICAgICB0b0JlTmFOLFxuICAgICAgdG9CZVVuZGVmaW5lZCxcbiAgICAgIGNoYW5nZWQsXG4gICAgICBjaGFuZ2VkVGltZXMsXG4gICAgICBnZXQgbm90KCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlVW50aWwociwgIWlzTm90KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxufVxuZnVuY3Rpb24gdW50aWwocikge1xuICByZXR1cm4gY3JlYXRlVW50aWwocik7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDb21wYXJhdG9yKHZhbHVlLCBvdGhWYWwpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhWYWw7XG59XG5mdW5jdGlvbiB1c2VBcnJheURpZmZlcmVuY2UoLi4uYXJncykge1xuICB2YXIgX2E7XG4gIGNvbnN0IGxpc3QgPSBhcmdzWzBdO1xuICBjb25zdCB2YWx1ZXMgPSBhcmdzWzFdO1xuICBsZXQgY29tcGFyZUZuID0gKF9hID0gYXJnc1syXSkgIT0gbnVsbCA/IF9hIDogZGVmYXVsdENvbXBhcmF0b3I7XG4gIGlmICh0eXBlb2YgY29tcGFyZUZuID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3Qga2V5ID0gY29tcGFyZUZuO1xuICAgIGNvbXBhcmVGbiA9ICh2YWx1ZSwgb3RoVmFsKSA9PiB2YWx1ZVtrZXldID09PSBvdGhWYWxba2V5XTtcbiAgfVxuICByZXR1cm4gY29tcHV0ZWQoKCkgPT4gdG9WYWx1ZShsaXN0KS5maWx0ZXIoKHgpID0+IHRvVmFsdWUodmFsdWVzKS5maW5kSW5kZXgoKHkpID0+IGNvbXBhcmVGbih4LCB5KSkgPT09IC0xKSk7XG59XG5cbmZ1bmN0aW9uIHVzZUFycmF5RXZlcnkobGlzdCwgZm4pIHtcbiAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IHRvVmFsdWUobGlzdCkuZXZlcnkoKGVsZW1lbnQsIGluZGV4LCBhcnJheSkgPT4gZm4odG9WYWx1ZShlbGVtZW50KSwgaW5kZXgsIGFycmF5KSkpO1xufVxuXG5mdW5jdGlvbiB1c2VBcnJheUZpbHRlcihsaXN0LCBmbikge1xuICByZXR1cm4gY29tcHV0ZWQoKCkgPT4gdG9WYWx1ZShsaXN0KS5tYXAoKGkpID0+IHRvVmFsdWUoaSkpLmZpbHRlcihmbikpO1xufVxuXG5mdW5jdGlvbiB1c2VBcnJheUZpbmQobGlzdCwgZm4pIHtcbiAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IHRvVmFsdWUoXG4gICAgdG9WYWx1ZShsaXN0KS5maW5kKChlbGVtZW50LCBpbmRleCwgYXJyYXkpID0+IGZuKHRvVmFsdWUoZWxlbWVudCksIGluZGV4LCBhcnJheSkpXG4gICkpO1xufVxuXG5mdW5jdGlvbiB1c2VBcnJheUZpbmRJbmRleChsaXN0LCBmbikge1xuICByZXR1cm4gY29tcHV0ZWQoKCkgPT4gdG9WYWx1ZShsaXN0KS5maW5kSW5kZXgoKGVsZW1lbnQsIGluZGV4LCBhcnJheSkgPT4gZm4odG9WYWx1ZShlbGVtZW50KSwgaW5kZXgsIGFycmF5KSkpO1xufVxuXG5mdW5jdGlvbiBmaW5kTGFzdChhcnIsIGNiKSB7XG4gIGxldCBpbmRleCA9IGFyci5sZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tID4gMCkge1xuICAgIGlmIChjYihhcnJbaW5kZXhdLCBpbmRleCwgYXJyKSlcbiAgICAgIHJldHVybiBhcnJbaW5kZXhdO1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5mdW5jdGlvbiB1c2VBcnJheUZpbmRMYXN0KGxpc3QsIGZuKSB7XG4gIHJldHVybiBjb21wdXRlZCgoKSA9PiB0b1ZhbHVlKFxuICAgICFBcnJheS5wcm90b3R5cGUuZmluZExhc3QgPyBmaW5kTGFzdCh0b1ZhbHVlKGxpc3QpLCAoZWxlbWVudCwgaW5kZXgsIGFycmF5KSA9PiBmbih0b1ZhbHVlKGVsZW1lbnQpLCBpbmRleCwgYXJyYXkpKSA6IHRvVmFsdWUobGlzdCkuZmluZExhc3QoKGVsZW1lbnQsIGluZGV4LCBhcnJheSkgPT4gZm4odG9WYWx1ZShlbGVtZW50KSwgaW5kZXgsIGFycmF5KSlcbiAgKSk7XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlJbmNsdWRlc09wdGlvbnMob2JqKSB7XG4gIHJldHVybiBpc09iamVjdChvYmopICYmIGNvbnRhaW5zUHJvcChvYmosIFwiZm9ybUluZGV4XCIsIFwiY29tcGFyYXRvclwiKTtcbn1cbmZ1bmN0aW9uIHVzZUFycmF5SW5jbHVkZXMoLi4uYXJncykge1xuICB2YXIgX2E7XG4gIGNvbnN0IGxpc3QgPSBhcmdzWzBdO1xuICBjb25zdCB2YWx1ZSA9IGFyZ3NbMV07XG4gIGxldCBjb21wYXJhdG9yID0gYXJnc1syXTtcbiAgbGV0IGZvcm1JbmRleCA9IDA7XG4gIGlmIChpc0FycmF5SW5jbHVkZXNPcHRpb25zKGNvbXBhcmF0b3IpKSB7XG4gICAgZm9ybUluZGV4ID0gKF9hID0gY29tcGFyYXRvci5mcm9tSW5kZXgpICE9IG51bGwgPyBfYSA6IDA7XG4gICAgY29tcGFyYXRvciA9IGNvbXBhcmF0b3IuY29tcGFyYXRvcjtcbiAgfVxuICBpZiAodHlwZW9mIGNvbXBhcmF0b3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCBrZXkgPSBjb21wYXJhdG9yO1xuICAgIGNvbXBhcmF0b3IgPSAoZWxlbWVudCwgdmFsdWUyKSA9PiBlbGVtZW50W2tleV0gPT09IHRvVmFsdWUodmFsdWUyKTtcbiAgfVxuICBjb21wYXJhdG9yID0gY29tcGFyYXRvciAhPSBudWxsID8gY29tcGFyYXRvciA6IChlbGVtZW50LCB2YWx1ZTIpID0+IGVsZW1lbnQgPT09IHRvVmFsdWUodmFsdWUyKTtcbiAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IHRvVmFsdWUobGlzdCkuc2xpY2UoZm9ybUluZGV4KS5zb21lKChlbGVtZW50LCBpbmRleCwgYXJyYXkpID0+IGNvbXBhcmF0b3IoXG4gICAgdG9WYWx1ZShlbGVtZW50KSxcbiAgICB0b1ZhbHVlKHZhbHVlKSxcbiAgICBpbmRleCxcbiAgICB0b1ZhbHVlKGFycmF5KVxuICApKSk7XG59XG5cbmZ1bmN0aW9uIHVzZUFycmF5Sm9pbihsaXN0LCBzZXBhcmF0b3IpIHtcbiAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IHRvVmFsdWUobGlzdCkubWFwKChpKSA9PiB0b1ZhbHVlKGkpKS5qb2luKHRvVmFsdWUoc2VwYXJhdG9yKSkpO1xufVxuXG5mdW5jdGlvbiB1c2VBcnJheU1hcChsaXN0LCBmbikge1xuICByZXR1cm4gY29tcHV0ZWQoKCkgPT4gdG9WYWx1ZShsaXN0KS5tYXAoKGkpID0+IHRvVmFsdWUoaSkpLm1hcChmbikpO1xufVxuXG5mdW5jdGlvbiB1c2VBcnJheVJlZHVjZShsaXN0LCByZWR1Y2VyLCAuLi5hcmdzKSB7XG4gIGNvbnN0IHJlZHVjZUNhbGxiYWNrID0gKHN1bSwgdmFsdWUsIGluZGV4KSA9PiByZWR1Y2VyKHRvVmFsdWUoc3VtKSwgdG9WYWx1ZSh2YWx1ZSksIGluZGV4KTtcbiAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHRvVmFsdWUobGlzdCk7XG4gICAgcmV0dXJuIGFyZ3MubGVuZ3RoID8gcmVzb2x2ZWQucmVkdWNlKHJlZHVjZUNhbGxiYWNrLCB0b1ZhbHVlKGFyZ3NbMF0pKSA6IHJlc29sdmVkLnJlZHVjZShyZWR1Y2VDYWxsYmFjayk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VBcnJheVNvbWUobGlzdCwgZm4pIHtcbiAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IHRvVmFsdWUobGlzdCkuc29tZSgoZWxlbWVudCwgaW5kZXgsIGFycmF5KSA9PiBmbih0b1ZhbHVlKGVsZW1lbnQpLCBpbmRleCwgYXJyYXkpKSk7XG59XG5cbmZ1bmN0aW9uIHVuaXEoYXJyYXkpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChhcnJheSkpO1xufVxuZnVuY3Rpb24gdW5pcXVlRWxlbWVudHNCeShhcnJheSwgZm4pIHtcbiAgcmV0dXJuIGFycmF5LnJlZHVjZSgoYWNjLCB2KSA9PiB7XG4gICAgaWYgKCFhY2Muc29tZSgoeCkgPT4gZm4odiwgeCwgYXJyYXkpKSlcbiAgICAgIGFjYy5wdXNoKHYpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIFtdKTtcbn1cbmZ1bmN0aW9uIHVzZUFycmF5VW5pcXVlKGxpc3QsIGNvbXBhcmVGbikge1xuICByZXR1cm4gY29tcHV0ZWQoKCkgPT4ge1xuICAgIGNvbnN0IHJlc29sdmVkTGlzdCA9IHRvVmFsdWUobGlzdCkubWFwKChlbGVtZW50KSA9PiB0b1ZhbHVlKGVsZW1lbnQpKTtcbiAgICByZXR1cm4gY29tcGFyZUZuID8gdW5pcXVlRWxlbWVudHNCeShyZXNvbHZlZExpc3QsIGNvbXBhcmVGbikgOiB1bmlxKHJlc29sdmVkTGlzdCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VDb3VudGVyKGluaXRpYWxWYWx1ZSA9IDAsIG9wdGlvbnMgPSB7fSkge1xuICBsZXQgX2luaXRpYWxWYWx1ZSA9IHVucmVmKGluaXRpYWxWYWx1ZSk7XG4gIGNvbnN0IGNvdW50ID0gcmVmKGluaXRpYWxWYWx1ZSk7XG4gIGNvbnN0IHtcbiAgICBtYXggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgbWluID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpbmMgPSAoZGVsdGEgPSAxKSA9PiBjb3VudC52YWx1ZSA9IE1hdGgubWF4KE1hdGgubWluKG1heCwgY291bnQudmFsdWUgKyBkZWx0YSksIG1pbik7XG4gIGNvbnN0IGRlYyA9IChkZWx0YSA9IDEpID0+IGNvdW50LnZhbHVlID0gTWF0aC5taW4oTWF0aC5tYXgobWluLCBjb3VudC52YWx1ZSAtIGRlbHRhKSwgbWF4KTtcbiAgY29uc3QgZ2V0ID0gKCkgPT4gY291bnQudmFsdWU7XG4gIGNvbnN0IHNldCA9ICh2YWwpID0+IGNvdW50LnZhbHVlID0gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbCkpO1xuICBjb25zdCByZXNldCA9ICh2YWwgPSBfaW5pdGlhbFZhbHVlKSA9PiB7XG4gICAgX2luaXRpYWxWYWx1ZSA9IHZhbDtcbiAgICByZXR1cm4gc2V0KHZhbCk7XG4gIH07XG4gIHJldHVybiB7IGNvdW50LCBpbmMsIGRlYywgZ2V0LCBzZXQsIHJlc2V0IH07XG59XG5cbmNvbnN0IFJFR0VYX1BBUlNFID0gL14oXFxkezR9KVstL10/KFxcZHsxLDJ9KT9bLS9dPyhcXGR7MCwyfSlbVFxcc10qKFxcZHsxLDJ9KT86PyhcXGR7MSwyfSk/Oj8oXFxkezEsMn0pP1suOl0/KFxcZCspPyQvaTtcbmNvbnN0IFJFR0VYX0ZPUk1BVCA9IC9bWU1ESGhtc11vfFxcWyhbXlxcXV0rKVxcXXxZezEsNH18TXsxLDR9fER7MSwyfXxkezEsNH18SHsxLDJ9fGh7MSwyfXxhezEsMn18QXsxLDJ9fG17MSwyfXxzezEsMn18WnsxLDJ9fFNTUy9nO1xuZnVuY3Rpb24gZGVmYXVsdE1lcmlkaWVtKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyY2FzZSwgaGFzUGVyaW9kKSB7XG4gIGxldCBtID0gaG91cnMgPCAxMiA/IFwiQU1cIiA6IFwiUE1cIjtcbiAgaWYgKGhhc1BlcmlvZClcbiAgICBtID0gbS5zcGxpdChcIlwiKS5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjICs9IGAke2N1cnJ9LmAsIFwiXCIpO1xuICByZXR1cm4gaXNMb3dlcmNhc2UgPyBtLnRvTG93ZXJDYXNlKCkgOiBtO1xufVxuZnVuY3Rpb24gZm9ybWF0T3JkaW5hbChudW0pIHtcbiAgY29uc3Qgc3VmZml4ZXMgPSBbXCJ0aFwiLCBcInN0XCIsIFwibmRcIiwgXCJyZFwiXTtcbiAgY29uc3QgdiA9IG51bSAlIDEwMDtcbiAgcmV0dXJuIG51bSArIChzdWZmaXhlc1sodiAtIDIwKSAlIDEwXSB8fCBzdWZmaXhlc1t2XSB8fCBzdWZmaXhlc1swXSk7XG59XG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUsIGZvcm1hdFN0ciwgb3B0aW9ucyA9IHt9KSB7XG4gIHZhciBfYTtcbiAgY29uc3QgeWVhcnMgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gIGNvbnN0IG1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xuICBjb25zdCBkYXlzID0gZGF0ZS5nZXREYXRlKCk7XG4gIGNvbnN0IGhvdXJzID0gZGF0ZS5nZXRIb3VycygpO1xuICBjb25zdCBtaW51dGVzID0gZGF0ZS5nZXRNaW51dGVzKCk7XG4gIGNvbnN0IHNlY29uZHMgPSBkYXRlLmdldFNlY29uZHMoKTtcbiAgY29uc3QgbWlsbGlzZWNvbmRzID0gZGF0ZS5nZXRNaWxsaXNlY29uZHMoKTtcbiAgY29uc3QgZGF5ID0gZGF0ZS5nZXREYXkoKTtcbiAgY29uc3QgbWVyaWRpZW0gPSAoX2EgPSBvcHRpb25zLmN1c3RvbU1lcmlkaWVtKSAhPSBudWxsID8gX2EgOiBkZWZhdWx0TWVyaWRpZW07XG4gIGNvbnN0IG1hdGNoZXMgPSB7XG4gICAgWW86ICgpID0+IGZvcm1hdE9yZGluYWwoeWVhcnMpLFxuICAgIFlZOiAoKSA9PiBTdHJpbmcoeWVhcnMpLnNsaWNlKC0yKSxcbiAgICBZWVlZOiAoKSA9PiB5ZWFycyxcbiAgICBNOiAoKSA9PiBtb250aCArIDEsXG4gICAgTW86ICgpID0+IGZvcm1hdE9yZGluYWwobW9udGggKyAxKSxcbiAgICBNTTogKCkgPT4gYCR7bW9udGggKyAxfWAucGFkU3RhcnQoMiwgXCIwXCIpLFxuICAgIE1NTTogKCkgPT4gZGF0ZS50b0xvY2FsZURhdGVTdHJpbmcob3B0aW9ucy5sb2NhbGVzLCB7IG1vbnRoOiBcInNob3J0XCIgfSksXG4gICAgTU1NTTogKCkgPT4gZGF0ZS50b0xvY2FsZURhdGVTdHJpbmcob3B0aW9ucy5sb2NhbGVzLCB7IG1vbnRoOiBcImxvbmdcIiB9KSxcbiAgICBEOiAoKSA9PiBTdHJpbmcoZGF5cyksXG4gICAgRG86ICgpID0+IGZvcm1hdE9yZGluYWwoZGF5cyksXG4gICAgREQ6ICgpID0+IGAke2RheXN9YC5wYWRTdGFydCgyLCBcIjBcIiksXG4gICAgSDogKCkgPT4gU3RyaW5nKGhvdXJzKSxcbiAgICBIbzogKCkgPT4gZm9ybWF0T3JkaW5hbChob3VycyksXG4gICAgSEg6ICgpID0+IGAke2hvdXJzfWAucGFkU3RhcnQoMiwgXCIwXCIpLFxuICAgIGg6ICgpID0+IGAke2hvdXJzICUgMTIgfHwgMTJ9YC5wYWRTdGFydCgxLCBcIjBcIiksXG4gICAgaG86ICgpID0+IGZvcm1hdE9yZGluYWwoaG91cnMgJSAxMiB8fCAxMiksXG4gICAgaGg6ICgpID0+IGAke2hvdXJzICUgMTIgfHwgMTJ9YC5wYWRTdGFydCgyLCBcIjBcIiksXG4gICAgbTogKCkgPT4gU3RyaW5nKG1pbnV0ZXMpLFxuICAgIG1vOiAoKSA9PiBmb3JtYXRPcmRpbmFsKG1pbnV0ZXMpLFxuICAgIG1tOiAoKSA9PiBgJHttaW51dGVzfWAucGFkU3RhcnQoMiwgXCIwXCIpLFxuICAgIHM6ICgpID0+IFN0cmluZyhzZWNvbmRzKSxcbiAgICBzbzogKCkgPT4gZm9ybWF0T3JkaW5hbChzZWNvbmRzKSxcbiAgICBzczogKCkgPT4gYCR7c2Vjb25kc31gLnBhZFN0YXJ0KDIsIFwiMFwiKSxcbiAgICBTU1M6ICgpID0+IGAke21pbGxpc2Vjb25kc31gLnBhZFN0YXJ0KDMsIFwiMFwiKSxcbiAgICBkOiAoKSA9PiBkYXksXG4gICAgZGQ6ICgpID0+IGRhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKG9wdGlvbnMubG9jYWxlcywgeyB3ZWVrZGF5OiBcIm5hcnJvd1wiIH0pLFxuICAgIGRkZDogKCkgPT4gZGF0ZS50b0xvY2FsZURhdGVTdHJpbmcob3B0aW9ucy5sb2NhbGVzLCB7IHdlZWtkYXk6IFwic2hvcnRcIiB9KSxcbiAgICBkZGRkOiAoKSA9PiBkYXRlLnRvTG9jYWxlRGF0ZVN0cmluZyhvcHRpb25zLmxvY2FsZXMsIHsgd2Vla2RheTogXCJsb25nXCIgfSksXG4gICAgQTogKCkgPT4gbWVyaWRpZW0oaG91cnMsIG1pbnV0ZXMpLFxuICAgIEFBOiAoKSA9PiBtZXJpZGllbShob3VycywgbWludXRlcywgZmFsc2UsIHRydWUpLFxuICAgIGE6ICgpID0+IG1lcmlkaWVtKGhvdXJzLCBtaW51dGVzLCB0cnVlKSxcbiAgICBhYTogKCkgPT4gbWVyaWRpZW0oaG91cnMsIG1pbnV0ZXMsIHRydWUsIHRydWUpXG4gIH07XG4gIHJldHVybiBmb3JtYXRTdHIucmVwbGFjZShSRUdFWF9GT1JNQVQsIChtYXRjaCwgJDEpID0+IHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICByZXR1cm4gKF9iID0gJDEgIT0gbnVsbCA/ICQxIDogKF9hMiA9IG1hdGNoZXNbbWF0Y2hdKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNhbGwobWF0Y2hlcykpICE9IG51bGwgPyBfYiA6IG1hdGNoO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZURhdGUoZGF0ZSkge1xuICBpZiAoZGF0ZSA9PT0gbnVsbClcbiAgICByZXR1cm4gbmV3IERhdGUoTnVtYmVyLk5hTik7XG4gIGlmIChkYXRlID09PSB2b2lkIDApXG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICBpZiAoZGF0ZSBpbnN0YW5jZW9mIERhdGUpXG4gICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUpO1xuICBpZiAodHlwZW9mIGRhdGUgPT09IFwic3RyaW5nXCIgJiYgIS9aJC9pLnRlc3QoZGF0ZSkpIHtcbiAgICBjb25zdCBkID0gZGF0ZS5tYXRjaChSRUdFWF9QQVJTRSk7XG4gICAgaWYgKGQpIHtcbiAgICAgIGNvbnN0IG0gPSBkWzJdIC0gMSB8fCAwO1xuICAgICAgY29uc3QgbXMgPSAoZFs3XSB8fCBcIjBcIikuc3Vic3RyaW5nKDAsIDMpO1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKGRbMV0sIG0sIGRbM10gfHwgMSwgZFs0XSB8fCAwLCBkWzVdIHx8IDAsIGRbNl0gfHwgMCwgbXMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IERhdGUoZGF0ZSk7XG59XG5mdW5jdGlvbiB1c2VEYXRlRm9ybWF0KGRhdGUsIGZvcm1hdFN0ciA9IFwiSEg6bW06c3NcIiwgb3B0aW9ucyA9IHt9KSB7XG4gIHJldHVybiBjb21wdXRlZCgoKSA9PiBmb3JtYXREYXRlKG5vcm1hbGl6ZURhdGUodG9WYWx1ZShkYXRlKSksIHRvVmFsdWUoZm9ybWF0U3RyKSwgb3B0aW9ucykpO1xufVxuXG5mdW5jdGlvbiB1c2VJbnRlcnZhbEZuKGNiLCBpbnRlcnZhbCA9IDFlMywgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBpbW1lZGlhdGUgPSB0cnVlLFxuICAgIGltbWVkaWF0ZUNhbGxiYWNrID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGxldCB0aW1lciA9IG51bGw7XG4gIGNvbnN0IGlzQWN0aXZlID0gcmVmKGZhbHNlKTtcbiAgZnVuY3Rpb24gY2xlYW4oKSB7XG4gICAgaWYgKHRpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgICAgIHRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgaXNBY3RpdmUudmFsdWUgPSBmYWxzZTtcbiAgICBjbGVhbigpO1xuICB9XG4gIGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICBjb25zdCBpbnRlcnZhbFZhbHVlID0gdG9WYWx1ZShpbnRlcnZhbCk7XG4gICAgaWYgKGludGVydmFsVmFsdWUgPD0gMClcbiAgICAgIHJldHVybjtcbiAgICBpc0FjdGl2ZS52YWx1ZSA9IHRydWU7XG4gICAgaWYgKGltbWVkaWF0ZUNhbGxiYWNrKVxuICAgICAgY2IoKTtcbiAgICBjbGVhbigpO1xuICAgIHRpbWVyID0gc2V0SW50ZXJ2YWwoY2IsIGludGVydmFsVmFsdWUpO1xuICB9XG4gIGlmIChpbW1lZGlhdGUgJiYgaXNDbGllbnQpXG4gICAgcmVzdW1lKCk7XG4gIGlmIChpc1JlZihpbnRlcnZhbCkgfHwgdHlwZW9mIGludGVydmFsID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zdCBzdG9wV2F0Y2ggPSB3YXRjaChpbnRlcnZhbCwgKCkgPT4ge1xuICAgICAgaWYgKGlzQWN0aXZlLnZhbHVlICYmIGlzQ2xpZW50KVxuICAgICAgICByZXN1bWUoKTtcbiAgICB9KTtcbiAgICB0cnlPblNjb3BlRGlzcG9zZShzdG9wV2F0Y2gpO1xuICB9XG4gIHRyeU9uU2NvcGVEaXNwb3NlKHBhdXNlKTtcbiAgcmV0dXJuIHtcbiAgICBpc0FjdGl2ZSxcbiAgICBwYXVzZSxcbiAgICByZXN1bWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlSW50ZXJ2YWwoaW50ZXJ2YWwgPSAxZTMsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgY29udHJvbHM6IGV4cG9zZUNvbnRyb2xzID0gZmFsc2UsXG4gICAgaW1tZWRpYXRlID0gdHJ1ZSxcbiAgICBjYWxsYmFja1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgY291bnRlciA9IHJlZigwKTtcbiAgY29uc3QgdXBkYXRlID0gKCkgPT4gY291bnRlci52YWx1ZSArPSAxO1xuICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICBjb3VudGVyLnZhbHVlID0gMDtcbiAgfTtcbiAgY29uc3QgY29udHJvbHMgPSB1c2VJbnRlcnZhbEZuKFxuICAgIGNhbGxiYWNrID8gKCkgPT4ge1xuICAgICAgdXBkYXRlKCk7XG4gICAgICBjYWxsYmFjayhjb3VudGVyLnZhbHVlKTtcbiAgICB9IDogdXBkYXRlLFxuICAgIGludGVydmFsLFxuICAgIHsgaW1tZWRpYXRlIH1cbiAgKTtcbiAgaWYgKGV4cG9zZUNvbnRyb2xzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvdW50ZXIsXG4gICAgICByZXNldCxcbiAgICAgIC4uLmNvbnRyb2xzXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VMYXN0Q2hhbmdlZChzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IG1zID0gcmVmKChfYSA9IG9wdGlvbnMuaW5pdGlhbFZhbHVlKSAhPSBudWxsID8gX2EgOiBudWxsKTtcbiAgd2F0Y2goXG4gICAgc291cmNlLFxuICAgICgpID0+IG1zLnZhbHVlID0gdGltZXN0YW1wKCksXG4gICAgb3B0aW9uc1xuICApO1xuICByZXR1cm4gbXM7XG59XG5cbmZ1bmN0aW9uIHVzZVRpbWVvdXRGbihjYiwgaW50ZXJ2YWwsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgaW1tZWRpYXRlID0gdHJ1ZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgaXNQZW5kaW5nID0gcmVmKGZhbHNlKTtcbiAgbGV0IHRpbWVyID0gbnVsbDtcbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgaWYgKHRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgdGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzdG9wKCkge1xuICAgIGlzUGVuZGluZy52YWx1ZSA9IGZhbHNlO1xuICAgIGNsZWFyKCk7XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnQoLi4uYXJncykge1xuICAgIGNsZWFyKCk7XG4gICAgaXNQZW5kaW5nLnZhbHVlID0gdHJ1ZTtcbiAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaXNQZW5kaW5nLnZhbHVlID0gZmFsc2U7XG4gICAgICB0aW1lciA9IG51bGw7XG4gICAgICBjYiguLi5hcmdzKTtcbiAgICB9LCB0b1ZhbHVlKGludGVydmFsKSk7XG4gIH1cbiAgaWYgKGltbWVkaWF0ZSkge1xuICAgIGlzUGVuZGluZy52YWx1ZSA9IHRydWU7XG4gICAgaWYgKGlzQ2xpZW50KVxuICAgICAgc3RhcnQoKTtcbiAgfVxuICB0cnlPblNjb3BlRGlzcG9zZShzdG9wKTtcbiAgcmV0dXJuIHtcbiAgICBpc1BlbmRpbmc6IHJlYWRvbmx5KGlzUGVuZGluZyksXG4gICAgc3RhcnQsXG4gICAgc3RvcFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VUaW1lb3V0KGludGVydmFsID0gMWUzLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGNvbnRyb2xzOiBleHBvc2VDb250cm9scyA9IGZhbHNlLFxuICAgIGNhbGxiYWNrXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBjb250cm9scyA9IHVzZVRpbWVvdXRGbihcbiAgICBjYWxsYmFjayAhPSBudWxsID8gY2FsbGJhY2sgOiBub29wLFxuICAgIGludGVydmFsLFxuICAgIG9wdGlvbnNcbiAgKTtcbiAgY29uc3QgcmVhZHkgPSBjb21wdXRlZCgoKSA9PiAhY29udHJvbHMuaXNQZW5kaW5nLnZhbHVlKTtcbiAgaWYgKGV4cG9zZUNvbnRyb2xzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlYWR5LFxuICAgICAgLi4uY29udHJvbHNcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZWFkeTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VUb051bWJlcih2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBtZXRob2QgPSBcInBhcnNlRmxvYXRcIixcbiAgICByYWRpeCxcbiAgICBuYW5Ub1plcm9cbiAgfSA9IG9wdGlvbnM7XG4gIHJldHVybiBjb21wdXRlZCgoKSA9PiB7XG4gICAgbGV0IHJlc29sdmVkID0gdG9WYWx1ZSh2YWx1ZSk7XG4gICAgaWYgKHR5cGVvZiByZXNvbHZlZCA9PT0gXCJzdHJpbmdcIilcbiAgICAgIHJlc29sdmVkID0gTnVtYmVyW21ldGhvZF0ocmVzb2x2ZWQsIHJhZGl4KTtcbiAgICBpZiAobmFuVG9aZXJvICYmIE51bWJlci5pc05hTihyZXNvbHZlZCkpXG4gICAgICByZXNvbHZlZCA9IDA7XG4gICAgcmV0dXJuIHJlc29sdmVkO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IGAke3RvVmFsdWUodmFsdWUpfWApO1xufVxuXG5mdW5jdGlvbiB1c2VUb2dnbGUoaW5pdGlhbFZhbHVlID0gZmFsc2UsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgdHJ1dGh5VmFsdWUgPSB0cnVlLFxuICAgIGZhbHN5VmFsdWUgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgdmFsdWVJc1JlZiA9IGlzUmVmKGluaXRpYWxWYWx1ZSk7XG4gIGNvbnN0IF92YWx1ZSA9IHJlZihpbml0aWFsVmFsdWUpO1xuICBmdW5jdGlvbiB0b2dnbGUodmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgX3ZhbHVlLnZhbHVlID0gdmFsdWU7XG4gICAgICByZXR1cm4gX3ZhbHVlLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0cnV0aHkgPSB0b1ZhbHVlKHRydXRoeVZhbHVlKTtcbiAgICAgIF92YWx1ZS52YWx1ZSA9IF92YWx1ZS52YWx1ZSA9PT0gdHJ1dGh5ID8gdG9WYWx1ZShmYWxzeVZhbHVlKSA6IHRydXRoeTtcbiAgICAgIHJldHVybiBfdmFsdWUudmFsdWU7XG4gICAgfVxuICB9XG4gIGlmICh2YWx1ZUlzUmVmKVxuICAgIHJldHVybiB0b2dnbGU7XG4gIGVsc2VcbiAgICByZXR1cm4gW192YWx1ZSwgdG9nZ2xlXTtcbn1cblxuZnVuY3Rpb24gd2F0Y2hBcnJheShzb3VyY2UsIGNiLCBvcHRpb25zKSB7XG4gIGxldCBvbGRMaXN0ID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaW1tZWRpYXRlKSA/IFtdIDogWy4uLnNvdXJjZSBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gc291cmNlKCkgOiBBcnJheS5pc0FycmF5KHNvdXJjZSkgPyBzb3VyY2UgOiB0b1ZhbHVlKHNvdXJjZSldO1xuICByZXR1cm4gd2F0Y2goc291cmNlLCAobmV3TGlzdCwgXywgb25DbGVhbnVwKSA9PiB7XG4gICAgY29uc3Qgb2xkTGlzdFJlbWFpbnMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBvbGRMaXN0Lmxlbmd0aCB9KTtcbiAgICBjb25zdCBhZGRlZCA9IFtdO1xuICAgIGZvciAoY29uc3Qgb2JqIG9mIG5ld0xpc3QpIHtcbiAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvbGRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghb2xkTGlzdFJlbWFpbnNbaV0gJiYgb2JqID09PSBvbGRMaXN0W2ldKSB7XG4gICAgICAgICAgb2xkTGlzdFJlbWFpbnNbaV0gPSB0cnVlO1xuICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgYWRkZWQucHVzaChvYmopO1xuICAgIH1cbiAgICBjb25zdCByZW1vdmVkID0gb2xkTGlzdC5maWx0ZXIoKF8yLCBpKSA9PiAhb2xkTGlzdFJlbWFpbnNbaV0pO1xuICAgIGNiKG5ld0xpc3QsIG9sZExpc3QsIGFkZGVkLCByZW1vdmVkLCBvbkNsZWFudXApO1xuICAgIG9sZExpc3QgPSBbLi4ubmV3TGlzdF07XG4gIH0sIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiB3YXRjaEF0TW9zdChzb3VyY2UsIGNiLCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBjb3VudCxcbiAgICAuLi53YXRjaE9wdGlvbnNcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGN1cnJlbnQgPSByZWYoMCk7XG4gIGNvbnN0IHN0b3AgPSB3YXRjaFdpdGhGaWx0ZXIoXG4gICAgc291cmNlLFxuICAgICguLi5hcmdzKSA9PiB7XG4gICAgICBjdXJyZW50LnZhbHVlICs9IDE7XG4gICAgICBpZiAoY3VycmVudC52YWx1ZSA+PSB0b1ZhbHVlKGNvdW50KSlcbiAgICAgICAgbmV4dFRpY2soKCkgPT4gc3RvcCgpKTtcbiAgICAgIGNiKC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgd2F0Y2hPcHRpb25zXG4gICk7XG4gIHJldHVybiB7IGNvdW50OiBjdXJyZW50LCBzdG9wIH07XG59XG5cbmZ1bmN0aW9uIHdhdGNoRGVib3VuY2VkKHNvdXJjZSwgY2IsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgZGVib3VuY2UgPSAwLFxuICAgIG1heFdhaXQgPSB2b2lkIDAsXG4gICAgLi4ud2F0Y2hPcHRpb25zXG4gIH0gPSBvcHRpb25zO1xuICByZXR1cm4gd2F0Y2hXaXRoRmlsdGVyKFxuICAgIHNvdXJjZSxcbiAgICBjYixcbiAgICB7XG4gICAgICAuLi53YXRjaE9wdGlvbnMsXG4gICAgICBldmVudEZpbHRlcjogZGVib3VuY2VGaWx0ZXIoZGVib3VuY2UsIHsgbWF4V2FpdCB9KVxuICAgIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gd2F0Y2hEZWVwKHNvdXJjZSwgY2IsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHdhdGNoKFxuICAgIHNvdXJjZSxcbiAgICBjYixcbiAgICB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgZGVlcDogdHJ1ZVxuICAgIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gd2F0Y2hJZ25vcmFibGUoc291cmNlLCBjYiwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBldmVudEZpbHRlciA9IGJ5cGFzc0ZpbHRlcixcbiAgICAuLi53YXRjaE9wdGlvbnNcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGZpbHRlcmVkQ2IgPSBjcmVhdGVGaWx0ZXJXcmFwcGVyKFxuICAgIGV2ZW50RmlsdGVyLFxuICAgIGNiXG4gICk7XG4gIGxldCBpZ25vcmVVcGRhdGVzO1xuICBsZXQgaWdub3JlUHJldkFzeW5jVXBkYXRlcztcbiAgbGV0IHN0b3A7XG4gIGlmICh3YXRjaE9wdGlvbnMuZmx1c2ggPT09IFwic3luY1wiKSB7XG4gICAgY29uc3QgaWdub3JlID0gcmVmKGZhbHNlKTtcbiAgICBpZ25vcmVQcmV2QXN5bmNVcGRhdGVzID0gKCkgPT4ge1xuICAgIH07XG4gICAgaWdub3JlVXBkYXRlcyA9ICh1cGRhdGVyKSA9PiB7XG4gICAgICBpZ25vcmUudmFsdWUgPSB0cnVlO1xuICAgICAgdXBkYXRlcigpO1xuICAgICAgaWdub3JlLnZhbHVlID0gZmFsc2U7XG4gICAgfTtcbiAgICBzdG9wID0gd2F0Y2goXG4gICAgICBzb3VyY2UsXG4gICAgICAoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAoIWlnbm9yZS52YWx1ZSlcbiAgICAgICAgICBmaWx0ZXJlZENiKC4uLmFyZ3MpO1xuICAgICAgfSxcbiAgICAgIHdhdGNoT3B0aW9uc1xuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZGlzcG9zYWJsZXMgPSBbXTtcbiAgICBjb25zdCBpZ25vcmVDb3VudGVyID0gcmVmKDApO1xuICAgIGNvbnN0IHN5bmNDb3VudGVyID0gcmVmKDApO1xuICAgIGlnbm9yZVByZXZBc3luY1VwZGF0ZXMgPSAoKSA9PiB7XG4gICAgICBpZ25vcmVDb3VudGVyLnZhbHVlID0gc3luY0NvdW50ZXIudmFsdWU7XG4gICAgfTtcbiAgICBkaXNwb3NhYmxlcy5wdXNoKFxuICAgICAgd2F0Y2goXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHN5bmNDb3VudGVyLnZhbHVlKys7XG4gICAgICAgIH0sXG4gICAgICAgIHsgLi4ud2F0Y2hPcHRpb25zLCBmbHVzaDogXCJzeW5jXCIgfVxuICAgICAgKVxuICAgICk7XG4gICAgaWdub3JlVXBkYXRlcyA9ICh1cGRhdGVyKSA9PiB7XG4gICAgICBjb25zdCBzeW5jQ291bnRlclByZXYgPSBzeW5jQ291bnRlci52YWx1ZTtcbiAgICAgIHVwZGF0ZXIoKTtcbiAgICAgIGlnbm9yZUNvdW50ZXIudmFsdWUgKz0gc3luY0NvdW50ZXIudmFsdWUgLSBzeW5jQ291bnRlclByZXY7XG4gICAgfTtcbiAgICBkaXNwb3NhYmxlcy5wdXNoKFxuICAgICAgd2F0Y2goXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICBjb25zdCBpZ25vcmUgPSBpZ25vcmVDb3VudGVyLnZhbHVlID4gMCAmJiBpZ25vcmVDb3VudGVyLnZhbHVlID09PSBzeW5jQ291bnRlci52YWx1ZTtcbiAgICAgICAgICBpZ25vcmVDb3VudGVyLnZhbHVlID0gMDtcbiAgICAgICAgICBzeW5jQ291bnRlci52YWx1ZSA9IDA7XG4gICAgICAgICAgaWYgKGlnbm9yZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBmaWx0ZXJlZENiKC4uLmFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICB3YXRjaE9wdGlvbnNcbiAgICAgIClcbiAgICApO1xuICAgIHN0b3AgPSAoKSA9PiB7XG4gICAgICBkaXNwb3NhYmxlcy5mb3JFYWNoKChmbikgPT4gZm4oKSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4geyBzdG9wLCBpZ25vcmVVcGRhdGVzLCBpZ25vcmVQcmV2QXN5bmNVcGRhdGVzIH07XG59XG5cbmZ1bmN0aW9uIHdhdGNoSW1tZWRpYXRlKHNvdXJjZSwgY2IsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHdhdGNoKFxuICAgIHNvdXJjZSxcbiAgICBjYixcbiAgICB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaW1tZWRpYXRlOiB0cnVlXG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiB3YXRjaE9uY2Uoc291cmNlLCBjYiwgb3B0aW9ucykge1xuICBjb25zdCBzdG9wID0gd2F0Y2goc291cmNlLCAoLi4uYXJncykgPT4ge1xuICAgIG5leHRUaWNrKCgpID0+IHN0b3AoKSk7XG4gICAgcmV0dXJuIGNiKC4uLmFyZ3MpO1xuICB9LCBvcHRpb25zKTtcbiAgcmV0dXJuIHN0b3A7XG59XG5cbmZ1bmN0aW9uIHdhdGNoVGhyb3R0bGVkKHNvdXJjZSwgY2IsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgdGhyb3R0bGUgPSAwLFxuICAgIHRyYWlsaW5nID0gdHJ1ZSxcbiAgICBsZWFkaW5nID0gdHJ1ZSxcbiAgICAuLi53YXRjaE9wdGlvbnNcbiAgfSA9IG9wdGlvbnM7XG4gIHJldHVybiB3YXRjaFdpdGhGaWx0ZXIoXG4gICAgc291cmNlLFxuICAgIGNiLFxuICAgIHtcbiAgICAgIC4uLndhdGNoT3B0aW9ucyxcbiAgICAgIGV2ZW50RmlsdGVyOiB0aHJvdHRsZUZpbHRlcih0aHJvdHRsZSwgdHJhaWxpbmcsIGxlYWRpbmcpXG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiB3YXRjaFRyaWdnZXJhYmxlKHNvdXJjZSwgY2IsIG9wdGlvbnMgPSB7fSkge1xuICBsZXQgY2xlYW51cEZuO1xuICBmdW5jdGlvbiBvbkVmZmVjdCgpIHtcbiAgICBpZiAoIWNsZWFudXBGbilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBmbiA9IGNsZWFudXBGbjtcbiAgICBjbGVhbnVwRm4gPSB2b2lkIDA7XG4gICAgZm4oKTtcbiAgfVxuICBmdW5jdGlvbiBvbkNsZWFudXAoY2FsbGJhY2spIHtcbiAgICBjbGVhbnVwRm4gPSBjYWxsYmFjaztcbiAgfVxuICBjb25zdCBfY2IgPSAodmFsdWUsIG9sZFZhbHVlKSA9PiB7XG4gICAgb25FZmZlY3QoKTtcbiAgICByZXR1cm4gY2IodmFsdWUsIG9sZFZhbHVlLCBvbkNsZWFudXApO1xuICB9O1xuICBjb25zdCByZXMgPSB3YXRjaElnbm9yYWJsZShzb3VyY2UsIF9jYiwgb3B0aW9ucyk7XG4gIGNvbnN0IHsgaWdub3JlVXBkYXRlcyB9ID0gcmVzO1xuICBjb25zdCB0cmlnZ2VyID0gKCkgPT4ge1xuICAgIGxldCByZXMyO1xuICAgIGlnbm9yZVVwZGF0ZXMoKCkgPT4ge1xuICAgICAgcmVzMiA9IF9jYihnZXRXYXRjaFNvdXJjZXMoc291cmNlKSwgZ2V0T2xkVmFsdWUoc291cmNlKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlczI7XG4gIH07XG4gIHJldHVybiB7XG4gICAgLi4ucmVzLFxuICAgIHRyaWdnZXJcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFdhdGNoU291cmNlcyhzb3VyY2VzKSB7XG4gIGlmIChpc1JlYWN0aXZlKHNvdXJjZXMpKVxuICAgIHJldHVybiBzb3VyY2VzO1xuICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2VzKSlcbiAgICByZXR1cm4gc291cmNlcy5tYXAoKGl0ZW0pID0+IHRvVmFsdWUoaXRlbSkpO1xuICByZXR1cm4gdG9WYWx1ZShzb3VyY2VzKTtcbn1cbmZ1bmN0aW9uIGdldE9sZFZhbHVlKHNvdXJjZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShzb3VyY2UpID8gc291cmNlLm1hcCgoKSA9PiB2b2lkIDApIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiB3aGVuZXZlcihzb3VyY2UsIGNiLCBvcHRpb25zKSB7XG4gIGNvbnN0IHN0b3AgPSB3YXRjaChcbiAgICBzb3VyY2UsXG4gICAgKHYsIG92LCBvbkludmFsaWRhdGUpID0+IHtcbiAgICAgIGlmICh2KSB7XG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm9uY2UpXG4gICAgICAgICAgbmV4dFRpY2soKCkgPT4gc3RvcCgpKTtcbiAgICAgICAgY2Iodiwgb3YsIG9uSW52YWxpZGF0ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgb25jZTogZmFsc2VcbiAgICB9XG4gICk7XG4gIHJldHVybiBzdG9wO1xufVxuXG5leHBvcnQgeyBhc3NlcnQsIHJlZkF1dG9SZXNldCBhcyBhdXRvUmVzZXRSZWYsIGJ5cGFzc0ZpbHRlciwgY2FtZWxpemUsIGNsYW1wLCBjb21wdXRlZEVhZ2VyLCBjb21wdXRlZFdpdGhDb250cm9sLCBjb250YWluc1Byb3AsIGNvbXB1dGVkV2l0aENvbnRyb2wgYXMgY29udHJvbGxlZENvbXB1dGVkLCBjb250cm9sbGVkUmVmLCBjcmVhdGVFdmVudEhvb2ssIGNyZWF0ZUZpbHRlcldyYXBwZXIsIGNyZWF0ZUdsb2JhbFN0YXRlLCBjcmVhdGVJbmplY3Rpb25TdGF0ZSwgcmVhY3RpZnkgYXMgY3JlYXRlUmVhY3RpdmVGbiwgY3JlYXRlU2hhcmVkQ29tcG9zYWJsZSwgY3JlYXRlU2luZ2xldG9uUHJvbWlzZSwgZGVib3VuY2VGaWx0ZXIsIHJlZkRlYm91bmNlZCBhcyBkZWJvdW5jZWRSZWYsIHdhdGNoRGVib3VuY2VkIGFzIGRlYm91bmNlZFdhdGNoLCBkaXJlY3RpdmVIb29rcywgY29tcHV0ZWRFYWdlciBhcyBlYWdlckNvbXB1dGVkLCBleHRlbmRSZWYsIGZvcm1hdERhdGUsIGdldCwgZ2V0TGlmZUN5Y2xlVGFyZ2V0LCBoYXNPd24sIGh5cGhlbmF0ZSwgaWRlbnRpdHksIHdhdGNoSWdub3JhYmxlIGFzIGlnbm9yYWJsZVdhdGNoLCBpbmNyZWFzZVdpdGhVbml0LCBpbmplY3RMb2NhbCwgaW52b2tlLCBpc0NsaWVudCwgaXNEZWYsIGlzRGVmaW5lZCwgaXNJT1MsIGlzT2JqZWN0LCBpc1dvcmtlciwgbWFrZURlc3RydWN0dXJhYmxlLCBub29wLCBub3JtYWxpemVEYXRlLCBub3ROdWxsaXNoLCBub3csIG9iamVjdEVudHJpZXMsIG9iamVjdE9taXQsIG9iamVjdFBpY2ssIHBhdXNhYmxlRmlsdGVyLCB3YXRjaFBhdXNhYmxlIGFzIHBhdXNhYmxlV2F0Y2gsIHByb21pc2VUaW1lb3V0LCBwcm92aWRlTG9jYWwsIHJhbmQsIHJlYWN0aWZ5LCByZWFjdGlmeU9iamVjdCwgcmVhY3RpdmVDb21wdXRlZCwgcmVhY3RpdmVPbWl0LCByZWFjdGl2ZVBpY2ssIHJlZkF1dG9SZXNldCwgcmVmRGVib3VuY2VkLCByZWZEZWZhdWx0LCByZWZUaHJvdHRsZWQsIHJlZldpdGhDb250cm9sLCByZXNvbHZlUmVmLCByZXNvbHZlVW5yZWYsIHNldCwgc3luY1JlZiwgc3luY1JlZnMsIHRocm90dGxlRmlsdGVyLCByZWZUaHJvdHRsZWQgYXMgdGhyb3R0bGVkUmVmLCB3YXRjaFRocm90dGxlZCBhcyB0aHJvdHRsZWRXYXRjaCwgdGltZXN0YW1wLCB0b1JlYWN0aXZlLCB0b1JlZiwgdG9SZWZzLCB0b1ZhbHVlLCB0cnlPbkJlZm9yZU1vdW50LCB0cnlPbkJlZm9yZVVubW91bnQsIHRyeU9uTW91bnRlZCwgdHJ5T25TY29wZURpc3Bvc2UsIHRyeU9uVW5tb3VudGVkLCB1bnRpbCwgdXNlQXJyYXlEaWZmZXJlbmNlLCB1c2VBcnJheUV2ZXJ5LCB1c2VBcnJheUZpbHRlciwgdXNlQXJyYXlGaW5kLCB1c2VBcnJheUZpbmRJbmRleCwgdXNlQXJyYXlGaW5kTGFzdCwgdXNlQXJyYXlJbmNsdWRlcywgdXNlQXJyYXlKb2luLCB1c2VBcnJheU1hcCwgdXNlQXJyYXlSZWR1Y2UsIHVzZUFycmF5U29tZSwgdXNlQXJyYXlVbmlxdWUsIHVzZUNvdW50ZXIsIHVzZURhdGVGb3JtYXQsIHJlZkRlYm91bmNlZCBhcyB1c2VEZWJvdW5jZSwgdXNlRGVib3VuY2VGbiwgdXNlSW50ZXJ2YWwsIHVzZUludGVydmFsRm4sIHVzZUxhc3RDaGFuZ2VkLCByZWZUaHJvdHRsZWQgYXMgdXNlVGhyb3R0bGUsIHVzZVRocm90dGxlRm4sIHVzZVRpbWVvdXQsIHVzZVRpbWVvdXRGbiwgdXNlVG9OdW1iZXIsIHVzZVRvU3RyaW5nLCB1c2VUb2dnbGUsIHdhdGNoQXJyYXksIHdhdGNoQXRNb3N0LCB3YXRjaERlYm91bmNlZCwgd2F0Y2hEZWVwLCB3YXRjaElnbm9yYWJsZSwgd2F0Y2hJbW1lZGlhdGUsIHdhdGNoT25jZSwgd2F0Y2hQYXVzYWJsZSwgd2F0Y2hUaHJvdHRsZWQsIHdhdGNoVHJpZ2dlcmFibGUsIHdhdGNoV2l0aEZpbHRlciwgd2hlbmV2ZXIgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9oZWxwZXJzL2J1bmRsZS11cmwnKS5nZXRCdW5kbGVVUkwoJ2NlU2RkJykgKyBcImljb24uNTIwYTBhYzUucG5nXCIgKyBcIj9cIiArIERhdGUubm93KCk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBidW5kbGVVUkwgPSB7fTtcbmZ1bmN0aW9uIGdldEJ1bmRsZVVSTENhY2hlZChpZCkge1xuICB2YXIgdmFsdWUgPSBidW5kbGVVUkxbaWRdO1xuICBpZiAoIXZhbHVlKSB7XG4gICAgdmFsdWUgPSBnZXRCdW5kbGVVUkwoKTtcbiAgICBidW5kbGVVUkxbaWRdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0QnVuZGxlVVJMKCkge1xuICB0cnkge1xuICAgIHRocm93IG5ldyBFcnJvcigpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB2YXIgbWF0Y2hlcyA9ICgnJyArIGVyci5zdGFjaykubWF0Y2goLyhodHRwcz98ZmlsZXxmdHB8KGNocm9tZXxtb3p8c2FmYXJpLXdlYiktZXh0ZW5zaW9uKTpcXC9cXC9bXilcXG5dKy9nKTtcbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgLy8gVGhlIGZpcnN0IHR3byBzdGFjayBmcmFtZXMgd2lsbCBiZSB0aGlzIGZ1bmN0aW9uIGFuZCBnZXRCdW5kbGVVUkxDYWNoZWQuXG4gICAgICAvLyBVc2UgdGhlIDNyZCBvbmUsIHdoaWNoIHdpbGwgYmUgYSBydW50aW1lIGluIHRoZSBvcmlnaW5hbCBidW5kbGUuXG4gICAgICByZXR1cm4gZ2V0QmFzZVVSTChtYXRjaGVzWzJdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcvJztcbn1cbmZ1bmN0aW9uIGdldEJhc2VVUkwodXJsKSB7XG4gIHJldHVybiAoJycgKyB1cmwpLnJlcGxhY2UoL14oKD86aHR0cHM/fGZpbGV8ZnRwfChjaHJvbWV8bW96fHNhZmFyaS13ZWIpLWV4dGVuc2lvbik6XFwvXFwvLispXFwvW14vXSskLywgJyQxJykgKyAnLyc7XG59XG5cbi8vIFRPRE86IFJlcGxhY2UgdXNlcyB3aXRoIGBuZXcgVVJMKHVybCkub3JpZ2luYCB3aGVuIGllMTEgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC5cbmZ1bmN0aW9uIGdldE9yaWdpbih1cmwpIHtcbiAgdmFyIG1hdGNoZXMgPSAoJycgKyB1cmwpLm1hdGNoKC8oaHR0cHM/fGZpbGV8ZnRwfChjaHJvbWV8bW96fHNhZmFyaS13ZWIpLWV4dGVuc2lvbik6XFwvXFwvW14vXSsvKTtcbiAgaWYgKCFtYXRjaGVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPcmlnaW4gbm90IGZvdW5kJyk7XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXNbMF07XG59XG5leHBvcnRzLmdldEJ1bmRsZVVSTCA9IGdldEJ1bmRsZVVSTENhY2hlZDtcbmV4cG9ydHMuZ2V0QmFzZVVSTCA9IGdldEJhc2VVUkw7XG5leHBvcnRzLmdldE9yaWdpbiA9IGdldE9yaWdpbjsiLCI8dGVtcGxhdGU+XG4gIDxzZWN0aW9uXG4gICAgcmVmPVwicmVmQWxlcnRcIlxuICAgIDpjbGFzcz1cIntcbiAgICAgIFskc3R5bGUudGlwc106IHRydWUsXG4gICAgICBbJHN0eWxlLnRpcHNFcnJvcl06IHR5cGUgPT09IEFMRVJUX1RZUEUuRVJST1IsXG4gICAgICBbJHN0eWxlLnRpcHNTdWNjZXNzXTogdHlwZSA9PT0gQUxFUlRfVFlQRS5TVUNDRVNTLFxuICAgIH1cIlxuICA+XG4gICAgPHNsb3QgbmFtZT1cImljb25cIj5cbiAgICAgIDxhcnRpY2xlIDpjbGFzcz1cIiRzdHlsZS5pY29uXCI+XG4gICAgICAgIDxJY29uQWxlcnRJbmZvIHYtaWY9XCJ0eXBlID09PSBBTEVSVF9UWVBFLklORk9cIiAvPlxuICAgICAgICA8SWNvblN1Y2Nlc3Mgdi1pZj1cInR5cGUgPT09IEFMRVJUX1RZUEUuU1VDQ0VTU1wiIC8+XG4gICAgICAgIDxJY29uRXJyb3Igdi1pZj1cInR5cGUgPT09IEFMRVJUX1RZUEUuRVJST1JcIiAvPlxuICAgICAgPC9hcnRpY2xlPlxuICAgIDwvc2xvdD5cbiAgICB7eyB0aXBzIH19XG4gIDwvc2VjdGlvbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQgc2V0dXA+XG5pbXBvcnQge3JlZn0gZnJvbSAndnVlJ1xuaW1wb3J0IHtvbkNsaWNrT3V0c2lkZX0gZnJvbSAnQHZ1ZXVzZS9jb3JlJ1xuXG5pbXBvcnQgSWNvbkFsZXJ0SW5mbyBmcm9tICcuL2ljb24vSWNvbkFsZXJ0SW5mby52dWUnXG5pbXBvcnQgSWNvbkVycm9yIGZyb20gJy4vaWNvbi9JY29uQWxlcnRFcnJvci52dWUnXG5pbXBvcnQgSWNvblN1Y2Nlc3MgZnJvbSAnLi9pY29uL0ljb25BbGVydFN1Y2Nlc3MudnVlJ1xuXG5jb25zdCBwcm9wcyA9IGRlZmluZVByb3BzKHtcbiAgdHlwZToge1xuICAgIHR5cGU6IFN0cmluZyxcbiAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICBkZWZhdWx0OiAnJyxcbiAgfSxcbiAgdGlwczoge1xuICAgIHR5cGU6IFN0cmluZyxcbiAgICByZXF1aXJlZDogdHJ1ZSxcbiAgfSxcbiAgY29sb3I6IHtcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgZGVmYXVsdDogJyM1ODViNTgnLFxuICB9LFxuICBhdXRvSGlkZToge1xuICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgZGVmYXVsdDogZmFsc2UsXG4gIH0sXG59KVxuXG5jb25zdCBlbWl0cyA9IGRlZmluZUVtaXRzKFsnb25IaWRlJ10pXG5cbmNvbnN0IHJlZkFsZXJ0ID0gcmVmKG51bGwpXG5cbm9uQ2xpY2tPdXRzaWRlKHJlZkFsZXJ0LCAoKSA9PiB7XG4gIGlmIChwcm9wcy5hdXRvSGlkZSkgZW1pdHMoJ29uSGlkZScpXG59KVxuXG5jb25zdCBBTEVSVF9UWVBFID0ge1xuICBJTkZPOiAnaW5mbycsXG4gIEVSUk9SOiAnZXJyb3InLFxuICBTVUNDRVNTOiAnc3VjY2VzcycsXG59XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCIgbW9kdWxlPlxuLnRpcHMge1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogcm93O1xuICBnYXA6IDZweDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgd2lkdGg6IGZpdC1jb250ZW50O1xuICBtaW4taGVpZ2h0OiAyN3B4O1xuICBwYWRkaW5nOiA1cHggOHB4IDVweCA2cHg7XG4gIGNvbG9yOiAjNTg1YjU4O1xuICBmb250LXNpemU6IDEycHg7XG4gIGxpbmUtaGVpZ2h0OiAxN3B4O1xuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoMGRlZywgcmdiKDc5IDkwIDI1NSAvIDEwJSksIHJnYig3OSA5MCAyNTUgLyAxMCUpKSwgI2ZmZjtcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xufVxuXG4uaWNvbiB7XG4gIGRpc3BsYXk6IGZsZXg7XG59XG5cbi50aXBzU3VjY2VzcyB7XG4gIGNvbG9yOiAjMzE4NjE5O1xufVxuXG4udGlwc0Vycm9yIHtcbiAgY29sb3I6ICNjMDA7XG59XG48L3N0eWxlPlxuIiwiPHRlbXBsYXRlPlxuICA8c3ZnIGZpbGw9XCJub25lXCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDE2IDE2XCIgd2lkdGg9XCIxNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cbiAgICA8cGF0aFxuICAgICAgY2xpcC1ydWxlPVwiZXZlbm9kZFwiXG4gICAgICBkPVwiTTggMEMxMi40MTgzIDAgMTYgMy41ODE3MiAxNiA4QzE2IDEyLjQxODMgMTIuNDE4MyAxNiA4IDE2QzMuNTgxNzIgMTYgMCAxMi40MTgzIDAgOEMwIDMuNTgxNzIgMy41ODE3MiAwIDggMFpcIlxuICAgICAgZmlsbD1cIiM0RjVBRkZcIlxuICAgICAgZmlsbC1ydWxlPVwiZXZlbm9kZFwiXG4gICAgLz5cbiAgICA8cGF0aFxuICAgICAgY2xpcC1ydWxlPVwiZXZlbm9kZFwiXG4gICAgICBkPVwiTTguMDAwMDkgNi4xODE4MkM4LjYwMjU4IDYuMTgxODIgOS4wOTEgNS42OTM0IDkuMDkxIDUuMDkwOTFDOS4wOTEgNC40ODg0MiA4LjYwMjU4IDQgOC4wMDAwOSA0QzcuMzk3NiA0IDYuOTA5MTggNC40ODg0MiA2LjkwOTE4IDUuMDkwOTFDNi45MDkxOCA1LjY5MzQgNy4zOTc2IDYuMTgxODIgOC4wMDAwOSA2LjE4MTgyWk04LjkwOTE4IDhDOC45MDkxOCA3LjQ5NzkyIDguNTAyMTcgNy4wOTA5MSA4LjAwMDA5IDcuMDkwOTFDNy43NTg5OCA3LjA5MDkxIDcuNTI3NzUgNy4xODY2OSA3LjM1NzI2IDcuMzU3MThDNy4xODY3OCA3LjUyNzY2IDcuMDkxIDcuNzU4ODkgNy4wOTEgOFYxMC45MDkxQzcuMDkxIDExLjQxMTIgNy40OTgwMSAxMS44MTgyIDguMDAwMDkgMTEuODE4MkM4LjUwMjE3IDExLjgxODIgOC45MDkxOCAxMS40MTEyIDguOTA5MTggMTAuOTA5MVY4WlwiXG4gICAgICBmaWxsPVwid2hpdGVcIlxuICAgICAgZmlsbC1ydWxlPVwiZXZlbm9kZFwiXG4gICAgLz5cbiAgPC9zdmc+XG48L3RlbXBsYXRlPlxuIiwiPHRlbXBsYXRlPlxuICA8c3ZnIGZpbGw9XCJub25lXCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDE2IDE2XCIgd2lkdGg9XCIxNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cbiAgICA8ZyBjbGlwLXBhdGg9XCJ1cmwoI2NsaXAwXzE3NDdfMzE2NSlcIj5cbiAgICAgIDxwYXRoXG4gICAgICAgIGNsaXAtcnVsZT1cImV2ZW5vZGRcIlxuICAgICAgICBkPVwiTTE2IDguMDAwNThDMTUuOTk5MiA4LjE5MTM3IDE1LjkyMzUgOC4zNzQyIDE1Ljc4OTEgOC41MDk2N0w4LjUxNjM2IDE1Ljc4MjRDOC4zODAzMSAxNS45MjEyIDguMTk0MzYgMTUuOTk5OCA4IDE2LjAwMDZDNy44MDkyMSAxNS45OTk4IDcuNjI2MzcgMTUuOTI0IDcuNDkwOTEgMTUuNzg5N0wwLjIxODE4MiA4LjUxNjk0QzAuMDc5Mzc3NyA4LjM4MDg5IDAuMDAwODA2ODU0IDguMTk0OTQgMCA4LjAwMDU4QzAuMDAwODA2ODU0IDcuODA2MjIgMC4wNzkzNzc3IDcuNjIwMjcgMC4yMTgxODIgNy40ODQyMUw3LjQ5MDkxIDAuMjExNDg2QzcuNzc0NTcgLTAuMDcwNDk1MiA4LjIzMjcgLTAuMDcwNDk1MiA4LjUxNjM2IDAuMjExNDg2TDE1Ljc4OTEgNy40ODQyMUMxNS45MjUyIDcuNjIxNDYgMTYuMDAxMSA3LjgwNzI3IDE2IDguMDAwNThaXCJcbiAgICAgICAgZmlsbD1cIiNDQzAwMDBcIlxuICAgICAgICBmaWxsLXJ1bGU9XCJldmVub2RkXCJcbiAgICAgIC8+XG4gICAgICA8cGF0aFxuICAgICAgICBjbGlwLXJ1bGU9XCJldmVub2RkXCJcbiAgICAgICAgZD1cIk03LjI3MjQ2IDguMDAwNjJDNy4yNzI0NiA4LjQwMjI4IDcuNTk4MDcgOC43Mjc4OSA3Ljk5OTczIDguNzI3ODlDOC40MDE0IDguNzI3ODkgOC43MjcwMSA4LjQwMjI4IDguNzI3MDEgOC4wMDA2MlY1LjA5MTUzQzguNzI3MDEgNC42ODk4NyA4LjQwMTQgNC4zNjQyNiA3Ljk5OTczIDQuMzY0MjZDNy41OTgwNyA0LjM2NDI2IDcuMjcyNDYgNC42ODk4NyA3LjI3MjQ2IDUuMDkxNTNWOC4wMDA2MlpNNy45OTk3MyAxMC45MDk3QzguNDAxNCAxMC45MDk3IDguNzI3MDEgMTAuNTg0MSA4LjcyNzAxIDEwLjE4MjRDOC43MjcwMSA5Ljc4MDc4IDguNDAxNCA5LjQ1NTE3IDcuOTk5NzMgOS40NTUxN0M3LjU5ODA3IDkuNDU1MTcgNy4yNzI0NiA5Ljc4MDc4IDcuMjcyNDYgMTAuMTgyNEM3LjI3MjQ2IDEwLjU4NDEgNy41OTgwNyAxMC45MDk3IDcuOTk5NzMgMTAuOTA5N1pcIlxuICAgICAgICBmaWxsPVwid2hpdGVcIlxuICAgICAgICBmaWxsLXJ1bGU9XCJldmVub2RkXCJcbiAgICAgIC8+XG4gICAgPC9nPlxuICAgIDxkZWZzPlxuICAgICAgPGNsaXBQYXRoIGlkPVwiY2xpcDBfMTc0N18zMTY1XCI+XG4gICAgICAgIDxyZWN0IGZpbGw9XCJ3aGl0ZVwiIGhlaWdodD1cIjE2XCIgd2lkdGg9XCIxNlwiIC8+XG4gICAgICA8L2NsaXBQYXRoPlxuICAgIDwvZGVmcz5cbiAgPC9zdmc+XG48L3RlbXBsYXRlPlxuIiwiPHRlbXBsYXRlPlxuICA8c3ZnIGZpbGw9XCJub25lXCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDE2IDE2XCIgd2lkdGg9XCIxNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cbiAgICA8cGF0aFxuICAgICAgY2xpcC1ydWxlPVwiZXZlbm9kZFwiXG4gICAgICBkPVwiTTggMEMxMi40MTgzIDAgMTYgMy41ODE3MiAxNiA4QzE2IDEyLjQxODMgMTIuNDE4MyAxNiA4IDE2QzMuNTgxNzIgMTYgMCAxMi40MTgzIDAgOEMwIDMuNTgxNzIgMy41ODE3MiAwIDggMFpcIlxuICAgICAgZmlsbD1cIiMzMTg2MTlcIlxuICAgICAgZmlsbC1ydWxlPVwiZXZlbm9kZFwiXG4gICAgLz5cbiAgICA8cGF0aFxuICAgICAgY2xpcC1ydWxlPVwiZXZlbm9kZFwiXG4gICAgICBkPVwiTTcuMjcyNDMgMTEuMjcyOUM3LjA4MDE3IDExLjI3NCA2Ljg3OTU4IDExLjE0NzkgNi43NDMwNyAxMS4wMTI4TDQuNTczMDkgOC44NDc5NUM0LjM4OTYxIDguNjY0OSA0LjMxNzk2IDguMzk4MTEgNC4zODUxMiA4LjE0ODA2QzQuNDUyMjcgNy44OTgwMSA0LjY0ODA0IDcuNzAyNyA0Ljg5ODY4IDcuNjM1N0M1LjE0OTMxIDcuNTY4NzEgNS40MTY3NCA3LjY0MDE5IDUuNjAwMjIgNy44MjMyNEw3LjE2MjYgOS40MTgwM0wxMC4yODc0IDUuMDg4MjhDMTAuNDI2NyA0Ljg1MzU4IDEwLjY4NjggNC43MTczMSAxMC45NTk1IDQuNzM2MDlDMTEuMjMyMyA0Ljc1NDg4IDExLjQ3MTIgNC45MjU1IDExLjU3NjggNS4xNzcwN0MxMS42ODI1IDUuNDI4NjQgMTEuNjM3IDUuNzE4MTcgMTEuNDU5MiA1LjkyNTM2TDcuODQyNTMgMTAuOTc2N0M3LjcxOTgzIDExLjE1MDQgNy41MjY2NSAxMS4yNjEzIDcuMzE0NSAxMS4yNzk4TDcuMjcyNDMgMTEuMjcyOVpcIlxuICAgICAgZmlsbD1cIndoaXRlXCJcbiAgICAgIGZpbGwtcnVsZT1cImV2ZW5vZGRcIlxuICAgIC8+XG4gIDwvc3ZnPlxuPC90ZW1wbGF0ZT5cbiIsIjx0ZW1wbGF0ZT5cbiAgPHNlY3Rpb24gOmNsYXNzPVwiJHN0eWxlLnNob3J0Y3V0V3JhcFwiPlxuICAgIDxzcGFuIDpjbGFzcz1cIiRzdHlsZS5zaG9ydGN1dFRleHRcIj5TaG9ydGN1dDo8L3NwYW4+XG4gICAgPHNlY3Rpb24gOmNsYXNzPVwiJHN0eWxlLnNob3J0Y3V0S2V5c1wiPlxuICAgICAge3sgc2hvcnRjdXQgfX1cbiAgICA8L3NlY3Rpb24+XG4gIDwvc2VjdGlvbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQgc2V0dXA+XG5pbXBvcnQge2NvbXB1dGVkfSBmcm9tICd2dWUnXG5cbmltcG9ydCB1c2VTdG9yZSBmcm9tICdAL3N0b3Jlcy9zdG9yZSdcbmltcG9ydCB7Zm9ybWF0U2hvcnRjdXR9IGZyb20gJ0AvdXRpbHMnXG5cbmNvbnN0IHN0b3JlID0gdXNlU3RvcmUoKVxuXG5jb25zdCBzaG9ydGN1dCA9IGNvbXB1dGVkKCgpID0+IHtcbiAgcmV0dXJuIGZvcm1hdFNob3J0Y3V0KHN0b3JlLmNvbmZpZy5jdXN0b21TaG9ydGN1dClcbn0pXG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCIgbW9kdWxlPlxuLnNob3J0Y3V0V3JhcCB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG59XG5cbi5zaG9ydGN1dFRleHQge1xuICBjb2xvcjogIzkyOTQ5NztcbiAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgZm9udC1zaXplOiAxMnB4O1xuICBsaW5lLWhlaWdodDogMjBweDtcbn1cblxuLnNob3J0Y3V0S2V5cyB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIG1heC13aWR0aDogMTgwcHg7XG4gIG1pbi1oZWlnaHQ6IDIwcHg7XG4gIG1hcmdpbi1sZWZ0OiA0cHggIWltcG9ydGFudDtcbiAgcGFkZGluZzogMCAycHg7XG4gIGNvbG9yOiAjOTI5NDk3O1xuICBmb250LXdlaWdodDogNDAwO1xuICBmb250LXNpemU6IDE0cHggIWltcG9ydGFudDtcbiAgbGluZS1oZWlnaHQ6IDIwcHg7XG5cbiAgLy8gYmFja2dyb3VuZC1jb2xvcjogdmFyKC0td2VicGlsb3QtdGhlbWUtbWFpbi1iYWNrZ3JvdW5kLWNvbG9yLCAjZmZmKTtcbiAgYm9yZGVyOiAxcHggc29saWQgIzkyOTQ5NztcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xufVxuPC9zdHlsZT5cbiIsImV4cG9ydCBmdW5jdGlvbiBnZXRPUygpIHtcbiAgY29uc3Qge3VzZXJBZ2VudCwgcGxhdGZvcm19ID0gZ2xvYmFsLm5hdmlnYXRvclxuICBjb25zdCBtYWNvc1BsYXRmb3JtcyA9IFsnTWFjaW50b3NoJywgJ01hY0ludGVsJywgJ01hY1BQQycsICdNYWM2OEsnXVxuICBjb25zdCB3aW5kb3dzUGxhdGZvcm1zID0gWydXaW4zMicsICdXaW42NCcsICdXaW5kb3dzJywgJ1dpbkNFJ11cbiAgY29uc3QgaW9zUGxhdGZvcm1zID0gWydpUGhvbmUnLCAnaVBhZCcsICdpUG9kJ11cblxuICBsZXQgb3MgPSBudWxsXG5cbiAgaWYgKG1hY29zUGxhdGZvcm1zLmluZGV4T2YocGxhdGZvcm0pICE9PSAtMSkge1xuICAgIG9zID0gJ01hYyBPUydcbiAgfSBlbHNlIGlmIChpb3NQbGF0Zm9ybXMuaW5kZXhPZihwbGF0Zm9ybSkgIT09IC0xKSB7XG4gICAgb3MgPSAnaU9TJ1xuICB9IGVsc2UgaWYgKHdpbmRvd3NQbGF0Zm9ybXMuaW5kZXhPZihwbGF0Zm9ybSkgIT09IC0xKSB7XG4gICAgb3MgPSAnV2luZG93cydcbiAgfSBlbHNlIGlmICgvQW5kcm9pZC8udGVzdCh1c2VyQWdlbnQpKSB7XG4gICAgb3MgPSAnQW5kcm9pZCdcbiAgfSBlbHNlIGlmICghb3MgJiYgL0xpbnV4Ly50ZXN0KHBsYXRmb3JtKSkge1xuICAgIG9zID0gJ0xpbnV4J1xuICB9XG5cbiAgcmV0dXJuIG9zXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRTaG9ydGN1dChrZXlzKSB7XG4gIGxldCBrZXlMaXN0ID0ga2V5c1xuXG4gIGtleUxpc3QgPSBrZXlMaXN0Lm1hcChpdGVtID0+IHtcbiAgICBpZiAoaXRlbSA9PT0gJ0NvbnRyb2wnKSByZXR1cm4gJ0N0cmwnXG4gICAgaWYgKGl0ZW0gPT09ICdNZXRhJykgcmV0dXJuICdDbWQnXG4gICAgaWYgKGl0ZW0gPT09ICcgJyAmJiAoaXRlbS5jaGFyQ29kZUF0KCkgPT09IDE2MCB8fCBpdGVtLmNoYXJDb2RlQXQoKSA9PT0gMzIpKSByZXR1cm4gJ1NwYWNlJ1xuICAgIC8vIGlmIChpdGVtID09PSAnTWV0YScpIHJldHVybiAn4oyYJ1xuICAgIHJldHVybiBpdGVtLmxlbmd0aCA9PT0gMSA/IGl0ZW0udG9VcHBlckNhc2UoKSA6IGl0ZW1cbiAgfSlcblxuICByZXR1cm4ga2V5TGlzdC5qb2luKCcgKyAnKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVjdEZyb21JbnB1dEFuZFRleHRhcmVhKHRhcmdldCkge1xuICBjb25zdCB7c2VsZWN0aW9uRW5kLCBzZWxlY3Rpb25TdGFydH0gPSB0YXJnZXRcblxuICBjb25zdCBjbG9uZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcblxuICBjb25zdCB7dG9wLCBsZWZ0fSA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXG4gIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGFyZ2V0KVxuICBjbG9uZUVsZW1lbnQudGV4dENvbnRlbnQgPSB0YXJnZXQudmFsdWVcbiAgY2xvbmVFbGVtZW50LnN0eWxlLndoaXRlU3BhY2UgPSAncHJlLXdyYXAnXG4gIGNsb25lRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbidcbiAgY2xvbmVFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJ1xuICBjbG9uZUVsZW1lbnQuc3R5bGUudG9wID0gYCR7dG9wfXB4YFxuICBjbG9uZUVsZW1lbnQuc3R5bGUubGVmdCA9IGAke2xlZnR9cHhgXG4gIGNsb25lRWxlbWVudC5zdHlsZS53aWR0aCA9IHN0eWxlLndpZHRoXG4gIGNsb25lRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBzdHlsZS5oZWlnaHRcbiAgY2xvbmVFbGVtZW50LnN0eWxlLm1hcmdpbiA9IHN0eWxlLm1hcmdpblxuICBjbG9uZUVsZW1lbnQuc3R5bGUucGFkZGluZyA9IHN0eWxlLnBhZGRpbmdcbiAgY2xvbmVFbGVtZW50LnN0eWxlLmZvbnRGYW1pbHkgPSBzdHlsZS5mb250RmFtaWx5XG4gIGNsb25lRWxlbWVudC5zdHlsZS5mb250U2l6ZSA9IHN0eWxlLmZvbnRTaXplXG4gIGNsb25lRWxlbWVudC5zdHlsZS5saW5lSGVpZ2h0ID0gc3R5bGUubGluZUhlaWdodFxuICBjbG9uZUVsZW1lbnQuc3R5bGUuZm9udFdlaWdodCA9IHN0eWxlLmZvbnRXZWlnaHRcbiAgY2xvbmVFbGVtZW50LnN0eWxlLmJvcmRlclRvcCA9IHN0eWxlLmJvcmRlclRvcFxuICBjbG9uZUVsZW1lbnQuc3R5bGUuYm9yZGVyTGVmdCA9IHN0eWxlLmJvcmRlckxlZnRcbiAgY2xvbmVFbGVtZW50LnN0eWxlLmJvcmRlclJpZ2h0ID0gc3R5bGUuYm9yZGVyUmlnaHRcbiAgY2xvbmVFbGVtZW50LnN0eWxlLmJvcmRlckJvdHRvbSA9IHN0eWxlLmJvcmRlckJvdHRvbVxuICBjbG9uZUVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3doaXRlJ1xuXG4gIC8vIGFkZCB0byBkb2N1bWVudFxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNsb25lRWxlbWVudClcblxuICAvLyBzZXQgc2VsZWN0aW9uIGNvbnRlbnQgb24gY2xvbmVlbGVtZW50XG4gIGNvbnN0IHJhbmdlID0gbmV3IFJhbmdlKClcbiAgcmFuZ2Uuc2V0U3RhcnQoY2xvbmVFbGVtZW50LmZpcnN0Q2hpbGQsIHNlbGVjdGlvblN0YXJ0KVxuICByYW5nZS5zZXRFbmQoY2xvbmVFbGVtZW50LmZpcnN0Q2hpbGQsIHNlbGVjdGlvbkVuZClcblxuICBjb25zdCBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKClcbiAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpXG4gIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSlcblxuICAvLyBnZXQgcmVjdFxuICBjb25zdCByZWN0ID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcblxuICAvLyByZW1vdmUgY2xvbmUgZWxlbW50XG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoY2xvbmVFbGVtZW50KVxuXG4gIC8vIHJlY292ZXJ5IHRleHRhcmVhciBvciBpbnB1dCBzZWxlY3Rpb25cbiAgdGFyZ2V0LnNldFNlbGVjdGlvblJhbmdlKHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpXG5cbiAgcmV0dXJuIHJlY3Rcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbFNjcm9sbGFibGVQYXJlbnRzKGVsZW1lbnQpIHtcbiAgY29uc3Qgc2Nyb2xsYWJsZUVsZW1ldG5zID0gW11cblxuICBsZXQgdGVtcEVsZW1lbnQgPSBlbGVtZW50XG4gIHdoaWxlICh0ZW1wRWxlbWVudCkge1xuICAgIGNvbnN0IHtzY3JvbGxIZWlnaHQsIGNsaWVudEhlaWdodH0gPSB0ZW1wRWxlbWVudFxuICAgIGNvbnN0IHtvdmVyZmxvd1l9ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGVtcEVsZW1lbnQpXG5cbiAgICBpZiAoc2Nyb2xsSGVpZ2h0ID4gY2xpZW50SGVpZ2h0ICYmIG92ZXJmbG93WSAhPT0gJ2hpZGRlbicpIHtcbiAgICAgIC8vIHNjcm9sbCBldmVudCBub3Qgd29ya3Mgb24gSFRNTCB0YWcsIHJlcGxhY2UgaXQgd2l0aCB3aW5kb3dcbiAgICAgIHNjcm9sbGFibGVFbGVtZXRucy5wdXNoKHRlbXBFbGVtZW50LnRhZ05hbWUgPT09ICdIVE1MJyA/IHdpbmRvdyA6IHRlbXBFbGVtZW50KVxuICAgIH1cbiAgICB0ZW1wRWxlbWVudCA9IHRlbXBFbGVtZW50Py5wYXJlbnRFbGVtZW50XG4gIH1cblxuICByZXR1cm4gc2Nyb2xsYWJsZUVsZW1ldG5zXG59XG4iXSwibmFtZXMiOltdLCJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wdXAuN2UzOTRjOGIuanMubWFwIn0=
 globalThis.define=__define;  })(globalThis.define);